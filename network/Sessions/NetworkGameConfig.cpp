//
// name:        NetworkGameConfig.cpp
// description: Game configuration.  Used to host games and to search
//				for games that match the parameters in the config.

#include "network/sessions/NetworkGameConfig.h"

// rage includes
#include "fwnet/netchannel.h"
#include "rline/rl.h"
#include "snet/snet.h"
#include "script/thread.h"

// network includes
#include "network/network.h"
#include "network/cloud/tunables.h"
#include "network/cloud/UserContentManager.h"
#include "network/General/NetworkAssetVerifier.h"
#include "network/General/NetworkUtil.h"
#include "network/Live/livemanager.h"
#include "network/xlast/Fuzzy.schema.h"

// game includes
#include "Frontend/PauseMenu.h"
#include "Peds/PlayerInfo.h"
#include "Peds/PedWeapons/PedTargetEvaluator.h"
#include "Peds/PedWeapons/PlayerPedTargeting.h"
#include "scene/world/GameWorld.h"
#include "stats/StatsInterface.h"
#include "stats/StatsMgr.h"
#include "scene/ExtraContent.h"

NETWORK_OPTIMISATIONS()

RAGE_DECLARE_SUBCHANNEL(net, game)
#undef __net_channel
#define __net_channel net_game

PARAM(netMatchMakingForceRegion, "Force matchmaking region to the following: ");
PARAM(netMatchmakingForceLanguage, "Force matchmaking language to the following: ");
PARAM(netMatchmakingForceAim , "Force matchmaking aiming to the following: ");
XPARAM(netSessionIgnoreDataHash);
XPARAM(netSessionIgnoreCheater);
XPARAM(netSessionIgnoreTimeout);
XPARAM(netSessionIgnoreVersion);
XPARAM(netSessionIgnoreAim);
PARAM(netSessionEnableRTT, "Enable RTT matchmaking");
PARAM(netSessionAverageRTT, "Override average RTT value");
PARAM(netSessionIgnoreAssets, "Ignore asset differences");

namespace rage 
{
	XPARAM(rlrosdomainenv);
}

#if RSG_DURANGO
PARAM(netSessionIgnoreReputation, "Ignore Xbox One reputation setting");
#endif

#if !__NO_OUTPUT
static const char* g_szAimBucket[MatchmakingAimBucket::AimBucket_Max] =
{
	"Assisted (0)",
	"Free Aim (1)"
};

const char* g_szLanguages[] = 
{
    "American",
    "French",
    "German",
    "Italian",
    "Spanish",
    "Portuguese",
    "Polish",
    "Russian",
    "Korean",
    "Chinese",
	"ChineseSimplified",
    "Japanese",
    "Mexican",
    "System Default"
};

CompileTimeAssert(COUNTOF(g_szLanguages)==MAX_LANGUAGES-LANGUAGE_UNDEFINED);

enum AimBucketReason
{
	ABR_Disabled,
	ABR_DisabledForArcadeModes,
	ABR_Forced,
	ABR_Ignored,
	ABR_Settings,
	ABR_Num,
};

static const char* s_AimBucketReasonStrings[] =
{
	"ABR_Disabled",
	"ABR_DisabledForArcadeModes",
	"ABR_Forced",
	"ABR_Ignored",
	"ABR_Settings",
};

CompileTimeAssert(COUNTOF(s_AimBucketReasonStrings) == ABR_Num);
static AimBucketReason s_AimBucketReason = AimBucketReason::ABR_Settings;
#endif

unsigned NetworkBaseConfig::GetStaticDiscriminator(const StaticDiscriminatorType discriminatorType)
{
	// the bits of the discriminator that don't change
	const unsigned discriminator =
		((GetMatchmakingPort() & PORT_MASK) << PORT_SHIFT)
		 | ((GetMatchmakingVersion() & VERSION_MASK) << VERSION_SHIFT)
		 | ((GetMatchmakingBuild() & BUILD_MASK) << BUILD_SHIFT)
		 | ((0 & EXCLUDE_MASK) << EXCLUDE_SHIFT)
		 | ((0 & VISIBLE_MASK) << VISIBLE_SHIFT)
		 | ((0 & IN_PROGRESS_MASK) << IN_PROGRESS_SHIFT)
		 | ((0 & AIM_MASK) << AIM_SHIFT)
		 | ((GetStaticUser(discriminatorType) & USER_MASK) << USER_SHIFT);

#if RSG_OUTPUT
	// use StaticDiscriminatorType::Type_Max + 1 to account for possibility of passing StaticDiscriminatorType::Type_Max
	static unsigned s_LastDiscriminator[StaticDiscriminatorType::Type_Max + 1] = { 0 };
	if(discriminator != s_LastDiscriminator[discriminatorType])
	{
		gnetDebug1("=== Static Discriminator ===");
		gnetDebug1("  Discriminator    = 0x%08x", discriminator);
		gnetDebug1("    Port           = %d (0x%08x)", GetMatchmakingPort(), ((GetMatchmakingPort() & PORT_MASK) << PORT_SHIFT));
		gnetDebug1("    Version        = %d (0x%08x)", GetMatchmakingVersion(), ((GetMatchmakingVersion() & VERSION_MASK) << VERSION_SHIFT));
		gnetDebug1("    Build          = %d (0x%08x)", GetMatchmakingBuild(), ((GetMatchmakingBuild() & BUILD_MASK) << BUILD_SHIFT));
		gnetDebug1("    User           = 0x%08x/0x%08x (0x%08x)", GetMatchmakingUser(), GetMatchmakingUser(false), ((GetMatchmakingUser() & USER_MASK) << USER_SHIFT));
		gnetDebug1("      Timeout      = %d%s", CNetwork::GetTimeoutTime(), PARAM_netSessionIgnoreTimeout.Get() ? " - Ignored" : "");
		gnetDebug1("      Assets       = 0x%08x%s", CNetwork::GetAssetVerifier().GetStaticCRC(), PARAM_netSessionIgnoreAssets.Get() ? " - Ignored" : "");
	}
	s_LastDiscriminator[discriminatorType] = discriminator;
#endif

	return discriminator;
}

unsigned NetworkBaseConfig::GetMatchmakingRegion()
{
	unsigned mmRegion = 0;
	if(!PARAM_netMatchMakingForceRegion.Get(mmRegion))
	{
		// use the region generated by rlRosGeoLocInfo - more accurately represents
		// what we want out of region matchmaking and makes better use of relay servers
		rlRosGeoLocInfo geoLoc;
		rlRos::GetGeoLocInfo(&geoLoc);
		mmRegion = geoLoc.m_RegionCode;
	}
	return mmRegion;
}

unsigned NetworkBaseConfig::GetMatchmakingDataHash()
{
	unsigned nDataHash = 0;

    // extra content has it's own kill switch (netSessionIgnoreECHash)
    nDataHash = EXTRACONTENT.GetCRC(nDataHash);

    return nDataHash;
}

unsigned NetworkBaseConfig::GetStaticUser(const StaticDiscriminatorType discriminatorType)
{
	unsigned nUser = 0;
	
	// tickle with timeout value
	if(!PARAM_netSessionIgnoreTimeout.Get())
	{
		unsigned nTimeOut = CNetwork::GetTimeoutTime();
		nUser = atDataHash(&nTimeOut, sizeof(nTimeOut), nUser);
	} 

	// tickle with asset CRC
	if(!PARAM_netSessionIgnoreAssets.Get())
	{
		unsigned nAssets = 0;
		switch(discriminatorType)
		{
		case StaticDiscriminatorType::Type_Early:
			nAssets = CNetwork::GetAssetVerifier().GetStaticCRC();
			break;

		case StaticDiscriminatorType::Type_InGame:
			nAssets = CNetwork::GetAssetVerifier().GetCRC();
			break;

		case StaticDiscriminatorType::Type_Max:
		default:
			gnetAssertf(0, "GetStaticUser :: Invalid discriminator type!");
			break;
		}
			
		nUser = atDataHash(&nAssets, sizeof(nAssets), nUser);
	}

	return nUser % USER_MAX_VALUE;
}

unsigned NetworkBaseConfig::GetMatchmakingUser(const bool capvalue)
{
	unsigned nUser = 0;
	if(!PARAM_netSessionIgnoreDataHash.Get())
	{
		unsigned nDataHash = GetMatchmakingDataHash();
		nUser = atDataHash(&nDataHash, sizeof(nDataHash), nUser);
	}

	// tickle if cheater
	if(!PARAM_netSessionIgnoreCheater.Get())
	{
		unsigned nCheater = GetMatchmakingPool() * 0xC43A73D;
		nUser = atDataHash(&nCheater, sizeof(nCheater), nUser);
	}

	// tickle with timeout value
	if(!PARAM_netSessionIgnoreTimeout.Get())
	{
		unsigned nTimeOut = CNetwork::GetTimeoutTime();
		nUser = atDataHash(&nTimeOut, sizeof(nTimeOut), nUser);
	} 

	//@@: range NETWORKBASECONFIG_GETMATCHMAKINGUSER_B {
    // tickle with asset CRC
    if(!PARAM_netSessionIgnoreAssets.Get())
    {
        unsigned nAssets = CNetwork::GetAssetVerifier().GetCRC();
        nUser = atDataHash(&nAssets, sizeof(nAssets), nUser);
    }
	//@@: } NETWORKBASECONFIG_GETMATCHMAKINGUSER_B

#if !__FINAL
	static const char* szCandidateCommand = "sc_UseRockstarCandidateMissions";
	if(sysParam::SearchArgArray(szCandidateCommand) != NULL)
	{
		unsigned nCandidate = 0xCA2D1DA7;
		nUser = atDataHash(&nCandidate, sizeof(nCandidate), nUser);
	}
#endif

#if RSG_DURANGO
	// tickle if reputation 
	if(!PARAM_netSessionIgnoreReputation.Get())
	{
		unsigned nReputation = CLiveManager::IsOverallReputationBad() ? 0x43617A10 : 0;
		nUser = atDataHash(&nReputation, sizeof(nReputation), nUser);
	}
#endif

	// cap to maximum user value
	if(capvalue)
		nUser %= USER_MAX_VALUE;

	return nUser;
}

unsigned NetworkBaseConfig::GetMatchmakingVersion()
{
	unsigned nVersion = 0;

#if !__FINAL
	if(!PARAM_netSessionIgnoreVersion.Get())
#endif
	{
		// version is in format MAJOR.MINOR[+PB]
		unsigned nVersionHi = 0, nVersionLo = 0, nVersionPb = 0;
		sscanf(CDebug::GetVersionNumber(), "%d.%d", &nVersionHi, &nVersionLo);
		sscanf(CDebug::GetVersionNumber(), "%*f+PB%d", &nVersionPb);

		// lose fraction and mod by cap
		nVersion = (nVersionHi * 10) + nVersionLo + ((nVersionPb > 0) ? 1 : 0);	
		nVersion %= VERSION_MAX_VALUE;
		gnetAssertf(nVersion <= VERSION_MAX_VALUE, "Matchmaking Version out of range!");
	}

	return nVersion; 
}

unsigned NetworkBaseConfig::GetMatchmakingPort()
{
	unsigned nPort = CNetwork::GetSocketPort();
	return ((nPort >> 24) & 0xFF) ^ ((nPort >> 16) & 0xFF) ^ ((nPort >> 8) & 0xFF) ^ ((nPort >> 0) & 0xFF);
}

unsigned NetworkBaseConfig::GetMatchmakingBuild()
{
	return DEFAULT_BUILD_TYPE_VALUE;
}

s32 NetworkBaseConfig::GetAimPreference()
{
	s32 nAimPreference = CPauseMenu::GetMenuPreference(PREF_TARGET_CONFIG);
	
	// correct invalid target mode
	if((nAimPreference < CPedTargetEvaluator::TARGETING_OPTION_GTA_TRADITIONAL) || (nAimPreference >= CPedTargetEvaluator::MAX_TARGETING_OPTIONS))
	{
		netError("GetAimPreference :: Invalid Target Mode: %u", nAimPreference);
		nAimPreference = CPedTargetEvaluator::TARGETING_OPTION_GTA_TRADITIONAL;
	}

    return nAimPreference;
}

unsigned NetworkBaseConfig::GetAimBucket(s32 nAimPreference)
{
	unsigned nAimBucket = MatchmakingAimBucket::AimBucket_Assisted;

	// the assisted aiming modes (casual / normal) are combined into one session bucket
	switch(nAimPreference)
	{
	case CPedTargetEvaluator::TARGETING_OPTION_GTA_TRADITIONAL:
	case CPedTargetEvaluator::TARGETING_OPTION_ASSISTED_AIM:
		nAimBucket = MatchmakingAimBucket::AimBucket_Assisted;
		break;
	case CPedTargetEvaluator::TARGETING_OPTION_ASSISTED_FREEAIM:
	case CPedTargetEvaluator::TARGETING_OPTION_FREEAIM:
		nAimBucket = MatchmakingAimBucket::AimBucket_Free;
		break;
	default:
		break;
	}

	return nAimBucket;
}

bool NetworkBaseConfig::sm_bAimBucketingEnabled = true;
bool NetworkBaseConfig::sm_bAimBucketingEnabledForArcadeGameModes = true;

unsigned NetworkBaseConfig::GetMatchmakingAimBucket(s32 nAimPreference)
{
	unsigned nAimBucket = MatchmakingAimBucket::AimBucket_Assisted;

#if !__FINAL
	if(PARAM_netMatchmakingForceAim.Get(nAimBucket))
	{
		OUTPUT_ONLY(s_AimBucketReason = AimBucketReason::ABR_Forced);
		return nAimBucket;
	}

	if(PARAM_netSessionIgnoreAim.Get())
	{
		// just return the default mode (MatchmakingAimBucket::AimBucket_Assisted)
		OUTPUT_ONLY(s_AimBucketReason = AimBucketReason::ABR_Ignored);
		return nAimBucket;
	}
#endif

	if(!sm_bAimBucketingEnabled)
	{
		// just return the default mode (MatchmakingAimBucket::AimBucket_Assisted)
		OUTPUT_ONLY(s_AimBucketReason = AimBucketReason::ABR_Disabled);
		return nAimBucket;
	}

	if(!sm_bAimBucketingEnabledForArcadeGameModes && NetworkInterface::IsInArcadeMode())
	{
		// just return the default mode (MatchmakingAimBucket::AimBucket_Assisted)
		OUTPUT_ONLY(s_AimBucketReason = AimBucketReason::ABR_DisabledForArcadeModes);
		return nAimBucket;
	}

    // if not specified, use the local preference settings
    if(nAimPreference < 0)
        nAimPreference = GetAimPreference();

	// convert to bucket
	nAimBucket = GetAimBucket(nAimPreference);

	// indicate that aim bucketing was processed from our user settings
	OUTPUT_ONLY(s_AimBucketReason = AimBucketReason::ABR_Settings);

    // check that we are within range
    gnetAssertf(nAimBucket < MatchmakingAimBucket::AimBucket_Max, "GetMatchmakingAimBucket :: Invalid aim setting value of %u", nAimBucket);
	return nAimBucket;
}

s32 NetworkBaseConfig::GetMatchmakingLanguage()
{
#if !__FINAL
    s32 nLanguageParam = 0;
    if(PARAM_netMatchmakingForceLanguage.Get(nLanguageParam))
        return nLanguageParam;
#endif
    return CPauseMenu::GetMenuPreference(PREF_CURRENT_LANGUAGE);
}

eMultiplayerPool NetworkBaseConfig::GetMatchmakingPool()
{
	// global kill-switches for the pooling systems  
	const bool bConsiderBadSports = Tunables::GetInstance().TryAccess(CD_GLOBAL_HASH, ATSTRINGHASH("MM_CONSIDER_BADSPORTS", 0xeda694ce), true);    
    const bool bConsiderCheaters = Tunables::GetInstance().TryAccess(CD_GLOBAL_HASH, ATSTRINGHASH("MM_CONSIDER_CHEATERS", 0xeb7e110a), true);
    volatile eMultiplayerPool retPool = POOL_NORMAL;
	
	// check cheater and bad sport settings
	if(CNetwork::IsCheater() && bConsiderCheaters)
		retPool = POOL_CHEATER;
	else if(StatsInterface::IsBadSport(false OUTPUT_ONLY(, true)) && bConsiderBadSports)
		retPool = POOL_BAD_SPORT;

	// in with the masses    
	return retPool; 
}

bool NetworkBaseConfig::s_bUseExclude = true;
bool NetworkBaseConfig::s_bExcludeCheaters = true;

#if RSG_DURANGO || RSG_ORBIS
bool NetworkBaseConfig::s_bExcludeFreeAim = true;
#endif

#if RSG_DURANGO
bool NetworkBaseConfig::s_bExcludeBadReputation = true;
#endif

bool NetworkBaseConfig::GetMatchmakingExclude()
{
	if(!s_bUseExclude)
		return false;

	// obey the command line here
	if(s_bExcludeCheaters && !PARAM_netSessionIgnoreCheater.Get())
	{
		if(GetMatchmakingPool() != POOL_NORMAL)
			return true;
	}
	
	// use asset verifier directly to take advantage of parameter to ignore
	if(CNetwork::GetAssetVerifier().IsDiscriminatingBySKU() && CNetwork::GetAssetVerifier().IsJapaneseBuild())
		return true;

#if RSG_DURANGO || RSG_ORBIS
	// ignore PC since free aim is a bigger bucket
	if(s_bExcludeFreeAim && GetMatchmakingAimBucket() == MatchmakingAimBucket::AimBucket_Free)
		return true;
#endif

#if RSG_DURANGO
	if(s_bExcludeBadReputation && !PARAM_netSessionIgnoreReputation.Get())
	{
		if(CLiveManager::IsOverallReputationBad())
			return true;
	}
#endif

	// no reason to exclude
	return false;
}

void NetworkBaseConfig::SetAimBucketingEnabled(const bool bEnabled)
{
	if(sm_bAimBucketingEnabled != bEnabled)
	{
		gnetDebug1("SetAimBucketingEnabled :: %s -> %s", sm_bAimBucketingEnabled ? "True" : "False", bEnabled ? "True" : "False");
		sm_bAimBucketingEnabled = bEnabled;
	}
}

void NetworkBaseConfig::SetAimBucketingEnabledForArcadeGameModes(const bool bEnabled)
{
	if(sm_bAimBucketingEnabledForArcadeGameModes != bEnabled)
	{
		gnetDebug1("SetAimBucketingEnabledForArcadeGameModes :: %s -> %s", sm_bAimBucketingEnabledForArcadeGameModes ? "True" : "False", bEnabled ? "True" : "False");
		sm_bAimBucketingEnabledForArcadeGameModes = bEnabled;
	}
}

///////////////////////////////////////////////////////////////////////////////
//  NetworkBaseConfig
///////////////////////////////////////////////////////////////////////////////
NetworkBaseConfig::NetworkBaseConfig()
{
    this->Clear();

	// validate discriminator size
	CompileTimeAssert(USER_SHIFT <= 32);
}

NetworkBaseConfig::~NetworkBaseConfig()
{
}

void NetworkBaseConfig::Clear()
{
	m_Port = 0;
    m_PortBits = 0;
    m_VersionBits = 0;
	m_ExcludeBits = 0;
	m_BuildBits = GetBuildType();
    m_VisibleBits = 1;
    m_InProgressBits = 1;
	m_AimBucket = MatchmakingAimBucket::AimBucket_Assisted;
    m_UserBits = 0;

	m_DiscriminatorFieldIndex = -1;
	m_RegionFieldIndex = -1;
	m_LanguageFieldIndex = -1;
	for(int i = 0; i < MAX_ACTIVE_MM_GROUPS; i++)
		m_GroupFieldIndex[i] = -1; 
	m_ActivityTypeFieldIndex = -1;
	m_ActivityIDFieldIndex = -1;
    m_ActivityPlayersFieldIndex = -1;
}

void NetworkBaseConfig::Init()
{
	// set up discriminator bits
	SetPort(CNetwork::GetSocketPort());
	SetVersion(GetMatchmakingVersion());
	SetUser(GetMatchmakingUser());	
}

unsigned NetworkBaseConfig::GetDiscriminator() const
{
	return ((m_PortBits & PORT_MASK) << PORT_SHIFT)
		| ((m_VersionBits & VERSION_MASK) << VERSION_SHIFT)
		| ((m_BuildBits & BUILD_MASK) << BUILD_SHIFT)
		| ((m_ExcludeBits & EXCLUDE_MASK) << EXCLUDE_SHIFT)
		| ((m_VisibleBits & VISIBLE_MASK) << VISIBLE_SHIFT)
		| ((m_InProgressBits & IN_PROGRESS_MASK) << IN_PROGRESS_SHIFT)
		| ((m_AimBucket & AIM_MASK) << AIM_SHIFT)
		| ((m_UserBits & USER_MASK) << USER_SHIFT); 
}

//protected:

void NetworkBaseConfig::SetDiscriminator(const unsigned discriminator)
{
	this->SetPort((discriminator >> PORT_SHIFT) & PORT_MASK);
	this->SetVersion((discriminator >> VERSION_SHIFT) & VERSION_MASK);
	this->SetBuildType((discriminator >> BUILD_SHIFT) & BUILD_MASK);
	this->SetExclude((discriminator >> EXCLUDE_SHIFT) & EXCLUDE_MASK);
	this->SetVisible((discriminator >> VISIBLE_SHIFT) & VISIBLE_MASK);
	this->SetInProgress((discriminator >> IN_PROGRESS_SHIFT) & IN_PROGRESS_MASK);
	this->SetAimBucket((discriminator >> AIM_SHIFT) & AIM_MASK);
	this->SetUser((discriminator >> USER_SHIFT) & USER_MASK); 
}

void NetworkBaseConfig::SetPort(const unsigned port)
{
	CompileTimeAssert(PORT_BITS == 8);
	m_Port = port;
	m_PortBits = ((port >> 24) & 0xFF) ^ ((port >> 16) & 0xFF) ^ ((port >> 8) & 0xFF) ^ ((port >> 0) & 0xFF);
}

void NetworkBaseConfig::SetVersion(const unsigned version)
{
	gnetAssert(version <= VERSION_MAX_VALUE);
	m_VersionBits = version;
}

void NetworkBaseConfig::SetBuildType(const unsigned nBuildType)
{
	gnetAssert(nBuildType <= BUILD_MAX_VALUE);
	m_BuildBits = nBuildType;
}

void NetworkBaseConfig::SetExclude(const unsigned nExclude)
{
    gnetAssert(nExclude <= EXCLUDE_MAX_VALUE);
    m_ExcludeBits = nExclude;
}

void NetworkBaseConfig::SetVisible(const bool bVisible)
{
	m_VisibleBits = bVisible;
}

void NetworkBaseConfig::SetInProgress(const bool bInProgress)
{
	m_InProgressBits = bInProgress;
}

void NetworkBaseConfig::SetAimBucket(const unsigned nAimBucket)
{
    gnetAssert(nAimBucket <= AIM_MAX_VALUE);
    m_AimBucket = nAimBucket;
}

void NetworkBaseConfig::SetUser(const unsigned user)
{
	gnetAssert(user <= USER_MAX_VALUE);
	m_UserBits = user;
}

///////////////////////////////////////////////////////////////////////////////
//  NetworkGameConfig
///////////////////////////////////////////////////////////////////////////////

NetworkGameConfig::NetworkGameConfig()
{
    this->Clear();
}

#if !__NO_OUTPUT
void 
NetworkGameConfig::LogDifferences(const rlSessionConfig& config, const char* szTag)
{
	if(this->GetDiscriminatorFieldIndex() < 0)
		return;

	const u32* pValue = config.m_Attrs.GetValueByIndex(this->GetDiscriminatorFieldIndex());
	if(!pValue)
		return;

	if(this->GetMaxPublicSlots() != config.m_MaxPublicSlots)
		gnetDebug2("%s :: Public Slots Changed. Was: %d, Now: %d", szTag, this->GetMaxPublicSlots(), config.m_MaxPublicSlots);
	if(this->GetMaxPrivateSlots() != config.m_MaxPrivateSlots)
		gnetDebug2("%s :: Private Slots Changed. Was: %d, Now: %d", szTag, this->GetMaxPrivateSlots(), config.m_MaxPrivateSlots);

	if(this->GetPort() != ((*pValue >> PORT_SHIFT) & PORT_MASK))
		gnetDebug2("%s :: Port Changed - Was: %d, Now: %d", szTag, this->GetPort(), ((*pValue >> PORT_SHIFT) & PORT_MASK));
	if(this->GetVersion() != ((*pValue >> VERSION_SHIFT) & VERSION_MASK))
		gnetDebug2("%s :: Version Changed - Was: %d, Now: %d", szTag, this->GetVersion(), ((*pValue >> VERSION_SHIFT) & VERSION_MASK));
	if(this->GetBuildType() != ((*pValue >> BUILD_SHIFT) & BUILD_MASK))
		gnetDebug2("%s :: Build Changed - Was: %d, Now: %d", szTag, this->GetBuildType(), ((*pValue >> BUILD_SHIFT) & BUILD_MASK));
	if(this->GetExclude() != ((*pValue >> EXCLUDE_SHIFT) & EXCLUDE_MASK))
		gnetDebug2("%s :: Exclude Changed - Was: %d, Now: %d", szTag, this->GetExclude(), ((*pValue >> EXCLUDE_SHIFT) & EXCLUDE_MASK));
	if(this->IsVisible() != (((*pValue >> VISIBLE_SHIFT) & VISIBLE_MASK) != 0))
		gnetDebug2("%s :: Visibility Changed - Was: %s, Now: %s", szTag, this->IsVisible() ? "Visible" : "Not Visible", (((*pValue >> VISIBLE_SHIFT) & VISIBLE_MASK) != 0) ? "Visible" : "Not Visible");
	if(this->IsInProgress() != (((*pValue >> IN_PROGRESS_SHIFT) & IN_PROGRESS_MASK) != 0))
		gnetDebug2("%s :: In Progress Changed - Was: %s, Now: %s", szTag, this->IsInProgress() ? "In Progress" : "Not In Progress", (((*pValue >> IN_PROGRESS_SHIFT) & IN_PROGRESS_MASK) != 0) ? "In Progress" : "Not In Progress");
	if(this->GetAimBucket() != ((*pValue >> AIM_SHIFT) & AIM_MASK))
		gnetDebug2("%s :: Aim Changed - Was: %s, Now: %s", szTag, g_szAimBucket[this->GetAimBucket()], g_szAimBucket[((*pValue >> AIM_SHIFT) & AIM_MASK)]);
	if(this->GetUser() != ((*pValue >> USER_SHIFT) & USER_MASK))
		gnetDebug2("%s :: User Changed - Was: %d, Now: %d", szTag, this->GetUser(), ((*pValue >> USER_SHIFT) & USER_MASK));
}
#endif

void
NetworkGameConfig::ResetAttrs(const rlMatchingAttributes& attrs)
{
    if(m_MatchingAttrs.GetCount() == 0)
        m_MatchingAttrs = attrs;
    else
    {
        gnetAssert(m_MatchingAttrs.GetCount() == attrs.GetCount());
        for(int i = 0; i < (int) attrs.GetCount(); ++i)
        {
            gnetAssertf(attrs.GetAttrId(i) == m_MatchingAttrs.GetAttrId(i), "The id for attribute %d doesn't match", i);
            const u32* val = attrs.GetValueByIndex(i);
            if(gnetVerifyf(NULL != val, "Attribute %d is nil", i))
                m_MatchingAttrs.SetValueByIndex(i, *val);
        }
    }
}

void
NetworkGameConfig::Apply(const rlSessionConfig& config)
{
	// pull out slots and attributes
	m_MaxSlots = config.m_MaxPublicSlots + config.m_MaxPrivateSlots;
	m_MaxPrivSlots = config.m_MaxPrivateSlots;
	m_MatchingAttrs = config.m_Attrs;

	// extract the discriminator
	if(gnetVerifyf(this->GetDiscriminatorFieldIndex() >= 0, "Apply :: No discriminator field index!"))
	{
		const u32* pValue = m_MatchingAttrs.GetValueByIndex(this->GetDiscriminatorFieldIndex());
		gnetAssertf(pValue, "Apply :: No discriminator value!");
		SetDiscriminator(pValue ? *pValue : GetDiscriminator());
	} 
}

void
NetworkGameConfig::Apply(const NetworkGameFilter* pFilter)
{
	SetGameMode(pFilter->GetGameMode());
    SetSessionPurpose(pFilter->GetSessionPurpose());
    SetPort(pFilter->GetPort());
	SetVersion(pFilter->GetVersion());
    SetAimBucket(pFilter->GetAimBucket());
    SetUser(pFilter->GetUser());
}

void
NetworkGameConfig::Clear()
{
    this->NetworkBaseConfig::Clear();
    m_MaxSlots = 0;
    m_MaxPrivSlots = 0;
    m_MatchingAttrs.Clear();
}

bool
NetworkGameConfig::IsValid() const
{
    bool isValid = true;
	isValid &= (m_MaxSlots > 0) && (m_MaxPrivSlots <= m_MaxSlots);
	isValid &= (this->GetDiscriminatorFieldIndex() != -1); 
    return isValid;
}

const rlMatchingAttributes&
NetworkGameConfig::GetMatchingAttributes() const
{
	// apply attributes and return
	
	//@@: range NETWORKBASECONFIG_GETMATCHINGATTRIBUTES {
    m_MatchingAttrs.SetValueByIndex(this->GetDiscriminatorFieldIndex(), this->GetDiscriminator());
	m_MatchingAttrs.SetValueByIndex(this->GetRegionFieldIndex(), this->GetMatchmakingRegion());
	m_MatchingAttrs.SetValueByIndex(this->GetLanguageFieldIndex(), this->GetMatchmakingLanguage());
	return m_MatchingAttrs;
	
	//@@: } NETWORKBASECONFIG_GETMATCHINGATTRIBUTES 
}

void
NetworkGameConfig::SetGameMode(const u16 gameMode)
{
    m_MatchingAttrs.SetGameMode(gameMode);
}

u16
NetworkGameConfig::GetGameMode() const
{
    return m_MatchingAttrs.GetGameMode();
}

void
NetworkGameConfig::SetSessionPurpose(const u16 sessionPurpose)
{
    m_MatchingAttrs.SetSessionPurpose(sessionPurpose);
}

u16
NetworkGameConfig::GetSessionPurpose() const
{
    return m_MatchingAttrs.GetSessionPurpose();
}

//PURPOSE
//  Sets/gets the game mode.
void SetSessionPurpose(const unsigned sessionPurpose);
unsigned GetSessionPurpose();

unsigned
NetworkGameConfig::GetMaxSlots() const
{
    return m_MaxSlots;
}

unsigned
NetworkGameConfig::GetMaxPublicSlots() const
{
    return this->GetMaxSlots() - this->GetMaxPrivateSlots();
}

unsigned NetworkGameConfig::GetMaxPrivateSlots() const
{
    return m_MaxPrivSlots;
}

bool NetworkGameConfig::HasPrivateSlots() const
{
	return m_MaxPrivSlots > 0;
}

void NetworkGameConfig::SetVisible(const bool bVisible)
{
	this->NetworkBaseConfig::SetVisible(bVisible);
}

void NetworkGameConfig::SetInProgress(const bool bInProgress)
{
	this->NetworkBaseConfig::SetInProgress(bInProgress);
}

void NetworkGameConfig::SetNumberInGroup(const unsigned nGroup, u32 nMembers)
{
	if(!gnetVerify(this->GetGroupFieldIndex(nGroup) >= 0))
		return;

	m_MatchingAttrs.SetValueByIndex(this->GetGroupFieldIndex(nGroup), nMembers);
}

u32 NetworkGameConfig::GetNumberInGroup(const unsigned nGroup) const
{
	if(!gnetVerify(this->GetGroupFieldIndex(nGroup) >= 0))
		return 0;

	return *m_MatchingAttrs.GetValueByIndex(this->GetGroupFieldIndex(nGroup));
}

void NetworkGameConfig::SetActivityPlayersSlotsAvailable(u32 nPlayers)
{
    if(!gnetVerify(this->GetActivityPlayersFieldIndex() >= 0))
        return;

    m_MatchingAttrs.SetValueByIndex(this->GetActivityPlayersFieldIndex(), nPlayers);
}

u32 NetworkGameConfig::GetActivityPlayersSlotsAvailable() const
{
    if(!gnetVerify(this->GetActivityPlayersFieldIndex() >= 0))
        return 0;

    return *m_MatchingAttrs.GetValueByIndex(this->GetActivityPlayersFieldIndex());
}

void NetworkGameConfig::SetLanguage(const s32 nLanguage)
{
	if(!gnetVerify(this->GetLanguageFieldIndex() >= 0))
		return;

	m_MatchingAttrs.SetValueByIndex(this->GetLanguageFieldIndex(), nLanguage);
}

s32 NetworkGameConfig::GetLanguage() const
{
	if(!gnetVerify(this->GetLanguageFieldIndex() >= 0))
		return 0;

	return *m_MatchingAttrs.GetValueByIndex(this->GetLanguageFieldIndex());
}

void NetworkGameConfig::SetActivityType(const int nActivityType)
{
	if(!gnetVerify(this->GetActivityTypeFieldIndex() >= 0))
		return;

	m_MatchingAttrs.SetValueByIndex(this->GetActivityTypeFieldIndex(), static_cast<unsigned>(nActivityType));
}

void NetworkGameConfig::SetActivityID(const unsigned nActivityID)
{
	if(!gnetVerify(this->GetActivityIDFieldIndex() >= 0))
		return;

	m_MatchingAttrs.SetValueByIndex(this->GetActivityIDFieldIndex(), nActivityID);
}

u32 NetworkGameConfig::GetActivityType() const
{
	if(!gnetVerify(this->GetActivityTypeFieldIndex() >= 0))
		return 0;

	return *m_MatchingAttrs.GetValueByIndex(this->GetActivityTypeFieldIndex());
}

u32 NetworkGameConfig::GetActivityID() const
{
	if(!gnetVerify(this->GetActivityIDFieldIndex() >= 0))
		return 0;

	return *m_MatchingAttrs.GetValueByIndex(this->GetActivityIDFieldIndex());
}

void NetworkGameConfig::SetContentCreator(const unsigned nContentCreator)
{
	if(!gnetVerify(this->GetContentCreatorFieldIndex() >= 0))
		return;

	m_MatchingAttrs.SetValueByIndex(this->GetContentCreatorFieldIndex(), nContentCreator);
}

unsigned NetworkGameConfig::GetContentCreator() const
{
	if(!gnetVerify(this->GetContentCreatorFieldIndex() >= 0))
		return 0;

	return *m_MatchingAttrs.GetValueByIndex(this->GetContentCreatorFieldIndex());
}

void NetworkGameConfig::SetActivityIsland(const unsigned nActivityIsland)
{
	if(!gnetVerify(this->GetActivityIslandFieldIndex() >= 0))
		return;

	m_MatchingAttrs.SetValueByIndex(this->GetActivityIslandFieldIndex(), nActivityIsland);
}

unsigned NetworkGameConfig::GetActivityIsland() const
{
	if(!gnetVerify(this->GetActivityIslandFieldIndex() >= 0))
		return 0;

	return *m_MatchingAttrs.GetValueByIndex(this->GetActivityIslandFieldIndex());
}

void NetworkGameConfig::DebugPrint(bool OUTPUT_ONLY(bDetail)) const
{
#if !__NO_OUTPUT
				gnetDebug1("=== Game Config ==="); 
	if(bDetail) gnetDebug1("  Valid            = %s", this->IsValid() ? "True" : "False");
	if(bDetail) gnetDebug1("  Game Mode        = %d", this->GetGameMode());
    if(bDetail) gnetDebug1("  Session Purpose  = %s", NetworkUtils::GetSessionPurposeAsString(static_cast<SessionPurpose>(this->GetSessionPurpose())));
    if(bDetail) gnetDebug1("  Max Slots        = %d", this->GetMaxSlots());
    if(bDetail) gnetDebug1("  Max Private      = %d", this->GetMaxPrivateSlots());
				gnetDebug1("  Discriminator    = 0x%08x", this->GetDiscriminator());
    if(bDetail) gnetDebug1("    Port           = %d", this->GetPort());
	if(bDetail) gnetDebug1("    Version        = %d", this->GetVersion());
	if(bDetail) gnetDebug1("    Build          = %d", this->GetBuildType());
	if(bDetail) gnetDebug1("    Exclude        = %s", (this->GetExclude() == 1) ? "True" : "False");
				gnetDebug1("    Visible        = %s", this->IsVisible() ? "True" : "False");
				gnetDebug1("    In Progress    = %s", this->IsInProgress() ? "True" : "False");
				gnetDebug1("    Aim Type       = %s [%u / %d] Reason: %s", g_szAimBucket[this->GetAimBucket()], GetMatchmakingAimBucket(), GetAimPreference(), s_AimBucketReasonStrings[s_AimBucketReason]);
    if(bDetail) gnetDebug1("    User           = %d", this->GetUser());
	if(bDetail) gnetDebug1("      Data Hash    = 0x%08x%s", this->GetMatchmakingDataHash(), PARAM_netSessionIgnoreDataHash.Get() ? " - Ignored" : "");
	if(bDetail) gnetDebug1("      Pool         = %s%s", NetworkUtils::GetPoolAsString(this->GetMatchmakingPool()), PARAM_netSessionIgnoreCheater.Get() ? " - Ignored" : "");
	if(bDetail) gnetDebug1("      Timeout      = %d%s", CNetwork::GetTimeoutTime(), PARAM_netSessionIgnoreTimeout.Get() ? " - Ignored" : "");
	if(bDetail) gnetDebug1("      Assets       = 0x%08x%s", CNetwork::GetAssetVerifier().GetCRC(), PARAM_netSessionIgnoreAssets.Get() ? " - Ignored" : "");
#if RSG_DURANGO
	if(bDetail) gnetDebug1("      Reputation   = %s%s", CLiveManager::IsOverallReputationBad() ? "True" : "False", PARAM_netSessionIgnoreReputation.Get() ? " - Ignored" : "");
#endif

	if(bDetail && this->GetLanguageFieldIndex() >= 0)
	{
		const u32* pValue = m_MatchingAttrs.GetValueByIndex(this->GetLanguageFieldIndex());
		if(pValue)
			gnetDebug1("  Language         = %s", g_szLanguages[*pValue]);
		else
			gnetDebug1("  Language         = Not Set");
	}

	if(this->GetSessionPurpose() == SessionPurpose::SP_Freeroam)
	{
		for(int i = 0; i < MAX_ACTIVE_MM_GROUPS; i++) if(this->GetGroupFieldIndex(i) >= 0)
		{
			const u32* pValue = m_MatchingAttrs.GetValueByIndex(this->GetGroupFieldIndex(i));
			if(pValue)
				gnetDebug1("  Group Members[%d] = %d", i, *pValue);
			else
				gnetDebug1("  Group Members[%d] = Not Set", i);
		}
	}
	else if(this->GetSessionPurpose() == SessionPurpose::SP_Activity)
	{
		if(this->GetContentCreatorFieldIndex() >= 0)
		{
			const u32* pValue = m_MatchingAttrs.GetValueByIndex(this->GetContentCreatorFieldIndex());
			if(pValue)
				gnetDebug1("  Content Creator  = %d", *pValue);
			else
				gnetDebug1("  Content Creator  = Not Set");
		}
		if(this->GetActivityIslandFieldIndex() >= 0)
		{
			const u32* pValue = m_MatchingAttrs.GetValueByIndex(this->GetActivityIslandFieldIndex());
			if(pValue)
				gnetDebug1("  Activity Island  = %d", *pValue);
			else
				gnetDebug1("  Activity Island  = Not Set");
		}
	}
	else
	{
		gnetDebug1("  Invalid Session Purpose (%d)", this->GetSessionPurpose());
	}
	
	if(bDetail && this->GetActivityTypeFieldIndex() >= 0)
	{
		const u32* pValue = m_MatchingAttrs.GetValueByIndex(this->GetActivityTypeFieldIndex());
		if(pValue)
			gnetDebug1("  Activity Type    = %d", *pValue);
		else
			gnetDebug1("  Activity Type    = Not Set");
	}

	if(bDetail && this->GetActivityIDFieldIndex() >= 0)
	{
		const u32* pValue = m_MatchingAttrs.GetValueByIndex(this->GetActivityIDFieldIndex());
		if(pValue)
			gnetDebug1("  Activity ID      = %08x", *pValue);
		else
			gnetDebug1("  Activity ID      = Not Set");
	}

    if(bDetail && this->GetActivityPlayersFieldIndex() >= 0)
    {
        const u32* pValue = m_MatchingAttrs.GetValueByIndex(this->GetActivityPlayersFieldIndex());
        if(pValue)
            gnetDebug1("  Activity Slots   = %08x", *pValue);
        else
            gnetDebug1("  Activity Slots   = Not Set");
    }
#endif
}

///////////////////////////////////////////////////////////////////////////////
//  NetworkGameFilter
///////////////////////////////////////////////////////////////////////////////

NetworkGameFilter::NetworkGameFilter()
{
    this->Clear();
}

void
NetworkGameFilter::Clear()
{
	m_bIsRegionApplied = false;
	m_bIsLanguageApplied = false;
	//@@: location NETWORKGAMEFILTER_CLEAR_BASE_CONFIG
	this->NetworkBaseConfig::Clear();
    this->SetVisible(true);
	this->SetInProgress(false);
	m_Filter.Clear();
}

void NetworkGameFilter::ApplyRegion(bool bApplyRegion)
{
	//@@: range NETWORKGAMEFILTER_APPLYREGION {
	m_bIsRegionApplied = bApplyRegion;
	if(bApplyRegion)
		m_Filter.SetValue(this->GetRegionFieldIndex(), this->GetMatchmakingRegion());
	else
		m_Filter.ClearValue(this->GetRegionFieldIndex()); 
	//@@: } NETWORKGAMEFILTER_APPLYREGION

}

void NetworkGameFilter::ApplyLanguage(bool bApplyLanguage)
{
	//@@: range NETWORKGAMEFILTER_APPLYLANGUAGE {
	m_bIsLanguageApplied = bApplyLanguage;
	if(bApplyLanguage)
		m_Filter.SetValue(this->GetLanguageFieldIndex(), this->GetMatchmakingLanguage());
	else
		m_Filter.ClearValue(this->GetLanguageFieldIndex()); 
	//@@: } NETWORKGAMEFILTER_APPLYLANGUAGE
}

bool
NetworkGameFilter::IsValid() const
{
	bool isValid = true;
	isValid &= (this->GetDiscriminatorFieldIndex() != -1); 

	// if we have a valid group limit index, make sure that we've applied a limit to at least one group
	if(isValid && m_Filter.GetId() == player_schema::MatchingFilter_Group::FILTER_ID)
	{
		bool bHasGroupLimit = false;
		for(int i = 0; i < MAX_ACTIVE_MM_GROUPS; i++) if(!bHasGroupLimit && this->GetGroupFieldIndex(i) >= 0)
			bHasGroupLimit |= (m_Filter.GetValue(this->GetGroupFieldIndex(i)) != NULL);

		isValid &= bHasGroupLimit;
	}
	
	return isValid;
}

unsigned
NetworkGameFilter::GetMatchingFilterID() const
{
    return m_Filter.GetId();
}

const rlMatchingFilter&
NetworkGameFilter::GetMatchingFilter() const
{
	m_Filter.SetValue(this->GetDiscriminatorFieldIndex(), this->GetDiscriminator());
	return m_Filter;
}

void NetworkGameFilter::SetGameMode(const u16 gameMode)
{
    m_Filter.SetGameMode(gameMode);
}

u16 NetworkGameFilter::GetGameMode() const
{
    return m_Filter.GetGameMode();
}

void NetworkGameFilter::SetSessionPurpose(const u16 sessionPurpose)
{
    m_Filter.SetSessionPurpose(sessionPurpose);
}

u16 NetworkGameFilter::GetSessionPurpose() const
{
    return m_Filter.GetSessionPurpose();
}

void NetworkGameFilter::SetGroupLimit(const unsigned nGroup, unsigned nLimit)
{
	if(!gnetVerify(this->GetGroupFieldIndex(nGroup) >= 0))
		return;

	m_Filter.SetValue(this->GetGroupFieldIndex(nGroup), nLimit);
}

void NetworkGameFilter::SetActivityType(const int nActivityType)
{
	if(!gnetVerify(this->GetActivityTypeFieldIndex() >= 0))
		return;

	m_Filter.SetValue(this->GetActivityTypeFieldIndex(), static_cast<unsigned>(nActivityType));
}

void NetworkGameFilter::SetActivityID(const unsigned nActivityID)
{
	if(!gnetVerify(this->GetActivityIDFieldIndex() >= 0))
		return;

	m_Filter.SetValue(this->GetActivityIDFieldIndex(), nActivityID);
}

bool NetworkGameFilter::GetActivityType(unsigned& nActivityType)
{
	if(this->GetActivityTypeFieldIndex() == -1)
		return false; 

	const unsigned* pValue = m_Filter.GetValue(this->GetActivityTypeFieldIndex());
	if(pValue)
		nActivityType = *pValue;

	return (pValue != NULL);
}

bool NetworkGameFilter::GetActivityID(unsigned& nActivityID)
{
	if(this->GetActivityIDFieldIndex() == -1)
		return false; 

	const unsigned* pValue = m_Filter.GetValue(this->GetActivityIDFieldIndex());
	if(pValue)
		nActivityID = *pValue;

	return (pValue != NULL);
}

void NetworkGameFilter::SetActivitySlotsRequired(const unsigned nSlotsRequired)
{
    if(!gnetVerify(this->GetActivityPlayersFieldIndex() >= 0))
        return;

    m_Filter.SetValue(this->GetActivityPlayersFieldIndex(), nSlotsRequired);
}

void NetworkGameFilter::SetInProgress(const bool bInProgress)
{
	this->NetworkBaseConfig::SetInProgress(bInProgress);
}

void NetworkGameFilter::SetContentFilter(const unsigned nContentFilter)
{
	if(!gnetVerify(this->GetContentCreatorFieldIndex() >= 0))
		return;

	m_Filter.SetValue(this->GetContentCreatorFieldIndex(), nContentFilter);
}

bool NetworkGameFilter::GetContentFilter(unsigned& nContentFilter)
{
	if(this->GetContentCreatorFieldIndex() == -1)
		return false; 

	const unsigned* pValue = m_Filter.GetValue(this->GetContentCreatorFieldIndex());
	if(pValue)
		nContentFilter = *pValue;

	return (pValue != NULL);
}

void NetworkGameFilter::SetActivityIsland(const unsigned nActivityIsland)
{
	if(!gnetVerify(this->GetActivityIslandFieldIndex() >= 0))
		return;

	m_Filter.SetValue(this->GetActivityIslandFieldIndex(), nActivityIsland);
}

bool NetworkGameFilter::GetActivityIsland(unsigned& nActivityIsland)
{
	if(this->GetActivityIslandFieldIndex() == -1)
		return false; 

	const unsigned* pValue = m_Filter.GetValue(this->GetActivityIslandFieldIndex());
	if(pValue)
		nActivityIsland = *pValue;

	return (pValue != NULL);
}

void NetworkGameFilter::DebugPrint() const
{
	gnetDebug1("=== Matchmaking Filter ==="); 
	gnetDebug1("  Filter          = %d", m_Filter.GetId());
	gnetDebug1("  Valid           = %s", this->IsValid() ? "True" : "False");
	gnetDebug1("  Game Mode       = %d", this->GetGameMode());
    gnetDebug1("  SessionPurpose  = %s", NetworkUtils::GetSessionPurposeAsString(static_cast<SessionPurpose>(this->GetSessionPurpose())));
    gnetDebug1("  Discriminator   = 0x%08x", this->GetDiscriminator());
	gnetDebug1("  Port            = %d", this->GetPort());
	gnetDebug1("  Version         = %d", this->GetVersion());
	gnetDebug1("  Build           = %d", this->GetBuildType());
	gnetDebug1("  Exclude         = %s", (this->GetExclude() == 1) ? "True" : "False");
	gnetDebug1("  Visible         = %s", this->IsVisible() ? "True" : "False");
	gnetDebug1("  In Progress     = %s", this->IsInProgress() ? "True" : "False");
	gnetDebug1("  Aim Type        = %s [%u / %d] Reason: %s", g_szAimBucket[this->GetAimBucket()], GetMatchmakingAimBucket(), GetAimPreference(), s_AimBucketReasonStrings[s_AimBucketReason]);
	gnetDebug1("  User            = %d", this->GetUser());
	gnetDebug1("    Data Hash     = 0x%08x%s", this->GetMatchmakingDataHash(), PARAM_netSessionIgnoreDataHash.Get() ? " - Ignored" : "");
	gnetDebug1("    Pool          = %s%s", NetworkUtils::GetPoolAsString(this->GetMatchmakingPool()), PARAM_netSessionIgnoreCheater.Get() ? " - Ignored" : "");
	gnetDebug1("    Timeout       = %d%s", CNetwork::GetTimeoutTime(), PARAM_netSessionIgnoreTimeout.Get() ? " - Ignored" : "");
	gnetDebug1("    Assets        = 0x%08x%s", CNetwork::GetAssetVerifier().GetCRC(), PARAM_netSessionIgnoreAssets.Get() ? " - Ignored" : "");
#if RSG_DURANGO
	gnetDebug1("    Reputation    = %s%s", CLiveManager::IsOverallReputationBad() ? "True" : "False", PARAM_netSessionIgnoreReputation.Get() ? " - Ignored" : "");
#endif

	if(this->GetLanguageFieldIndex() >= 0)
	{
		const u32* pValue = m_Filter.GetValue(this->GetLanguageFieldIndex());
		if(pValue)
			gnetDebug1("  Language        = %s", g_szLanguages[*pValue]);
		else
			gnetDebug1("  Language        = Not Set");
	}
	
	if(this->GetSessionPurpose() == SessionPurpose::SP_Freeroam)
	{
		for(int i = 0; i < MAX_ACTIVE_MM_GROUPS; i++) if(this->GetGroupFieldIndex(i) >= 0)
		{
			const u32* pValue = m_Filter.GetValue(this->GetGroupFieldIndex(i));
			if(pValue)
				gnetDebug1("  Group Limits[%d] = %d", i, *pValue);
			else
				gnetDebug1("  Group Limits[%d] = Not Set", i);
		}
	}
	else if(this->GetSessionPurpose() == SessionPurpose::SP_Activity)
	{
		if(this->GetContentCreatorFieldIndex() >= 0)
		{
			const u32* pValue = m_Filter.GetValue(this->GetContentCreatorFieldIndex());
			if(pValue)
				gnetDebug1("  Content Filter  = %d", *pValue);
			else
				gnetDebug1("  Content Filter  = Not Set");
		}
		if(this->GetActivityIslandFieldIndex() >= 0)
		{
			const u32* pValue = m_Filter.GetValue(this->GetActivityIslandFieldIndex());
			if(pValue)
				gnetDebug1("  Activity Island  = %d", *pValue);
			else
				gnetDebug1("  Activity Island  = Not Set");
		}
	}
	else
	{
		gnetDebug1("  Invalid Session Purpose (%d)", this->GetSessionPurpose());
	}

	if(this->GetActivityTypeFieldIndex() >= 0)
	{
		const u32* pValue = m_Filter.GetValue(this->GetActivityTypeFieldIndex());
		if(pValue)
			gnetDebug1("  Activity Type    = %d", *pValue);
		else
			gnetDebug1("  Activity Type    = Not Set");
	}

	if(this->GetActivityIDFieldIndex() >= 0)
	{
		const u32* pValue = m_Filter.GetValue(this->GetActivityIDFieldIndex());
		if(pValue)
			gnetDebug1("  Activity ID      = %08x", *pValue);
		else
			gnetDebug1("  Activity ID      = Not Set");
	}

    if(this->GetActivityPlayersFieldIndex() >= 0)
    {
        const u32* pValue = m_Filter.GetValue(this->GetActivityPlayersFieldIndex());
        if(pValue)
            gnetDebug1("  Activity Slots   = %08x", *pValue);
        else
            gnetDebug1("  Activity Slots   = Not Set");
    }
}
