#ifndef FUZZY_XB1_HEISTS_SCHEMA_H
#define FUZZY_XB1_HEISTS_SCHEMA_H

//DO NOT MODIFY THIS FILE!
//It was automatically generated by xlast2c v2.0 on 2017-11-27-13-08-14 -05


#include <string.h>



namespace player_schema
{

class SchemaBase
{
public:
    enum FieldType
    {
        FIELDTYPE_INVALID = -1,
        FIELDTYPE_INT32 = 1,
        FIELDTYPE_INT64 = 2,
        FIELDTYPE_FLOAT = 5,
        FIELDTYPE_DOUBLE = 3,
    };
    enum FieldId
    {
        FIELD_ID_MMATTR_REGION = 0x10000018,
        FIELD_ID_MMATTR_AIM_TYPE = 0x10000017,
        FIELD_ID_GAME_MODE = 0x0000800b,
        FIELD_ID_MMATTR_MM_GROUP_2 = 0x10000014,
        FIELD_ID_MMATTR_MM_GROUP_1 = 0x10000013,
        FIELD_ID_MMATTR_ACTIVITY_PLAYERS = 0x1000001c,
        FIELD_ID_RANK = 0x10008001,
        FIELD_ID_CT_SPRC = 0x0000000f,
        FIELD_ID_CT_SPMG = 0x0000000e,
        FIELD_ID_MMATTR_DISCRIMINATOR = 0x10000001,
        FIELD_ID_CT_SESSION_TYPE = 0x0000000c,
        FIELD_ID_CT_RACES = 0x0000000a,
        FIELD_ID_CT_GAMEMODES = 0x00000009,
        FIELD_ID_CT_MAP_AREA = 0x00000008,
        FIELD_ID_CT_GANGS = 0x00000006,
        FIELD_ID_CT_MP_MISSIONS = 0x00000005,
        FIELD_ID_CT_DEATHM_LOC = 0x00000004,
        FIELD_ID_CT_SP_MISSIONS = 0x00000003,
        FIELD_ID_MMATTR_ACTIVITY_ID = 0x1000001b,
        FIELD_ID_MMATTR_ACTIVITY_TYPE = 0x1000001a,
    };
    enum CT_SP_MISSIONS
    {
        SPM_2 = 2,
        SPM_56 = 56,
        SPM_102 = 102,
        SPM_51 = 51,
        SPM_41 = 41,
        SPM_9 = 9,
        SPM_42 = 42,
        SPM_11 = 11,
        SPM_47 = 47,
        SPM_31 = 31,
        SPM_21 = 21,
        SPM_17 = 17,
        SPM_22 = 22,
        SPM_18 = 18,
        SPM_48 = 48,
        SPM_38 = 38,
        SPM_28 = 28,
        SPM_92 = 92,
        SPM_82 = 82,
        SPM_97 = 97,
        SPM_87 = 87,
        SPM_98 = 98,
        SPM_68 = 68,
        SPM_125 = 125,
        SPM_107 = 107,
        SPM_70 = 70,
        SPM_104 = 104,
        SPM_61 = 61,
        SPM_116 = 116,
        SPM_73 = 73,
        SPM_128 = 128,
        SPM_57 = 57,
        SPM_112 = 112,
        SPM_65 = 65,
        SPM_118 = 118,
        SPM_33 = 33,
        SPM_77 = 77,
        SPM_114 = 114,
        SPM_95 = 95,
        SPM_124 = 124,
        SPM_88 = 88,
        SPM_120 = 120,
        SPM_69 = 69,
        SPM_76 = 76,
        SPM_53 = 53,
        SPM_43 = 43,
        SPM_54 = 54,
        SPM_63 = 63,
        SPM_13 = 13,
        SPM_49 = 49,
        SPM_14 = 14,
        SPM_23 = 23,
        SPM_19 = 19,
        SPM_24 = 24,
        SPM_39 = 39,
        SPM_29 = 29,
        SPM_93 = 93,
        SPM_83 = 83,
        SPM_94 = 94,
        SPM_84 = 84,
        SPM_99 = 99,
        SPM_89 = 89,
        SPM_117 = 117,
        SPM_123 = 123,
        SPM_109 = 109,
        SPM_62 = 62,
        SPM_113 = 113,
        SPM_30 = 30,
        SPM_121 = 121,
        SPM_74 = 74,
        SPM_101 = 101,
        SPM_58 = 58,
        SPM_122 = 122,
        SPM_66 = 66,
        SPM_6 = 6,
        SPM_34 = 34,
        SPM_78 = 78,
        SPM_105 = 105,
        SPM_72 = 72,
        SPM_127 = 127,
        SPM_71 = 71,
        SPM_37 = 37,
        SPM_81 = 81,
        SPM_64 = 64,
        SPM_129 = 129,
        SPM_126 = 126,
        SPM_50 = 50,
        SPM_40 = 40,
        SPM_55 = 55,
        SPM_45 = 45,
        SPM_10 = 10,
        SPM_46 = 46,
        SPM_15 = 15,
        SPM_20 = 20,
        SPM_16 = 16,
        SPM_25 = 25,
        SPM_36 = 36,
        SPM_26 = 26,
        SPM_90 = 90,
        SPM_80 = 80,
        SPM_75 = 75,
        SPM_85 = 85,
        SPM_96 = 96,
        SPM_86 = 86,
        SPM_59 = 59,
        SPM_8 = 8,
        SPM_110 = 110,
        SPM_67 = 67,
        SPM_119 = 119,
        SPM_35 = 35,
        SPM_79 = 79,
        SPM_100 = 100,
        SPM_115 = 115,
        SPM_91 = 91,
        SPM_111 = 111,
        SPM_27 = 27,
        SPM_103 = 103,
        SPM_52 = 52,
        SPM_108 = 108,
        SPM_60 = 60,
        SPM_106 = 106,
        SPM_12 = 12,
        SPM_32 = 32,
        SPM_5 = 5,
        SPM_4 = 4,
        SPM_7 = 7,
        SPM_44 = 44,
        SPM_1 = 1,
        SPM_0 = 0,
        SPM_3 = 3,
    };
    enum CT_DEATHM_LOC
    {
        DM_LOC_0 = 0,
        DM_LOC_23 = 23,
        DM_LOC_22 = 22,
        DM_LOC_21 = 21,
        DM_LOC_20 = 20,
        DM_LOC_27 = 27,
        DM_LOC_26 = 26,
        DM_LOC_25 = 25,
        DM_LOC_24 = 24,
        DM_LOC_17 = 17,
        DM_LOC_19 = 19,
        DM_LOC_18 = 18,
        DM_LOC_13 = 13,
        DM_LOC_12 = 12,
        DM_LOC_11 = 11,
        DM_LOC_10 = 10,
        DM_LOC_6 = 6,
        DM_LOC_16 = 16,
        DM_LOC_15 = 15,
        DM_LOC_14 = 14,
        DM_LOC_9 = 9,
        DM_LOC_8 = 8,
        DM_LOC_1 = 1,
        DM_LOC_7 = 7,
        DM_LOC_2 = 2,
        DM_LOC_4 = 4,
        DM_LOC_28 = 28,
        DM_LOC_3 = 3,
        DM_LOC_5 = 5,
    };
    enum CT_MP_MISSIONS
    {
        MPM_37 = 37,
        MPM_76 = 76,
        MPM_83 = 83,
        MPM_73 = 73,
        MPM_63 = 63,
        MPM_31 = 31,
        MPM_43 = 43,
        MPM_17 = 17,
        MPM_44 = 44,
        MPM_59 = 59,
        MPM_49 = 49,
        MPM_39 = 39,
        MPM_29 = 29,
        MPM_19 = 19,
        MPM_82 = 82,
        MPM_87 = 87,
        MPM_94 = 94,
        MPM_74 = 74,
        MPM_67 = 67,
        MPM_10 = 10,
        MPM_54 = 54,
        MPM_22 = 22,
        MPM_66 = 66,
        MPM_84 = 84,
        MPM_34 = 34,
        MPM_78 = 78,
        MPM_14 = 14,
        MPM_71 = 71,
        MPM_64 = 64,
        MPM_90 = 90,
        MPM_80 = 80,
        MPM_70 = 70,
        MPM_60 = 60,
        MPM_50 = 50,
        MPM_40 = 40,
        MPM_30 = 30,
        MPM_45 = 45,
        MPM_56 = 56,
        MPM_46 = 46,
        MPM_36 = 36,
        MPM_26 = 26,
        MPM_16 = 16,
        MPM_11 = 11,
        MPM_55 = 55,
        MPM_75 = 75,
        MPM_23 = 23,
        MPM_24 = 24,
        MPM_35 = 35,
        MPM_79 = 79,
        MPM_15 = 15,
        MPM_27 = 27,
        MPM_92 = 92,
        MPM_72 = 72,
        MPM_9 = 9,
        MPM_8 = 8,
        MPM_7 = 7,
        MPM_6 = 6,
        MPM_5 = 5,
        MPM_4 = 4,
        MPM_3 = 3,
        MPM_2 = 2,
        MPM_1 = 1,
        MPM_0 = 0,
        MPM_91 = 91,
        MPM_81 = 81,
        MPM_32 = 32,
        MPM_61 = 61,
        MPM_51 = 51,
        MPM_62 = 62,
        MPM_52 = 52,
        MPM_42 = 42,
        MPM_57 = 57,
        MPM_47 = 47,
        MPM_58 = 58,
        MPM_48 = 48,
        MPM_38 = 38,
        MPM_28 = 28,
        MPM_18 = 18,
        MPM_12 = 12,
        MPM_68 = 68,
        MPM_88 = 88,
        MPM_93 = 93,
        MPM_41 = 41,
        MPM_85 = 85,
        MPM_53 = 53,
        MPM_21 = 21,
        MPM_65 = 65,
        MPM_33 = 33,
        MPM_77 = 77,
        MPM_89 = 89,
        MPM_20 = 20,
        MPM_13 = 13,
        MPM_86 = 86,
        MPM_25 = 25,
        MPM_69 = 69,
    };
    enum CT_GANGS
    {
        GANG_2 = 2,
        GANG_1 = 1,
        Cop = 0,
        GANG_3 = 3,
        GANG_4 = 4,
    };
    enum CT_MAP_AREA
    {
        MAP_AREA_0 = 0,
    };
    enum CT_GAMEMODES
    {
        GAME_0 = 0,
        GAME_4 = 4,
        GAME_1 = 1,
        GAME_2 = 2,
        GAME_3 = 3,
    };
    enum CT_RACES
    {
        RACE_0 = 0,
    };
    enum CT_SESSION_TYPE
    {
        GAME = 0,
        PARTY = 1,
    };
    enum CT_SPMG
    {
        SPMG_3 = 3,
        SPMG_30 = 30,
        SPMG_4 = 4,
        SPMG_1 = 1,
        SPMG_9 = 9,
        SPMG_11 = 11,
        SPMG_10 = 10,
        SPMG_2 = 2,
        SPMG_20 = 20,
        SPMG_7 = 7,
        SPMG_14 = 14,
        SPMG_13 = 13,
        SPMG_12 = 12,
        SPMG_8 = 8,
        SPMG_24 = 24,
        SPMG_23 = 23,
        SPMG_21 = 21,
        SPMG_22 = 22,
        SPMG_18 = 18,
        SPMG_17 = 17,
        SPMG_16 = 16,
        SPMG_15 = 15,
        SPMG_28 = 28,
        SPMG_5 = 5,
        SPMG_26 = 26,
        SPMG_25 = 25,
        SPMG_6 = 6,
        SPMG_19 = 19,
        SPMG_27 = 27,
        SPMG_29 = 29,
        SPMG_0 = 0,
    };
    enum CT_SPRC
    {
        SPRC_61 = 61,
        SPRC_59 = 59,
        SPRC_69 = 69,
        SPRC_36 = 36,
        SPRC_46 = 46,
        SPRC_57 = 57,
        SPRC_28 = 28,
        SPRC_67 = 67,
        SPRC_32 = 32,
        SPRC_42 = 42,
        SPRC_53 = 53,
        SPRC_63 = 63,
        SPRC_29 = 29,
        SPRC_34 = 34,
        SPRC_44 = 44,
        SPRC_30 = 30,
        SPRC_40 = 40,
        SPRC_3 = 3,
        SPRC_4 = 4,
        SPRC_9 = 9,
        SPRC_48 = 48,
        SPRC_15 = 15,
        SPRC_25 = 25,
        SPRC_11 = 11,
        SPRC_21 = 21,
        SPRC_19 = 19,
        SPRC_38 = 38,
        SPRC_17 = 17,
        SPRC_56 = 56,
        SPRC_27 = 27,
        SPRC_66 = 66,
        SPRC_13 = 13,
        SPRC_52 = 52,
        SPRC_23 = 23,
        SPRC_62 = 62,
        SPRC_54 = 54,
        SPRC_64 = 64,
        SPRC_50 = 50,
        SPRC_60 = 60,
        SPRC_0 = 0,
        SPRC_5 = 5,
        SPRC_6 = 6,
        SPRC_58 = 58,
        SPRC_68 = 68,
        SPRC_35 = 35,
        SPRC_18 = 18,
        SPRC_45 = 45,
        SPRC_31 = 31,
        SPRC_41 = 41,
        SPRC_39 = 39,
        SPRC_49 = 49,
        SPRC_16 = 16,
        SPRC_26 = 26,
        SPRC_37 = 37,
        SPRC_47 = 47,
        SPRC_12 = 12,
        SPRC_22 = 22,
        SPRC_33 = 33,
        SPRC_43 = 43,
        SPRC_14 = 14,
        SPRC_24 = 24,
        SPRC_10 = 10,
        SPRC_20 = 20,
        SPRC_70 = 70,
        SPRC_1 = 1,
        SPRC_2 = 2,
        SPRC_7 = 7,
        SPRC_8 = 8,
        SPRC_55 = 55,
        SPRC_65 = 65,
        SPRC_51 = 51,
    };
    static FieldType GetFieldTypeFromFieldId(const FieldId fieldId)
    {
        switch((int)fieldId)
        {
        case FIELD_ID_MMATTR_REGION: return FIELDTYPE_INT32;
        case FIELD_ID_MMATTR_AIM_TYPE: return FIELDTYPE_INT32;
        case FIELD_ID_GAME_MODE: return FIELDTYPE_INT32;
        case FIELD_ID_MMATTR_MM_GROUP_2: return FIELDTYPE_INT32;
        case FIELD_ID_MMATTR_MM_GROUP_1: return FIELDTYPE_INT32;
        case FIELD_ID_MMATTR_ACTIVITY_PLAYERS: return FIELDTYPE_INT32;
        case FIELD_ID_RANK: return FIELDTYPE_INT32;
        case FIELD_ID_CT_SPRC: return FIELDTYPE_INT32;
        case FIELD_ID_CT_SPMG: return FIELDTYPE_INT32;
        case FIELD_ID_MMATTR_DISCRIMINATOR: return FIELDTYPE_INT32;
        case FIELD_ID_CT_SESSION_TYPE: return FIELDTYPE_INT32;
        case FIELD_ID_CT_RACES: return FIELDTYPE_INT32;
        case FIELD_ID_CT_GAMEMODES: return FIELDTYPE_INT32;
        case FIELD_ID_CT_MAP_AREA: return FIELDTYPE_INT32;
        case FIELD_ID_CT_GANGS: return FIELDTYPE_INT32;
        case FIELD_ID_CT_MP_MISSIONS: return FIELDTYPE_INT32;
        case FIELD_ID_CT_DEATHM_LOC: return FIELDTYPE_INT32;
        case FIELD_ID_CT_SP_MISSIONS: return FIELDTYPE_INT32;
        case FIELD_ID_MMATTR_ACTIVITY_ID: return FIELDTYPE_INT32;
        case FIELD_ID_MMATTR_ACTIVITY_TYPE: return FIELDTYPE_INT32;
        }
        return FIELDTYPE_INVALID;
    }
};
class MatchingAttributes : public SchemaBase
{
public:
    enum
    {
        FIELD_COUNT = 8,
    };
    enum GAME_MODE
    {
        GAME_MODE_GM0_STR = 0,
        GAME_MODE_GM4_STR = 4,
        GAME_MODE_GM3_STR = 3,
        GAME_MODE_GM1_STR = 1,
        GAME_MODE_GM6_STR = 6,
        GAME_MODE_GM5_STR = 5,
        GAME_MODE_GM2_STR = 2,
    };
    MatchingAttributes()
    {
        *(rage::u32*) m_fieldCount = 8;
        *(rage::u64*) m_fieldMask = 0;
        *(rage::u32*) m_MMATTR_DISCRIMINATOR_id = 0x10000001;
        *(rage::u32*) m_MMATTR_MM_GROUP_1_id = 0x10000013;
        *(rage::u32*) m_MMATTR_MM_GROUP_2_id = 0x10000014;
        *(rage::u32*) m_MMATTR_AIM_TYPE_id = 0x10000017;
        *(rage::u32*) m_MMATTR_REGION_id = 0x10000018;
        *(rage::u32*) m_MMATTR_ACTIVITY_TYPE_id = 0x1000001a;
        *(rage::u32*) m_MMATTR_ACTIVITY_ID_id = 0x1000001b;
        *(rage::u32*) m_MMATTR_ACTIVITY_PLAYERS_id = 0x1000001c;
    }
    bool IsFieldNil(const int fieldIndex) const
    {
        return 0 != (*((const rage::u64*) m_fieldMask) & (rage::u64(1) << fieldIndex));
    }
    void ClearField(const int fieldIndex)
    {
        *((rage::u64*) m_fieldMask) &= ~(rage::u64(1) << fieldIndex);
    }
    void ClearAllFields()
    {
        *((rage::u64*) m_fieldMask) = rage::u64(0);
    }
    bool SetFieldData(const int fieldIndex, const void* data, const unsigned sizeofData)
    {
        switch(fieldIndex)
        {
        case 0:
        if(sizeof(m_MMATTR_DISCRIMINATOR)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_DISCRIMINATOR = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<0);
            return true;
        }
        break;
        case 1:
        if(sizeof(m_MMATTR_MM_GROUP_1)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_MM_GROUP_1 = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<1);
            return true;
        }
        break;
        case 2:
        if(sizeof(m_MMATTR_MM_GROUP_2)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_MM_GROUP_2 = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<2);
            return true;
        }
        break;
        case 3:
        if(sizeof(m_MMATTR_AIM_TYPE)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_AIM_TYPE = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<3);
            return true;
        }
        break;
        case 4:
        if(sizeof(m_MMATTR_REGION)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_REGION = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<4);
            return true;
        }
        break;
        case 5:
        if(sizeof(m_MMATTR_ACTIVITY_TYPE)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_ACTIVITY_TYPE = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<5);
            return true;
        }
        break;
        case 6:
        if(sizeof(m_MMATTR_ACTIVITY_ID)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_ACTIVITY_ID = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<6);
            return true;
        }
        break;
        case 7:
        if(sizeof(m_MMATTR_ACTIVITY_PLAYERS)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_ACTIVITY_PLAYERS = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<7);
            return true;
        }
        break;
        }
        return false;
    }
    const void* GetFieldData(const int fieldIndex) const
    {
        switch(fieldIndex)
        {
        case 0: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<0)) ? m_MMATTR_DISCRIMINATOR : 0;
        case 1: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<1)) ? m_MMATTR_MM_GROUP_1 : 0;
        case 2: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<2)) ? m_MMATTR_MM_GROUP_2 : 0;
        case 3: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<3)) ? m_MMATTR_AIM_TYPE : 0;
        case 4: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<4)) ? m_MMATTR_REGION : 0;
        case 5: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<5)) ? m_MMATTR_ACTIVITY_TYPE : 0;
        case 6: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<6)) ? m_MMATTR_ACTIVITY_ID : 0;
        case 7: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<7)) ? m_MMATTR_ACTIVITY_PLAYERS : 0;
        }
        return 0;
    }
    void SetMMATTR_DISCRIMINATOR(const rage::u32 val) { *(rage::u32*) m_MMATTR_DISCRIMINATOR = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<0); }
    rage::u32 GetMMATTR_DISCRIMINATOR() const { return *(rage::u32*) m_MMATTR_DISCRIMINATOR; }
    void ClearMMATTR_DISCRIMINATOR() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<0); }
    bool IsSetMMATTR_DISCRIMINATOR() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<0)) != 0; }
    void SetMMATTR_MM_GROUP_1(const rage::u32 val) { *(rage::u32*) m_MMATTR_MM_GROUP_1 = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<1); }
    rage::u32 GetMMATTR_MM_GROUP_1() const { return *(rage::u32*) m_MMATTR_MM_GROUP_1; }
    void ClearMMATTR_MM_GROUP_1() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<1); }
    bool IsSetMMATTR_MM_GROUP_1() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<1)) != 0; }
    void SetMMATTR_MM_GROUP_2(const rage::u32 val) { *(rage::u32*) m_MMATTR_MM_GROUP_2 = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<2); }
    rage::u32 GetMMATTR_MM_GROUP_2() const { return *(rage::u32*) m_MMATTR_MM_GROUP_2; }
    void ClearMMATTR_MM_GROUP_2() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<2); }
    bool IsSetMMATTR_MM_GROUP_2() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<2)) != 0; }
    void SetMMATTR_AIM_TYPE(const rage::u32 val) { *(rage::u32*) m_MMATTR_AIM_TYPE = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<3); }
    rage::u32 GetMMATTR_AIM_TYPE() const { return *(rage::u32*) m_MMATTR_AIM_TYPE; }
    void ClearMMATTR_AIM_TYPE() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<3); }
    bool IsSetMMATTR_AIM_TYPE() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<3)) != 0; }
    void SetMMATTR_REGION(const rage::u32 val) { *(rage::u32*) m_MMATTR_REGION = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<4); }
    rage::u32 GetMMATTR_REGION() const { return *(rage::u32*) m_MMATTR_REGION; }
    void ClearMMATTR_REGION() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<4); }
    bool IsSetMMATTR_REGION() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<4)) != 0; }
    void SetMMATTR_ACTIVITY_TYPE(const rage::u32 val) { *(rage::u32*) m_MMATTR_ACTIVITY_TYPE = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<5); }
    rage::u32 GetMMATTR_ACTIVITY_TYPE() const { return *(rage::u32*) m_MMATTR_ACTIVITY_TYPE; }
    void ClearMMATTR_ACTIVITY_TYPE() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<5); }
    bool IsSetMMATTR_ACTIVITY_TYPE() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<5)) != 0; }
    void SetMMATTR_ACTIVITY_ID(const rage::u32 val) { *(rage::u32*) m_MMATTR_ACTIVITY_ID = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<6); }
    rage::u32 GetMMATTR_ACTIVITY_ID() const { return *(rage::u32*) m_MMATTR_ACTIVITY_ID; }
    void ClearMMATTR_ACTIVITY_ID() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<6); }
    bool IsSetMMATTR_ACTIVITY_ID() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<6)) != 0; }
    void SetMMATTR_ACTIVITY_PLAYERS(const rage::u32 val) { *(rage::u32*) m_MMATTR_ACTIVITY_PLAYERS = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<7); }
    rage::u32 GetMMATTR_ACTIVITY_PLAYERS() const { return *(rage::u32*) m_MMATTR_ACTIVITY_PLAYERS; }
    void ClearMMATTR_ACTIVITY_PLAYERS() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<7); }
    bool IsSetMMATTR_ACTIVITY_PLAYERS() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<7)) != 0; }
    static int GetFieldIndexFromFieldId(const FieldId fieldId)
    {
        switch((int)fieldId)
        {
        case FIELD_ID_MMATTR_DISCRIMINATOR: return 0;
        case FIELD_ID_MMATTR_MM_GROUP_1: return 1;
        case FIELD_ID_MMATTR_MM_GROUP_2: return 2;
        case FIELD_ID_MMATTR_AIM_TYPE: return 3;
        case FIELD_ID_MMATTR_REGION: return 4;
        case FIELD_ID_MMATTR_ACTIVITY_TYPE: return 5;
        case FIELD_ID_MMATTR_ACTIVITY_ID: return 6;
        case FIELD_ID_MMATTR_ACTIVITY_PLAYERS: return 7;
        }
        return -1;
    }
    static FieldId GetFieldIdFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return FIELD_ID_MMATTR_DISCRIMINATOR;
        case 1: return FIELD_ID_MMATTR_MM_GROUP_1;
        case 2: return FIELD_ID_MMATTR_MM_GROUP_2;
        case 3: return FIELD_ID_MMATTR_AIM_TYPE;
        case 4: return FIELD_ID_MMATTR_REGION;
        case 5: return FIELD_ID_MMATTR_ACTIVITY_TYPE;
        case 6: return FIELD_ID_MMATTR_ACTIVITY_ID;
        case 7: return FIELD_ID_MMATTR_ACTIVITY_PLAYERS;
        }
        return FieldId(-1);
    }
    static const char* GetFieldNameFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return "MMATTR_DISCRIMINATOR";
        case 1: return "MMATTR_MM_GROUP_1";
        case 2: return "MMATTR_MM_GROUP_2";
        case 3: return "MMATTR_AIM_TYPE";
        case 4: return "MMATTR_REGION";
        case 5: return "MMATTR_ACTIVITY_TYPE";
        case 6: return "MMATTR_ACTIVITY_ID";
        case 7: return "MMATTR_ACTIVITY_PLAYERS";
        }
        return NULL;
    }
    static void GetFieldIds(unsigned (&fldIds)[FIELD_COUNT])
    {
        fldIds[0] = FIELD_ID_MMATTR_DISCRIMINATOR;
        fldIds[1] = FIELD_ID_MMATTR_MM_GROUP_1;
        fldIds[2] = FIELD_ID_MMATTR_MM_GROUP_2;
        fldIds[3] = FIELD_ID_MMATTR_AIM_TYPE;
        fldIds[4] = FIELD_ID_MMATTR_REGION;
        fldIds[5] = FIELD_ID_MMATTR_ACTIVITY_TYPE;
        fldIds[6] = FIELD_ID_MMATTR_ACTIVITY_ID;
        fldIds[7] = FIELD_ID_MMATTR_ACTIVITY_PLAYERS;
    }
    static void GetFieldNames(const char* (&fldNames)[FIELD_COUNT])
    {
        fldNames[0] = GetFieldNameFromFieldIndex(0);
        fldNames[1] = GetFieldNameFromFieldIndex(1);
        fldNames[2] = GetFieldNameFromFieldIndex(2);
        fldNames[3] = GetFieldNameFromFieldIndex(3);
        fldNames[4] = GetFieldNameFromFieldIndex(4);
        fldNames[5] = GetFieldNameFromFieldIndex(5);
        fldNames[6] = GetFieldNameFromFieldIndex(6);
        fldNames[7] = GetFieldNameFromFieldIndex(7);
    }
    static FieldType GetFieldTypeFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return FIELDTYPE_INT32;
        case 1: return FIELDTYPE_INT32;
        case 2: return FIELDTYPE_INT32;
        case 3: return FIELDTYPE_INT32;
        case 4: return FIELDTYPE_INT32;
        case 5: return FIELDTYPE_INT32;
        case 6: return FIELDTYPE_INT32;
        case 7: return FIELDTYPE_INT32;
        }
        return FIELDTYPE_INVALID;
    }
    static unsigned GetSizeofFieldFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return (unsigned) sizeof(rage::u32); //m_MMATTR_DISCRIMINATOR
        case 1: return (unsigned) sizeof(rage::u32); //m_MMATTR_MM_GROUP_1
        case 2: return (unsigned) sizeof(rage::u32); //m_MMATTR_MM_GROUP_2
        case 3: return (unsigned) sizeof(rage::u32); //m_MMATTR_AIM_TYPE
        case 4: return (unsigned) sizeof(rage::u32); //m_MMATTR_REGION
        case 5: return (unsigned) sizeof(rage::u32); //m_MMATTR_ACTIVITY_TYPE
        case 6: return (unsigned) sizeof(rage::u32); //m_MMATTR_ACTIVITY_ID
        case 7: return (unsigned) sizeof(rage::u32); //m_MMATTR_ACTIVITY_PLAYERS
        }
        return 0;
    }
private:
    rage::u8 m_fieldCount[sizeof(rage::u32)];
    rage::u8 m_fieldMask[sizeof(rage::u64)];
    rage::u8 m_MMATTR_DISCRIMINATOR_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_DISCRIMINATOR[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_1_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_1[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_2_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_2[sizeof(rage::u32)];
    rage::u8 m_MMATTR_AIM_TYPE_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_AIM_TYPE[sizeof(rage::u32)];
    rage::u8 m_MMATTR_REGION_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_REGION[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_TYPE_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_TYPE[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_ID_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_ID[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_PLAYERS_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_PLAYERS[sizeof(rage::u32)];
};
class MatchingFilter_General : public SchemaBase
{
public:
    enum
    {
        FIELD_COUNT = 3,
    };
    enum
    {
        FILTER_ID = 0,
        CONDITION_COUNT = 3,
    };
    MatchingFilter_General()
    {
        *(rage::u32*) m_fieldCount = 3;
        *(rage::u64*) m_fieldMask = 0;
        *(rage::u32*) m_MMATTR_DISCRIMINATOR_id = 0x10000001;
        *(rage::u32*) m_MMATTR_REGION_id = 0x10000018;
        *(rage::u32*) m_MMATTR_AIM_TYPE_id = 0x10000017;
    }
    bool IsFieldNil(const int fieldIndex) const
    {
        return 0 != (*((const rage::u64*) m_fieldMask) & (rage::u64(1) << fieldIndex));
    }
    void ClearField(const int fieldIndex)
    {
        *((rage::u64*) m_fieldMask) &= ~(rage::u64(1) << fieldIndex);
    }
    void ClearAllFields()
    {
        *((rage::u64*) m_fieldMask) = rage::u64(0);
    }
    bool SetFieldData(const int fieldIndex, const void* data, const unsigned sizeofData)
    {
        switch(fieldIndex)
        {
        case 0:
        if(sizeof(m_MMATTR_DISCRIMINATOR)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_DISCRIMINATOR = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<0);
            return true;
        }
        break;
        case 1:
        if(sizeof(m_MMATTR_REGION)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_REGION = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<1);
            return true;
        }
        break;
        case 2:
        if(sizeof(m_MMATTR_AIM_TYPE)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_AIM_TYPE = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<2);
            return true;
        }
        break;
        }
        return false;
    }
    const void* GetFieldData(const int fieldIndex) const
    {
        switch(fieldIndex)
        {
        case 0: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<0)) ? m_MMATTR_DISCRIMINATOR : 0;
        case 1: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<1)) ? m_MMATTR_REGION : 0;
        case 2: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<2)) ? m_MMATTR_AIM_TYPE : 0;
        }
        return 0;
    }
    void SetMMATTR_DISCRIMINATOR(const rage::u32 val) { *(rage::u32*) m_MMATTR_DISCRIMINATOR = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<0); }
    rage::u32 GetMMATTR_DISCRIMINATOR() const { return *(rage::u32*) m_MMATTR_DISCRIMINATOR; }
    void ClearMMATTR_DISCRIMINATOR() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<0); }
    bool IsSetMMATTR_DISCRIMINATOR() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<0)) != 0; }
    void SetMMATTR_REGION(const rage::u32 val) { *(rage::u32*) m_MMATTR_REGION = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<1); }
    rage::u32 GetMMATTR_REGION() const { return *(rage::u32*) m_MMATTR_REGION; }
    void ClearMMATTR_REGION() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<1); }
    bool IsSetMMATTR_REGION() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<1)) != 0; }
    void SetMMATTR_AIM_TYPE(const rage::u32 val) { *(rage::u32*) m_MMATTR_AIM_TYPE = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<2); }
    rage::u32 GetMMATTR_AIM_TYPE() const { return *(rage::u32*) m_MMATTR_AIM_TYPE; }
    void ClearMMATTR_AIM_TYPE() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<2); }
    bool IsSetMMATTR_AIM_TYPE() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<2)) != 0; }
    typedef MatchingAttributes MatchingAttributesType;
    //Returns the id of the session attribute that will be filtered
    //against by the operation at the given condition index.
    //This represents the id of the attribute advertised by the
    //session host and corresponds to the left hand side of the filter
    //operation.
    static FieldId GetAttributeIdForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return FIELD_ID_MMATTR_DISCRIMINATOR;
        case 1: return FIELD_ID_MMATTR_REGION;
        case 2: return FIELD_ID_MMATTR_AIM_TYPE;
        }
        return FieldId(-1);
    }
    //Returns the index of the session attribute that will be filtered
    //against by the operation at the given condition index.
    //This represents the index of the attribute advertised by the
    //session host and corresponds to the left hand side of the filter
    //operation.
    static int GetAttributeIndexForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_DISCRIMINATOR);
        case 1: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_REGION);
        case 2: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_AIM_TYPE);
        }
        return -1;
    }
    //Returns the id of the filter parameter for the given condition.
    //This represents the right hand side of the filter operation.
    static FieldId GetParamIdForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return FIELD_ID_MMATTR_DISCRIMINATOR;
        case 1: return FIELD_ID_MMATTR_REGION;
        case 2: return FIELD_ID_MMATTR_AIM_TYPE;
        }
        return FieldId(-1);
    }
    //Returns the index of the filter parameter for the given condition.
    //This represents the right hand side of the filter operation.
    static int GetParamIndexForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_DISCRIMINATOR);
        case 1: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_REGION);
        case 2: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_AIM_TYPE);
        }
        return -1;
    }
    static unsigned GetOperator(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return '==';
        case 1: return '==';
        case 2: return '==';
        }
        return 0;
    }
    static const char* GetFilterName()
    {
        return "General";
    }
    static int GetFieldIndexFromFieldId(const FieldId fieldId)
    {
        switch((int)fieldId)
        {
        case FIELD_ID_MMATTR_DISCRIMINATOR: return 0;
        case FIELD_ID_MMATTR_REGION: return 1;
        case FIELD_ID_MMATTR_AIM_TYPE: return 2;
        }
        return -1;
    }
    static FieldId GetFieldIdFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return FIELD_ID_MMATTR_DISCRIMINATOR;
        case 1: return FIELD_ID_MMATTR_REGION;
        case 2: return FIELD_ID_MMATTR_AIM_TYPE;
        }
        return FieldId(-1);
    }
    static void GetFieldIds(unsigned (&fldIds)[FIELD_COUNT])
    {
        fldIds[0] = FIELD_ID_MMATTR_DISCRIMINATOR;
        fldIds[1] = FIELD_ID_MMATTR_REGION;
        fldIds[2] = FIELD_ID_MMATTR_AIM_TYPE;
    }
    static FieldType GetFieldTypeFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return FIELDTYPE_INT32;
        case 1: return FIELDTYPE_INT32;
        case 2: return FIELDTYPE_INT32;
        }
        return FIELDTYPE_INVALID;
    }
    static unsigned GetSizeofFieldFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return (unsigned) sizeof(rage::u32); //m_MMATTR_DISCRIMINATOR
        case 1: return (unsigned) sizeof(rage::u32); //m_MMATTR_REGION
        case 2: return (unsigned) sizeof(rage::u32); //m_MMATTR_AIM_TYPE
        }
        return 0;
    }
private:
    rage::u8 m_fieldCount[sizeof(rage::u32)];
    rage::u8 m_fieldMask[sizeof(rage::u64)];
    rage::u8 m_MMATTR_DISCRIMINATOR_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_DISCRIMINATOR[sizeof(rage::u32)];
    rage::u8 m_MMATTR_REGION_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_REGION[sizeof(rage::u32)];
    rage::u8 m_MMATTR_AIM_TYPE_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_AIM_TYPE[sizeof(rage::u32)];
};
class MatchingFilter_Group : public SchemaBase
{
public:
    enum
    {
        FIELD_COUNT = 5,
    };
    enum
    {
        FILTER_ID = 1,
        CONDITION_COUNT = 5,
    };
    MatchingFilter_Group()
    {
        *(rage::u32*) m_fieldCount = 5;
        *(rage::u64*) m_fieldMask = 0;
        *(rage::u32*) m_MMATTR_DISCRIMINATOR_id = 0x10000001;
        *(rage::u32*) m_MMATTR_MM_GROUP_1_id = 0x10000013;
        *(rage::u32*) m_MMATTR_MM_GROUP_2_id = 0x10000014;
        *(rage::u32*) m_MMATTR_REGION_id = 0x10000018;
        *(rage::u32*) m_MMATTR_AIM_TYPE_id = 0x10000017;
    }
    bool IsFieldNil(const int fieldIndex) const
    {
        return 0 != (*((const rage::u64*) m_fieldMask) & (rage::u64(1) << fieldIndex));
    }
    void ClearField(const int fieldIndex)
    {
        *((rage::u64*) m_fieldMask) &= ~(rage::u64(1) << fieldIndex);
    }
    void ClearAllFields()
    {
        *((rage::u64*) m_fieldMask) = rage::u64(0);
    }
    bool SetFieldData(const int fieldIndex, const void* data, const unsigned sizeofData)
    {
        switch(fieldIndex)
        {
        case 0:
        if(sizeof(m_MMATTR_DISCRIMINATOR)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_DISCRIMINATOR = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<0);
            return true;
        }
        break;
        case 1:
        if(sizeof(m_MMATTR_MM_GROUP_1)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_MM_GROUP_1 = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<1);
            return true;
        }
        break;
        case 2:
        if(sizeof(m_MMATTR_MM_GROUP_2)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_MM_GROUP_2 = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<2);
            return true;
        }
        break;
        case 3:
        if(sizeof(m_MMATTR_REGION)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_REGION = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<3);
            return true;
        }
        break;
        case 4:
        if(sizeof(m_MMATTR_AIM_TYPE)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_AIM_TYPE = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<4);
            return true;
        }
        break;
        }
        return false;
    }
    const void* GetFieldData(const int fieldIndex) const
    {
        switch(fieldIndex)
        {
        case 0: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<0)) ? m_MMATTR_DISCRIMINATOR : 0;
        case 1: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<1)) ? m_MMATTR_MM_GROUP_1 : 0;
        case 2: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<2)) ? m_MMATTR_MM_GROUP_2 : 0;
        case 3: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<3)) ? m_MMATTR_REGION : 0;
        case 4: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<4)) ? m_MMATTR_AIM_TYPE : 0;
        }
        return 0;
    }
    void SetMMATTR_DISCRIMINATOR(const rage::u32 val) { *(rage::u32*) m_MMATTR_DISCRIMINATOR = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<0); }
    rage::u32 GetMMATTR_DISCRIMINATOR() const { return *(rage::u32*) m_MMATTR_DISCRIMINATOR; }
    void ClearMMATTR_DISCRIMINATOR() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<0); }
    bool IsSetMMATTR_DISCRIMINATOR() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<0)) != 0; }
    void SetMMATTR_MM_GROUP_1(const rage::u32 val) { *(rage::u32*) m_MMATTR_MM_GROUP_1 = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<1); }
    rage::u32 GetMMATTR_MM_GROUP_1() const { return *(rage::u32*) m_MMATTR_MM_GROUP_1; }
    void ClearMMATTR_MM_GROUP_1() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<1); }
    bool IsSetMMATTR_MM_GROUP_1() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<1)) != 0; }
    void SetMMATTR_MM_GROUP_2(const rage::u32 val) { *(rage::u32*) m_MMATTR_MM_GROUP_2 = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<2); }
    rage::u32 GetMMATTR_MM_GROUP_2() const { return *(rage::u32*) m_MMATTR_MM_GROUP_2; }
    void ClearMMATTR_MM_GROUP_2() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<2); }
    bool IsSetMMATTR_MM_GROUP_2() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<2)) != 0; }
    void SetMMATTR_REGION(const rage::u32 val) { *(rage::u32*) m_MMATTR_REGION = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<3); }
    rage::u32 GetMMATTR_REGION() const { return *(rage::u32*) m_MMATTR_REGION; }
    void ClearMMATTR_REGION() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<3); }
    bool IsSetMMATTR_REGION() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<3)) != 0; }
    void SetMMATTR_AIM_TYPE(const rage::u32 val) { *(rage::u32*) m_MMATTR_AIM_TYPE = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<4); }
    rage::u32 GetMMATTR_AIM_TYPE() const { return *(rage::u32*) m_MMATTR_AIM_TYPE; }
    void ClearMMATTR_AIM_TYPE() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<4); }
    bool IsSetMMATTR_AIM_TYPE() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<4)) != 0; }
    typedef MatchingAttributes MatchingAttributesType;
    //Returns the id of the session attribute that will be filtered
    //against by the operation at the given condition index.
    //This represents the id of the attribute advertised by the
    //session host and corresponds to the left hand side of the filter
    //operation.
    static FieldId GetAttributeIdForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return FIELD_ID_MMATTR_DISCRIMINATOR;
        case 1: return FIELD_ID_MMATTR_MM_GROUP_1;
        case 2: return FIELD_ID_MMATTR_MM_GROUP_2;
        case 3: return FIELD_ID_MMATTR_REGION;
        case 4: return FIELD_ID_MMATTR_AIM_TYPE;
        }
        return FieldId(-1);
    }
    //Returns the index of the session attribute that will be filtered
    //against by the operation at the given condition index.
    //This represents the index of the attribute advertised by the
    //session host and corresponds to the left hand side of the filter
    //operation.
    static int GetAttributeIndexForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_DISCRIMINATOR);
        case 1: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_MM_GROUP_1);
        case 2: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_MM_GROUP_2);
        case 3: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_REGION);
        case 4: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_AIM_TYPE);
        }
        return -1;
    }
    //Returns the id of the filter parameter for the given condition.
    //This represents the right hand side of the filter operation.
    static FieldId GetParamIdForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return FIELD_ID_MMATTR_DISCRIMINATOR;
        case 1: return FIELD_ID_MMATTR_MM_GROUP_1;
        case 2: return FIELD_ID_MMATTR_MM_GROUP_2;
        case 3: return FIELD_ID_MMATTR_REGION;
        case 4: return FIELD_ID_MMATTR_AIM_TYPE;
        }
        return FieldId(-1);
    }
    //Returns the index of the filter parameter for the given condition.
    //This represents the right hand side of the filter operation.
    static int GetParamIndexForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_DISCRIMINATOR);
        case 1: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_MM_GROUP_1);
        case 2: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_MM_GROUP_2);
        case 3: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_REGION);
        case 4: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_AIM_TYPE);
        }
        return -1;
    }
    static unsigned GetOperator(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return '==';
        case 1: return '<';
        case 2: return '<';
        case 3: return '==';
        case 4: return '==';
        }
        return 0;
    }
    static const char* GetFilterName()
    {
        return "Group";
    }
    static int GetFieldIndexFromFieldId(const FieldId fieldId)
    {
        switch((int)fieldId)
        {
        case FIELD_ID_MMATTR_DISCRIMINATOR: return 0;
        case FIELD_ID_MMATTR_MM_GROUP_1: return 1;
        case FIELD_ID_MMATTR_MM_GROUP_2: return 2;
        case FIELD_ID_MMATTR_REGION: return 3;
        case FIELD_ID_MMATTR_AIM_TYPE: return 4;
        }
        return -1;
    }
    static FieldId GetFieldIdFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return FIELD_ID_MMATTR_DISCRIMINATOR;
        case 1: return FIELD_ID_MMATTR_MM_GROUP_1;
        case 2: return FIELD_ID_MMATTR_MM_GROUP_2;
        case 3: return FIELD_ID_MMATTR_REGION;
        case 4: return FIELD_ID_MMATTR_AIM_TYPE;
        }
        return FieldId(-1);
    }
    static void GetFieldIds(unsigned (&fldIds)[FIELD_COUNT])
    {
        fldIds[0] = FIELD_ID_MMATTR_DISCRIMINATOR;
        fldIds[1] = FIELD_ID_MMATTR_MM_GROUP_1;
        fldIds[2] = FIELD_ID_MMATTR_MM_GROUP_2;
        fldIds[3] = FIELD_ID_MMATTR_REGION;
        fldIds[4] = FIELD_ID_MMATTR_AIM_TYPE;
    }
    static FieldType GetFieldTypeFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return FIELDTYPE_INT32;
        case 1: return FIELDTYPE_INT32;
        case 2: return FIELDTYPE_INT32;
        case 3: return FIELDTYPE_INT32;
        case 4: return FIELDTYPE_INT32;
        }
        return FIELDTYPE_INVALID;
    }
    static unsigned GetSizeofFieldFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return (unsigned) sizeof(rage::u32); //m_MMATTR_DISCRIMINATOR
        case 1: return (unsigned) sizeof(rage::u32); //m_MMATTR_MM_GROUP_1
        case 2: return (unsigned) sizeof(rage::u32); //m_MMATTR_MM_GROUP_2
        case 3: return (unsigned) sizeof(rage::u32); //m_MMATTR_REGION
        case 4: return (unsigned) sizeof(rage::u32); //m_MMATTR_AIM_TYPE
        }
        return 0;
    }
private:
    rage::u8 m_fieldCount[sizeof(rage::u32)];
    rage::u8 m_fieldMask[sizeof(rage::u64)];
    rage::u8 m_MMATTR_DISCRIMINATOR_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_DISCRIMINATOR[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_1_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_1[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_2_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_2[sizeof(rage::u32)];
    rage::u8 m_MMATTR_REGION_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_REGION[sizeof(rage::u32)];
    rage::u8 m_MMATTR_AIM_TYPE_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_AIM_TYPE[sizeof(rage::u32)];
};
class MatchingFilter_Activity : public SchemaBase
{
public:
    enum
    {
        FIELD_COUNT = 8,
    };
    enum
    {
        FILTER_ID = 2,
        CONDITION_COUNT = 8,
    };
    MatchingFilter_Activity()
    {
        *(rage::u32*) m_fieldCount = 8;
        *(rage::u64*) m_fieldMask = 0;
        *(rage::u32*) m_MMATTR_DISCRIMINATOR_id = 0x10000001;
        *(rage::u32*) m_MMATTR_REGION_id = 0x10000018;
        *(rage::u32*) m_MMATTR_AIM_TYPE_id = 0x10000017;
        *(rage::u32*) m_MMATTR_ACTIVITY_TYPE_id = 0x1000001a;
        *(rage::u32*) m_MMATTR_ACTIVITY_ID_id = 0x1000001b;
        *(rage::u32*) m_MMATTR_ACTIVITY_PLAYERS_id = 0x1000001c;
        *(rage::u32*) m_MMATTR_MM_GROUP_1_id = 0x10000013;
        *(rage::u32*) m_MMATTR_MM_GROUP_2_id = 0x10000014;
    }
    bool IsFieldNil(const int fieldIndex) const
    {
        return 0 != (*((const rage::u64*) m_fieldMask) & (rage::u64(1) << fieldIndex));
    }
    void ClearField(const int fieldIndex)
    {
        *((rage::u64*) m_fieldMask) &= ~(rage::u64(1) << fieldIndex);
    }
    void ClearAllFields()
    {
        *((rage::u64*) m_fieldMask) = rage::u64(0);
    }
    bool SetFieldData(const int fieldIndex, const void* data, const unsigned sizeofData)
    {
        switch(fieldIndex)
        {
        case 0:
        if(sizeof(m_MMATTR_DISCRIMINATOR)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_DISCRIMINATOR = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<0);
            return true;
        }
        break;
        case 1:
        if(sizeof(m_MMATTR_REGION)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_REGION = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<1);
            return true;
        }
        break;
        case 2:
        if(sizeof(m_MMATTR_AIM_TYPE)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_AIM_TYPE = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<2);
            return true;
        }
        break;
        case 3:
        if(sizeof(m_MMATTR_ACTIVITY_TYPE)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_ACTIVITY_TYPE = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<3);
            return true;
        }
        break;
        case 4:
        if(sizeof(m_MMATTR_ACTIVITY_ID)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_ACTIVITY_ID = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<4);
            return true;
        }
        break;
        case 5:
        if(sizeof(m_MMATTR_ACTIVITY_PLAYERS)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_ACTIVITY_PLAYERS = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<5);
            return true;
        }
        break;
        case 6:
        if(sizeof(m_MMATTR_MM_GROUP_1)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_MM_GROUP_1 = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<6);
            return true;
        }
        break;
        case 7:
        if(sizeof(m_MMATTR_MM_GROUP_2)==sizeofData)
        {
            *(rage::u32*) m_MMATTR_MM_GROUP_2 = *(const rage::u32*) data;
            *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<7);
            return true;
        }
        break;
        }
        return false;
    }
    const void* GetFieldData(const int fieldIndex) const
    {
        switch(fieldIndex)
        {
        case 0: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<0)) ? m_MMATTR_DISCRIMINATOR : 0;
        case 1: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<1)) ? m_MMATTR_REGION : 0;
        case 2: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<2)) ? m_MMATTR_AIM_TYPE : 0;
        case 3: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<3)) ? m_MMATTR_ACTIVITY_TYPE : 0;
        case 4: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<4)) ? m_MMATTR_ACTIVITY_ID : 0;
        case 5: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<5)) ? m_MMATTR_ACTIVITY_PLAYERS : 0;
        case 6: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<6)) ? m_MMATTR_MM_GROUP_1 : 0;
        case 7: return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<7)) ? m_MMATTR_MM_GROUP_2 : 0;
        }
        return 0;
    }
    void SetMMATTR_DISCRIMINATOR(const rage::u32 val) { *(rage::u32*) m_MMATTR_DISCRIMINATOR = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<0); }
    rage::u32 GetMMATTR_DISCRIMINATOR() const { return *(rage::u32*) m_MMATTR_DISCRIMINATOR; }
    void ClearMMATTR_DISCRIMINATOR() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<0); }
    bool IsSetMMATTR_DISCRIMINATOR() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<0)) != 0; }
    void SetMMATTR_REGION(const rage::u32 val) { *(rage::u32*) m_MMATTR_REGION = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<1); }
    rage::u32 GetMMATTR_REGION() const { return *(rage::u32*) m_MMATTR_REGION; }
    void ClearMMATTR_REGION() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<1); }
    bool IsSetMMATTR_REGION() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<1)) != 0; }
    void SetMMATTR_AIM_TYPE(const rage::u32 val) { *(rage::u32*) m_MMATTR_AIM_TYPE = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<2); }
    rage::u32 GetMMATTR_AIM_TYPE() const { return *(rage::u32*) m_MMATTR_AIM_TYPE; }
    void ClearMMATTR_AIM_TYPE() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<2); }
    bool IsSetMMATTR_AIM_TYPE() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<2)) != 0; }
    void SetMMATTR_ACTIVITY_TYPE(const rage::u32 val) { *(rage::u32*) m_MMATTR_ACTIVITY_TYPE = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<3); }
    rage::u32 GetMMATTR_ACTIVITY_TYPE() const { return *(rage::u32*) m_MMATTR_ACTIVITY_TYPE; }
    void ClearMMATTR_ACTIVITY_TYPE() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<3); }
    bool IsSetMMATTR_ACTIVITY_TYPE() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<3)) != 0; }
    void SetMMATTR_ACTIVITY_ID(const rage::u32 val) { *(rage::u32*) m_MMATTR_ACTIVITY_ID = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<4); }
    rage::u32 GetMMATTR_ACTIVITY_ID() const { return *(rage::u32*) m_MMATTR_ACTIVITY_ID; }
    void ClearMMATTR_ACTIVITY_ID() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<4); }
    bool IsSetMMATTR_ACTIVITY_ID() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<4)) != 0; }
    void SetMMATTR_ACTIVITY_PLAYERS(const rage::u32 val) { *(rage::u32*) m_MMATTR_ACTIVITY_PLAYERS = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<5); }
    rage::u32 GetMMATTR_ACTIVITY_PLAYERS() const { return *(rage::u32*) m_MMATTR_ACTIVITY_PLAYERS; }
    void ClearMMATTR_ACTIVITY_PLAYERS() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<5); }
    bool IsSetMMATTR_ACTIVITY_PLAYERS() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<5)) != 0; }
    void SetMMATTR_MM_GROUP_1(const rage::u32 val) { *(rage::u32*) m_MMATTR_MM_GROUP_1 = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<6); }
    rage::u32 GetMMATTR_MM_GROUP_1() const { return *(rage::u32*) m_MMATTR_MM_GROUP_1; }
    void ClearMMATTR_MM_GROUP_1() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<6); }
    bool IsSetMMATTR_MM_GROUP_1() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<6)) != 0; }
    void SetMMATTR_MM_GROUP_2(const rage::u32 val) { *(rage::u32*) m_MMATTR_MM_GROUP_2 = val; *((rage::u64*) m_fieldMask) |= (rage::u64(1)<<7); }
    rage::u32 GetMMATTR_MM_GROUP_2() const { return *(rage::u32*) m_MMATTR_MM_GROUP_2; }
    void ClearMMATTR_MM_GROUP_2() {*((rage::u64*) m_fieldMask) &= ~(rage::u64(1)<<7); }
    bool IsSetMMATTR_MM_GROUP_2() const { return (*((rage::u64*) m_fieldMask) & (rage::u64(1)<<7)) != 0; }
    typedef MatchingAttributes MatchingAttributesType;
    //Returns the id of the session attribute that will be filtered
    //against by the operation at the given condition index.
    //This represents the id of the attribute advertised by the
    //session host and corresponds to the left hand side of the filter
    //operation.
    static FieldId GetAttributeIdForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return FIELD_ID_MMATTR_DISCRIMINATOR;
        case 1: return FIELD_ID_MMATTR_REGION;
        case 2: return FIELD_ID_MMATTR_AIM_TYPE;
        case 3: return FIELD_ID_MMATTR_ACTIVITY_TYPE;
        case 4: return FIELD_ID_MMATTR_ACTIVITY_ID;
        case 5: return FIELD_ID_MMATTR_ACTIVITY_PLAYERS;
        case 6: return FIELD_ID_MMATTR_MM_GROUP_1;
        case 7: return FIELD_ID_MMATTR_MM_GROUP_2;
        }
        return FieldId(-1);
    }
    //Returns the index of the session attribute that will be filtered
    //against by the operation at the given condition index.
    //This represents the index of the attribute advertised by the
    //session host and corresponds to the left hand side of the filter
    //operation.
    static int GetAttributeIndexForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_DISCRIMINATOR);
        case 1: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_REGION);
        case 2: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_AIM_TYPE);
        case 3: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_ACTIVITY_TYPE);
        case 4: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_ACTIVITY_ID);
        case 5: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_ACTIVITY_PLAYERS);
        case 6: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_MM_GROUP_1);
        case 7: return MatchingAttributes::GetFieldIndexFromFieldId(FIELD_ID_MMATTR_MM_GROUP_2);
        }
        return -1;
    }
    //Returns the id of the filter parameter for the given condition.
    //This represents the right hand side of the filter operation.
    static FieldId GetParamIdForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return FIELD_ID_MMATTR_DISCRIMINATOR;
        case 1: return FIELD_ID_MMATTR_REGION;
        case 2: return FIELD_ID_MMATTR_AIM_TYPE;
        case 3: return FIELD_ID_MMATTR_ACTIVITY_TYPE;
        case 4: return FIELD_ID_MMATTR_ACTIVITY_ID;
        case 5: return FIELD_ID_MMATTR_ACTIVITY_PLAYERS;
        case 6: return FIELD_ID_MMATTR_MM_GROUP_1;
        case 7: return FIELD_ID_MMATTR_MM_GROUP_2;
        }
        return FieldId(-1);
    }
    //Returns the index of the filter parameter for the given condition.
    //This represents the right hand side of the filter operation.
    static int GetParamIndexForCondition(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_DISCRIMINATOR);
        case 1: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_REGION);
        case 2: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_AIM_TYPE);
        case 3: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_ACTIVITY_TYPE);
        case 4: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_ACTIVITY_ID);
        case 5: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_ACTIVITY_PLAYERS);
        case 6: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_MM_GROUP_1);
        case 7: return GetFieldIndexFromFieldId(FIELD_ID_MMATTR_MM_GROUP_2);
        }
        return -1;
    }
    static unsigned GetOperator(const unsigned conditionIndex)
    {
        switch(conditionIndex)
        {
        case 0: return '==';
        case 1: return '==';
        case 2: return '==';
        case 3: return '==';
        case 4: return '==';
        case 5: return '>=';
        case 6: return '==';
        case 7: return '==';
        }
        return 0;
    }
    static const char* GetFilterName()
    {
        return "Activity";
    }
    static int GetFieldIndexFromFieldId(const FieldId fieldId)
    {
        switch((int)fieldId)
        {
        case FIELD_ID_MMATTR_DISCRIMINATOR: return 0;
        case FIELD_ID_MMATTR_REGION: return 1;
        case FIELD_ID_MMATTR_AIM_TYPE: return 2;
        case FIELD_ID_MMATTR_ACTIVITY_TYPE: return 3;
        case FIELD_ID_MMATTR_ACTIVITY_ID: return 4;
        case FIELD_ID_MMATTR_ACTIVITY_PLAYERS: return 5;
        case FIELD_ID_MMATTR_MM_GROUP_1: return 6;
        case FIELD_ID_MMATTR_MM_GROUP_2: return 7;
        }
        return -1;
    }
    static FieldId GetFieldIdFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return FIELD_ID_MMATTR_DISCRIMINATOR;
        case 1: return FIELD_ID_MMATTR_REGION;
        case 2: return FIELD_ID_MMATTR_AIM_TYPE;
        case 3: return FIELD_ID_MMATTR_ACTIVITY_TYPE;
        case 4: return FIELD_ID_MMATTR_ACTIVITY_ID;
        case 5: return FIELD_ID_MMATTR_ACTIVITY_PLAYERS;
        case 6: return FIELD_ID_MMATTR_MM_GROUP_1;
        case 7: return FIELD_ID_MMATTR_MM_GROUP_2;
        }
        return FieldId(-1);
    }
    static void GetFieldIds(unsigned (&fldIds)[FIELD_COUNT])
    {
        fldIds[0] = FIELD_ID_MMATTR_DISCRIMINATOR;
        fldIds[1] = FIELD_ID_MMATTR_REGION;
        fldIds[2] = FIELD_ID_MMATTR_AIM_TYPE;
        fldIds[3] = FIELD_ID_MMATTR_ACTIVITY_TYPE;
        fldIds[4] = FIELD_ID_MMATTR_ACTIVITY_ID;
        fldIds[5] = FIELD_ID_MMATTR_ACTIVITY_PLAYERS;
        fldIds[6] = FIELD_ID_MMATTR_MM_GROUP_1;
        fldIds[7] = FIELD_ID_MMATTR_MM_GROUP_2;
    }
    static FieldType GetFieldTypeFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return FIELDTYPE_INT32;
        case 1: return FIELDTYPE_INT32;
        case 2: return FIELDTYPE_INT32;
        case 3: return FIELDTYPE_INT32;
        case 4: return FIELDTYPE_INT32;
        case 5: return FIELDTYPE_INT32;
        case 6: return FIELDTYPE_INT32;
        case 7: return FIELDTYPE_INT32;
        }
        return FIELDTYPE_INVALID;
    }
    static unsigned GetSizeofFieldFromFieldIndex(const int fieldIndex)
    {
        switch(fieldIndex)
        {
        case 0: return (unsigned) sizeof(rage::u32); //m_MMATTR_DISCRIMINATOR
        case 1: return (unsigned) sizeof(rage::u32); //m_MMATTR_REGION
        case 2: return (unsigned) sizeof(rage::u32); //m_MMATTR_AIM_TYPE
        case 3: return (unsigned) sizeof(rage::u32); //m_MMATTR_ACTIVITY_TYPE
        case 4: return (unsigned) sizeof(rage::u32); //m_MMATTR_ACTIVITY_ID
        case 5: return (unsigned) sizeof(rage::u32); //m_MMATTR_ACTIVITY_PLAYERS
        case 6: return (unsigned) sizeof(rage::u32); //m_MMATTR_MM_GROUP_1
        case 7: return (unsigned) sizeof(rage::u32); //m_MMATTR_MM_GROUP_2
        }
        return 0;
    }
private:
    rage::u8 m_fieldCount[sizeof(rage::u32)];
    rage::u8 m_fieldMask[sizeof(rage::u64)];
    rage::u8 m_MMATTR_DISCRIMINATOR_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_DISCRIMINATOR[sizeof(rage::u32)];
    rage::u8 m_MMATTR_REGION_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_REGION[sizeof(rage::u32)];
    rage::u8 m_MMATTR_AIM_TYPE_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_AIM_TYPE[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_TYPE_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_TYPE[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_ID_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_ID[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_PLAYERS_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_ACTIVITY_PLAYERS[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_1_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_1[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_2_id[sizeof(rage::u32)];
    rage::u8 m_MMATTR_MM_GROUP_2[sizeof(rage::u32)];
};
class Achievements
{
public:
    enum
    {
#if RSG_NP
        COUNT = 78
#else
        COUNT = 77
#endif //RSG_NP
    };
    enum
    {
#if RSG_NP
        PLATINUM = 0,
#endif //RSG_NP
        ACH00 = 1,
        ACH01 = 2,
        ACH02 = 3,
        ACH03 = 4,
        ACH04 = 5,
        ACH05 = 6,
        ACH06 = 7,
        ACH42 = 8,
        ACH07 = 9,
        ACH08 = 10,
        ACH09 = 11,
        ACH10 = 12,
        ACH11 = 13,
        ACH50 = 14,
        ACH12 = 15,
        ACH13 = 16,
        ACH14 = 17,
        ACH15 = 18,
        ACH16 = 19,
        ACH17 = 20,
        ACH18 = 21,
        ACH19 = 22,
        ACH20 = 23,
        ACH21 = 24,
        ACH22 = 25,
        ACH23 = 26,
        ACH24 = 27,
        ACH25 = 28,
        ACH26 = 29,
        ACH27 = 30,
        ACH28 = 31,
        ACH29 = 32,
        ACH30 = 33,
        ACH31 = 34,
        ACH32 = 35,
        ACH33 = 36,
        ACH34 = 37,
        ACH35 = 38,
        ACH36 = 39,
        ACH38 = 40,
        ACH39 = 41,
        ACH40 = 42,
        ACH41 = 43,
        ACH43 = 44,
        ACH45 = 45,
        ACH46 = 46,
        ACH47 = 47,
        ACH48 = 48,
        ACH49 = 49,
        ACH51 = 50,
        ACHH1 = 51,
        ACHH2 = 52,
        ACHH3 = 53,
        ACHH4 = 54,
        ACHH5 = 55,
        ACHH6 = 56,
        ACHH7 = 57,
        ACHH8 = 58,
        ACHH10 = 59,
        ACHH11 = 60,
        ACHR2 = 61,
        ACHR3 = 62,
        ACHR4 = 63,
        ACHR5 = 64,
        ACHR6 = 65,
        ACHR7 = 66,
        ACHR8 = 67,
        ACHR9 = 68,
        ACHR10 = 69,
        ACHGO1 = 70,
        ACHGO2 = 71,
        ACHGO3 = 72,
        ACHGO4 = 73,
        ACHGO5 = 74,
        ACHGO6 = 75,
        ACHGO7 = 76,
        ACHGO8 = 77,
    };
    static int IdToIndex(const int achId)
    {
        switch(achId)
        {
#if RSG_NP 
        case PLATINUM: return 0;
#endif
        case ACH00: return 1;
        case ACH01: return 2;
        case ACH02: return 3;
        case ACH03: return 4;
        case ACH04: return 5;
        case ACH05: return 6;
        case ACH06: return 7;
        case ACH42: return 8;
        case ACH07: return 9;
        case ACH08: return 10;
        case ACH09: return 11;
        case ACH10: return 12;
        case ACH11: return 13;
        case ACH50: return 14;
        case ACH12: return 15;
        case ACH13: return 16;
        case ACH14: return 17;
        case ACH15: return 18;
        case ACH16: return 19;
        case ACH17: return 20;
        case ACH18: return 21;
        case ACH19: return 22;
        case ACH20: return 23;
        case ACH21: return 24;
        case ACH22: return 25;
        case ACH23: return 26;
        case ACH24: return 27;
        case ACH25: return 28;
        case ACH26: return 29;
        case ACH27: return 30;
        case ACH28: return 31;
        case ACH29: return 32;
        case ACH30: return 33;
        case ACH31: return 34;
        case ACH32: return 35;
        case ACH33: return 36;
        case ACH34: return 37;
        case ACH35: return 38;
        case ACH36: return 39;
        case ACH38: return 40;
        case ACH39: return 41;
        case ACH40: return 42;
        case ACH41: return 43;
        case ACH43: return 44;
        case ACH45: return 45;
        case ACH46: return 46;
        case ACH47: return 47;
        case ACH48: return 48;
        case ACH49: return 49;
        case ACH51: return 50;
        case ACHH1: return 51;
        case ACHH2: return 52;
        case ACHH3: return 53;
        case ACHH4: return 54;
        case ACHH5: return 55;
        case ACHH6: return 56;
        case ACHH7: return 57;
        case ACHH8: return 58;
        case ACHH10: return 59;
        case ACHH11: return 60;
        case ACHR2: return 61;
        case ACHR3: return 62;
        case ACHR4: return 63;
        case ACHR5: return 64;
        case ACHR6: return 65;
        case ACHR7: return 66;
        case ACHR8: return 67;
        case ACHR9: return 68;
        case ACHR10: return 69;
        case ACHGO1: return 70;
        case ACHGO2: return 71;
        case ACHGO3: return 72;
        case ACHGO4: return 73;
        case ACHGO5: return 74;
        case ACHGO6: return 75;
        case ACHGO7: return 76;
        case ACHGO8: return 77;
        }
        return -1;
    }
    static int IndexToId(const int index)
    {
        switch(index)
        {
#if RSG_NP 
        case 0: return PLATINUM;
#endif
        case 1: return ACH00;
        case 2: return ACH01;
        case 3: return ACH02;
        case 4: return ACH03;
        case 5: return ACH04;
        case 6: return ACH05;
        case 7: return ACH06;
        case 8: return ACH42;
        case 9: return ACH07;
        case 10: return ACH08;
        case 11: return ACH09;
        case 12: return ACH10;
        case 13: return ACH11;
        case 14: return ACH50;
        case 15: return ACH12;
        case 16: return ACH13;
        case 17: return ACH14;
        case 18: return ACH15;
        case 19: return ACH16;
        case 20: return ACH17;
        case 21: return ACH18;
        case 22: return ACH19;
        case 23: return ACH20;
        case 24: return ACH21;
        case 25: return ACH22;
        case 26: return ACH23;
        case 27: return ACH24;
        case 28: return ACH25;
        case 29: return ACH26;
        case 30: return ACH27;
        case 31: return ACH28;
        case 32: return ACH29;
        case 33: return ACH30;
        case 34: return ACH31;
        case 35: return ACH32;
        case 36: return ACH33;
        case 37: return ACH34;
        case 38: return ACH35;
        case 39: return ACH36;
        case 40: return ACH38;
        case 41: return ACH39;
        case 42: return ACH40;
        case 43: return ACH41;
        case 44: return ACH43;
        case 45: return ACH45;
        case 46: return ACH46;
        case 47: return ACH47;
        case 48: return ACH48;
        case 49: return ACH49;
        case 50: return ACH51;
        case 51: return ACHH1;
        case 52: return ACHH2;
        case 53: return ACHH3;
        case 54: return ACHH4;
        case 55: return ACHH5;
        case 56: return ACHH6;
        case 57: return ACHH7;
        case 58: return ACHH8;
        case 59: return ACHH10;
        case 60: return ACHH11;
        case 61: return ACHR2;
        case 62: return ACHR3;
        case 63: return ACHR4;
        case 64: return ACHR5;
        case 65: return ACHR6;
        case 66: return ACHR7;
        case 67: return ACHR8;
        case 68: return ACHR9;
        case 69: return ACHR10;
        case 70: return ACHGO1;
        case 71: return ACHGO2;
        case 72: return ACHGO3;
        case 73: return ACHGO4;
        case 74: return ACHGO5;
        case 75: return ACHGO6;
        case 76: return ACHGO7;
        case 77: return ACHGO8;
        }
        return -1;
    }
 
#if __STEAM_BUILD
	static const char* IdToChar(const int achId)
	{
		switch(achId)
		{
   	     case ACH00: return "ACH00";
   	     case ACH01: return "ACH01";
   	     case ACH02: return "ACH02";
   	     case ACH03: return "ACH03";
   	     case ACH04: return "ACH04";
   	     case ACH05: return "ACH05";
   	     case ACH06: return "ACH06";
   	     case ACH42: return "ACH42";
   	     case ACH07: return "ACH07";
   	     case ACH08: return "ACH08";
   	     case ACH09: return "ACH09";
   	     case ACH10: return "ACH10";
   	     case ACH11: return "ACH11";
   	     case ACH50: return "ACH50";
   	     case ACH12: return "ACH12";
   	     case ACH13: return "ACH13";
   	     case ACH14: return "ACH14";
   	     case ACH15: return "ACH15";
   	     case ACH16: return "ACH16";
   	     case ACH17: return "ACH17";
   	     case ACH18: return "ACH18";
   	     case ACH19: return "ACH19";
   	     case ACH20: return "ACH20";
   	     case ACH21: return "ACH21";
   	     case ACH22: return "ACH22";
   	     case ACH23: return "ACH23";
   	     case ACH24: return "ACH24";
   	     case ACH25: return "ACH25";
   	     case ACH26: return "ACH26";
   	     case ACH27: return "ACH27";
   	     case ACH28: return "ACH28";
   	     case ACH29: return "ACH29";
   	     case ACH30: return "ACH30";
   	     case ACH31: return "ACH31";
   	     case ACH32: return "ACH32";
   	     case ACH33: return "ACH33";
   	     case ACH34: return "ACH34";
   	     case ACH35: return "ACH35";
   	     case ACH36: return "ACH36";
   	     case ACH38: return "ACH38";
   	     case ACH39: return "ACH39";
   	     case ACH40: return "ACH40";
   	     case ACH41: return "ACH41";
   	     case ACH43: return "ACH43";
   	     case ACH45: return "ACH45";
   	     case ACH46: return "ACH46";
   	     case ACH47: return "ACH47";
   	     case ACH48: return "ACH48";
   	     case ACH49: return "ACH49";
   	     case ACH51: return "ACH51";
   	     case ACHH1: return "ACHH1";
   	     case ACHH2: return "ACHH2";
   	     case ACHH3: return "ACHH3";
   	     case ACHH4: return "ACHH4";
   	     case ACHH5: return "ACHH5";
   	     case ACHH6: return "ACHH6";
   	     case ACHH7: return "ACHH7";
   	     case ACHH8: return "ACHH8";
   	     case ACHH10: return "ACHH10";
   	     case ACHH11: return "ACHH11";
   	     case ACHR2: return "ACHR2";
   	     case ACHR3: return "ACHR3";
   	     case ACHR4: return "ACHR4";
   	     case ACHR5: return "ACHR5";
   	     case ACHR6: return "ACHR6";
   	     case ACHR7: return "ACHR7";
   	     case ACHR8: return "ACHR8";
   	     case ACHR9: return "ACHR9";
   	     case ACHR10: return "ACHR10";
   	     case ACHGO1: return "ACHGO1";
   	     case ACHGO2: return "ACHGO2";
   	     case ACHGO3: return "ACHGO3";
   	     case ACHGO4: return "ACHGO4";
   	     case ACHGO5: return "ACHGO5";
   	     case ACHGO6: return "ACHGO6";
   	     case ACHGO7: return "ACHGO7";
   	     case ACHGO8: return "ACHGO8";
		}
		return "";
}
#endif
};
class GamerPictures
{
public:
    enum
    {
        COUNT = 0,
    };
};

}; //namespace player_schema

#endif //FUZZY_XB1_HEISTS_SCHEMA_H

