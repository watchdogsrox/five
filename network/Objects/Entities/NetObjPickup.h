//
// name:		NetObjPickup.h
// description:	Derived from netObject, this class handles all pickup-related network object
//				calls. See NetworkObject.h for a full description of all the methods.
// written by:	John Gurney
//

#ifndef NETOBJPICKUP_H
#define NETOBJPICKUP_H

#include "network/objects/entities/NetObjPhysical.h"
#include "network/objects/synchronisation/SyncTrees/ProjectSyncTrees.h"
#include "pickups/PickupPlacement.h"

class CPickup;

class CNetObjPickup : public CNetObjPhysical, public IPickupNodeDataAccessor
{
public:

	FW_REGISTER_CLASS_POOL(CNetObjPickup);

	struct CPickupScopeData : public netScopeData
	{
		static const float SCOPE_DIST_EXTENDER_COLLIDER_SIZE;
		static const float SCOPE_DIST_EXTENDER_MULTIPLIER;
		CPickupScopeData()
		{
			m_scopeDistance			= 50.0f; // pickups generated by placements use the same scope as the placement
			m_scopeDistanceInterior = 50.0f;
			m_syncDistanceNear		= 10.0;
			m_syncDistanceFar		= 60.0f;
		}
	};

	static const int PICKUP_SYNC_DATA_NUM_NODES = 14;
	static const int PICKUP_SYNC_DATA_BUFFER_SIZE = 229;

	class CPickupSyncData : public netSyncData_Static<MAX_NUM_PHYSICAL_PLAYERS, PICKUP_SYNC_DATA_NUM_NODES, PICKUP_SYNC_DATA_BUFFER_SIZE, CNetworkSyncDataULBase::NUM_UPDATE_LEVELS>
	{
	public:
        FW_REGISTER_CLASS_POOL(CPickupSyncData);
    };

public:

	CNetObjPickup(class CPickup					*pickup,
					const NetworkObjectType		type,
					const ObjectId				objectID,
					const PhysicalPlayerIndex   playerIndex,
					const NetObjFlags			localFlags,
					const NetObjFlags			globalFlags);

    virtual const char *GetObjectTypeName() const { return IsOrWasScriptObject() ? "SCRIPT_PICKUP" : "PICKUP"; }

	CPickup* GetPickup() const				{ return (CPickup*)GetGameObject(); }

	void DestroyWhenLocal()					{ m_bDestroyNextUpdate = true; }

    static void CreateSyncTree();
    static void DestroySyncTree();

	static  CProjectSyncTree*	GetStaticSyncTree()  { return ms_pickupSyncTree; }
	virtual CProjectSyncTree*	GetSyncTree()		 { return ms_pickupSyncTree; }
	virtual netScopeData&		GetScopeData()		 { return ms_pickupScopeData; }
	virtual netScopeData&		GetScopeData() const { return ms_pickupScopeData; }
    static  netScopeData&		GetStaticScopeData() { return ms_pickupScopeData; }
	virtual netSyncDataBase*	CreateSyncData()	 { return rage_new CPickupSyncData(); }

	virtual netINodeDataAccessor *GetDataAccessor(u32 dataAccessorType);

	virtual float GetScopeDistance(const netPlayer* pRelativePlayer = NULL) const;

	virtual bool	Update();
    virtual u32	    CalcReassignPriority() const;
	virtual bool	CanClone(const netPlayer& player, unsigned *resultCode = 0) const;
	virtual bool	IsInScope(const netPlayer& player, unsigned *scopeReason = NULL) const;
	virtual bool	CanPassControl(const netPlayer& player, eMigrationType migrationType, unsigned *resultCode = 0) const;
	virtual bool	CanDelete(unsigned* reason = nullptr);
    virtual void	PostCreate();
	virtual bool	CanBlend(unsigned *resultCode = 0) const;
    virtual bool    NetworkBlenderIsOverridden(unsigned *resultCode = 0) const;
	virtual bool	ProcessControl();
	virtual void    CleanUpGameObject(bool bDestroyObject);
	virtual bool	CheckPlayerHasAuthorityOverObject(const netPlayer& player);
	virtual bool	OnReassigned();
	virtual void	OnConversionToAmbientObject();
	virtual bool    CanSynchronise(bool bOnRegistration) const;
	virtual void	SetIsVisible(bool isVisible, const char* reason, bool bNetworkUpdate = false);
	virtual bool	HasCollisionLoadedUnderEntity() const;
	virtual void	OverrideBlenderUntilAcceptingObjects();
	virtual bool	CanEnableCollision() const;

	virtual void	SetPosition( const Vector3& pos );

	virtual void	TryToPassControlProximity();
	virtual bool	TryToPassControlOutOfScope();

    virtual bool    AllowFixByNetwork() const;
    virtual bool    UseBoxStreamerForFixByNetworkCheck() const;

	virtual void	HideForCutscene();
	virtual void	ExposeAfterCutscene();

	// don't migrate to host so collection works better
	virtual bool	FavourMigrationToHost() const { return false; }

    virtual bool    IsAttachmentStateSentOverNetwork() const;
    virtual void    AttemptPendingDetachment(CPhysical* pEntityToAttachTo);

	virtual void	SetIsFixed(bool isFixed);

#if __BANK
	virtual bool ShouldDisplayAdditionalDebugInfo() { return true; }
	virtual void DisplayNetworkInfoForObject(const Color32 &col, float scale, Vector2 &screenCoords, const float debugTextYIncrement);
#endif // __BANK

	// sync parser create functions
	void GetPickupCreateData(CPickupCreationDataNode& data)  const;
	void GetPickupSectorPosData(CPickupSectorPosNode& data) const;
	void GetPickupScriptGameStateData(CPickupScriptGameStateNode& data) const;

	void SetPickupCreateData(const CPickupCreationDataNode& data);
	void SetPickupSectorPosData(const CPickupSectorPosNode& data);
	void SetPickupScriptGameStateData(const CPickupScriptGameStateNode& data);

	void PortablePickupLocallyAttached();

	virtual void ClearPendingAttachmentData() { CNetObjPhysical::ClearPendingAttachmentData(); }
	ObjectId	GetPendingAttachmentObjectID() const { return m_pendingAttachmentObjectID; }

	void SetBlockedPlayersFromCollecting(int players) { m_AllowedPlayersList = players; }
	bool IsAllowedForLocalPlayer();

#if ENABLE_NETWORK_LOGGING
	virtual const char *GetCannotDeleteReason(unsigned reason);
#endif // ENABLE_NETWORK_LOGGING

protected:
	void InteriorCheck();

	bool m_bCompletedInteriorCheck;
	bool m_bDestroyNextUpdate;
	PlayerFlags m_AllowedPlayersList;

	static CPickupSyncTree *ms_pickupSyncTree;
	static CPickupScopeData	ms_pickupScopeData;

#if ENABLE_NETWORK_LOGGING
private:
	unsigned m_lastPassControlToCarrierFailReason;
#endif // ENABLE_NETWORK_LOGGING
};

#endif  // NETOBJPICKUP_H
