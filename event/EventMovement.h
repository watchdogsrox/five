#ifndef INC_EVENT_MOVEMENT_H
#define INC_EVENT_MOVEMENT_H

// Game headers
#include "ai/AITarget.h"
#include "Event/EventEditable.h"
#include "Event/EventPriorities.h"
#include "Peds/PedDefines.h"
#include "pathserver/PathServer_DataTypes.h"
#include "scene/RegdRefTypes.h"

// Forward declarations
// enum eWaypointSpecialAction;
class CVehicle;
class CEntity;
class CObject;
//////////////////////////////////////////////////////////////////////////
// CEventClimbLadderOnRoute
//////////////////////////////////////////////////////////////////////////

// Event generated by CTaskComplexMoveFollowNavMesh when the route progress
// reaches the point at which a ladder has to be climbed.
// The response is to climb/descend the ladder, and then quit - at which
// point the navmesh route task be reactivated & will start again, causing
// a new route to be calculated from the ped's new position.
class CEventClimbLadderOnRoute : public CEvent
{
public:
	
	// Top & bottom of ladder.  Direction is (+1 for up or -1 for down).  Heading is what way to face before climbing.
	CEventClimbLadderOnRoute(const Vector3& vLadderBottom, const Vector3& vLadderTop, const int iDirection, const float fLadderHeading, const float fMoveBlendRatio);
	virtual ~CEventClimbLadderOnRoute() {}

	virtual CEvent* Clone() const { return rage_new CEventClimbLadderOnRoute(m_vLadderBottom, m_vLadderTop, m_iDirection, m_fLadderHeading, m_fMoveBlendRatio); }

	//
	// Event querying
	//

	virtual int GetEventType() const { return EVENT_CLIMB_LADDER_ON_ROUTE; }
	virtual int GetEventPriority() const { return E_PRIORITY_CLIMB_LADDER_ON_ROUTE; }
	virtual bool IsTemporaryEvent() const { return true; }

	//
	//
	//

	// Core implementation of affects ped
	virtual bool AffectsPedCore(CPed* pPed) const;

	//
	//
	//

	// Construct a task in response to this event
	virtual bool CreateResponseTask(CPed* pPed, CEventResponse& response) const;

#if !__FINAL
	// Debug function to return event name as a string for error output
	virtual atString GetName() const { return atString("ClimbLadderOnRoute"); }
#endif

private:

	Vector3 m_vLadderBottom;
	Vector3 m_vLadderTop;
	int     m_iDirection;
	float   m_fLadderHeading;
	float   m_fMoveBlendRatio;
};

//////////////////////////////////////////////////////////////////////////
// CEventClimbNavMeshOnRoute
//////////////////////////////////////////////////////////////////////////

// Event generated by CTaskComplexMoveFollowNavMesh when the route progress
// reaches the point at which a navmesh climb has to be performed.
// The response is to do a CTaskComplexClimb, and then quit.  The original
// navmesh task will then be reactivated & will start again, causing a new
// route to be calculated from the ped's new position.
class CEventClimbNavMeshOnRoute : public CEvent
{
public:

	CEventClimbNavMeshOnRoute(const Vector3& vClimbPosition, const float fClimbHeading, const Vector3& vClimbTarget, const float fMoveBlendRatio, const u32 iWptFlags, CEntity* pEntityWeAreOn, const s32 iWarpTimer, const Vector3& vWarpTarget, bool bForceJump = false);
	virtual ~CEventClimbNavMeshOnRoute();

	virtual CEvent* Clone() const { return rage_new CEventClimbNavMeshOnRoute(m_vClimbPosition, m_fClimbHeading, m_vClimbTarget, m_fMoveBlendRatio, m_iWptFlags, m_pEntityWeAreOn, m_iWarpTimer, m_vWarpTarget, m_bForceJump); }

	//
	// Event querying
	//

	virtual int GetEventType() const { return EVENT_CLIMB_NAVMESH_ON_ROUTE; }
	virtual int GetEventPriority() const {return E_PRIORITY_CLIMB_NAVMESH_ON_ROUTE;}
	virtual bool IsTemporaryEvent() const { return true; }

	//
	//
	//

	// Core implementation of affects ped
	virtual bool AffectsPedCore(CPed* pPed) const;

	//
	//
	//

	// Construct a task in response to this event
	virtual bool CreateResponseTask(CPed* pPed, CEventResponse& response) const;

	//
	// 
	//

	virtual const Vector3& GetSourcePos() const { return m_vClimbPosition; }

#if !__FINAL
	// Debug function to return event name as a string for error output
	virtual atString GetName() const { return atString("ClimbNavMeshOnRoute"); }
#endif

private:

	Vector3		m_vClimbPosition;
	Vector3		m_vClimbTarget;
	float		m_fClimbHeading;
	float		m_fMoveBlendRatio;
	u32			m_iWptFlags;
	RegdEnt		m_pEntityWeAreOn;
	int			m_iWarpTimer;
	Vector3		m_vWarpTarget;
	bool		m_bForceJump;
};

//////////////////////////////////////////////////////////////////////////
// CEventPotentialBeWalkedInto
//////////////////////////////////////////////////////////////////////////

// A ped is about to walk into this ped.  We have the opportunity to move out of way if desired.
class CEventPotentialBeWalkedInto : public CEvent
{
public:

	struct Tunables : public CTuning
	{
		Tunables();

		float m_AngleThresholdDegrees;
		float m_ChancesToReactToRunningPedsBehindUs;
		float m_ChanceToUseCasualAvoidAgainstRunningPed;

		PAR_PARSABLE;
	};

	CEventPotentialBeWalkedInto(CPed* pOtherPed, const Vector3& vTarget, const float fMoveBlendRatio);
	virtual ~CEventPotentialBeWalkedInto();

	virtual CEvent* Clone() const;

	//
	// Event querying
	//

	virtual int GetEventType() const { return EVENT_POTENTIAL_BE_WALKED_INTO; }
	virtual int GetEventPriority() const { return E_PRIORITY_POTENTIAL_BE_WALKED_INTO; }
	virtual bool IsTemporaryEvent() const { return true; }

	//
	//
	//

	// Core implementation of affects ped
	virtual bool AffectsPedCore(CPed* pPed) const;

	//
	//
	//

	// Construct a task in response to this event
	virtual bool CreateResponseTask(CPed* pPed, CEventResponse& response) const;

	//
	// 
	//

	// Get the source of this event
	virtual CEntity* GetSourceEntity() const;

#if !__FINAL
	// Debug function to return event name as a string for error output
	virtual atString GetName() const { return atString("PotentialBeWalkedInto"); }
#endif

protected:

	virtual bool TakesPriorityOver(const CEvent& otherEvent) const { return otherEvent.IsTemporaryEvent() ? true : CEvent::TakesPriorityOver(otherEvent); }

private:

	RegdPed m_pOtherPed;
	Vector3 m_vTarget;
	float   m_fMoveBlendRatio;
	float	m_fOtherPedSpeedSq;

public:

	static Tunables sm_Tunables;

};

//////////////////////////////////////////////////////////////////////////
// CEventPotentialGetRunOver
//////////////////////////////////////////////////////////////////////////

// Ped is potentially to collide with a vehicle
class CEventPotentialGetRunOver : public CEventEditableResponse
{
public:
	struct Tunables : public CTuning
	{
		Tunables();

		float	m_MinSpeedToDive;
		float	m_SpeedToAlwaysDive;
		float	m_MaxSpeedToDive;
		float	m_ChancesToDive;
		float	m_ChancesToBeCasual;
		float	m_MinDelay;
		float	m_MaxDelay;

		PAR_PARSABLE;
	};

	CEventPotentialGetRunOver(CVehicle* pThreatVehicle);
	virtual ~CEventPotentialGetRunOver();

	virtual CEventEditableResponse* CloneEditable() const;

	//
	// Event querying
	//

	virtual int GetEventType() const { return EVENT_POTENTIAL_GET_RUN_OVER; }
	virtual int GetEventPriority() const { return E_PRIORITY_POTENTIAL_GET_RUN_OVER; }
	virtual bool IsTemporaryEvent() const { return true; }

	//
	//
	//

	// Core implementation of affects ped
	virtual bool AffectsPedCore(CPed* pPed) const;

	//
	//
	//

	// Construct a task in response to this event
	virtual bool CreateResponseTask(CPed* pPed, CEventResponse& response) const;

	//
	// 
	//

	// Get the source of this event
	virtual CEntity* GetSourceEntity() const;

	virtual bool GetTunableDelay(const CPed* pPed, float& fMin, float& fMax) const;

#if !__FINAL
	// Debug function to return event name as a string for error output
	virtual atString GetName() const { return atString("PotentialGetRunOver"); }
#endif 

private:

	RegdVeh m_pThreatVehicle;
	float	m_fThreatVehicleSpeedSq;

	static Tunables		sm_Tunables;
};

//////////////////////////////////////////////////////////////////////////
// CEventPotentialBlast
//////////////////////////////////////////////////////////////////////////

class CEventPotentialBlast : public CEvent
{

public:

	struct Tunables : public CTuning
	{
		Tunables();

		PAR_PARSABLE;
	};

public:

	CEventPotentialBlast(const CAITarget& rTarget, float fRadius, u32 uTimeOfExplosion);
	virtual ~CEventPotentialBlast() {}

public:

			float		GetRadius()				const { return m_fRadius; }
	const	CAITarget&	GetTarget()				const { return m_Target; }
			u32			GetTimeOfExplosion()	const { return m_uTimeOfExplosion; }
			bool		GetIsSmoke()			const { return m_bIsSmoke; }

public:

	void SetIsSmoke(bool bValue) { m_bIsSmoke = bValue; }

public:

	virtual CEvent* Clone() const;

	//
	// Event querying
	//

	virtual int GetEventType() const { return EVENT_POTENTIAL_BLAST; }
	virtual int GetEventPriority() const { return E_PRIORITY_POTENTIAL_BLAST; }

	//
	//
	//

	// Core implementation of affects ped
	virtual bool AffectsPedCore(CPed* pPed) const;
	virtual bool CreateResponseTask(CPed* pPed, CEventResponse& response) const;
	virtual bool IsTemporaryEvent() const { return true; }

	//
	// 
	//

	virtual CEntity* GetSourceEntity() const { return const_cast<CEntity *>(m_Target.GetEntity()); }

	virtual bool TakesPriorityOver(const CEvent& otherEvent) const { return otherEvent.GetEventType() != EVENT_LEADER_ENTERED_CAR_AS_DRIVER && CEvent::TakesPriorityOver(otherEvent); }

#if !__FINAL
	// Debug function to return event name as a string for error output
	virtual atString GetName() const { return atString("EVENT_POTENTIAL_BLAST"); }
#endif

private:
	
	CAITarget	m_Target;
	float		m_fRadius;
	u32			m_uTimeOfExplosion;
	bool		m_bIsSmoke;

private:

	static Tunables sm_Tunables;

};

//////////////////////////////////////////////////////////////////////////
// CEventPotentialWalkIntoFire
//////////////////////////////////////////////////////////////////////////

// Fire that can be walked into.
class CEventPotentialWalkIntoFire : public CEventEditableResponse
{
public:

	CEventPotentialWalkIntoFire(const Vector3& vFirePos, const float fFireRadius, const float fMoveBlendRatio);
	virtual ~CEventPotentialWalkIntoFire() {}

	virtual CEventEditableResponse* CloneEditable() const { return rage_new CEventPotentialWalkIntoFire(m_vFirePos, m_fFireRadius, m_fMoveBlendRatio); }

	//
	// Event querying
	//

	virtual int GetEventType() const { return EVENT_POTENTIAL_WALK_INTO_FIRE; }
	virtual int GetEventPriority() const { return E_PRIORITY_POTENTIAL_WALK_INTO_FIRE; }
	virtual bool IsTemporaryEvent() const { return true; }

	//
	//
	//

	// Core implementation of affects ped
	virtual bool AffectsPedCore(CPed* pPed) const;

	//
	//
	//

	// Construct a task in response to this event
	virtual bool CreateResponseTask(CPed* pPed, CEventResponse& response) const;

	//
	// 
	//

	virtual const Vector3& GetSourcePos() const { return m_vFirePos; }

#if !__FINAL
	// Debug function to return event name as a string for error output
	virtual atString GetName() const { return atString("PotWalkIntoFire"); }
#endif    

private:

	// [SPHERE-OPTIMISE] m_vFirePos, m_fFireRadius should be a spdSphere
	Vector3 m_vFirePos;
	float   m_fFireRadius;
	float   m_fMoveBlendRatio;
};

//////////////////////////////////////////////////////////////////////////
// CEventPotentialWalkIntoObject
//////////////////////////////////////////////////////////////////////////

class CEventPotentialWalkIntoObject : public CEventEditableResponse
{
public:

	CEventPotentialWalkIntoObject(CObject* pObject, const float fMoveBlendRatio);
	virtual ~CEventPotentialWalkIntoObject();

	virtual CEventEditableResponse* CloneEditable() const { return rage_new CEventPotentialWalkIntoObject(m_pObject, m_fMoveBlendRatio); }

	//
	// Event querying
	//

	virtual int GetEventType() const { return EVENT_POTENTIAL_WALK_INTO_OBJECT; }
	virtual int GetEventPriority() const { return E_PRIORITY_POTENTIAL_WALK_INTO_OBJECT; }
	virtual bool IsTemporaryEvent() const { return true; }

	//
	//
	//

	// Core implementation of affects ped
	virtual bool AffectsPedCore(CPed* pPed) const;

	//
	//
	//

	// Construct a task in response to this event
	virtual bool CreateResponseTask(CPed* pPed, CEventResponse& response) const;

	//
	// 
	//

	// Get the source of this event
	virtual CEntity* GetSourceEntity() const;

#if !__FINAL
	// Debug function to return event name as a string for error output
	virtual atString GetName() const {return atString("PotentialWalkIntoObject");}
#endif

protected:

	virtual bool TakesPriorityOver(const CEvent& UNUSED_PARAM(otherEvent)) const { return true; }

private:

	RegdObj  m_pObject;
	float    m_fMoveBlendRatio;    
};

//////////////////////////////////////////////////////////////////////////
// CEventPotentialWalkIntoVehicle
//////////////////////////////////////////////////////////////////////////

class CEventPotentialWalkIntoVehicle : public CEventEditableResponse
{
public:

	CEventPotentialWalkIntoVehicle(CVehicle* pThreatVehicle, const float fMoveBlendRatio, const Vector3 & vTarget);
	virtual ~CEventPotentialWalkIntoVehicle();

	virtual CEventEditableResponse* CloneEditable() const { return rage_new CEventPotentialWalkIntoVehicle((m_pThreatVehicle), m_fMoveBlendRatio, m_vTarget); }

	//
	// Event querying
	//

	virtual int GetEventType() const { return EVENT_POTENTIAL_WALK_INTO_VEHICLE; }
	virtual int GetEventPriority() const { return E_PRIORITY_POTENTIAL_WALK_INTO_VEHICLE; }
	virtual bool IsTemporaryEvent() const { return true; }

	//
	//
	//

	// Core implementation of affects ped
	virtual bool AffectsPedCore(CPed* pPed) const;

	//
	//
	//

	// Construct a task in response to this event
	virtual bool CreateResponseTask(CPed* pPed, CEventResponse& response) const;

	//
	// 
	//

	// Get the source of this event
	virtual CEntity* GetSourceEntity()  const;

	inline const Vector3& GetTarget() { return m_vTarget; }

#if !__FINAL
	// Debug function to return event name as a string for error output
	virtual atString GetName() const {return atString("PotentialWalkIntoVehicle");}
#endif 

protected:

	virtual bool TakesPriorityOver(const CEvent& UNUSED_PARAM(otherEvent)) const { return true; }

private:

	Vector3	  m_vTarget;
	RegdVeh   m_pThreatVehicle;
	float     m_fMoveBlendRatio;
};

#endif // INC_EVENT_MOVEMENT_H
