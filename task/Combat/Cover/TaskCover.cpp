//
// Task/Combat/Cover/TaskCover.cpp
//
// Copyright (C) 1999-2011 Rockstar Games.  All Rights Reserved.
//

// File header
#include "Task/Combat/Cover/TaskCover.h"

// Rage Headers
#include "fwanimation/animmanager.h"
#include "fwanimation/animdirector.h"
#include "fwanimation/clipsets.h"
#include "fwmaths/geomutil.h"
#include "grcore/debugdraw.h"
#include "phbound/boundcomposite.h"
#include "phbound/boundbvh.h"
#include "phbound/boundcylinder.h"

// Game headers
#include "ai/debug/system/AIDebugLogManager.h"
#include "animation/AnimManager.h"
#include "animation/EventTags.h"
#include "animation/MovePed.h"
#include "camera/CamInterface.h"
#include "camera/helpers/ControlHelper.h"
#include "camera/gameplay/GameplayDirector.h"
#include "camera/gameplay/ThirdPersonCamera.h"
#if FPS_MODE_SUPPORTED
#include "camera/gameplay/aim/FirstPersonShooterCamera.h"
#endif // FPS_MODE_SUPPORTED
#include "debug/DebugScene.h"
#include "debug/VectorMap.h"
#include "event/EventDamage.h"
#include "event/EventShocking.h"
#include "event/EventWeapon.h"
#include "event/ShockingEvents.h"
#include "frontend/MobilePhone.h"
#include "frontend/PauseMenu.h"
#include "frontend/NewHud.h"
#include "ik/IkRequest.h"
#include "ik/solvers/TorsoSolver.h"
#include "math/angmath.h"
#include "modelinfo/PedModelInfo.h"
#include "network/Objects/Entities/NetObjPlayer.h"
#include "network/Objects/Prediction/NetBlenderPed.h"
#include "Objects/Door.h"
#include "PedGroup/PedGroup.h"
#include "PedGroup/Formation.h"
#include "physics/WorldProbe/worldprobe.h"
#include "Physics/GtaInst.h"
#include "Physics/GtaMaterialManager.h"
#include "physics/iterator.h"
#include "Physics/physics.h"
#include "Peds/MovingGround.h"
#include "Peds/PedCapsule.h"
#include "Peds/PedDebugVisualiser.h"
#include "Peds/PedPlacement.h"
#include "peds/PedIntelligence.h"
#include "peds/PedWeapons/PedTargeting.h"
#include "peds/Ped.h"
#include "Peds/PedMoveBlend/PedMoveBlendBase.h"
#include "Scene/Entity.h"
#include "Scene/EntityIterator.h"
#include "Scene/World/GameWorld.h"
#include "Script/script.h"
#include "Script/script_channel.h"
#include "Task/Combat/CombatDirector.h"
#include "Task/combat/TaskCombat.h"
#include "Task/combat/TaskNewCombat.h"
#include "Task/Combat/TaskSearch.h"
#include "Task/Combat/Subtasks/TaskShootAtTarget.h"
#include "Task/Default/TaskPlayer.h"
#include "Task/Default/TaskChat.h"
#include "Task/Default/TaskCuffed.h"
#include "Task/Default/Patrol/TaskPatrol.h"
#include "Task/General/TaskBasic.h"
#include "Task/General/Phone/TaskMobilePhone.h"
#include "Task/Motion/TaskMotionBase.h"
#include "Task/Motion/Locomotion/TaskHumanLocomotion.h"
#include "Task/Motion/Locomotion/TaskLocomotion.h"
#include "Task/Motion/Locomotion/TaskMotionAiming.h"
#include "Task/Motion/Locomotion/TaskMotionPed.h"
#include "Task/Movement/TaskGoTo.h"
#include "Task/Movement/TaskGotoPointAiming.h"
#include "Task/Movement/Jumping/TaskJump.h"
#include "Task/Movement/TaskNavMesh.h"
#include "Task/Weapons/Gun/GunFlags.h"
#include "Task/Weapons/Gun/TaskAimGun.h"
#include "Task/Weapons/Gun/TaskReloadGun.h"
#include "Task/Weapons/WeaponController.h"
#include "Task/Weapons/TaskProjectile.h"
#include "Task/Weapons/TaskSwapWeapon.h"
#include "Task/Weapons/TaskWeaponBlocked.h"
#include "Task/Weapons/TaskDetonator.h"
#include "Task/Vehicle/TaskCar.h"
#include "Task/Vehicle/TaskEnterVehicle.h"
#include "text/messages.h"
#include "vehicles/vehicle.h"
#include "vehicles/Metadata/VehicleLayoutInfo.h"
#include "weapons/Weapon.h"
#include "AI/Ambient/ConditionalAnimManager.h"

AI_OPTIMISATIONS()
AI_COVER_OPTIMISATIONS()

namespace AICombatStats
{
	EXT_PF_TIMER(ComputeHighCoverStepOutPosition);
}
using namespace AICombatStats;

////////////////////////////////////////////////////////////////////////////////

// Statics
CTaskCover::Tunables CTaskCover::ms_Tunables;

IMPLEMENT_COMBAT_TASK_TUNABLES(CTaskCover, 0x5016e90a);

REGISTER_TUNE_GROUP_FLOAT(INITIAL_Z_OFFSET_FOR_PEEK_PROBE, -0.1f);
REGISTER_TUNE_GROUP_FLOAT(PEEK_PROBE_LENGTH, 1.0f);
REGISTER_TUNE_GROUP_FLOAT(FINAL_Z_OFFSET_FOR_PEEK_PROBE, 0.4f);
REGISTER_TUNE_GROUP_FLOAT(Z_INCREMENT_BETWEEN_PEEK_PROBES, 0.05f);

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskCover::Tunables::GetStreamedUnarmedCoverMovementClipSetIdForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed)) const
{
#if FPS_MODE_SUPPORTED
	return (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonLocoAnimations && rPed.IsFirstPersonShooterModeEnabledForPlayer(false)) ? m_StreamedUnarmedCoverMovementFPSClipSetId : m_StreamedUnarmedCoverMovementClipSetId;
#else // FPS_MODE_SUPPORTED
	return m_StreamedUnarmedCoverMovementClipSetId;
#endif // FPS_MODE_SUPPORTED
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskCover::Tunables::GetCoreWeaponAimingClipSetIdForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed)) const
{
#if FPS_MODE_SUPPORTED
	return (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations && rPed.IsFirstPersonShooterModeEnabledForPlayer(false)) ? m_CoreWeaponAimingFPSClipSetId : m_CoreWeaponAimingClipSetId;
#else // FPS_MODE_SUPPORTED
	return m_CoreWeaponAimingClipSetId;
#endif // FPS_MODE_SUPPORTED
}

////////////////////////////////////////////////////////////////////////////////

float CTaskCover::Tunables::GetMaxPlayerToCoverDist(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed)) const
{ 
#if FPS_MODE_SUPPORTED
	return rPed.IsFirstPersonShooterModeEnabledForPlayer(false) ? m_MaxPlayerToCoverDistFPS : m_MaxPlayerToCoverDist;
#else // FPS_MODE_SUPPORTED
	return m_MaxPlayerToCoverDist;
#endif // FPS_MODE_SUPPORTED
}

////////////////////////////////////////////////////////////////////////////////

static const u32 MAX_DIR_VECS = 32;

dev_float COVER_DIR_MATCH_LIMIT = 0.906f;//60 degrees
dev_float MIN_DIST_TO_SCALE = 5.0f;
dev_float MAX_DIST_TO_SCALE = 20.0f;
dev_float MIN_SCALE = 0.2f;
dev_float MAX_SCALE = 3.0f;

static bool ENABLE_ROUND_COVER = true;

////////////////////////////////////////////////////////////////////////////////

const fwMvNetworkId CTaskCover::ms_MotionTaskNetworkId("MotionTaskNetwork",0x1ECFC0C9);
const fwMvNetworkId CTaskCover::ms_PrimaryTaskNetworkId("PrimaryTaskNetwork",0x814424AF);
const fwMvRequestId CTaskCover::ms_TaskRequestId("Task",0xB9FCBE75);

const fwMvRequestId CTaskCover::ms_NoTaskIgnoreMoverBlendRequestId("NoTaskIgnoreMoverBlend",0x02a893fe);
const fwMvRequestId CTaskCover::ms_NoTaskRequestId("NoTask",0x50893F03);
const fwMvRequestId CTaskCover::ms_NoMotionTaskRequestId("NoMotionTask",0xC45C70FA);
const fwMvRequestId CTaskCover::ms_MotionTaskRequestId("MotionTask",0x48ABA729);
const fwMvRequestId CTaskCover::ms_MotionTaskIgnoreMoverBlendRequestId("MotionTaskIgnoreMoverBlend",0x544901cc);
const fwMvBooleanId CTaskCover::ms_MotionTaskOnEnterId("MotionTask_OnEnter",0x8A8857AE);

const fwMvFloatId CTaskCover::ms_TaskBlendDurationId("TaskBlendDuration",0x1a67a6b2); 
const fwMvFloatId CTaskCover::ms_NoMotionTaskBlendDurationId("NoMotionTaskBlendDuration",0x3d4215e8); 
const fwMvFloatId CTaskCover::ms_NoTaskBlendDurationId("NoTaskBlendDuration",0xAE827512);
const fwMvFlagId CTaskCover::ms_IsCrouchedId("IsCrouched",0x236D194B);
const fwMvFilterId CTaskCover::ms_IgnoreMoverBlendFilterId("IgnoreMoverBlend_filter",0xA337AF2F);
const fwMvBooleanId CTaskCover::ms_CoverSearchInterruptId("CoverSearchInterrupt",0x228009DC);
const float CTaskCover::INVALID_COVER_SCORE = 99999999999.0f;

REGISTER_TUNE_GROUP_BOOL( DISABLE_AUTO_STEP_AROUND, true )
REGISTER_TUNE_GROUP_BOOL( USE_PEEK_TOGGLE, false )

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsPedValidThreat(const CPed& rPed, const CPed& rPlayerPed, bool& bHasLos)
{
	if (!bHasLos)
	{
		// Script can mark peds to always be considered as a threat even with los, so that we negatively
		// weight cover points that would leave us exposed, even though our current position doesn't have line of sight
		// ideally if we could cope with the cost with should do a los between the cover point we're considering and all nearby threats
		// as is, this would probably be too expensive as the number of cover points/threats would exponentially increase the number of probes
		// we'd need to do.
		CPedTargetting* pPedTargetting = rPed.GetPedIntelligence()->GetTargetting( false );
		if(pPedTargetting)
		{
			LosStatus losStatusToTarget = pPedTargetting->GetLosStatus(&rPlayerPed);
			bHasLos = (losStatusToTarget == Los_clear || losStatusToTarget == Los_blockedByFriendly);
		}
	}

	if (!rPed.IsInjured() &&
		((bHasLos || rPed.GetPedResetFlag(CPED_RESET_FLAG_IsEnteringCover) || rPed.GetIsInCover() || rPed.GetPedIntelligence()->GetQueriableInterface()->GetHostileTarget() == &rPlayerPed) || rPed.IsAPlayerPed()) &&
		!rPed.GetPedIntelligence()->GetQueriableInterface()->IsTaskCurrentlyRunning( CTaskTypes::TASK_INVESTIGATE))
	{
		if (rPed.GetPedIntelligence()->IsThreatenedBy(rPlayerPed))
		{
			return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::ComputeDesiredProtectionDirection(const CPed& rPlayerPed, const Vector3& vCoverPosition, Vector3& vDesiredProtection)
{
	// Look through nearby peds to try and best guess the cover direction
	// Approximate a threat direction from all nearby enemies
	TUNE_GROUP_FLOAT(COVER_TUNE, THREAT_SEARCH_DISTANCE_INTERIOR, 25.0f, 0.0f, 100.0f, 0.1f);
	TUNE_GROUP_FLOAT(COVER_TUNE, THREAT_SEARCH_DISTANCE_EXTERIOR, 50.0f, 0.0f, 100.0f, 0.1f);
	const float THREAT_SEARCH_DISTANCE = rPlayerPed.GetIsInInterior() ? THREAT_SEARCH_DISTANCE_INTERIOR : THREAT_SEARCH_DISTANCE_EXTERIOR;
	Vec3V vTemp = VECTOR3_TO_VEC3V(vCoverPosition);
	CEntityIterator entityIterator( IteratePeds, &rPlayerPed, &vTemp, THREAT_SEARCH_DISTANCE );
	CPed* pPed = (CPed*)entityIterator.GetNext();
	Vector3 vClosestThreatDir(0.0f, 0.0f, 0.0f);
	float fClosestThreatDistSq = 0.0f;
	bool 	bGotThreat = false;
	bool 	bAtLeastOnePedHasLos = false;
	bool	abAllLos[MAX_DIR_VECS];
	float	afAllDists[MAX_DIR_VECS];
	Vector3 avAllThreatDirs[MAX_DIR_VECS];
	Vector3 avAllThreatPos[MAX_DIR_VECS];
	Vector3 vAverageThreatDir(0.0f, 0.0f, 0.0f);
	s32 iNoThreatDirs = 0;
	s32 iClosestThreat = 0;

	// Find both the closest enemy and build an array of all nearby threats that have los to us
	while (pPed)
	{
		if (iNoThreatDirs >= MAX_DIR_VECS)
		{
			break;
		}

#if __DEV
		TUNE_GROUP_BOOL(COVER_TUNE, FORCE_ALL_MISSION_PEDS_AS_THREATS, false);
		const bool bAlwaysConsider = pPed->GetPedResetFlag(CPED_RESET_FLAG_ConsiderAsPlayerCoverThreatWithoutLOS) || (pPed->PopTypeIsMission() && FORCE_ALL_MISSION_PEDS_AS_THREATS);
#else
		const bool bAlwaysConsider = pPed->GetPedResetFlag(CPED_RESET_FLAG_ConsiderAsPlayerCoverThreatWithoutLOS);
#endif // __DEV

		bool bHasLos = bAlwaysConsider;
		const bool bThreatValid = IsPedValidThreat(*pPed, rPlayerPed, bHasLos);
		const Vector3 vPedPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());

#if DEBUG_DRAW
		const Vector3 vDebugPedPosition = vPedPosition + Vector3(0.0f, 0.0f, 1.0f);
		CCoverDebug::sDebugSphereParams sphereParams;
		sphereParams.vPos = RCC_VEC3V(vDebugPedPosition);
		sphereParams.fRadius = 0.05f;
		sphereParams.color = bThreatValid ? Color_red : Color_green;
		sphereParams.uContextHash = CCoverDebug::THREATS;
		CCoverDebug::AddDebugPositionSphere(sphereParams);
#endif // DEBUG_DRAW

		if (bThreatValid)
		{
			Vector3 vDiff = vPedPosition - vCoverPosition;

			// Make sure the target is within a 45 degree vertical plane
			if( vDiff.XYMag2() > rage::square(vDiff.z) )
			{
				float fDistance = vDiff.Mag();
				float fDistSq = rage::square(fDistance);
				vDiff.z = 0.0f;
				vDiff.Normalize();
				avAllThreatPos[iNoThreatDirs] = vPedPosition;

				if (bHasLos)
				{
					bAtLeastOnePedHasLos = true;
				}
				afAllDists[iNoThreatDirs] = fDistance;
				abAllLos[iNoThreatDirs] = bHasLos;
				avAllThreatDirs[iNoThreatDirs++] = vDiff;

#if __BANK
				if (CCoverDebug::ms_Tunables.m_RenderProtectionDirectionVec)
				{
					CVectorMap::DrawLine(vPedPosition, vCoverPosition, Color_green, Color_green );
					CVectorMap::DrawCircle(vPedPosition, 0.5f, Color_green, false);
				}
#endif
				if (!bGotThreat || fDistSq < fClosestThreatDistSq)
				{
					vClosestThreatDir = vDiff;
					bGotThreat = true;
					fClosestThreatDistSq = fDistSq;
					iClosestThreat = iNoThreatDirs-1;
				}
			}
		}

		pPed = (CPed*)entityIterator.GetNext();
	}

	if (bGotThreat)
	{
		for (s32 i=0; i<iNoThreatDirs; ++i)
		{
			// If no peds have los, consider all as threats otherwise only consider those that have los
			if (!bAtLeastOnePedHasLos || abAllLos[i])
			{
				//Scale the direction depending on how close the ped is.
				Vector3 vScaledDir = avAllThreatDirs[i];
				if (afAllDists[i] < MIN_DIST_TO_SCALE)
					vScaledDir *= MAX_SCALE;
				else if(afAllDists[i] > MAX_DIST_TO_SCALE)
					vScaledDir *= MIN_SCALE;
				else
				{
					float fScale = (afAllDists[i]-MIN_DIST_TO_SCALE)/(MAX_DIST_TO_SCALE-MIN_DIST_TO_SCALE);
					vScaledDir *= (fScale*MIN_SCALE) + ((1.0f - fScale)*MAX_SCALE);
				}
				vAverageThreatDir += vScaledDir;
			}
		}

		// Incorporate all enemies in a nearby direction to the closest and take the average vector
		bool bAbortCosATargetIsInAnInvalidArea = false;
#if __BANK
		if( CCoverDebug::ms_Tunables.m_RenderProtectionDirectionVec )
		{
			Vector3 vLineEnd = ( vAverageThreatDir * 10.0f ) + vCoverPosition;
			CVectorMap::DrawLine(vCoverPosition, vLineEnd, Color_blue, Color_blue );
			CVectorMap::DrawCircle(vLineEnd, 1.0f, Color_blue, false);
		}
#endif 
		for( s32 i = 0; i < iNoThreatDirs; i++ )
		{
			if( i != iClosestThreat )
			{
				if( avAllThreatDirs[i].Dot(vAverageThreatDir) > 0.0f )
				{
					//Nothing
				}
				else
				{
					// One outside of the average range
#if __BANK
					if( CCoverDebug::ms_Tunables.m_RenderProtectionDirectionVec )
					{
						CVectorMap::DrawLineThick(vCoverPosition, avAllThreatPos[i], Color_red, Color_red );
						CVectorMap::DrawCircle(avAllThreatPos[i], 1.0f, Color_red, false);
					}
#endif
					bAbortCosATargetIsInAnInvalidArea = true;
				}
			}
		}

		if( !bAbortCosATargetIsInAnInvalidArea )
		{
			vAverageThreatDir.Normalize();
			vDesiredProtection = vAverageThreatDir;
		}
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::CalculateCoverSearchVariables( PlayerCoverSearchData& coverSearchData )
{
	CPed* pPlayerPed = coverSearchData.m_pPlayerPed;

	const Vector3 vPlayerPedPos = VEC3V_TO_VECTOR3(pPlayerPed->GetTransform().GetPosition());

	// If the stick is active use that as an estimated direction to cover
	// Otherwise use the ped direction
	coverSearchData.m_CoverSearchDir = VEC3V_TO_VECTOR3(pPlayerPed->GetTransform().GetB());
	Vector2 vecStickInput = CDynamicCoverHelper::GetStickInputForCoverSearch(*pPlayerPed);

	coverSearchData.m_CoverSearchDist = 0.0f;
	if( pPlayerPed->GetMotionData()->GetIsRunning() || pPlayerPed->GetMotionData()->GetIsSprinting() )
	{
		coverSearchData.m_CoverSearchDist = 3.0f;
	}
	else if( pPlayerPed->GetMotionData()->GetIsWalking() )
	{
		coverSearchData.m_CoverSearchDist = 1.5f;
	}

	float fSearchDir = CPlayerInfo::ms_DynamicCoverHelper.ComputeInitialSearchDirection(pPlayerPed);
	coverSearchData.m_CoverSearchDir = Vector3(-rage::Sinf(fSearchDir), rage::Cosf(fSearchDir), 0.0f);
	coverSearchData.m_CoverSearchDir.Normalize();
	coverSearchData.m_CoverSearchDist = vecStickInput.Mag() * 3.0f;

	if(vecStickInput.Mag2() == 0.0f && !(coverSearchData.m_iSearchFlags&CTaskPlayerOnFoot::CSF_ConsiderCloseCover))
	{
		return false;
	}

	// Try to find cover that protects from where the ped is facing
	coverSearchData.m_CoverProtectionDir = camInterface::GetFront();

	const CTaskPlayerOnFoot* pPlayerOnFootTask = static_cast<const CTaskPlayerOnFoot*>(pPlayerPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_PLAYER_ON_FOOT));
	if (pPlayerOnFootTask && pPlayerOnFootTask->GetState() != CTaskPlayerOnFoot::STATE_PLAYER_GUN && pPlayerOnFootTask->IsPlayerStickInputValid(*pPlayerPed))
	{
		Vector3 vDesired(0.0f,1.0f,0.0f);
		vDesired.RotateZ(pPlayerPed->GetDesiredHeading());
		coverSearchData.m_CoverProtectionDir = vDesired;	
	}

	coverSearchData.m_CoverProtectionDir.z = 0.0f;
	coverSearchData.m_CoverProtectionDir.Normalize();

	if( coverSearchData.m_iSearchFlags&CTaskPlayerOnFoot::CSF_MatchCurrentCoverDir )
	{
		coverSearchData.m_CoverProtectionDir = coverSearchData.m_vPreviousCoverDir;
	}
	// Always use the camera direction when strafing
	else if (CTaskPlayerOnFoot::sm_Tunables.GetUseThreatWeighting(*pPlayerPed) && !CTaskPlayerOnFoot::sm_Tunables.m_EvaluateThreatFromCoverPoints && !pPlayerPed->IsStrafing())
	{
		coverSearchData.m_HasThreat = ComputeDesiredProtectionDirection(*pPlayerPed, vPlayerPedPos, coverSearchData.m_CoverProtectionDir);	
	}

#if DEBUG_DRAW
	if( CCoverDebug::ms_Tunables.m_RenderSearchDirectionVec )
	{
		grcDebugDraw::Line(vPlayerPedPos, vPlayerPedPos + (coverSearchData.m_CoverSearchDir*coverSearchData.m_CoverSearchDist), Color32(0.0f, 0.0f, 1.0f));
	}

	if( CCoverDebug::ms_Tunables.m_RenderProtectionDirectionVec )
	{
		grcDebugDraw::Line(vPlayerPedPos, vPlayerPedPos + (coverSearchData.m_CoverProtectionDir*2.0f), Color32(0.0f, 1.0f, 0.0f) );
	}
#endif // DEBUG_DRAW

	return true;
}

////////////////////////////////////////////////////////////////////////////////

#if __BANK
void CTaskCover::SpewStreamingDebugToTTY(const CPed& rPed, const fwMvClipSetId clipSetId)
{
	bool bRequestedInPrioritizedClipSetMgr = CPrioritizedClipSetRequestManager::GetInstance().HasClipSetBeenRequested(CPrioritizedClipSetRequestManager::RC_Cover, clipSetId);
	const CPrioritizedClipSetRequestHelper* pClipSetHelper = CPrioritizedClipSetRequestManager::GetInstance().GetPrioritizedClipSetRequestHelperForClipSet(CPrioritizedClipSetRequestManager::RC_Cover, clipSetId);
	const CPrioritizedClipSetRequest* pRequest = CPrioritizedClipSetStreamer::GetInstance().FindRequest(clipSetId);
	eStreamingPriority nPriority = pRequest ? pRequest->GetStreamingPriority() : SP_Invalid;
	aiDebugf1("Frame : %i, Ped %s (%p) waiting for clipset %s to be loaded", fwTimer::GetFrameCount(), rPed.GetModelName(), &rPed, clipSetId.GetCStr());
	aiDebugf1("Frame : %i, Trying to stream clipset: %s (helper requesting %s), (in clipset mgr=%s, has req=%s, pri=%d)", fwTimer::GetFrameCount(), clipSetId.GetCStr(), pClipSetHelper ? pClipSetHelper->GetClipSetId().GetCStr() : "NULL", bRequestedInPrioritizedClipSetMgr ? "true" : "false", pRequest ? "true" : "false", nPriority); 
}
#endif // __BANK

#if FPS_MODE_SUPPORTED

bool CTaskCover::GetShouldUseCustomLowCoverAnims(const CPed& rPed)
{
	if (!rPed.GetPedResetFlag(CPED_RESET_FLAG_IsInLowCover))
	{
		return false;
	}

#if FPS_MODE_SUPPORTED
	if (rPed.IsFirstPersonShooterModeEnabledForPlayer(false) && CTaskCover::IsPlayerAimingDirectlyInFirstPerson(rPed))
	{
		return false;
	}
#endif // FPS_MODE_SUPPORTED

	return true;
}

bool CTaskCover::IsPlayerAimingDirectlyInFirstPerson(const CPed& rPed)
{
	if (rPed.GetIsInCover() && rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		const CTaskCover* pCoverTask = static_cast<const CTaskCover*>(rPed.GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_COVER));
		if (pCoverTask && pCoverTask->IsCoverFlagSet(CTaskCover::CF_AimDirectly))
		{
			return true;
		}
	}
	return false;
}
#endif // FPS_MODE_SUPPORTED

bool CTaskCover::CanUseThirdPersonCoverInFirstPerson(const CPed& rPed)
{
#if FPS_MODE_SUPPORTED
	if (CPauseMenu::GetMenuPreference(PREF_FPS_THIRD_PERSON_COVER) == TRUE)
	{
		// Block third person cover if script have locked the camera mode to first person mode.
		const CControl *pControl = rPed.GetControlFromPlayer();
		const int viewMode = camControlHelper::GetViewModeForContext(camControlHelperMetadataViewMode::ON_FOOT);
		bool bInputsDisabledFromClosingPauseMenu = ((CPauseMenu::sm_uTimeInputsDisabledFromClose + CPauseMenu::sm_uDisableInputDuration) >= fwTimer::GetTimeInMilliseconds()) 
													|| (pControl && pControl->GetAreInputsStillDisabled());
		if (viewMode == camControlHelperMetadataViewMode::FIRST_PERSON && pControl && pControl->IsInputDisabled(INPUT_NEXT_CAMERA) && !bInputsDisabledFromClosingPauseMenu)
		{
			return false;
		}

		return true;
	}
#endif	//FPS_MODE_SUPPORTED
	return false;
}

bool CTaskCover::HitInstIsFoliage(const phInst& rInst, u16 uHitComponent)
{
	if (rInst.GetArchetype()->GetTypeFlags() & ArchetypeFlags::GTA_FOLIAGE_TYPE)
	{
		if (rInst.GetArchetype()->GetBound()->GetType()==phBound::COMPOSITE)
		{
			phBoundComposite* pBoundComposite = static_cast<phBoundComposite*>(rInst.GetArchetype()->GetBound());
			if(pBoundComposite->GetTypeAndIncludeFlags() && pBoundComposite->GetTypeFlags(uHitComponent)&ArchetypeFlags::GTA_FOLIAGE_TYPE)
			{
				return true;
			}
		}
		else
		{
			return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsPlayerPedInCoverAgainstVehicleDoor(const CPed& rPed, const CCoverPoint& rCoverPoint)
{
	taskAssertf(rPed.IsLocalPlayer(), "Only call on local player ped");
	const Vector3 vPedPos = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
	const Vector3 vCoverDir = VEC3V_TO_VECTOR3(rCoverPoint.GetCoverDirectionVector());
	const Vector3 vEndPos = vPedPos + vCoverDir;
	Vector3 vIntersectionPosUnused;

	s32 iHitComponentIndex = -1;
	const phInst* pHitInst = CDynamicCoverHelper::DoLineProbeTest(vPedPos, vEndPos, vIntersectionPosUnused, &iHitComponentIndex);
	if (CTaskEnterCover::CheckIfHitVehicleCoverDoor(*pHitInst, iHitComponentIndex))
	{
		return true;
	}

	return false;
}

CEntity* CTaskCover::GetEntityPlayerIsInCoverAgainst(const CPed& rPed, const CCoverPoint& rCoverPoint)
{
	taskAssertf(rPed.IsLocalPlayer(), "Only call on local player ped");
	TUNE_GROUP_FLOAT(COVER_TUNE, Z_OFFSET, 0.2f, 0.0f, 1.0f, 0.01f);
	const Vector3 vZOffset(0.0f, 0.0f, Z_OFFSET);
	const Vector3 vPedPos = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition()) - vZOffset;
	const Vector3 vCoverDir = VEC3V_TO_VECTOR3(rCoverPoint.GetCoverDirectionVector());
	const Vector3 vEndPos = vPedPos + vCoverDir - vZOffset;
	Vector3 vIntersectionPosUnused;

	s32 iHitComponentIndex = -1;
	const phInst* pHitInst = CDynamicCoverHelper::DoLineProbeTest(vPedPos, vEndPos, vIntersectionPosUnused, &iHitComponentIndex);
	return static_cast<CEntity*>(CPhysics::GetEntityFromInst(const_cast<phInst*>(pHitInst)));
}

////////////////////////////////////////////////////////////////////////////////

float CTaskCover::PlayerCoverpointScoringCallback( const CCoverPoint* pCoverPoint, const Vector3& vCoverPointCoords, void* pData )
{
	PlayerCoverSearchData* pCoverSearchData = (PlayerCoverSearchData*)pData;
	Vector3 vCoverCoords = vCoverPointCoords;
	vCoverCoords.z += 1.0f;
	CPed* pPlayerPed = pCoverSearchData->m_pPlayerPed;

	const float PRIORITY_COVER_WEIGHTING = ms_Tunables.m_PriorityCoverWeighting;
	const float DISTANCE_WEIGHTING = ms_Tunables.m_DistanceWeighting;
	const float ANGLE_TO_COVER_WEIGHTING = ms_Tunables.m_AngleToCoverWeighting;
	const float ANGLE_OF_COVER_WEIGHTING = ms_Tunables.m_AngleOfCoverWeighting;
	const float EDGE_OF_COVER_WEIGHTING = ms_Tunables.m_EdgeWeighting;
	const float ANGLE_TO_DYNAMIC_COVER_WEIGHTING = ms_Tunables.m_AngleToDynamicCoverWeighting;
	const float ANGLE_TO_CAMERA_WEIGHTING = ms_Tunables.m_AngleToCameraWeighting;

	Vector3 vPlayerPedPos = VEC3V_TO_VECTOR3(pPlayerPed->GetTransform().GetPosition());
	bool bCoverValidInArk = false;
	bool bCoverValid = false;
	Vector2 vecStickInput = CDynamicCoverHelper::GetStickInputForCoverSearch(*pPlayerPed);

	// If the stick is active use that as an estimated direction to cover
	// Otherwise use the ped direction
	Vector3 vCoverSearchDirection = pCoverSearchData->m_CoverSearchDir;

	float fDistanceToSearchForCover = pCoverSearchData->m_CoverSearchDist;

	// When strafind, try to find cover that protects from where the ped is facing
	Vector3 vDesiredCoverDirection = pCoverSearchData->m_CoverProtectionDir;

	// Rule out any coverpoint not with 150o of the player heading
	const Vector3 vFakeTargetDir = (VEC3V_TO_VECTOR3(pPlayerPed->GetTransform().GetB()) * 10.0f) + vPlayerPedPos;
	Vector3 vCoverDir = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector( &RCC_VEC3V(vFakeTargetDir) ));

	Vector3 vToCover = vCoverCoords - vPlayerPedPos;
	vToCover.Normalize();

	// If flagged, ignore any coverpoints that dont match the previous cover dir
	if( pCoverSearchData->m_iSearchFlags&CTaskPlayerOnFoot::CSF_MatchCurrentCoverDir )
	{
		if(pCoverSearchData->m_vPreviousCoverDir.Dot(vCoverDir) < COVER_DIR_MATCH_LIMIT )
		{
			return INVALID_COVER_SCORE;
		}
		Vector3 vCoverRight = vCoverDir;
		vCoverRight.RotateZ(-HALF_PI);
		if( pCoverPoint->GetUsage() == CCoverPoint::COVUSE_WALLTOLEFT )
		{
			vCoverRight.Negate();
			if( vCoverSearchDirection.Dot(vCoverRight) < 0.0f )
			{
				return INVALID_COVER_SCORE;
			}
		}
		else if( pCoverPoint->GetUsage() == CCoverPoint::COVUSE_WALLTORIGHT )
		{
			if( vCoverSearchDirection.Dot(vCoverRight) < 0.0f )
			{
				return INVALID_COVER_SCORE;
			}
		}
		else
		{
			return INVALID_COVER_SCORE;
		}
	}

	//BANK_ONLY(Vector3 vCameraFront = GetCamFrontForCover());
	const bool bIsVehicleCover = pCoverPoint->m_pEntity && pCoverPoint->m_pEntity->GetIsTypeVehicle();
	const float fDistance = (vCoverCoords - vPlayerPedPos).XYMag();
	const float fMaxToCoverDist = CTaskCover::ms_Tunables.GetMaxPlayerToCoverDist(*pPlayerPed);
	float fPriorityScore = pCoverPoint->GetFlag(CCoverPoint::COVFLAGS_IsPriority) ? PRIORITY_COVER_WEIGHTING : 0.0f;
	float fDistanceScore = DISTANCE_WEIGHTING * (( fMaxToCoverDist - MIN(fDistance,fMaxToCoverDist) ) / fMaxToCoverDist);
	float fDirectionToCoverScore = ANGLE_TO_COVER_WEIGHTING * ( 1.0f + vToCover.Dot( vCoverSearchDirection ))  * 0.5f;
	float fDirectionOfCoverScore = ANGLE_OF_COVER_WEIGHTING * ( 1.0f + vCoverDir.Dot( vDesiredCoverDirection ))  * 0.5f;
	float fEdgeCoverScore = pCoverPoint->IsEdgeOrDoubleEdgeCoverPoint() ? EDGE_OF_COVER_WEIGHTING : 0.0f;
	// Edges aren't as important for low cover as we can fire over the top
	if (pCoverPoint->GetHeight() != CCoverPoint::COVHEIGHT_TOOHIGH)
	{
		fEdgeCoverScore = EDGE_OF_COVER_WEIGHTING;
	}
	float fAngleToDynamicCoverScore = 0.0f;
	
	if (pPlayerPed->GetCoverPoint())
	{
		Vector3 vDynamicCoverDirection = VEC3V_TO_VECTOR3(pPlayerPed->GetCoverPoint()->GetCoverDirectionVector());
		Vector3 vStaticCoverDirection = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector());
		fAngleToDynamicCoverScore = ANGLE_TO_DYNAMIC_COVER_WEIGHTING * (1.0f + vDynamicCoverDirection.Dot(vStaticCoverDirection)) * 0.5f;
	}

	const float fTopScore = PRIORITY_COVER_WEIGHTING + DISTANCE_WEIGHTING + ANGLE_TO_COVER_WEIGHTING + ANGLE_OF_COVER_WEIGHTING + EDGE_OF_COVER_WEIGHTING + ANGLE_TO_DYNAMIC_COVER_WEIGHTING + ANGLE_TO_CAMERA_WEIGHTING;
	// The lower the score the better, so reverse
	float fTotalScore = fTopScore - ( fPriorityScore + fDistanceScore + fDirectionToCoverScore + fDirectionOfCoverScore + fEdgeCoverScore + fAngleToDynamicCoverScore);

	// If we're really close to priority cover, treat it as valid
	if( pCoverPoint->GetFlag(CCoverPoint::COVFLAGS_IsPriority) && fDistance < ms_Tunables.m_MinDistToPriorityCoverToForce)
	{
		bCoverValid = true;
	}

	// if the coverpoint is close, treat it as valid
	if( !bCoverValid && fDistance < ms_Tunables.m_MinDistToCoverAnyDir )
	{
		if( !(pCoverSearchData->m_iSearchFlags&CTaskPlayerOnFoot::CSF_ConsiderCloseCover) )
		{
			return INVALID_COVER_SCORE;
		}

		// Ignore direction to cover if ontop of the coverpoint and no direction is held
		if( ( vecStickInput.Mag2() < 0.1f ) )
		{
			fTotalScore = fTopScore - ( fDistanceScore + 1.0f + fDirectionOfCoverScore );
			//return false;
		}

		// Accept cover behind the player if its vehicle cover
		if( !bIsVehicleCover && vecStickInput.Mag2() > 0.0f )
		{
			bCoverValid = vToCover.Dot(vCoverSearchDirection) > 0.0f;
		}
		else
		{
			bCoverValid = true;
		}
	}

	// For coverpoints we can dive into
	if( !bCoverValid )
	{
		// Search infront of the player depending on distance
		Vector3 vBehindPedToCover = vCoverCoords - ( vPlayerPedPos - ( vCoverSearchDirection * 2.0f ) );
		vBehindPedToCover.Normalize();
		float fMaxDistance = ms_Tunables.m_MinDistToCoverSpecificDir + ( ( fDistanceToSearchForCover / 3.0f ) * (5.0f - ms_Tunables.m_MinDistToCoverSpecificDir) );
#if __DEV
		if( CCoverDebug::ms_Tunables.m_DebugSearchIgnoreMovement )
		{
			fMaxDistance = 5.0f;
		}
#endif
		if( fDistance < fMaxDistance )
		{
			const bool bBehindPedToCoverConditionPassed = vBehindPedToCover.Dot(vCoverSearchDirection) > ms_Tunables.m_BehindPedToCoverCosTolerance;
			const bool bSearchToCoverConditionPassed = bBehindPedToCoverConditionPassed ? vToCover.Dot(vCoverSearchDirection) > ms_Tunables.m_SearchToCoverCosTolerance : false;
			if( bBehindPedToCoverConditionPassed && bSearchToCoverConditionPassed )
			{
				bCoverValidInArk = true;
			}
		}
	}

	// If the coverpoint is in an arc infront of the player, treat it as valid
	if( bCoverValid || bCoverValidInArk )
	{
		// Extend the LOS check to go beyond the coverposition by the peds radius and a bit to make sure there is space.
		Vector3 vLosEndCheck = vCoverCoords - vPlayerPedPos;

		if (!bIsVehicleCover)
		{
			float fLength = vLosEndCheck.Mag();
			vLosEndCheck.Normalize();
			vLosEndCheck.Scale(fLength);// + PED_RADIUS + 0.01f );
		}
		vLosEndCheck += vPlayerPedPos;

		// Do two probes one high, one low (can't do capsule test here since we could be testing loads of cover points)
		TUNE_GROUP_FLOAT(COVER_TUNE, Z_OFFSET_FOR_LOS_TEST_1, 0.4f, -1.0f, 1.0f, 0.01f);
		Vector3 vStart = vPlayerPedPos - Vector3(0.0f, 0.0f, Z_OFFSET_FOR_LOS_TEST_1);
		Vector3 vEnd = vLosEndCheck - Vector3(0.0f, 0.0f, Z_OFFSET_FOR_LOS_TEST_1);

		Vector3 vIntersectionPosUnused;
		const phInst* pHitInst = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPosUnused);
		if (!pHitInst)
		{
			TUNE_GROUP_FLOAT(COVER_TUNE, Z_OFFSET_FOR_LOS_TEST_2, -0.4f, -1.0f, 1.0f, 0.01f);
			vStart = vPlayerPedPos - Vector3(0.0f, 0.0f, Z_OFFSET_FOR_LOS_TEST_2);
			vEnd = vLosEndCheck - Vector3(0.0f, 0.0f, Z_OFFSET_FOR_LOS_TEST_2);
			pHitInst = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPosUnused);
		}

		if (pHitInst)
		{
			// allowed to hit the object for Object types
			if( pCoverPoint->GetType() == CCoverPoint::COVTYPE_OBJECT )
			{
				const CEntity* pEntity = CPhysics::GetEntityFromInst(pHitInst);
				if( pEntity && pEntity == pCoverPoint->m_pEntity )
				{
#if __DEV
					if( CCoverDebug::ms_Tunables.m_RenderCoverPointScores )
					{
						float fScore = ( 3.0f - fTotalScore ) / 3.0f;
						grcDebugDraw::Line( vPlayerPedPos, vLosEndCheck, Color32( 0.0f, fScore, 0.0f) );
					}
#endif
					return fTotalScore;
				}
			}
#if __DEV
			if( CCoverDebug::ms_Tunables.m_RenderCoverPointScores )
			{
				float fScore = ( 3.0f - fTotalScore ) / 3.0f;
				grcDebugDraw::Line( vPlayerPedPos, vLosEndCheck, Color32( fScore, 0.0f, 0.0f) );
			}
#endif
			return INVALID_COVER_SCORE;
		}

#if DEBUG_DRAW
		CTask::ms_debugDraw.AddLine(RCC_VEC3V(vPlayerPedPos), RCC_VEC3V(vLosEndCheck), Color_green, 2000, 0 );
#endif // DEBUG_DRAW


		// Check to see if there is collision high enough for it to be used by the player
		{
			Vector3 vStart, vEnd;
			vStart = vCoverCoords;
			static float HEIGHT_OFFSET = -0.15f;
			vStart.z += HEIGHT_OFFSET;
			vEnd = vStart + (vCoverDir*0.7f);
			WorldProbe::CShapeTestProbeDesc probeDesc;
			probeDesc.SetResultsStructure(NULL);
			probeDesc.SetStartAndEnd(vStart, vEnd);
			probeDesc.SetIncludeFlags(ArchetypeFlags::GTA_ALL_MAP_TYPES|ArchetypeFlags::GTA_OBJECT_TYPE|ArchetypeFlags::GTA_VEHICLE_TYPE);
			// Ignore the height condition for vehicles, assume its valid cover
			if( !WorldProbe::GetShapeTestManager()->SubmitTest(probeDesc) && !bIsVehicleCover)
			{
#if __DEV
				if( CCoverDebug::ms_Tunables.m_RenderCoverPointScores )
				{
					float fScore = ( 3.0f - fTotalScore ) / 3.0f;
					grcDebugDraw::Line( vPlayerPedPos, vLosEndCheck, Color32( 0.0f, 0.0f, fScore) );
				}
#endif
				return INVALID_COVER_SCORE;
			}
		}

#if __DEV
		if( CCoverDebug::ms_Tunables.m_RenderCoverPointScores )
		{
			float fScore = ( 3.0f - fTotalScore ) / 3.0f;
			CTask::ms_debugDraw.AddLine( RCC_VEC3V(vPlayerPedPos), RCC_VEC3V(vCoverCoords), Color32( 0.0f, fScore, 0.0f), 2000 );
			char szText[128];
			formatf(szText, "(TS: %.2f, D : %.2f, ATC : %.2f, AOC : %.2f", fScore, fDistanceScore, fDirectionToCoverScore, fDirectionOfCoverScore);
			CTask::ms_debugDraw.AddText( RCC_VEC3V(vCoverCoords), 0, 10, szText, Color32( 0.0f, fScore, 0.0f), 2000 );
		}
#endif
		return fTotalScore;
	}
	return INVALID_COVER_SCORE;
}

////////////////////////////////////////////////////////////////////////////////

const CTaskCover::CoverAnimStateInfo* CTaskCover::GetAnimStateInfoForState(const atArray<CoverAnimStateInfo>& aCoverAnimStateInfos, s32 iFlags)
{
	for (s32 i=0; i<aCoverAnimStateInfos.GetCount(); i++)
	{
		if (aCoverAnimStateInfos[i].m_Flags == iFlags)
		{
			return &aCoverAnimStateInfos[i];
		}
	}
	return NULL;
}

//////////////////////////////////////////////////////////////////////////

float CTaskCover::ComputeMvCamHeadingForPed(const CPed& rPed) 
{
	const float fCamHeading = camInterface::GetGameplayDirector().GetFrame().ComputeHeading();
	const float fCovHeading = CTaskMotionInCover::ComputeCoverHeading(rPed);
	const float fDelta = fwAngle::LimitRadianAngle(fCovHeading - fCamHeading);
	float fMvCamHeading = rage::Clamp((fDelta + PI) / TWO_PI, 0.0f, 1.0f);
	return fMvCamHeading;
}

////////////////////////////////////////////////////////////////////////////////

CTaskCover::CTaskCover(const CWeaponTarget& coverThreat, s32 iCoverFlags, eForcedExit forcedExit)
: m_CoverThreat(coverThreat)
, m_vSearchPosition(Vector3::ZeroType)
, m_fSearchDistanceMin(0.0f)
, m_fLastFramesCoverSpeed(-1.0f)
, m_fSearchDistanceMax(20.0f)
, m_vCoverCoors(Vector3::ZeroType)
, m_fEndHeading(-1.0f)
, m_fMoveBlendRatio(MOVEBLENDRATIO_RUN)
, m_fTimeInCover(-1.0)
, m_fTestSpheresIntersectingRouteTimer(-1.0f)
, m_iSearchType(CCover::CS_PREFER_PROVIDE_COVER)
, m_SeekCoverFlags(0)
, m_CoverFlags(iCoverFlags)
, m_iScriptedCoverIndex(INVALID_COVER_POINT_INDEX)
, m_pSubTaskWhilstSearching(NULL)
, m_pCoverPointFilterConstructFn(NULL)
, m_pSpheresOfInfluenceBuilder(CTaskCombat::SpheresOfInfluenceBuilder)
, m_pCoverFinder(NULL)
, m_fBlendInDuration(INSTANT_BLEND_DURATION)
, m_bRightFootPlant(false)
, m_bWantedToReloadDuringEntry(false)
, m_bHelpTextNeedsClearing(false)
, m_eInCoverTerminationReason(TR_NormalExit)
, m_eForcedExit(forcedExit)
, m_pCoverVehicle(NULL)
, m_eCoverVehicleDoorId(VEH_INVALID_ID)
, m_iDynamicObjectIndex(DYNAMIC_OBJECT_INDEX_NONE)
, m_iDynamicObjectLastUpdateTime(0)
, m_bHasNetCoverPointInfo(false)
, m_bHasVehicleStoodOn(false)
, m_vNetCoverPointPosition(VEC3_ZERO)
, m_vNetCoverPointDirection(VEC3_ZERO)
, m_iNetCoverPointUsage(0)
, m_TimeBeforeDisplayHelpText(0.0f)
{
#if __DEV
	Vector3 targetPos = VEC3_ZERO;

	if (m_CoverThreat.GetIsValid())
		m_CoverThreat.GetPosition(targetPos);

	aiAssertf(targetPos.x >= WORLDLIMITS_XMIN && targetPos.x <= WORLDLIMITS_XMAX &&
				targetPos.y >= WORLDLIMITS_YMIN && targetPos.y <= WORLDLIMITS_YMAX &&
				targetPos.z >= WORLDLIMITS_ZMIN && targetPos.z <= WORLDLIMITS_ZMAX, "CTaskCover - created with an invalid target position %f, %f, %f", targetPos.x, targetPos.y, targetPos.z );
#endif // __DEV
	SetInternalTaskType(CTaskTypes::TASK_COVER);
}

////////////////////////////////////////////////////////////////////////////////

aiTask* CTaskCover::Copy() const
{
	CTaskCover* pClone = rage_new CTaskCover(GetTarget(), m_CoverFlags.GetAllFlags(), m_eForcedExit);
	pClone->SetMoveBlendRatio(m_fMoveBlendRatio);
	pClone->SetSearchPosition(m_vSearchPosition);
	pClone->SetMinMaxSearchDistances( m_fSearchDistanceMin, m_fSearchDistanceMax );
	pClone->SetSearchFlags(m_SeekCoverFlags.GetAllFlags());
	pClone->SetScriptedCoverIndex(m_iScriptedCoverIndex);
	pClone->SetSearchType(m_iSearchType);
	pClone->SetTimeInCover(m_fTimeInCover);
	pClone->SetBlendInDuration(m_fBlendInDuration);

	// Set the subtask of the clone if one is set for this task
	if( m_pSubTaskWhilstSearching )
		pClone->SetSubtaskToUseWhilstSearching(m_pSubTaskWhilstSearching->Copy());

	pClone->SetSpheresOfInfluenceBuilder(m_pSpheresOfInfluenceBuilder);

	return pClone;
}

////////////////////////////////////////////////////////////////////////////////

CTaskCover::~CTaskCover()
{
	if (m_pSubTaskWhilstSearching)
	{
		delete m_pSubTaskWhilstSearching;
		m_pSubTaskWhilstSearching = NULL;
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::GetOverriddenGameplayCameraSettings(tGameplayCameraSettings& settings) const
{
	const bool isConsiderInCoverForCamera = IsConsideredInCoverForCamera();
	if(isConsiderInCoverForCamera)
	{
		const CPed *pPed		= GetPed(); //Get the ped ptr.
		const u32 cameraHash	= ComputeCameraHash(*pPed);
		if(cameraHash)
		{
			settings.m_CameraHash = cameraHash;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsConsideredInCoverForCamera() const
{
	//NOTE: We do not override the gameplay camera when the mobile phone camera is active,
	//as we need to allow the secondary task tree to request the necessary camera.
	const bool isRenderingMobilePhoneCamera	= CPhoneMgr::CamGetState();
	const bool isConsiderInCoverForCamera	= !isRenderingMobilePhoneCamera &&
												((GetState() == State_Start) ||
												(GetState() == State_Resume) ||
												(GetState() == State_EnterCover) ||
												(GetState() == State_UseCover));

	return isConsiderInCoverForCamera;
}

////////////////////////////////////////////////////////////////////////////////

u32 CTaskCover::ComputeCameraHash(const CPed& ped)
{
	const CWeaponInfo* weaponInfo = camGameplayDirector::ComputeWeaponInfoForPed(ped);
	if(!taskVerifyf(weaponInfo, "Could not obtain a weapon info object for the specified ped"))
	{
		return 0;
	}

	const u32 cameraHash = weaponInfo->GetCoverCameraHash();

	return cameraHash;
}

////////////////////////////////////////////////////////////////////////////////

Vector3 CTaskCover::GetCamPosForCover()
{
	camGameplayDirector& gameplayDirector = camInterface::GetGameplayDirector();
	camThirdPersonCamera* pThirdPersonCamera = gameplayDirector.GetThirdPersonCamera();
	Vector3 vCameraFront(Vector3::ZeroType);
	if (pThirdPersonCamera)
	{
		vCameraFront = pThirdPersonCamera->GetBasePivotPosition();
	}
	else
	{
		vCameraFront = camInterface::GetPos();
	}
	return vCameraFront;
}

////////////////////////////////////////////////////////////////////////////////

Vector3 CTaskCover::GetCamFrontForCover()
{
	camGameplayDirector& gameplayDirector = camInterface::GetGameplayDirector();
	camThirdPersonCamera* pThirdPersonCamera = gameplayDirector.GetThirdPersonCamera();
	Vector3 vCameraFront(Vector3::ZeroType);
	if (pThirdPersonCamera)
	{
		vCameraFront = pThirdPersonCamera->GetBaseFront();
	}
	else
	{
		vCameraFront = camInterface::GetFront();
	}
	return vCameraFront;
}

////////////////////////////////////////////////////////////////////////////////

Vector2 CTaskCover::ComputeStickInput(const CPed& ped, const Vector3& vCoverDirection)
{
	Vector2 vecStick(0.0f,0.0f);
	const CControl* pControl = ped.GetControlFromPlayer();
	if (pControl)
	{
		vecStick = Vector2(pControl->GetPedWalkLeftRight().GetNorm() * 127.0f, -pControl->GetPedWalkUpDown().GetNorm() * 127.0f);
		vecStick.Rotate(camInterface::GetPlayerControlCamHeading(ped));
		vecStick.Rotate(-rage::Atan2f(-vCoverDirection.x, vCoverDirection.y));
	}
	return vecStick;
}

////////////////////////////////////////////////////////////////////////////////

Vector2 CTaskCover::ComputeStickInput(const CPed& ped)
{
	if (taskVerifyf(ped.IsLocalPlayer(), "Ped isn't local player"))
	{
		CCoverPoint* pCoverPoint = ped.GetCoverPoint();
		if (pCoverPoint)
		{
			const Vector3 vCoverDirection = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector());
			return CTaskCover::ComputeStickInput(ped, vCoverDirection);
		}
	}
	return Vector2(0.0f,0.0f);
}

////////////////////////////////////////////////////////////////////////////////

Vector3 CTaskCover::ComputeCameraHeadingVec(const CPed& ped)
{
	if (taskVerifyf(ped.IsLocalPlayer(), "Ped isn't local player"))
	{
		const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
		return aimCameraFrame.GetFront();
	}
	return Vector3(0.0f,1.0f,0.0f);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::HasNetCoverPoint(const CPed& ped) const
{
	return ped.IsNetworkClone() ? m_bHasNetCoverPointInfo : (ped.GetCoverPoint() != NULL);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::GetNetCoverPointPosition(const CPed& ped, Vector3& vCoverPointPos) const
{
	if (!ped.IsNetworkClone())
	{
		CCoverPoint* pCoverPoint = ped.GetCoverPoint();

		if (pCoverPoint && pCoverPoint->GetCoverPointPosition(vCoverPointPos))
		{
			return true;
		}
	}
	else
	{
		if (m_bHasNetCoverPointInfo)
		{
			// We sync the cover position relative to the vehicle, if we're stood on one, so we need to transform to global space
			if (m_pVehicleStoodOn)
			{
				Vec3V vCoverPosition	= VECTOR3_TO_VEC3V(m_vNetCoverPointPosition);
				vCoverPointPos			= VEC3V_TO_VECTOR3(m_pVehicleStoodOn->GetTransform().Transform(vCoverPosition));
			}
			else
			{
				vCoverPointPos = m_vNetCoverPointPosition;
			}	
			return true;
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::GetNetCoverPointDirection(const CPed& ped, Vector3& vCoverPointDirection) const
{
	if (!ped.IsNetworkClone())
	{
		CCoverPoint* pCoverPoint = ped.GetCoverPoint();

		if (pCoverPoint)
		{
			vCoverPointDirection = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector());
			return true;
		}
	}
	else
	{
		if (m_bHasNetCoverPointInfo)
		{
			vCoverPointDirection = m_vNetCoverPointDirection;
			return true;
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::GetNetCoverPointUsage(const CPed& ped, CCoverPoint::eCoverUsage& usage) const
{
	if (!ped.IsNetworkClone())
	{
		CCoverPoint* pCoverPoint = ped.GetCoverPoint();

		if (pCoverPoint)
		{
			usage = pCoverPoint->GetUsage();
			return true;
		}
	}
	else
	{
		if (m_bHasNetCoverPointInfo)
		{
			usage = (CCoverPoint::eCoverUsage)m_iNetCoverPointUsage;
			return true;
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::GetNetCoverPointHeight(const CPed& ped, CCoverPoint::eCoverHeight& coverPointHeight) const
{
	if (!ped.IsNetworkClone())
	{
		CCoverPoint* pCoverPoint = ped.GetCoverPoint();

		if (pCoverPoint)
		{
			coverPointHeight = pCoverPoint->GetHeight();
			return true;
		}
	}
	else
	{
		if (m_bHasNetCoverPointInfo)
		{
			coverPointHeight = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) ? CCoverPoint::COVHEIGHT_TOOHIGH : CCoverPoint::COVHEIGHT_HIGH;
			return true;
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::GetNetIsStoodOnVehicle(const CPed& ped) const
{
	if (!ped.IsNetworkClone())
	{	
		return ped.GetGroundPhysical() && static_cast<const CEntity*>(ped.GetGroundPhysical())->GetIsTypeVehicle(); 
	}
	else
	{
		return m_pVehicleStoodOn != NULL;
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::SetSubtaskToUseWhilstSearching(aiTask* pSubtask) 
{ 	
	if(m_pSubTaskWhilstSearching) 
		delete m_pSubTaskWhilstSearching; 
	
	m_pSubTaskWhilstSearching = pSubtask; 
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::UpdateTarget(const CEntity* pEntity, Vector3* pvPosition)
{
	if (pEntity)
	{
		GetTarget().SetEntity(pEntity);
	}
	else if (pvPosition)
	{
		GetTarget().SetPosition(*pvPosition);
	}
	else
	{
		taskAssertf(0,"NULL entity and NULL position pointers");
	}
}

//////////////////////////////////////////////////////////////////////////

void CTaskCover::UpdateLeftHandIk(CPed* pPed)
{
	if (CTaskInCover::ms_Tunables.m_EnableLeftHandIkInCover)
	{
		if (pPed->GetWeaponManager())
		{
			bool bProcessLeftHandIk = true;
			float fIkBlendInDuration = -1.0f;
			float fIkBlendOutDuration = -1.0f;

			const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfoFromObject();
			if (pWeaponInfo)
			{				
				// Motion in cover also disables left hand ik under certain conditions
				if (!pWeaponInfo->GetUseLeftHandIkInCover())
				{
					bProcessLeftHandIk = false;
				}
				else if (pWeaponInfo->GetIsGun2Handed() && pWeaponInfo->GetIs1HandedInCover() && !pWeaponInfo->ShouldPedUseAlternateCoverClipSet(*pPed))
				{
					bProcessLeftHandIk = false;
				}
				else if (pWeaponInfo->GetIsGun1Handed() && !pWeaponInfo->ShouldPedUseAlternateCoverClipSet(*pPed))
				{
					bProcessLeftHandIk = false;
				}

				if (bProcessLeftHandIk)
				{
					CTaskMotionAiming::ProcessOnFootAimingLeftHandGripIk(*pPed, *pWeaponInfo, false, fIkBlendInDuration, fIkBlendOutDuration);
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsCoverValid(const CCoverPoint& rCoverPoint, const CPed& rPed)
{
	Vector3 vCoverPosition;
	if (rCoverPoint.GetCoverPointPosition(vCoverPosition))
	{
		return IsCoverPositionValid(vCoverPosition, rPed);
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsCoverPositionValid(const Vector3& vCoverPosition, const CPed& rPed)
{
	// Make sure the player isn't trying to enter cover nearby another ped
	const CEntityScannerIterator entityList = rPed.GetPedIntelligence()->GetNearbyPeds();
	for(const CEntity* pEnt = entityList.GetFirst(); pEnt; pEnt = entityList.GetNext())
	{
		const CPed* pOtherPed = static_cast<const CPed*>(pEnt);
		if (pOtherPed && !pOtherPed->GetIsDeadOrDying() && pOtherPed->IsCollisionEnabled())
		{
			Vector3 vOtherPos = VEC3V_TO_VECTOR3(pOtherPed->GetTransform().GetPosition());
			Vector3 vTheirPointToThisPoint = vCoverPosition - vOtherPos;
			if (vTheirPointToThisPoint.XYMag2() < rage::square(0.5f))
			{
				AI_LOG_WITH_ARGS("Other ped %s's position is too close to us (%.2f) (%s) so cover position is invalid", AILogging::GetDynamicEntityNameSafe(pOtherPed), sqrt(vTheirPointToThisPoint.XYMag2()), AILogging::GetDynamicEntityNameSafe(&rPed));
				return false;
			}

			TUNE_GROUP_FLOAT(COVER_TUNE, MAX_DIST_FROM_OTHER_PEDS_COVER, 0.5f, 0.0f, 1.5f, 0.01f);
			const CTaskCover* pCoverTask = static_cast<const CTaskCover*>(pOtherPed->GetPedIntelligence()->FindTaskByType(CTaskTypes::TASK_COVER));
			if (pCoverTask && pCoverTask->GetNetCoverPointPosition(*pOtherPed, vOtherPos))
			{
				Vector3 vTheirPointToThisPoint = vCoverPosition - vOtherPos;
				if (vTheirPointToThisPoint.XYMag2() < rage::square(MAX_DIST_FROM_OTHER_PEDS_COVER))
				{
					AI_LOG_WITH_ARGS("Other ped %s's cover position is too close to us (%.2f) (%s) so cover position is invalid", AILogging::GetDynamicEntityNameSafe(pOtherPed), sqrt(vTheirPointToThisPoint.XYMag2()), AILogging::GetDynamicEntityNameSafe(&rPed));
					return false;
				}
			}
		}
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsCoverPointPositionTooFarAndAcute(const CPed& rPed, const Vector3& vCoverPosition)
{
	TUNE_GROUP_BOOL(PLAYER_COVER_TUNE, IGNORE_ACUTE_NESS_CHECK, false);
	if (IGNORE_ACUTE_NESS_CHECK)
		return false;

	if (!rPed.IsLocalPlayer())
		return false;

	bool bIsFPS = false;
#if FPS_MODE_SUPPORTED
	bIsFPS = rPed.IsFirstPersonShooterModeEnabledForPlayer(false);
#endif // FPS_MODE_SUPPORETD

	const Vector3 vPedPos = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
	TUNE_GROUP_FLOAT(PLAYER_COVER_TUNE, MAX_DIST_FROM_PED_TO_ALWAYS_ACCEPT_COVER, 3.5f, 0.0f, 10.0f, 0.01f);
	TUNE_GROUP_FLOAT(PLAYER_COVER_TUNE, MAX_DIST_FROM_PED_TO_ALWAYS_ACCEPT_COVER_FPS, 1.0f, 0.0f, 10.0f, 0.01f);
	const float fMaxDistToAlwaysAccept = bIsFPS ? MAX_DIST_FROM_PED_TO_ALWAYS_ACCEPT_COVER_FPS : MAX_DIST_FROM_PED_TO_ALWAYS_ACCEPT_COVER;
	const float fDistSqd = vPedPos.Dist2(vCoverPosition);
	if (fDistSqd < square(fMaxDistToAlwaysAccept))
	{
		return false;
	}

	TUNE_GROUP_FLOAT(PLAYER_COVER_TUNE, MIN_DOT_TO_ACCEPT_COVER, 0.5f, -1.0f, 1.0f, 0.01f);
	const camFrame& rCameraFrame = camInterface::GetGameplayDirector().GetFrame();
	const Vector3 vCamPos = rCameraFrame.GetPosition();
	const Vector3 vCamFwd = rCameraFrame.GetFront();
	Vector3 vToCover = vCoverPosition - vCamPos;
	vToCover.z = 0.0f;
	vToCover.Normalize();
	const float fCamDotCover = vCamFwd.Dot(vToCover);
	if (fCamDotCover < MIN_DOT_TO_ACCEPT_COVER)
	{
		aiDebugf1("Cam Dot : %.2f", fCamDotCover);
		return true;
	}

	if (NetworkInterface::IsGameInProgress())
	{
		TUNE_GROUP_FLOAT(PLAYER_COVER_TUNE, MIN_CAM_DOT_TO_PED_ACCEPT_COVER, 0.5f, -1.0f, 1.0f, 0.01f);
		Vector3 vPedToCover = vCoverPosition - vPedPos;
		vPedToCover.z = 0.0f;
		vPedToCover.Normalize();
		const float fCamPedDotCover = vCamFwd.Dot(vPedToCover);
		if (fCamPedDotCover < MIN_CAM_DOT_TO_PED_ACCEPT_COVER)
		{
			aiDebugf1("Cam Ped Dot : %.2f", fCamPedDotCover);
			return true;
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::DoesCoverPointProvideCoverFromThreat(const Vector3& vCoverDir, const Vector3& vThreatDir)
{
	TUNE_GROUP_FLOAT(PLAYER_COVER_TUNE, MIN_THREAT_DOT_TO_ACCEPT_COVER, 0.5f, -1.0f, 1.0f, 0.01f);
	// Accept cover providing cover from our threats though
	const float fThreatDotCovDir = vThreatDir.Dot(vCoverDir);
	aiDebugf1("Threat Dot : %.2f", fThreatDotCovDir);
	if (fThreatDotCovDir > MIN_THREAT_DOT_TO_ACCEPT_COVER)
	{
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::VerifyCoverPointDirection(const CCoverPoint& rCoverPoint)
{
	Vector3 vCoverPosition;
	if (rCoverPoint.GetCoverPointPosition(vCoverPosition))
	{
		const Vector3 vCoverDirection = VEC3V_TO_VECTOR3(rCoverPoint.GetCoverDirectionVector());
		TUNE_GROUP_FLOAT(COVER_TUNE, Z_OFFSET_FOR_PROBE, 0.55f, -1.0f, 1.0f, 0.01f);
		TUNE_GROUP_FLOAT(COVER_TUNE, BACKWARDS_OFFSET, 0.5f, -1.0f, 1.0f, 0.01f);
		Vector3 vStart = vCoverPosition + Vector3(0.0f, 0.0f, Z_OFFSET_FOR_PROBE);
		Vector3 vEnd = vStart + vCoverDirection * BACKWARDS_OFFSET;
		Vector3 vIntersectionPos;
		const phInst* pHitInst = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPos);
#if DEBUG_DRAW
		TUNE_GROUP_BOOL(COVER_TUNE, RENDER_PROBE, false);
		if (RENDER_PROBE)
		{
			CCoverDebug::ms_debugDraw.AddLine(RCC_VEC3V(vStart), pHitInst ? RCC_VEC3V(vIntersectionPos) : RCC_VEC3V(vEnd), pHitInst ? Color_cyan : Color_brown, 5000, ATSTRINGHASH("COVER_INTERSECT_LINE", 0x773E8186));
			CCoverDebug::ms_debugDraw.AddSphere(pHitInst ? RCC_VEC3V(vIntersectionPos) : RCC_VEC3V(vEnd), 0.05f, pHitInst ? Color_cyan : Color_brown, 5000, ATSTRINGHASH("COVER_INTERSECT_SPHERE", 0x3FE5DE76));
		}

		Vector3 vNewCoverDirPos = vCoverPosition + vCoverDirection;
		CCoverDebug::ms_debugDraw.AddLine(RCC_VEC3V(vCoverPosition), RCC_VEC3V(vNewCoverDirPos), Color_orange, 5000, ATSTRINGHASH("NEW_COVER_LINE", 0x1413972B));
		CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(vCoverPosition), 0.05f, Color_orange, 5000, ATSTRINGHASH("NEW_COVER_SPHERE", 0x3A5DF494));
#endif // DEBUG_DRAW
		
		return pHitInst ? true : false;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::CleanUp()
{
	CPed* pPed = GetPed();

	if (!pPed->IsNetworkClone() && m_pCoverVehicle && m_eCoverVehicleDoorId != VEH_INVALID_ID)
	{
		CCarDoor* pDoor = m_pCoverVehicle->GetDoorFromId(m_eCoverVehicleDoorId);
		if (pDoor)
		{
			pDoor->ClearFlag(CCarDoor::PED_USING_DOOR_FOR_COVER);
		}
	}

	if (pPed->IsLocalPlayer())
	{
		//pPed->GetPlayerInfo()->GetTargeting().ClearLockOnTarget();

		TUNE_GROUP_BOOL(COVER_TUNE, PERSIST_CROUCH_STATE_WHEN_QUITTING, false);
		if (!PERSIST_CROUCH_STATE_WHEN_QUITTING)
		{
			if (pPed->GetIsCrouching() && m_CoverFlags.IsFlagSet(CF_CrouchingAtStart))
				pPed->SetIsCrouching(true);
			else
				pPed->SetIsCrouching(false, -1, false);
		}

		// Flag that we are not using a cover point (possibly should be done for ai too)
		pPed->SetPedConfigFlag( CPED_CONFIG_FLAG_UsingCoverPoint, false );

		if (ENABLE_ROUND_COVER)
		{
			CPlayerInfo::ms_DynamicCoverHelper.ResetRoundCoverTest();
		}
	}
	else
	{
		if(!pPed->IsNetworkClone())
		{
			if (pPed->GetIsCrouching() && m_CoverFlags.IsFlagSet(CF_CrouchingAtStart))
				pPed->SetIsCrouching(true);
			else
				pPed->SetIsCrouching(false, -1, false);
		}

		// If we're running the cover task as part of a sequence and its not the last task, we keep the cover flag set so the next task can pick up on it
		if (!pPed->IsNetworkClone())
		{
			CTaskUseSequence* pSeqTask = static_cast<CTaskUseSequence*>(pPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_USE_SEQUENCE));
			if (pSeqTask && GetState() >= State_EnterCover)
			{
				pPed->SetIsInCover(2);
			}
		}
		else if (GetState() >= State_EnterCover && GetState() < State_Finish)
		{
			pPed->SetIsInCover(2);
		}
		pPed->SetPedResetFlag(CPED_RESET_FLAG_KeepCoverPoint, true );
		pPed->SetPedResetFlag(CPED_RESET_FLAG_InCoverFacingLeft, m_CoverFlags.IsFlagSet(CF_FacingLeft));
	}

	//Clean up blocking object
	RemoveBlockingObject();

	u32 uBlendOutFlags = 0;
	if(pPed->GetMotionData()->GetCurrentMoveBlendRatio().Mag2() > 0.0f || m_eInCoverTerminationReason == TR_CornerExit)
	{
		if (!pPed->WantsToUseActionMode() || m_eInCoverTerminationReason == TR_CornerExit)
		{
			uBlendOutFlags = CMovePed::Task_TagSyncTransition;
		}
	}
	else
	{
		//pPed->ForceMotionStateThisFrame(CPedMotionStates::MotionState_Idle, true);
		uBlendOutFlags = CMovePed::Task_IgnoreMoverBlendRotation;
	}

	float fNetworkBlendOutDuration = ms_Tunables.m_NetworkBlendOutDuration;
	if (m_eInCoverTerminationReason == TR_IdleExitToRunStart)
	{
		fNetworkBlendOutDuration = ms_Tunables.m_NetworkBlendOutDurationRunStart;
	}
	else if (m_eInCoverTerminationReason == TR_IdleExitToRun)
	{
		fNetworkBlendOutDuration = ms_Tunables.m_NetworkBlendOutDurationRun;
	}
	pPed->GetMotionData()->SetFacingLeftInCover(m_CoverFlags.IsFlagSet(CF_FacingLeft));

	if(NetworkInterface::IsGameInProgress() && pPed->GetNetworkObject() && IsMigrating())
	{
		CNetObjPed* netObjPed = static_cast<CNetObjPed*>(pPed->GetNetworkObject());
		netObjPed->TakeControlOfOrphanedMoveNetworkTaskSubNetwork(m_TaskCoverMoveNetworkHelper.GetNetworkPlayer(), fNetworkBlendOutDuration, uBlendOutFlags);
	}
	else
	{
		pPed->GetMovePed().ClearTaskNetwork(m_TaskCoverMoveNetworkHelper, fNetworkBlendOutDuration, uBlendOutFlags);
	}

	if(!pPed->IsPlayer())
	{
		CTaskMotionBase* pMotionTask = pPed->GetPrimaryMotionTask();
		if(pMotionTask && pMotionTask->GetTaskType() == CTaskTypes::TASK_MOTION_PED)
		{
			static_cast<CTaskMotionPed*>(pMotionTask)->SetBlockAimingTransitionIndependentMover(fNetworkBlendOutDuration);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::DoAbort(const AbortPriority UNUSED_PARAM(priority), const aiEvent* pEvent)
{
	bool bSetIsInCover = false;
	CPed& ped = *GetPed();

	// If script have given a task to the ped when they're in cover
	if (pEvent && pEvent->GetEventType() == EVENT_SCRIPT_COMMAND)
	{
		const CEventScriptCommand* pScriptCommand = static_cast<const CEventScriptCommand*>(pEvent);
		if (pScriptCommand->GetTask())
		{
			bSetIsInCover = true;
		}
	}

	// If our response task is threat response then we should stay in cover temporarily
	if (ped.GetPedIntelligence()->GetEventResponseTask())
	{
		s32 iTaskType = ped.GetPedIntelligence()->GetEventResponseTask()->GetTaskType();
		if (iTaskType == CTaskTypes::TASK_THREAT_RESPONSE)
		{
			bSetIsInCover = true;
		}
	}

	// Possibly reset flags active so the incoming task can put the ped directly into cover to prevent pops/coming out of cover unexpectedly
	if(bSetIsInCover)
	{
		if (GetState() != State_ExitCover)
		{
			ped.SetIsInCover(2);
		}

		ped.SetPedResetFlag(CPED_RESET_FLAG_KeepCoverPoint, true );
		ped.SetPedResetFlag(CPED_RESET_FLAG_InCoverFacingLeft, m_CoverFlags.IsFlagSet(CF_FacingLeft));
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::ProcessPreFSM()
{
	CPed* pPed = GetPed();
	pPed->SetPedResetFlag(CPED_RESET_FLAG_KeepCoverPoint, true);
	pPed->SetPedResetFlag(CPED_RESET_FLAG_InCoverFacingLeft, m_CoverFlags.IsFlagSet(CF_FacingLeft));

#if FPS_MODE_SUPPORTED
	if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_ProcessPreRender2, true);
		pPed->SetPedResetFlag(CPED_RESET_FLAG_ProcessPostCamera, true);
	}
#endif // FPS_MODE_SUPPORTED

	// If we're an ai ped who have been given a scripted cover task, allow updating the ped targetting if we have a valid ped target
	if (!pPed->IsPlayer() && !pPed->IsNetworkClone() && !pPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_COMBAT))
	{
		if (m_CoverThreat.GetIsValid() && m_CoverThreat.GetEntity() && m_CoverThreat.GetEntity()->GetIsTypePed())
		{
			const CPed* pThreatPed = static_cast<const CPed*>(m_CoverThreat.GetEntity());
			if(!pPed->GetPedIntelligence()->IsFriendlyWith(*pThreatPed))
			{
				CPedTargetting* pPedTargetting = pPed->GetPedIntelligence()->GetTargetting(true);
				pPedTargetting->RegisterThreat(pThreatPed);
			}
		}
	}

	// Stream player specific cover anims
	if (pPed->IsPlayer() && pPed->GetInventory())
	{
		CTaskCover::RequestCoverClipSet(ms_Tunables.m_CoreWeaponClipSetId, SP_High);
		if (pPed->IsLocalPlayer())
		{
#if FPS_MODE_SUPPORTED
#if GTA_REPLAY
			if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
			{
				CReplayMgr::DisableCameraMovementThisFrame();
			}
#endif //GTA_REPLAY
			if (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonLocoAnimations)
			{
				CTaskCover::RequestCoverClipSet(ms_Tunables.GetStreamedUnarmedCoverMovementFirstPersonClipSetId(), SP_High);
			}
#endif // FPS_MODE_SUPPORTED
			CTaskCover::RequestCoverClipSet(ms_Tunables.GetStreamedUnarmedCoverMovementThirdPersonClipSetId(), SP_High);
		}
		else
		{
			CTaskCover::RequestCoverClipSet(ms_Tunables.GetStreamedUnarmedCoverMovementClipSetIdForPed(*pPed), SP_High);
		}
		fwMvClipSetId streamedClipsetId = GetWeaponHoldingExtraClipSetForArmament(*pPed);
		CTaskCover::RequestCoverClipSet(streamedClipsetId, SP_High);
	}

	// Stream upper body overlays for cover motion for the current weapon
	fwMvClipSetId weaponHoldingClipsetId = CTaskCover::GetWeaponHoldingClipSetForArmament(pPed);
	CTaskCover::RequestCoverClipSet(weaponHoldingClipsetId, SP_High);
	// Stream blindfire/moving out to fire anims for the current weapon
	fwMvClipSetId weaponAimingClipsetId = CTaskCover::GetWeaponClipSetForArmament(pPed, !pPed->IsAPlayerPed());
	CTaskCover::RequestCoverClipSet(weaponAimingClipsetId, SP_High);
	const CWeaponInfo* pCurrentWeaponInfo = pPed->GetCurrentWeaponInfoForHeldObject();
	if (pCurrentWeaponInfo)
	{
		fwMvClipSetId currentObjectWeaponAimingClipsetId = pCurrentWeaponInfo->GetPedCoverWeaponClipSetId(*pPed);
		if (currentObjectWeaponAimingClipsetId != weaponAimingClipsetId)
		{
			CTaskCover::RequestCoverClipSet(currentObjectWeaponAimingClipsetId, SP_High);
		}
		if (pPed->IsLocalPlayer())
		{
			fwMvClipSetId currentAppropriateObjectWeaponClipsetId = pCurrentWeaponInfo->GetAppropriateWeaponClipSetId(pPed);
			if (currentAppropriateObjectWeaponClipsetId != currentObjectWeaponAimingClipsetId)
			{
				CTaskCover::RequestCoverClipSet(currentAppropriateObjectWeaponClipsetId, SP_High);
			}
		}
	}
	// Stream base moving out to fire anims for the current weapon
	CTaskCover::RequestCoverClipSet(CTaskCover::ms_Tunables.GetCoreWeaponAimingThirdPersonClipSetId(), SP_High);
#if FPS_MODE_SUPPORTED
	if (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations && pPed->IsLocalPlayer())
	{
		CTaskCover::RequestCoverClipSet(CTaskCover::ms_Tunables.GetCoreWeaponAimingFirstPersonClipSetId(), SP_High);
	}
#endif // FPS_MODE_SUPPORTED

	if (!pPed->IsNetworkClone() && GetState() >= State_EnterCover && GetState() <= State_ExitCover && pPed->GetCoverPoint())
	{
		eHierarchyId eHierachyId = pPed->GetCoverPoint()->GetVehicleHierarchyId();
		if (eHierachyId != VEH_INVALID_ID)
		{
			if (pPed->GetCoverPoint()->m_pEntity && pPed->GetCoverPoint()->m_pEntity->GetIsTypeVehicle())
			{
				CVehicle* pVehicle = static_cast<CVehicle*>(pPed->GetCoverPoint()->m_pEntity.Get());
				CCarDoor* pDoor = pVehicle->GetDoorFromId(eHierachyId);
				if (pDoor)
				{
					m_eCoverVehicleDoorId = eHierachyId;
					m_pCoverVehicle = pVehicle;
					pDoor->SetFlag(CCarDoor::PED_USING_DOOR_FOR_COVER);
				}
			}
		}
	}

	if (GetState() == State_UseCover)
	{
		pPed->SetIsInCover(1);
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::UpdateFSM(const s32 iState, const FSM_Event iEvent)
{
	FSM_Begin

		FSM_State(State_Start)
			FSM_OnUpdate
				return Start_OnUpdate();

		FSM_State(State_Resume)
			FSM_OnUpdate
				return Resume_OnUpdate();

		FSM_State(State_ExitVehicle)
			FSM_OnEnter
				return ExitVehicle_OnEnter();
			FSM_OnUpdate
				return ExitVehicle_OnUpdate();

		FSM_State(State_SeekCover)
			FSM_OnEnter
				return SeekCover_OnEnter();
			FSM_OnUpdate
				return SeekCover_OnUpdate();

		FSM_State(State_MoveToCover)
			FSM_OnEnter
				return MoveToCover_OnEnter();
			FSM_OnUpdate
				return MoveToCover_OnUpdate();
			FSM_OnExit
				return MoveToCover_OnExit();

		FSM_State(State_MoveToSearchLocation)
			FSM_OnEnter
				return MoveToSearchLocation_OnEnter();
			FSM_OnUpdate
				return MoveToSearchLocation_OnUpdate();

		FSM_State(State_EnterCover)
			FSM_OnEnter
				return EnterCover_OnEnter();
			FSM_OnUpdate
				return EnterCover_OnUpdate();
				
		FSM_State(State_UseCover)
			FSM_OnEnter
				return UseCover_OnEnter();
			FSM_OnUpdate
				return UseCover_OnUpdate();
			FSM_OnExit
				return UseCover_OnExit();

		FSM_State(State_ExitCover)
			FSM_OnEnter
				return ExitCover_OnEnter();
			FSM_OnUpdate
				return ExitCover_OnUpdate();

		FSM_State(State_Finish)
			FSM_OnUpdate
				return FSM_Quit;

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::ProcessPostFSM()
{
	if (GetState() >= State_EnterCover && GetState() <= State_ExitCover)
	{
		bool bDisableTorsoReact = false;

		if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_IN_COVER)
		{
			if (GetSubTask()->GetState() == CTaskInCover::State_Aim)
			{
				bDisableTorsoReact = false;
			}
		}

		CPed& ped = *GetPed();

		if (bDisableTorsoReact)
		{
			ped.SetPedResetFlag(CPED_RESET_FLAG_DisableTorsoReactSolver, true);
		}
	}
	return FSM_Continue;
}

#if FPS_MODE_SUPPORTED
void CTaskCover::ProcessPreRender2()
{
	// Taken from CPed::ApplyBoneOverrides
	TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, ENABLE_BONE_ROTATION_OVERRIDE_WHEN_CLOSE_OR_IN_COVER, true);
	if (ENABLE_BONE_ROTATION_OVERRIDE_WHEN_CLOSE_OR_IN_COVER && !CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonLocoAnimations)
	{
		CPed& rPed = *GetPed();
		if (rPed.IsFirstPersonShooterModeEnabledForPlayer(false) && !rPed.GetPedResetFlag(CPED_RESET_FLAG_IsAimingFromCover))
		{
			bool bDoBoneOverride = true;

			const CTaskEnterCover* pEnterCoverTask = static_cast<const CTaskEnterCover*>(FindSubTaskOfType(CTaskTypes::TASK_ENTER_COVER));
			TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, DISTANCE_TO_COVER_TO_DO_BONE_OVERRIDE, 0.0f, 0.0f, 3.0f, 0.01f);
			Vector3 vCoverCoords;
			Vector3 vUnused;
			if (pEnterCoverTask &&CCover::FindCoverCoordinatesForPed(rPed, vUnused, vCoverCoords))
			{
				const Vector3 vPedPos = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
				const float fToCoverDistSqd = vPedPos.Dist2(vCoverCoords);
				if (fToCoverDistSqd < square(DISTANCE_TO_COVER_TO_DO_BONE_OVERRIDE))
				{
					bDoBoneOverride = false;
				}
			}

			const CTaskInCover* pInCoverTask = static_cast<const CTaskInCover*>(FindSubTaskOfType(CTaskTypes::TASK_IN_COVER));

			if (bDoBoneOverride)
			{
				crSkeleton* pSkel = rPed.GetSkeleton();
				if (pSkel && pInCoverTask && 
					(pInCoverTask->GetState() != CTaskInCover::State_AimIntro && pInCoverTask->GetState() !=  CTaskInCover::State_Aim
					&& pInCoverTask->GetState() != CTaskInCover::State_BlindFiring) )
				{
					pSkel->InverseUpdate();

					TUNE_GROUP_INT(FIRST_PERSON_COVER_TUNE, BONE_INDEX, 49, 0, rPed.GetSkeletonData().GetNumBones(), 1);	// SPINE_1
					TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, BLEND_TIME, 0.125f, 0.0f, 5.0f, 0.01f);
					TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MIN_OUTRO_TIME_TO_START_BLEND, 0.1f, 0.0f, 5.0f, 0.01f);
					float fTimeIdle = BLEND_TIME;
					float fBlend = 0.0f;
					if (pInCoverTask->GetState() == CTaskInCover::State_AimOutro)
					{
						taskAssert(MIN_OUTRO_TIME_TO_START_BLEND < BLEND_TIME);
						fBlend = Clamp((pInCoverTask->GetTimeInState() - MIN_OUTRO_TIME_TO_START_BLEND) / (BLEND_TIME - MIN_OUTRO_TIME_TO_START_BLEND), 0.0f, 1.0f);
					}
					else
					{
						fBlend = Clamp(fTimeIdle / BLEND_TIME, 0.0f, 1.0f);
					}
					
					Matrix34 localMatrix = MAT34V_TO_MATRIX34(pSkel->GetLocalMtx(BONE_INDEX));

					TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, OVERRIDE_ROTATION, false);
					if (OVERRIDE_ROTATION)
					{
						TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, ROTATION_OVERRIDE_X, -1.445f, -PI, PI, 0.01f);
						TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, ROTATION_OVERRIDE_Y, -0.880f, -PI, PI, 0.01f);
						TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, ROTATION_OVERRIDE_Z, 2.545f, -PI, PI, 0.01f);
						Vector3 vRotationOverride(ROTATION_OVERRIDE_X,ROTATION_OVERRIDE_Y,ROTATION_OVERRIDE_Z);
						TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, MAKE_HEADING_RELATIVE_TO_CAM_HEADING, false);
						TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, MAKE_ROTATION_RELATIVE_TO_CAM_PITCH, false);
						const camFirstPersonShooterCamera* pFPSCam = camInterface::GetGameplayDirector().GetFirstPersonShooterCamera();
						if (pFPSCam)
						{
							if (MAKE_HEADING_RELATIVE_TO_CAM_HEADING)
							{
								const Vector3 vPedFwd = VEC3V_TO_VECTOR3(rPed.GetTransform().GetB());
								const float fDelta = pFPSCam->GetBaseFront().AngleZ(vPedFwd);
								vRotationOverride.z = fwAngle::LimitRadianAngle(vRotationOverride.z - fDelta);	
							}
							if (MAKE_ROTATION_RELATIVE_TO_CAM_PITCH)
							{
								const Vector3 vPedSide = VEC3V_TO_VECTOR3(rPed.GetTransform().GetA());
								const float fDelta = pFPSCam->GetBaseFront().AngleZ(vPedSide);
								vRotationOverride.y = fwAngle::LimitRadianAngle(vRotationOverride.y - fDelta);	
							}
						}

						Matrix34 bind = MAT34V_TO_MATRIX34(rPed.GetSkeletonData().GetDefaultTransform(BONE_INDEX));	
						Matrix34 goal;
						goal.Identity();
						goal.FromEulersXYZ(vRotationOverride);
						goal.Dot(bind);

						// Set the bone local rotation to the bind + override
						RC_MATRIX34(pSkel->GetLocalMtx(BONE_INDEX)).Interpolate(localMatrix, goal, fBlend);
					}

					TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, OVERRIDE_TRANSLATION, true);
					if (OVERRIDE_TRANSLATION)
					{
						TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, TRANSLATION_OVERRIDE_X, -0.682f, -1.0f, 1.0f, 0.01f);
						TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, TRANSLATION_OVERRIDE_Y, 0.0f, -1.0f, 1.0f, 0.01f);
						TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, TRANSLATION_OVERRIDE_Z, 0.0f, -1.0f, 1.0f, 0.01f);

						Vector3 translation = Vector3(TRANSLATION_OVERRIDE_X, TRANSLATION_OVERRIDE_Y, TRANSLATION_OVERRIDE_Z);
						translation.Dot3x3(localMatrix);

						Vector3 bindTranslation = VEC3V_TO_VECTOR3(rPed.GetSkeletonData().GetDefaultTransform(BONE_INDEX).d());
						translation = bindTranslation + translation;

						Matrix34 source = RC_MATRIX34(pSkel->GetLocalMtx(BONE_INDEX));
						Matrix34 goal = RC_MATRIX34(pSkel->GetLocalMtx(BONE_INDEX));
						goal.d.Set(translation);

						// Set the bone local rotation to the override
						RC_MATRIX34(pSkel->GetLocalMtx(BONE_INDEX)).Interpolate(source, goal, fBlend);
					}

					pSkel->Update();
				}	
			}
		}
	}
}
#endif // FPS_MODE_SUPPORTED

////////////////////////////////////////////////////////////////////////////////

CTaskInfo* CTaskCover::CreateQueriableState() const
{
	const CWeaponTarget* pTarget = NULL;

	// only sync the target if this task is contained in a sequence and has no ped ptr. It is only required during construction of the task in a sequence.
	// Normally the target is synced via the gun task, when running on a ped and being synced via the current task data.
	if (!GetEntity())
	{
		pTarget = &m_CoverThreat;	
	}

	bool bLowCorner = false;

	const CPed* pPed = GetPed();
	if (pPed && pPed->GetCoverPoint())
	{
		bLowCorner = pPed->GetCoverPoint()->GetFlag(CCoverPoint::COVFLAGS_IsLowCorner);
	}

	const CVehicle* pVehicleStoodOn = NULL;
	if (pPed && pPed->GetGroundPhysical() && pPed->GetGroundPhysical()->GetIsTypeVehicle())
	{
		pVehicleStoodOn = static_cast<const CVehicle*>(pPed->GetGroundPhysical());
	}

	return rage_new CClonedCoverInfo(pTarget, GetPed(), GetState(), static_cast<u32>(m_CoverFlags), bLowCorner, static_cast<u32>(m_eInCoverTerminationReason), pVehicleStoodOn);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::ReadQueriableState(CClonedFSMTaskInfo* pTaskInfo)
{
	Assert( pTaskInfo->GetTaskInfoType() == CTaskInfo::INFO_TYPE_COVER_CLONED_FSM );
	CClonedCoverInfo *coverInfo = static_cast<CClonedCoverInfo*>(pTaskInfo);

	u32 coverFlags = (u32)m_CoverFlags.GetAllFlags();
	u32 remoteCoverFlags = coverInfo->GetFlags();
	u32 syncedFlagsMask = (CF_LastSyncedFlag<<1)-1;
		
	coverFlags &= ~syncedFlagsMask;

	if (m_CoverFlags.IsFlagSet(CF_FacingLeft))
	{
		coverFlags |= CF_FacingLeft;
	}

	// don't alter the facing left flag locally but set it as desired
	if (remoteCoverFlags & CF_FacingLeft)
	{
		coverFlags |= CF_DesiredFacingLeft;
		remoteCoverFlags &= ~CF_FacingLeft;
	}
	else
	{
		coverFlags &= ~CF_DesiredFacingLeft;
	}

	coverFlags |= remoteCoverFlags;

	m_CoverFlags.SetAllFlags((s32)coverFlags);

	m_bHasNetCoverPointInfo		 = coverInfo->HasCoverPoint();
	m_pVehicleStoodOn			 = coverInfo->GetVehicleStoodOn();
	m_vNetCoverPointPosition	 = coverInfo->GetCoverPosition();
	m_vNetCoverPointDirection	 = coverInfo->GetCoverDirection();
	m_iNetCoverPointUsage		 = coverInfo->GetCoverUsage();
	m_bHasVehicleStoodOn		= coverInfo->HasVehicleStoodOn();
	m_eInCoverTerminationReason  = static_cast<CTaskCover::eInCoverTerminationReason>(coverInfo->GetTerminationReason());

	CTaskFSMClone::ReadQueriableState(pTaskInfo);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::SetIsMigrating(bool const isMigrating)
{
	CTaskFSMClone::SetIsMigrating(isMigrating);
}


//////////////////////////////////////////////////////////////////////////
bool CTaskCover::CheckForMovingCover(CPed* pPed)
{
	if (pPed->IsNetworkClone())
	{
		return false;
	}

	CCoverPoint* pCoverPoint = pPed->GetCoverPoint();
	if (!pCoverPoint)
		return true;

	if (pCoverPoint->GetEntity() && pCoverPoint->GetEntity() != pPed->GetGroundPhysical())
	{
		phCollider* pCol = pCoverPoint->GetEntity()->GetCollider();
		if (pCol)
		{
			static dev_float sf_MinAcceptableSpeedUnoccupiedVehicle = 2.0f;
			static dev_float sf_MinAcceptableSpeedVehicleSlowingDown = 2.0f;
			static dev_float sf_MinAcceptableSpeedObject = 0.75f;
			static dev_float sf_MinAcceptableSpeed = 0.25f;			

			// We can end up moving the vehicle ourself when entering cover against it, so increase the acceptable speed if no one is driving it
			float fMinAcceptableSpeed = sf_MinAcceptableSpeed;
			Vec3V vel = pCol->GetVelocity();
			float fSpeed = Mag(vel).Getf();
			if (pCoverPoint->GetEntity()->GetIsTypeVehicle())
			{
				// If we're stood on the vehicle and it's moving, we want to test the relative velocity
				const CVehicle* pVeh = static_cast<const CVehicle*>(pCoverPoint->GetEntity());
				if (NetworkInterface::IsGameInProgress())
				{
					const Vector3 vRelVehVel = pVeh->GetRelativeVelocity(*pPed);
					fSpeed = vRelVehVel.Mag();
				}

				if (!pVeh->GetSeatManager()->GetDriver())
				{
					fMinAcceptableSpeed = sf_MinAcceptableSpeedUnoccupiedVehicle;
				}

				//check for vehicles slowing down which are ok
				static dev_float sf_MinAcceptableVelocityDelta = 0.1f;
				if (fSpeed <= sf_MinAcceptableSpeedVehicleSlowingDown)
				{
					if (m_fLastFramesCoverSpeed < 0)
					{
						m_fLastFramesCoverSpeed = fSpeed;
						return false;
					} 
					else if ((fSpeed - m_fLastFramesCoverSpeed) <= sf_MinAcceptableVelocityDelta)		
					{
						m_fLastFramesCoverSpeed = fSpeed;
						return false;
					}
				}
			}
			else  //object
			{
				fMinAcceptableSpeed = sf_MinAcceptableSpeedObject;
			}
			if (fSpeed > fMinAcceptableSpeed)
			{
				aiDisplayf("Frame : %i, Ped %s (%p) aborted cover due to cover entity (%s) moving too fast (%.2f / %.2f)", fwTimer::GetFrameCount(), pPed->GetModelName(), pPed, pCoverPoint->GetEntity()->GetModelName(), Mag(vel).Getf(), fMinAcceptableSpeed);
				return true;
			}
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::UpdateClonedSubTasks(CPed* pPed, int const iState)
{
	if(!GetSubTask() && !GetNewTask())
	{
		// these are the only states that can shoot guns in TaskCover (via m_pSubTaskWhilstSearching & CTaskComplexControlMovement) so we test against them
		// This stops a clone getting ahead of an owner and trying to fire before the owner has....
		if((State_SeekCover == iState) || (State_MoveToCover == iState) || (State_MoveToSearchLocation == iState))
		{
			// When moving to cover we can climb up and down ladders too...
			if(State_MoveToCover == iState)
			{
				if(CreateSubTaskFromClone(pPed, CTaskTypes::TASK_CLIMB_LADDER))
				{
					return;
				}
			}
		
			// do we have another subtask running? We can't replace it with a gun task as it 
			// wipes the existing task - the existing subtask needs to deal with the gun request.

			CreateSubTaskFromClone(pPed, CTaskTypes::TASK_GUN);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

CTaskCover::FSM_Return CTaskCover::UpdateClonedFSM(const s32 iState, const FSM_Event iEvent)
{
	CPed* pPed = GetPed();

	if (iState < 0 || iState > State_Finish)
	{
		aiDisplayf("%s is running the cover task with an invalid state %d (state from network: %d)", pPed->GetNetworkObject() ? pPed->GetNetworkObject()->GetLogName() : "??", iState, GetStateFromNetwork());
	}

	// update the player's target
	if (pPed && pPed->IsPlayer() && static_cast<CNetObjPlayer*>(pPed->GetNetworkObject())->HasValidTarget())
	{
		GetTarget().SetPosition(pPed->GetWeaponManager()->GetWeaponAimPosition());
	}

	// if the state change is not handled by the clone FSM block below
	// we need to keep the state in sync with the values received from the network
	if(iState != State_Finish)
	{
		if(iEvent == OnUpdate)
		{
			if(GetState() != GetStateFromNetwork())
			{
				if(!StateChangeHandledByCloneFSM(iState))
				{
					BANK_ONLY(taskDebugf2("Frame : %u - %s%s : %p : changed state from %s:%s:%p to %s", fwTimer::GetFrameCount(), GetPed()->IsNetworkClone() ? "Clone ped : " : "Local ped : ", GetPed()->GetDebugName(), GetPed(), GetTaskName(), GetStateName(GetState()), this, GetStateName(GetStateFromNetwork())));
					SetState(GetStateFromNetwork());
					return FSM_Continue;
				}
			}

			Assert(GetState() == iState);
			UpdateClonedSubTasks(pPed, GetState());
		}
	}

	FSM_Begin

		FSM_State(State_Start)
			FSM_OnUpdate
				return Start_OnUpdateClone();

		FSM_State(State_ExitVehicle)
			FSM_OnUpdate
				return ExitVehicle_OnUpdateClone();

        FSM_State(State_MoveToCover)
			FSM_OnUpdate
				return MoveToCover_OnUpdateClone();

		FSM_State(State_EnterCover)
			FSM_OnEnter
				return EnterCover_OnEnterClone();
			FSM_OnUpdate
				return EnterCover_OnUpdateClone();

		FSM_State(State_UseCover)
			FSM_OnUpdate
				return UseCover_OnUpdateClone();
			FSM_OnExit
				return UseCover_OnExit();

		FSM_State(State_ExitCover)
			FSM_OnEnter
				return ExitCover_OnEnter();
			FSM_OnUpdate
				return ExitCover_OnUpdate();

		FSM_State(State_Finish)
			FSM_OnUpdate
				return FSM_Quit;

		// unhandled states
		FSM_State(State_Resume)
		FSM_State(State_SeekCover)
		FSM_State(State_MoveToSearchLocation)

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::OnCloneTaskNoLongerRunningOnOwner()
{
	SetStateFromNetwork(State_Finish);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::OverridesNetworkBlender(CPed* pPed) 
{ 
	s32 state = GetState();

	if (state == State_Start || state == State_EnterCover || (state == State_UseCover && !GetSubTask() && !pPed->IsBaseFlagSet(fwEntity::IS_FIXED)))
	{
		return true;
	}

	return false; 
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::ControlPassingAllowed(CPed *UNUSED_PARAM(pPed), const netPlayer& UNUSED_PARAM(player), eMigrationType UNUSED_PARAM(migrationType))
{
	return ((GetState() != State_EnterCover) && (GetState() != State_ExitCover));
}

////////////////////////////////////////////////////////////////////////////////

CTaskFSMClone*	CTaskCover::CreateTaskForClonePed(CPed* UNUSED_PARAM(pPed))
{
	CTaskCover *newTask = rage_new CTaskCover(GetTarget(), m_CoverFlags);

	return newTask;
}

////////////////////////////////////////////////////////////////////////////////

CTaskFSMClone*	CTaskCover::CreateTaskForLocalPed(CPed* pPed)
{
	return CreateTaskForClonePed(pPed);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::LeaveScope(const CPed* pPed)
{
	// if we are running an enter cover subtask, force it to quit as it may get stuck when the task comes back into scope again 
	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_ENTER_COVER)
	{
		((CTaskEnterCover*)GetSubTask())->ForceCloneQuit();
	}

	CTaskFSMClone::LeaveScope(pPed);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsInScope(const CPed* pPed)
{
	Assert(pPed->IsNetworkClone());

	if(pPed->IsPlayer())
	{
		// If a clone player has a vehicle they're stood on, but that vehicle doesn't exist, don't process their tasks
		if (m_bHasVehicleStoodOn && !m_pVehicleStoodOn)
		{
			return false;
		}
	}
	else
	{
		return CTaskFSMClone::IsInScope(pPed);
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::StateChangeHandledByCloneFSM(s32 iState)
{
	switch(iState)
	{
	case State_Start:
	case State_ExitVehicle:
	case State_EnterCover:
	case State_UseCover:
	case State_ExitCover:
		return true;
	default:
		return false;
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::OnGunAimedAt(const CEventGunAimedAt& rEvent)
{
	//Check if the sub-task is valid.
	CTask* pSubTask = GetSubTask();
	if(pSubTask)
	{
		//Check if the sub-task is in cover.
		if(pSubTask->GetTaskType() == CTaskTypes::TASK_IN_COVER)
		{
			//Send the event to the sub-task.
			CTaskInCover* pTask = static_cast<CTaskInCover *>(pSubTask);
			pTask->OnGunAimedAt(rEvent);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::Start_OnUpdate()
{
	CPed* pPed = GetPed();

	// Seems like script can try to put peds into cover when they're in a vehicle
	// don't allow this! Can't put assert in script command in case its as part of a sequence
	if (pPed->GetIsInVehicle())
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	// Check if we were supposed to move to desired cover and reset the flag if we don't have desired cover
	if(m_SeekCoverFlags.IsFlagSet(CF_MoveToPedsCover))
	{
		if(!taskVerifyf(pPed->GetCoverPoint(), "Task was told to move to ped's cover but the ped does not have a cover point"))
		{
			m_SeekCoverFlags.ClearFlag(CF_MoveToPedsCover);
		}
	}

	if (m_eForcedExit != FE_None)
	{
		if (!scriptVerifyf(pPed->GetCoverPoint(), "Ped %s doesn't have a valid cover point", pPed->GetDebugName()))
		{	
			SetState(State_Finish);
			return FSM_Continue;
		}

		if (!scriptVerifyf(m_eForcedExit != FE_Aim || 
			(pPed->GetWeaponManager()->GetEquippedWeaponInfo() && pPed->GetWeaponManager()->GetEquippedWeaponInfo()->GetIsGunOrCanBeFiredLikeGun()),
			"Ped trying to use forced aim exit without an equipped weapon"))
		{
			SetState(State_Finish);
			return FSM_Continue;
		}

		if (pPed->GetMotionData()->GetFacingLeftInCover())
		{
			m_CoverFlags.SetFlag(CTaskCover::CF_FacingLeft);
		}

		TUNE_GROUP_FLOAT(COVER_TUNE, SCRIPT_EXIT_COVER_BLEND_IN_DURATION, NORMAL_BLEND_DURATION, INSTANT_BLEND_DURATION, 2.0f, 0.01f);
		m_fBlendInDuration = SCRIPT_EXIT_COVER_BLEND_IN_DURATION;
		SetState(State_UseCover);
		return FSM_Continue;
	}

	// If the local player is flagged to be put directly into cover,
	// Quit the task, force a post cam ai-clip update
	// This will allow the TaskPlayerOnFoot task to be run as the top most task
	bool bAIPedOrLocalPlayerNotRunningPlayerOnFoot = !pPed->IsLocalPlayer() || !GetParent() || GetParent()->GetTaskType() != CTaskTypes::TASK_PLAYER_ON_FOOT;
	if (m_CoverFlags.IsFlagSet(CF_PutPedDirectlyIntoCover))
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_ForcePostCameraAIUpdate, true);
		pPed->SetPedResetFlag(CPED_RESET_FLAG_ForcePostCameraAnimUpdate, true);

		if (!m_SeekCoverFlags.IsFlagSet(CF_CoverSearchScripted))
		{
			if (bAIPedOrLocalPlayerNotRunningPlayerOnFoot && !pPed->GetCoverPoint())
			{
				m_SeekCoverFlags.SetFlag(CF_FindClosestPointAtStart);
			}

			if (!m_SeekCoverFlags.IsFlagSet(CF_FindClosestPointAtStart) && taskVerifyf(pPed->GetCoverPoint(), "Expected a valid cover point"))
			{
				SetState(State_UseCover);
				return FSM_Continue;
			}
		}
	}

	bool bSeekCover = m_SeekCoverFlags.IsFlagSet(CF_SeekCover);

	if (bSeekCover && m_SeekCoverFlags.IsFlagSet(CF_CoverSearchScripted))
	{
		CCoverPoint* pCoverPoint = CCover::FindCoverPointWithIndex(m_iScriptedCoverIndex);
		if (pCoverPoint)
		{
			CPed* pCoverPointPed = pCoverPoint->GetOccupiedBy();
			if (pCoverPointPed)
			{
				if (pCoverPointPed != pPed)
				{
					aiWarningf("Scripted cover point w/ index %d is already occupied!", m_iScriptedCoverIndex);
					SetState(State_Finish);
					return FSM_Continue;
				}
			}
			else
			{
				pPed->SetCoverPoint(pCoverPoint);
				pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
			}

			AI_LOG_WITH_ARGS_IF_SCRIPT_PED(pPed, "[Cover] Script ped %s found scripted cover at (%.2f,%.2f,%.2f)\n", AILogging::GetDynamicEntityNameSafe(pPed), VEC3V_ARGS(pCoverPoint->GetCoverPointPosition()));
			bSeekCover = false;
		}
		else
		{
			aiWarningf("Scripted cover point w/ index %d could not be found!", m_iScriptedCoverIndex);
			SetState(State_Finish);
			return FSM_Continue;
		}
	}

	const float fMaxDistanceToDirectlyEnterCover = pPed->IsAPlayerPed() ? CTaskEnterCover::ms_Tunables.m_CoverEntryMaxDistance : CTaskEnterCover::ms_Tunables.m_CoverEntryMaxDistanceAI;

	// If flagged to find the closest cover point at the start do so, if we don't find a valid point, quit
	if (m_SeekCoverFlags.IsFlagSet(CF_FindClosestPointAtStart) || (m_CoverFlags.IsFlagSet(CF_PutPedDirectlyIntoCover) && m_SeekCoverFlags.IsFlagSet(CF_CoverSearchScripted)))
	{
		CCoverPoint* pCoverPoint = m_SeekCoverFlags.IsFlagSet(CF_FindClosestPointAtStart) ? 
			CCover::FindClosestCoverPointWithCB(pPed, m_vSearchPosition, fMaxDistanceToDirectlyEnterCover, NULL, CCover::CS_ANY, NULL, NULL, NULL) 
			: CCover::FindCoverPointWithIndex(m_iScriptedCoverIndex);
		
		if (!pCoverPoint)
		{
			aiWarningf("Couldn't find a scripted cover point or valid cover point within 5m, check there are coverpoints in the search area and are streamed in");
			SetState(State_Finish);
			return FSM_Continue;
		}

		Vector3 vCoverPosition(Vector3::ZeroType);
		if (!pCoverPoint->GetCoverPointPosition(vCoverPosition))
		{
			aiWarningf("Couldn't find cover points position");
			SetState(State_Finish);
			return FSM_Continue;
		}

		AI_LOG_WITH_ARGS_IF_SCRIPT_PED(pPed, "[Cover] Script ped %s found %s cover at (%.2f,%.2f,%.2f)\n", AILogging::GetDynamicEntityNameSafe(pPed), m_SeekCoverFlags.IsFlagSet(CF_FindClosestPointAtStart) ? "FindClosest" : "FindScripted", VEC3V_ARGS(pCoverPoint->GetCoverPointPosition()));

		if (m_CoverFlags.IsFlagSet(CF_WarpPedToCoverPosition))
		{
			const Vector3 vPlayerCoverPosition = Vector3(vCoverPosition.x, vCoverPosition.y, vCoverPosition.z + pPed->GetCapsuleInfo()->GetGroundToRootOffset());
			const float fPlayerCoverHeading = GetDesiredHeadingForPedWithCoverPoint(pPed, pCoverPoint);
			pPed->Teleport(vPlayerCoverPosition, fPlayerCoverHeading, true, false, true);
		}

		if (m_CoverFlags.IsFlagSet(CF_SkipIdleCoverTransition) && !m_CoverFlags.IsFlagSet(CF_WarpPedToCoverPosition))
		{
			// If we're too far from the cover point to directly enter, then enter normally
			if (vCoverPosition.Dist(VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition())) > CTaskEnterCover::ms_Tunables.m_CoverEntryMaxDirectDistance)
			{
				m_CoverFlags.ClearFlag(CF_SkipIdleCoverTransition);
			}
		}

		// Set and reserve the cover point on the ped
		if (pPed->IsLocalPlayer())
		{
			pPed->GetPlayerInfo()->GetDynamicCoverPoint()->Copy(*pCoverPoint);
			pPed->SetCoverPoint(pPed->GetPlayerInfo()->GetDynamicCoverPoint());
			pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
			// Record the cover entity in the players dynamic cover helper for audio
			CPlayerInfo::ms_DynamicCoverHelper.SetCoverEntryEntity(pCoverPoint->m_pEntity);
		}
		else
		{
			pPed->SetCoverPoint(pCoverPoint);
			pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
		}

		if (pPed->IsLocalPlayer() && bAIPedOrLocalPlayerNotRunningPlayerOnFoot)
		{
			if (IsCoverFlagSet(CTaskCover::CF_SkipIdleCoverTransition))
			{
				pPed->SetPlayerResetFlag(CPlayerResetFlags::PRF_SKIP_COVER_ENTRY_ANIM);
			}
			pPed->SetPlayerResetFlag(CPlayerResetFlags::PRF_FORCE_PLAYER_INTO_COVER);
			if (IsCoverFlagSet(CTaskCover::CF_SpecifyInitialHeading))
			{
				pPed->SetPlayerResetFlag(CPlayerResetFlags::PRF_SPECIFY_INITIAL_COVER_HEADING);
				// If this task has been given and processed as part of the post cam (post script update)
				// the below flag will get reset and we'll always end up facing right, since this only affects the player, we set the player specific
				// flag which only ever gets reset when the use cover task starts up (may need to reset this elsewhere also?)
				if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
				{
					pPed->SetPlayerResetFlag(CPlayerResetFlags::PRF_FACING_LEFT_IN_COVER);
				}
				pPed->SetPedResetFlag(CPED_RESET_FLAG_InCoverFacingLeft, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
			}
			pPed->GetPlayerInfo()->m_fPutPedDirectlyIntoCoverNetworkBlendInDuration = m_fBlendInDuration;
			CTaskPlayerOnFoot* pPlayerTask = rage_new CTaskPlayerOnFoot();
			pPlayerTask->SetScriptedToGoIntoCover(true);
			pPed->GetPedIntelligence()->AddTaskDefault(pPlayerTask);
			pPed->SetPedResetFlag(CPED_RESET_FLAG_KeepCoverPoint, true);
			SetFlag(aiTaskFlags::ProcessNextActiveTaskImmediately);
			SetState(State_Finish);
			return FSM_Continue;
		}
	}
#if __DEV
	else if (!bSeekCover && pPed->IsLocalPlayer() && !pPed->GetCoverPoint())
	{
		taskWarningf("Frame: %i, Expected player to have a valid coverpoint", fwTimer::GetFrameCount());
	}
#endif // __DEV

	// Cache the ped position for later use
	const Vector3 vPedPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	Vector3 vThreatPosition(Vector3::ZeroType);

	// If we didn't set a valid cover threat, create a fake one
	if (!GetTarget().GetIsValid())
	{
		if (pPed->IsLocalPlayer())
		{
			Vector3 vDir = VEC3V_TO_VECTOR3(pPed->GetTransform().GetB());
			vThreatPosition = vPedPosition + (vDir * 10.0f);
		}
		else if (pPed->GetCoverPoint())
		{
			pPed->GetCoverPoint()->GetCoverPointPosition(vThreatPosition);
			Vector3 b = VEC3V_TO_VECTOR3(pPed->GetTransform().GetB());
			vThreatPosition += VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector(&RCC_VEC3V(b))) * (CTaskInCover::ms_Tunables.m_MinDistanceToTargetForPeek + 1.0f);
		}
		else if (NetworkInterface::IsGameInProgress())
		{
#if __ASSERT
			aiDisplayf("Frame %i, Ped %s quit cover task because no cover point", fwTimer::GetFrameCount(), pPed->GetDebugName());
#endif // __ASSERT
			return FSM_Quit;
		}
		taskAssertf(!vThreatPosition.IsClose(VEC3_ZERO, SMALL_FLOAT), "Threat position hasn't been initialised");
		m_CoverThreat.SetPosition(vThreatPosition);
	}
	else
	{
		GetTarget().GetPosition(vThreatPosition);
	}

	// Quit if we couldn't find the cover position
	if (m_SeekCoverFlags.IsFlagSet(CF_FindClosestPointAtStart))
	{
		// If we're an ai ped and we have no cover or the cover is invalid, quit
		CCoverPoint* pCoverPoint = pPed->GetCoverPoint();
		if (!pPed->IsAPlayerPed() && pCoverPoint)
		{
			const CEntity* pTargetEntity = GetTarget().GetEntity();
			if(!CCover::DoesCoverPointProvideCoverFromTargets(pPed, vThreatPosition, pCoverPoint, pCoverPoint->GetArcToUse(*pPed, pTargetEntity), pTargetEntity))
			{
				SetState(State_Finish);
				return FSM_Continue;
			}
			AI_LOG_WITH_ARGS_IF_SCRIPT_PED(pPed, "[Cover] Script ped %s found closest cover at (%.2f,%.2f,%.2f)\n", AILogging::GetDynamicEntityNameSafe(pPed), VEC3V_ARGS(pCoverPoint->GetCoverPointPosition()));
		}
	}

	// If not seeking cover and we have no cover, then quit
	if (!bSeekCover && !pPed->GetCoverPoint())
	{
		SetState(State_Finish);
		return FSM_Continue;
	}
	
	// Find the cover coords
	if (!bSeekCover && m_CoverThreat.GetIsValid() && taskVerifyf(m_CoverThreat.GetPosition(vThreatPosition), "Couldn't find threat position"))
	{
		Vector3 vVantagePosition(Vector3::ZeroType);
		if (!GetCoverPointPosition(vThreatPosition, pPed, m_vCoverCoors, vVantagePosition))
		{
			SetState(State_Finish);
			return FSM_Continue;
		}
	}

	// Store the crouch state
	m_CoverFlags.ChangeFlag(CF_CrouchingAtStart, pPed->GetIsCrouching());

#if __BANK
	if (!bSeekCover && pPed->GetCoverPoint())
		AI_LOG_WITH_ARGS_IF_SCRIPT_PED(pPed, "[Cover] Script ped %s going to cover at (%.2f,%.2f,%.2f)\n", AILogging::GetDynamicEntityNameSafe(pPed), VEC3V_ARGS(pPed->GetCoverPoint()->GetCoverPointPosition()));
#endif // __BANK

	// Seek cover if specified to, otherwise use our cover
	if (bSeekCover || m_SeekCoverFlags.IsFlagSet(CF_MoveToPedsCover))
	{
		if (pPed->GetIsInVehicle())
		{
			SetState(State_ExitVehicle);
			return FSM_Continue;
		}
		else
		{
			if(m_SeekCoverFlags.IsFlagSet(CF_MoveToPedsCover))
			{
				SetState(State_MoveToCover);
			}
			else
			{
				SetState(State_SeekCover);
			}
			return FSM_Continue;
		}
	}
	else
	{
		if (!m_CoverFlags.IsFlagSet(CF_SpecifyInitialHeading))
		{
			//Vector3 vCoverDir = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector());
			if (m_CoverFlags.IsFlagSet(CF_SkipIdleCoverTransition))
			{
				const bool bShouldFaceLeft = pPed->GetCoverPoint()->PedClosestToFacingLeft(*pPed);
				//aiDisplayf("Frame: %i, %s Ped %s %p Deciding Facing Direction, Face Left ? %s", fwTimer::GetFrameCount(), GetPed()->IsLocalPlayer() ? "LOCAL PLAYER" : "AI PED", GetPed()->GetModelName(), GetPed(), bShouldFaceLeft ? "TRUE" : "FALSE");
				m_CoverFlags.ChangeFlag(CF_FacingLeft, bShouldFaceLeft);
			}
			else
			{
				// Need to set the cover direction when putting peds directly into cover as they don't move to cover
				bool bUnused;
				ComputeFacingDirection(vThreatPosition, bUnused, false);
			}
		}

		if (pPed->GetCoverPoint()->GetHeight() == CCoverPoint::COVHEIGHT_TOOHIGH)
		{
			m_CoverFlags.SetFlag(CTaskCover::CF_TooHighCoverPoint);
		}

		if (!m_CoverFlags.IsFlagSet(CF_SpecifyInitialHeading) && !m_CoverFlags.IsFlagSet(CF_SkipIdleCoverTransition) && pPed->IsLocalPlayer())
		{
			Vector3 vCoverDir = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector());
			bool bApproachFromRight = false;
			const float fDistToCoverSqd = m_vCoverCoors.Dist2(VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()));
			if (fDistToCoverSqd > CTaskEnterCover::ms_Tunables.m_CoverEntryMinDistance*CTaskEnterCover::ms_Tunables.m_CoverEntryMinDistance)
			{
				CTaskEnterCover::ComputeApproachDirectionForPed(pPed, vCoverDir, m_vCoverCoors, bApproachFromRight);
				// When approaching from the left or right we face the opposite direction for non corner cover
				if (pPed->GetCoverPoint()->GetUsage() != CCoverPoint::COVUSE_WALLTOLEFT && pPed->GetCoverPoint()->GetUsage() != CCoverPoint::COVUSE_WALLTORIGHT)
				{
					m_CoverFlags.ChangeFlag(CTaskCover::CF_FacingLeft, bApproachFromRight);
				}
			}
			else
			{
				bool bFaceLeft = false;
				if (!CTaskEnterCover::GetFacingDirectionIfEdgeCover(*pPed->GetCoverPoint(), bFaceLeft))
				{
					CTaskEnterCover::ComputeCloseFacingDirectionForPed(pPed, vCoverDir, bFaceLeft);
				}
				m_CoverFlags.ChangeFlag(CTaskCover::CF_FacingLeft, bFaceLeft);
			}

			m_CoverFlags.ChangeFlag(CTaskCover::CF_EnterLeft, !bApproachFromRight);
		}

		const float fDistance = ( m_vCoverCoors - vPedPosition ).XYMag();

		// If specified to skip the enter cover clips go straight into the in cover task
		if (m_CoverFlags.IsFlagSet(CF_SkipIdleCoverTransition))
		{
			pPed->ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);
			SetState(State_UseCover);
			return FSM_Continue;
		}
		else
		{
			bool bPlayerControlledEntry = false;
			if (pPed->IsLocalPlayer())
			{
				if (pPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_PLAYER_ON_FOOT))
				{
					bPlayerControlledEntry = true;
				}
			}

			bool bMoveToCover = false;

			// If we're close enough, go into cover if the path is clear, otherwise move to cover
			if (bPlayerControlledEntry || fDistance < fMaxDistanceToDirectlyEnterCover)
			{
				m_SeekCoverFlags.ClearFlag(CF_FindClosestPointAtStart);

				bool bWeaponUsableInCover = pPed->GetWeaponManager() ? pPed->GetWeaponManager()->IsEquippedWeaponUsableInCover() : false;

				if (bPlayerControlledEntry || bWeaponUsableInCover)
				{
					Vector3 vCapsuleZOffset(0.0f, 0.0f, ms_Tunables.m_CapsuleZOffset);
					if (bPlayerControlledEntry || IsPathClearForPed(*pPed, vPedPosition, m_vCoverCoors, vCapsuleZOffset, ArchetypeFlags::GTA_ALL_TYPES_MOVER))
					{
						SetState(State_EnterCover);
						return FSM_Continue;
					}
					else
					{
						bMoveToCover = true;
					}
				}
				else
				{
					if (m_SeekCoverFlags.IsFlagSet(CTaskCover::CF_ScriptedSeekCover))
					{
						bMoveToCover = true;
					}
					else
					{
						SetState(State_Finish);
						return FSM_Continue;
					}
				}
			}
			else
			{
				bMoveToCover = true;
			}
			
			if (bMoveToCover)
			{
				SetState(State_MoveToCover);
				return FSM_Continue;
			}
		}
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::Start_OnUpdateClone()
{
	s32 iNetworkState = GetStateFromNetwork();

	if (iNetworkState == State_EnterCover)
	{
		Vector3 coverPos(VEC3_ZERO);

		// we need to wait for the cover point position before proceeding
		if (!GetNetCoverPointPosition(*GetPed(), coverPos))
		{
			return FSM_Continue;
		}
	}

	if (iNetworkState != -1 && GetState() != iNetworkState)
	{
		SetState(iNetworkState);
		return FSM_Continue;
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::Resume_OnUpdate()
{
	//Keep the sub-task across the transition.
	SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);

	//Set the state to resume to.
	int iStateToResumeTo = ChooseStateToResumeTo();
	SetState(iStateToResumeTo);

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::ExitVehicle_OnEnter()
{
	SetNewTask(rage_new CTaskLeaveAnyCar());
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::ExitVehicle_OnUpdate()
{
	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished))
	{
		if(m_SeekCoverFlags.IsFlagSet(CF_MoveToPedsCover))
		{
			SetState(State_MoveToCover);
		}
		else
		{
			SetState(State_SeekCover);
		}
	}

	return FSM_Continue;
}


////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::ExitVehicle_OnUpdateClone()
{
	CPed* pPed = GetPed();

	if(GetStateFromNetwork() == State_ExitVehicle)
	{
		if (!GetSubTask() && pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_InVehicle))
		{
			CTaskInfo *taskInfo = pPed->GetPedIntelligence()->GetQueriableInterface()->GetTaskInfoForTaskType(CTaskTypes::TASK_EXIT_VEHICLE, PED_TASK_PRIORITY_MAX);

			if(taskInfo)
			{
				CTask *exitVehicleTask = pPed->GetPedIntelligence()->CreateCloneTaskFromInfo(taskInfo);

				if(exitVehicleTask)
				{
					SetNewTask(exitVehicleTask);
				}
			}
		}
	}
	else
	{
		if (GetSubTask())
		{
			if (GetIsFlagSet(aiTaskFlags::SubTaskFinished))
			{
				SetState(GetStateFromNetwork());
			}
		}
		else
		{
			if (pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_InVehicle))
			{
				pPed->SetPedOutOfVehicle(CPed::PVF_Warp);
			}

			SetState(GetStateFromNetwork());		
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::SeekCover_OnEnter()
{
	// Quit out if we tried to seek cover but don't have a cover finder
	if(!m_pCoverFinder)
	{
		m_pCoverFinder = GetPed()->GetPedIntelligence()->GetCoverFinder();
		if(!m_pCoverFinder)
		{
			return FSM_Quit;
		}
	}

	if (taskVerifyf(GetTarget().GetIsValid(), "Target isn't valid"))
	{
		Vector3 vThreatPosition(Vector3::ZeroType);
		if (GetTarget().GetPosition(vThreatPosition))
		{
			bool bStartCoverSearch = true;
			s32 iSearchMode = CCoverFinderFSM::COVER_SEARCH_ANY;
			
			if (m_SeekCoverFlags.IsFlagSet(CF_CoverSearchByPos))
			{
				iSearchMode = CCoverFinderFSM::COVER_SEARCH_BY_POS;
			}
			else if (!m_SeekCoverFlags.IsFlagSet(CF_CoverSearchAny) && !m_SeekCoverFlags.IsFlagSet(CF_CoverSearchScripted))
			{
				bStartCoverSearch = false;
				taskAssertf(0, "Seek cover type flag not set");
			}

			if(bStartCoverSearch && taskVerifyf(m_pCoverFinder, "NULL Cover Finder Pointer"))
			{
				const CEntity* pTargetEntity = GetTarget().GetEntity();
				const CPed* pTargetPed = (pTargetEntity && pTargetEntity->GetIsTypePed()) ? static_cast<const CPed*>(pTargetEntity) : NULL;

				// If we should start then we need to setup the rest of the params that are required then enable the cover finder
				m_pCoverFinder->SetupSearchParams(pTargetPed, vThreatPosition, m_vSearchPosition, m_SeekCoverFlags.GetAllFlags(), m_fSearchDistanceMin, 
												m_fSearchDistanceMax, m_iSearchType, iSearchMode, m_iScriptedCoverIndex, m_pCoverPointFilterConstructFn);
				m_pCoverFinder->StartSearch(GetPed());

				// Run our subtask if we were told we should and we have one
				if(m_pSubTaskWhilstSearching && m_SeekCoverFlags.IsFlagSet(CTaskCover::CF_RunSubtaskWhenStationary))
				{
					aiTask* pTask = m_pSubTaskWhilstSearching->Copy();

					// If we are seeking cover while in combat we shouldn't just be standing there, make sure we are attacking without subtask
					if(pTask && pTask->GetTaskType() == CTaskTypes::TASK_ADDITIONAL_COMBAT_TASK)
					{
						static_cast<CTaskCombatAdditionalTask*>(pTask)->SetFlags(CTaskCombatAdditionalTask::RT_Default);
					}

					SetNewTask(pTask);
				}
			}
		}
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::SeekCover_OnUpdate()
{
	CPed* pPed = GetPed();

	// Make sure to keep any desired cover point
	pPed->SetPedResetFlag( CPED_RESET_FLAG_KeepDesiredCoverPoint, true );

	// If we don't have a cover finder then we need to quit like we would have in the on enter
	if (!m_pCoverFinder)
	{
		aiWarningf("NULL Cover Finder Pointer");
		return FSM_Quit;
	}

	// If the cover finder is no longer active it means it never started or has finished
	if (!m_pCoverFinder->IsActive())
	{
		CCoverPoint* pDesiredCover = pPed->GetDesiredCoverPoint();
		if (!pDesiredCover || !pDesiredCover->CanAccomodateAnotherPed() || pDesiredCover->IsDangerous() || pDesiredCover->IsCloseToPlayer(*pPed))
		{
			if (m_SeekCoverFlags.IsFlagSet(CF_DontMoveIfNoCoverFound) || m_vSearchPosition.IsClose(VEC3_ZERO, SMALL_FLOAT) || IsAtSearchPosition())
			{
				SetState(State_Finish);
				return FSM_Continue;
			}
			else
			{
				SetState(State_MoveToSearchLocation);
				return FSM_Continue;
			}
		}
		else
		{
			// Set our cover point to what we found and unset the desired.
			pPed->SetCoverPoint(pDesiredCover);
			pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
			pPed->SetDesiredCoverPoint(NULL);

			if (pPed->GetCoverPoint()->GetHeight() == CCoverPoint::COVHEIGHT_TOOHIGH)
			{
				m_CoverFlags.SetFlag(CTaskCover::CF_TooHighCoverPoint);
			}

			Vector3 vThreatPosition(Vector3::ZeroType);
			if (CTaskEnterCover::ShouldPedUseAiEntryAnims(*pPed) && GetTarget().GetPosition(vThreatPosition))
			{
				Vector3 vVantagePosition(Vector3::ZeroType);
				if (GetCoverPointPosition(vThreatPosition, pPed, m_vCoverCoors, vVantagePosition))
				{
					Vector3 vPedPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
					const float fDistance = ( m_vCoverCoors - vPedPosition ).XYMag();
					const float fMaxDistanceToDirectlyEnterCover = pPed->IsAPlayerPed() ? CTaskEnterCover::ms_Tunables.m_CoverEntryMaxDistance : CTaskEnterCover::ms_Tunables.m_CoverEntryMaxDistanceAI;

					Vector3 vCapsuleZOffset(0.0f, 0.0f, ms_Tunables.m_CapsuleZOffset);
					if (fDistance < fMaxDistanceToDirectlyEnterCover && 
						(CTaskEnterCover::IsPedAngleToCoverAcceptableForMovingEntry(*pPed) || CTaskEnterCover::ShouldPedDoStandingEntry(*pPed))
						&& IsPathClearForPed(*pPed, vPedPosition, m_vCoverCoors, vCapsuleZOffset, ArchetypeFlags::GTA_ALL_TYPES_MOVER))
					{
						m_SeekCoverFlags.ClearFlag(CF_FindClosestPointAtStart);
						SetState(State_EnterCover);
						return FSM_Continue;
					}
				}
			}

			SetState(State_MoveToCover);
			return FSM_Continue;
		}
	}
#if AI_DEBUG_OUTPUT_ENABLED
	aiDebugf2("[Cover] - SeekCover_OnUpdate(), Ped: %s cover finder is not active\n", AILogging::GetDynamicEntityNameSafe(pPed));
#endif
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::MoveToCover_OnEnter()
{
	// Check if we are resuming the state and keep the sub-task if possible
	CTask* pSubTask = GetSubTask();
	if(pSubTask && pSubTask->GetTaskType() == CTaskTypes::TASK_COMPLEX_CONTROL_MOVEMENT)
	{
		const CTaskComplexControlMovement* pComplexTask = static_cast<const CTaskComplexControlMovement*>(pSubTask);
		if(pComplexTask->GetMoveTaskType() == CTaskTypes::TASK_MOVE_FOLLOW_NAVMESH)
		{
			return FSM_Continue;
		}
	}

	// Need to reset our initial distance to target
	m_fInitialDistToTarget = -1.0f;

	CPed* pPed = GetPed();

	// The ped should always have a valid coverpoint at this stage
	if (!taskVerifyf(pPed->GetCoverPoint(), "Coverpoint expected")) 
	{
		return FSM_Continue;
	}

	// Obtain the cover coords - quit if this fails
	Vector3 vThreatPosition(Vector3::ZeroType);
	GetTarget().GetPosition(vThreatPosition);
	Vector3 vVantagePosition(Vector3::ZeroType);
	if( !GetCoverPointPosition( vThreatPosition, pPed, m_vCoverCoors, vVantagePosition) )
	{
		return FSM_Continue;
	}

	if (!IsCoverFlagSet(CTaskCover::CF_SpecifyInitialHeading))
	{
		bool bUnused;
		ComputeFacingDirection(vThreatPosition, bUnused, false);
	}

#if __DEV
	TUNE_GROUP_BOOL(COVER_TUNE, FORCE_POINT_GUN, false);
	if (FORCE_POINT_GUN && CTaskEnterCover::ShouldPedUseAiEntryAnims(*pPed))
	{
		static dev_float MOVE_BLEND_RATIO = MOVEBLENDRATIO_RUN;
		Vector3 vInFrontOfPed = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()) + VEC3V_TO_VECTOR3(pPed->GetTransform().GetB()) * 10.0f;
		CTaskGoToPointAiming* pTask = rage_new CTaskGoToPointAiming(CAITarget(m_vCoverCoors), CAITarget(vInFrontOfPed), MOVE_BLEND_RATIO, false);
		pTask->SetTargetRadius(0.25f);
		pTask->SetUseNavmesh(true);
		pTask->SetScriptNavFlags(0);
		SetCoverFlag(CTaskCover::CF_StrafeToCover);
		SetNewTask(pTask);
		return FSM_Continue;
	}
#endif // __DEV

	// Say our line and request other AI to cover us
	if(pPed->GetPedType() == PEDTYPE_COP && pPed->GetPedIntelligence()->GetQueriableInterface()->IsTaskCurrentlyRunning(CTaskTypes::TASK_COMBAT, true))
	{
		ScalarV scDistToCoverSq = DistSquared(pPed->GetTransform().GetPosition(), VECTOR3_TO_VEC3V(m_vCoverCoors));
		ScalarV scMinDistToCoverSq = LoadScalar32IntoScalarV(ms_Tunables.m_MinMoveToCoverDistForCoverMeAudio);
		scMinDistToCoverSq = (scMinDistToCoverSq * scMinDistToCoverSq);
		if(IsGreaterThanAll(scDistToCoverSq, scMinDistToCoverSq))
		{
			ScalarV scDistToTargetSq = DistSquared(pPed->GetTransform().GetPosition(), VECTOR3_TO_VEC3V(vThreatPosition));
			ScalarV scCoverToTargetSq = DistSquared( VECTOR3_TO_VEC3V(m_vCoverCoors), VECTOR3_TO_VEC3V(vThreatPosition));
			if(IsLessThanAll(scCoverToTargetSq, scDistToTargetSq))
			{
				if(fwRandom::GetRandomTrueFalse())
				{
					pPed->NewSay("COVER_ME");
				}
				else
				{
					pPed->NewSay("MOVE_IN");
				}

				CEventCallForCover event(pPed);
				event.CommunicateEvent(pPed, true, false);
			}
		}
	}

	// Follow a nav mesh route to the cover location
	CTaskMoveFollowNavMesh* pMovementTask = rage_new CTaskMoveFollowNavMesh(m_fMoveBlendRatio, m_vCoverCoors, 0.1f, 3.0f, -1, true, false, m_pSpheresOfInfluenceBuilder, 0.5f );

	if(m_SeekCoverFlags.IsFlagSet(CF_KeepMovingWhilstWaitingForPath))
	{
		pMovementTask->SetKeepMovingWhilstWaitingForPath(true);
	}

	//Check if we should never enter water.
	if(m_SeekCoverFlags.IsFlagSet(CF_NeverEnterWater))
	{
		pMovementTask->SetNeverEnterWater(true);
	}

	if(m_SeekCoverFlags.IsFlagSet(CF_DontUseLadders))
	{
		pMovementTask->SetDontUseLadders(true);
	}

	if(m_SeekCoverFlags.IsFlagSet(CF_DontUseClimbs))
	{
		pMovementTask->SetDontUseClimbs(true);
	}

	if(m_SeekCoverFlags.IsFlagSet(CF_UseLargerSearchExtents))
	{
		pMovementTask->SetUseLargerSearchExtents(true);
	}

	pMovementTask->SetExpandStartEndTessellationRadius(true); // So we get better precision when pathing to covers, we might take unecessary long routes otherwise

	// Set the new subtask if it should be running whilst moving
	CTask* pMainSubtask = NULL;
	if( m_pSubTaskWhilstSearching && m_SeekCoverFlags.IsFlagSet(CF_RunSubtaskWhenMoving) )
	{
		pMainSubtask = (CTask*)m_pSubTaskWhilstSearching->Copy();

		// if the main sub task is the additional combat task and we can use dynamic strafe decisions then see if we should try running directly to cover
		if(pMainSubtask && pMainSubtask->GetTaskType() == CTaskTypes::TASK_ADDITIONAL_COMBAT_TASK)
		{
			CTaskCombatAdditionalTask* pCombatAdditionalTask = static_cast<CTaskCombatAdditionalTask*>(pMainSubtask);
			pCombatAdditionalTask->SetFlags(CTaskCombat::GenerateCombatRunningFlags(true, MOVEBLENDRATIO_RUN) | CTaskCombatAdditionalTask::RT_MakeDynamicAimFireDecisions);
		}
		
		SetCoverFlag(CTaskCover::CF_StrafeToCover);
	}

	fragInstNMGta* pRagdollInst = pPed->GetRagdollInst();
	if (pRagdollInst != NULL)
	{
		// The initial velocity of the ragdoll will be calculated from the previous and current skeleton bounds.
		// This can be a problem when initially starting to move to cover since the ped ducks down somewhat before
		// starting to run. If the character ragdolls as they are coming out of the duck they can end up inheriting 
		// quite a bit of upwards velocity (see bug #1544843). Trying to keep this change as local as possible so
		// only enabling this limit while moving to cover

		// The next time the ragdoll is activated, the initial velocity will be scaled
		static bank_float sfMovingToCoverRagdollIncomingAnimVelocityScale = 0.5f;
		pRagdollInst->SetIncomingAnimVelocityScaleReset(sfMovingToCoverRagdollIncomingAnimVelocityScale);

		taskWarningf("CTaskCover::MoveToCover_OnEnter: Scaling initial ragdoll velocity by %f", sfMovingToCoverRagdollIncomingAnimVelocityScale);
	}

	// Construct the control movement subtask and set it as the current subtask
	CTaskComplexControlMovement* pTask = rage_new CTaskComplexControlMovement( pMovementTask, pMainSubtask, CTaskComplexControlMovement::TerminateOnMovementTask );
	pTask->SetAllowClimbLadderSubtask(m_SeekCoverFlags.IsFlagSet(CF_AllowClimbLadderSubtask));
	SetNewTask(pTask);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::MoveToCover_OnUpdate()
{
	CPed* pPed = GetPed();

	// If we somehow find ourself as the player without controls enabled (switched) quit out
	if (pPed->IsLocalPlayer() && !pPed->GetPlayerInfo()->AreControlsDisabled())
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	if (pPed->GetPedResetFlag(CPED_RESET_FLAG_MoveBlend_bTaskComplexGunRunning) && pPed->GetIsCrouching())
	{
		pPed->SetIsCrouching(false);
	}

	// The ped should always have a valid coverpoint (that isn't dangerous) at this stage
	CCoverPoint* pCoverPoint = pPed->GetCoverPoint();
	bool bIsCoverPointDangerous = pCoverPoint && pCoverPoint->IsDangerous();
	bool bIsCoverPointCloseToPlayer = pCoverPoint && pCoverPoint->IsCloseToPlayer(*pPed);

	if (!pCoverPoint || bIsCoverPointDangerous || bIsCoverPointCloseToPlayer || IsLocalPlayerEnteringCloseCover()) 
	{
		if(bIsCoverPointDangerous || bIsCoverPointCloseToPlayer)
		{
			pPed->ReleaseCoverPoint();
		}

		if(m_SeekCoverFlags.IsFlagSet(CF_MoveToPedsCover) || m_SeekCoverFlags.IsFlagSet(CF_QuitAfterMovingToCover) ||
		   !m_SeekCoverFlags.IsFlagSet(CF_SeekCover) || !m_pCoverFinder)
		{
			SetState(State_Finish);
		}
		else
		{
			SetState(State_SeekCover);
		}
		return FSM_Continue;
	}

	// Obtain the cover coords - quit if this fails
	Vector3 vThreatPosition(Vector3::ZeroType);
	GetTarget().GetPosition(vThreatPosition);
	Vector3 vVantagePosition;

	if (!GetCoverPointPosition( vThreatPosition, pPed, m_vCoverCoors, vVantagePosition))
	{
		if(m_SeekCoverFlags.IsFlagSet(CF_MoveToPedsCover) || m_SeekCoverFlags.IsFlagSet(CF_QuitAfterMovingToCover) ||
		   !m_SeekCoverFlags.IsFlagSet(CF_SeekCover) || !m_pCoverFinder)
		{
			SetState(State_Finish);
		}
		else
		{
			SetState(State_SeekCover);
		}
		return FSM_Continue;
	}

	const CEntity* pTargetEntity = GetTarget().GetEntity();
	const bool bPointProvidesCover = CCover::DoesCoverPointProvideCoverFromTargets(pPed, vThreatPosition, pCoverPoint, pCoverPoint->GetArcToUse(*pPed, pTargetEntity), pTargetEntity);
	bool bPointRequiresCover = (!m_SeekCoverFlags.IsFlagSet(CF_SeekCover) || m_iSearchType == CCover::CS_MUST_PROVIDE_COVER);

	bool bWeaponUsableInCover = pPed->GetWeaponManager() ? pPed->GetWeaponManager()->IsEquippedWeaponUsableInCover() : false;
	
	// See if we can play the cover entry clips
	if (bWeaponUsableInCover && CheckForEnteringCover(pPed) && !m_SeekCoverFlags.IsFlagSet(CF_QuitAfterMovingToCover))
	{
		if( !bPointProvidesCover && bPointRequiresCover )
		{
			if(!m_SeekCoverFlags.IsFlagSet(CF_QuitAfterMovingToCover))
			{
				pPed->ReleaseCoverPoint();
			}

			SetState(State_Finish);
			return FSM_Continue;
		}
		SetState(State_EnterCover);
		return FSM_Continue;
	}

	// If the task has
	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished))
	{
		//Check we're actually at the cover point
		const float fDistToCover = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()).Dist2(m_vCoverCoors);
		if (m_SeekCoverFlags.IsFlagSet(CF_QuitAfterMovingToCover) || (!bPointProvidesCover && bPointRequiresCover) || !bWeaponUsableInCover ||
			fDistToCover > CTaskEnterCover::ms_Tunables.m_CoverEntryMinDistance*CTaskEnterCover::ms_Tunables.m_CoverEntryMinDistance)
		{
			if(!m_SeekCoverFlags.IsFlagSet(CF_QuitAfterMovingToCover))
			{
				pPed->ReleaseCoverPoint();
			}

			SetState(State_Finish);
			return FSM_Continue;
		}
		else
		{
			SetState(State_EnterCover);
			return FSM_Continue;
		}
	}

	// If we've failed to navigate within range to play the cover entry clip, quit
	if (HasNavigationTaskFailed(pPed))
	{
		aiDebugf2("Ped 0x%p failed to navigate to cover point", pPed);
		pPed->ReleaseCoverPoint();
		SetState(State_Finish);
		return FSM_Continue;
	}

	ActivateTimeslicing();
#if AI_DEBUG_OUTPUT_ENABLED
	aiDebugf2("[Cover] - MoveToCover_OnUpdate(), Ped: %s moving to cover\n", AILogging::GetDynamicEntityNameSafe(pPed));
#endif
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::MoveToCover_OnExit()
{
	CPed* pPed = GetPed();

	fragInstNMGta* pRagdollInst = pPed->GetRagdollInst();
	if (pRagdollInst != NULL)
	{
		// Reset the incoming anim velocity scale
		pRagdollInst->SetIncomingAnimVelocityScaleReset(-1.0f);

		taskWarningf("CTaskCover::MoveToCover_OnExit: Reset initial ragdoll velocity");
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::MoveToCover_OnUpdateClone()
{
    ActivateTimeslicing();

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::MoveToSearchLocation_OnEnter()
{
	CTaskMoveFollowNavMesh* pMoveTask = rage_new CTaskMoveFollowNavMesh(
		m_fMoveBlendRatio, 
		m_vSearchPosition, 
		CTaskMoveFollowNavMesh::ms_fTargetRadius, 
		1.0f, 
		-1,
		true,
		false,
		m_pSpheresOfInfluenceBuilder,
		0.5f	// fCompletionRadius : allow pathfinder to succeed if it finds a pos within this distance of target
		);	

	// Set the new subtask if it should be running whilst moving
	CTask* pMainSubtask = NULL;
	if( m_pSubTaskWhilstSearching && m_SeekCoverFlags.IsFlagSet(CF_RunSubtaskWhenMoving) )
		pMainSubtask = (CTask*)m_pSubTaskWhilstSearching->Copy();

	SetNewTask( rage_new CTaskComplexControlMovement(pMoveTask, pMainSubtask, CTaskComplexControlMovement::TerminateOnMovementTask) );
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::MoveToSearchLocation_OnUpdate()
{
	// If the task has finished, quit
	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished))
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	// If no route is available, quit (e.g. enemy ped is on a balcony with no entry point)
	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_COMPLEX_CONTROL_MOVEMENT)
	{
		aiTask* pMoveTask = static_cast<CTaskComplexControlMovement*>(GetSubTask())->GetRunningMovementTask(GetPed());
		if (pMoveTask && pMoveTask->GetTaskType() == CTaskTypes::TASK_MOVE_FOLLOW_NAVMESH)
		{
			if (static_cast<CTaskMoveFollowNavMesh*>(pMoveTask)->IsUnableToFindRoute())
			{
				SetState(State_Finish);
				return FSM_Continue;
			}
		}
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::EnterCover_OnEnter()
{
	CPed* pPed = GetPed();
	taskAssert(pPed->GetCoverPoint());

	m_bWantedToReloadDuringEntry = false;

	if (m_TaskMotionInCoverMoveNetworkHelper.IsNetworkActive())
	{
		m_TaskMotionInCoverMoveNetworkHelper.ReleaseNetworkPlayer();
	}

	TUNE_GROUP_BOOL(COVER_TUNE, ENABLE_ENTRY_EDGE_TEST, true);
	TUNE_GROUP_BOOL(COVER_TUNE, ENABLE_ENTRY_EDGE_TEST_FOR_LOW_COVER, true);
	if (ENABLE_ENTRY_EDGE_TEST && pPed->GetCoverPoint())
	{
		CCoverPoint::eCoverUsage usage = pPed->GetCoverPoint()->GetUsage();
		if ((ENABLE_ENTRY_EDGE_TEST_FOR_LOW_COVER && pPed->GetCoverPoint()->GetHeight() != CCoverPoint::COVHEIGHT_TOOHIGH) || (usage == CCoverPoint::COVUSE_WALLTOLEFT || usage == CCoverPoint::COVUSE_WALLTORIGHT))
		{
			// This is checked in CTaskInCover::FindCoverEdgeAndUpdateCoverPosition so we can do a height probe test to get more accurate height info
			pPed->SetPedResetFlag(CPED_RESET_FLAG_IsEnteringCover, true);
			m_vCoverCoors.z -= 1.0f;
			float fEdgeDistance = -1.0f;
			CTaskInCover::FindCoverEdgeAndUpdateCoverPosition(pPed, m_vCoverCoors, fEdgeDistance, usage == CCoverPoint::COVUSE_WALLTORIGHT ? true : false, false, -1.0f, true);
			if (pPed->IsLocalPlayer())
				pPed->GetPlayerInfo()->SetDynamicCoverEdgeDistance(fEdgeDistance);
		}
	}

#if __ASSERT
	Vector3 vPedPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	const float fDistanceToCover = (m_vCoverCoors - vPedPosition).XYMag();
	const float fCoverEntryMaxDistance = pPed->IsAPlayerPed() ? CTaskEnterCover::ms_Tunables.m_CoverEntryMaxDistance : CTaskEnterCover::ms_Tunables.m_CoverEntryMaxDistanceAI;
	if (!taskVerifyf(fDistanceToCover < (fCoverEntryMaxDistance + 1.0f), "(%s) Ped entering cover from too far distance to cover (%.4f) : Cover Coords <<%.2f, %.2f, %.2f>>, Ped Coords <<%.2f, %.2f, %.2f>>.", pPed->IsAPlayerPed() ? "Player" : "AI", fDistanceToCover, m_vCoverCoors.x, m_vCoverCoors.y, m_vCoverCoors.z, vPedPosition.x, vPedPosition.y, vPedPosition.z))
	{
		pPed->GetPedIntelligence()->PrintTasks();
	}
#endif

	Vector3 vCoverDir = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector());
	pPed->GetCoverPoint()->GetCoverPointPosition(m_vCoverCoors);
	m_vCoverCoors.z += 1.0f;

	if (AssertVerify(pPed->GetCoverPoint()) && !IsCoverFlagSet(CTaskCover::CF_SpecifyInitialHeading))
	{
		if (pPed->GetCoverPoint()->GetHeight() == CCoverPoint::COVHEIGHT_TOOHIGH)
		{
			m_CoverFlags.SetFlag(CTaskCover::CF_TooHighCoverPoint);
		}
		else 
		{
			m_CoverFlags.ClearFlag(CTaskCover::CF_TooHighCoverPoint);
		}

		bool bShouldFaceLeft = false;

		if (pPed->IsLocalPlayer())
		{
			bool bUseCloseCorner = false;

			// Face the same direction the player is coming to the cover from
			Vector3 vToTarget = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()) - m_vCoverCoors;
			vToTarget.z = 0.0f;
			vCoverDir.z = 0.0f;

			TUNE_GROUP_FLOAT(COVER_TUNE, FROM_EXIT_VEHICLE_MAX_COVER_DIST, 1.5f, 0.0f, 3.0f, 0.01f);
			if ((pPed->GetPedResetFlag(CPED_RESET_FLAG_ExitVehicleTaskFinishedThisFrame) || pPed->GetPedResetFlag(CPED_RESET_FLAG_IsEnteringVehicle)) && vToTarget.Mag2() < square(FROM_EXIT_VEHICLE_MAX_COVER_DIST))
			{
				CTaskEnterCover::ComputeCloseFacingDirectionForPed(pPed, vCoverDir, bShouldFaceLeft);
			}
			else
			{
				// If we're very close to cover, let the camera direction relative to the cover direction to decide the default facing direction
				TUNE_GROUP_FLOAT(COVER_TUNE, MAX_DIST_FROM_COVER_TO_CHOOSE_CAM_DIRECTION, 1.0f, 0.0f, 3.0f, 0.01f);
				Vector3 vThreatDir = camInterface::GetFront();
				aiDebugf2("Dist to target %.2f", vToTarget.Mag());
				aiDebugf2("vThreatDir.CrossZ(vCoverDir) %.2f", vThreatDir.CrossZ(vCoverDir));
				aiDebugf2("vToTarget.CrossZ(vCoverDir) %.2f", vToTarget.CrossZ(vCoverDir));
				if (NetworkInterface::IsGameInProgress() && vToTarget.Mag2() < square(MAX_DIST_FROM_COVER_TO_CHOOSE_CAM_DIRECTION))
				{
					if (vThreatDir.CrossZ(vCoverDir) < 0.0f)
					{
						bShouldFaceLeft = true;
					}
				}
				else
				{
					// Sign flipped here because vToTarget is actually the vec away from cover
					if (vToTarget.CrossZ(vCoverDir) > 0.0f)
					{
						bShouldFaceLeft = true;
					}
				}

				TUNE_GROUP_BOOL(COVER_TUNE, USE_NEARBY_CORNER_FOR_WALL_TO_BOTH, true);
				TUNE_GROUP_BOOL(COVER_TUNE, ALWAYS_FACE_CORNER, true);
				TUNE_GROUP_BOOL(COVER_TUNE, ALWAYS_FACE_TOWARDS_THREAT_DOUBLE_CORNER, true);
				TUNE_GROUP_BOOL(COVER_TUNE, ALWAYS_FACE_TOWARDS_THREAT_WALL_TO_BOTH, true);
				if (pPed->GetCoverPoint()->GetFlag(CCoverPoint::COVFLAGS_IsPriority) && pPed->GetCoverPoint()->GetUsage() != CCoverPoint::COVUSE_WALLTOBOTH)
				{
					CTaskEnterCover::GetFacingDirectionIfEdgeCover(*pPed->GetCoverPoint(), bShouldFaceLeft);
				}
				else if (ALWAYS_FACE_CORNER &&
					(pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTORIGHT ||
					pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTOLEFT))
				{
					if (!NetworkInterface::IsGameInProgress() || !CTaskEnterCover::GetFacingDirectionIfBlocked(*pPed, m_vCoverCoors, vCoverDir, bShouldFaceLeft, !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), true))
					{
						CTaskEnterCover::GetFacingDirectionIfEdgeCover(*pPed->GetCoverPoint(), bShouldFaceLeft);
					}
				}
				else if (ALWAYS_FACE_TOWARDS_THREAT_DOUBLE_CORNER && pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTONEITHER
					&& CTaskCover::ComputeDesiredProtectionDirection(*pPed, m_vCoverCoors, vThreatDir))
				{
					bShouldFaceLeft = vThreatDir.CrossZ(vCoverDir) <= 0.0f;
				}
				else if (ALWAYS_FACE_TOWARDS_THREAT_WALL_TO_BOTH && pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTOBOTH
					&& CTaskCover::ComputeDesiredProtectionDirection(*pPed, m_vCoverCoors, vThreatDir))
				{
					if (!NetworkInterface::IsGameInProgress() || !CTaskEnterCover::GetFacingDirectionIfBlocked(*pPed, m_vCoverCoors, vCoverDir, bShouldFaceLeft, !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), false))
					{
						bShouldFaceLeft = vThreatDir.CrossZ(vCoverDir) <= 0.0f;
					}	
				}
				else if (USE_NEARBY_CORNER_FOR_WALL_TO_BOTH && pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTOBOTH && ComputeFacingDirection(vThreatDir, bUseCloseCorner, true) && bUseCloseCorner)
				{
					bShouldFaceLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
					aiDisplayf("Facing left ? %s", IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? "TRUE" : "FALSE");
				}
				else
				{
					const bool bIsHighEdgeCover = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && pPed->GetCoverPoint()->IsEdgeCoverPoint();
					// If aiming use the camera direction
					if (!bIsHighEdgeCover && pPed->GetPedIntelligence()->FindTaskActiveMotionByType(CTaskTypes::TASK_MOTION_AIMING))
					{
						const Vector3 vCamFront = camInterface::GetFront();
						if (vCamFront.CrossZ(vCoverDir) > 0.0f)
						{
							bShouldFaceLeft = false;
						}
						else
						{
							bShouldFaceLeft = true;
						}
					}
					else
					{
						CTaskEnterCover::GetFacingDirectionIfBlocked(*pPed, m_vCoverCoors, vCoverDir, bShouldFaceLeft, !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), false);
					}
				}
			}
		}
		else
		{
			if (!CTaskEnterCover::GetFacingDirectionIfEdgeCover(*pPed->GetCoverPoint(), bShouldFaceLeft))
			{
				Vector3 vTargetPos(Vector3::ZeroType);
				if (GetTarget().GetPosition(vTargetPos))
				{
					Vector3 vToTarget = vTargetPos - m_vCoverCoors;
					vToTarget.z = 0.0f;
					vTargetPos.Normalize();
					vCoverDir.z = 0.0f;
					vToTarget.Cross(vCoverDir);
					if (vToTarget.z < 0.0f)
					{
						bShouldFaceLeft = true;
					}
				}
			}
		}

		if (bShouldFaceLeft)
		{
			SetCoverFlag(CTaskCover::CF_FacingLeft);
		}
		else
		{
			ClearCoverFlag(CTaskCover::CF_FacingLeft);
		}
	}

	float endDir = rage::Atan2f(-vCoverDir.x, vCoverDir.y);

	CTaskEnterCover* pIntroTask = rage_new CTaskEnterCover(m_vCoverCoors, endDir);
	SetNewTask(pIntroTask);
	return FSM_Continue;
}


////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::EnterCover_OnUpdate()
{
	bool bPedBlockingMyCover = false;
	CPed& ped = *GetPed();
	if (ped.IsLocalPlayer() && ped.GetCoverPoint())
	{
#if FPS_MODE_SUPPORTED
		ped.SetPlayerResetFlag(CPlayerResetFlags::PRF_DISABLE_CAMERA_VIEW_MODE_CYCLE);

		TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DISABLE_CAMERA_COLLISION_CONSTRAINT_FALLBACK_DURING_ENTRY, true);
		if (DISABLE_CAMERA_COLLISION_CONSTRAINT_FALLBACK_DURING_ENTRY && !NetworkInterface::IsGameInProgress())
		{
			ped.SetPedResetFlag(CPED_RESET_FLAG_DisableCameraConstraintFallBackThisFrame, true);
		}
#endif // FPS_MODE_SUPPORTED

		// See if there are nearby peds with a certain distance from the cover point
		Vector3 vPos;
		ped.GetCoverPoint()->GetCoverPointPosition(vPos);
		Vector3 vPedCoverPos(vPos.x, vPos.y, vPos.z + 1.0f); // Add one to z height as cover position is on the ground
		const CPed* pBlockingPed = CTaskEnterCover::GetPedBlockingMyCover(ped, vPedCoverPos);
		if(pBlockingPed)
		{
			bPedBlockingMyCover = true;
#if AI_DEBUG_OUTPUT_ENABLED
			aiDebugf2("[Cover] - Cover is blocked by ped: %s\n", AILogging::GetDynamicEntityNameSafe(pBlockingPed));
#endif
		}
	}

	if (bPedBlockingMyCover || CheckForCoverExit() || IsLocalPlayerEnteringCloseCover())
	{
		if (bPedBlockingMyCover && NetworkInterface::IsGameInProgress() && ped.GetNetworkObject())
		{
			CNetObjPed* pPedObj = SafeCast(CNetObjPed, ped.GetNetworkObject());
			//Since motion state is InFrequent make sure we have the latest up-to-date position / task info to decide whether we should abort
			pPedObj->ForceResendAllData();
		}

		if (GetTimeInState() > 0.0f)
		{
			ped.ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);
		}
		// Ensure we are not classed as moving
		ped.GetMotionData()->SetCurrentMoveBlendRatio(0.0f);

		if (m_TaskCoverMoveNetworkHelper.IsNetworkActive() && CTaskExitCover::IsTaskValid(ped) && ped.IsLocalPlayer() && ped.GetCoverPoint())
		{
			// Probably should move the m_vecStick calculation into CTaskCover
			CControl *pControl = ped.GetControlFromPlayer();
			Vector2 vecStick(pControl->GetPedWalkLeftRight().GetNorm(), -pControl->GetPedWalkUpDown().GetNorm());
			vecStick *= 128.0f;
			vecStick.Rotate(camInterface::GetGameplayDirector().GetFrame().ComputeHeading());
			Vector3 vCoverDirection = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector());
			vecStick.Rotate(-rage::Atan2f(-vCoverDirection.x, vCoverDirection.y));

			if (CTaskMotionInCover::PlayerCheckForCornerExit(ped, IsCoverFlagSet(CTaskCover::CF_FacingLeft), vecStick))
			{
				m_eInCoverTerminationReason = TR_CornerExit;
			}
			else
			{
				m_eInCoverTerminationReason = TR_IdleExit;
			}

			if (m_eInCoverTerminationReason == TR_IdleExit && ped.IsFirstPersonShooterModeEnabledForPlayer(false))
			{
				SetState(State_Finish);
				return FSM_Continue;
			}

			SetState(State_ExitCover);
			return FSM_Continue;
		}
		else
		{
			SetState(State_Finish);
			return FSM_Continue;
		}
	}

	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished))
	{
#if AI_DEBUG_OUTPUT_ENABLED
		aiDebugf2("[Cover] - CTaskCover::EnterCover_OnUpdate(), Ped: %s, sub task to finished\n",  AILogging::GetDynamicEntityNameSafe(&ped));
#endif
		// The combat task uses this flag as it needs to change its state to in/at cover
		if (m_SeekCoverFlags.IsFlagSet(CF_QuitAfterCoverEntry))
		{
			SetState(State_Finish);
			return FSM_Continue;
		}
		else
		{
			SetState(State_UseCover);
			return FSM_Continue;
		}
	}
	else
	{
#if AI_DEBUG_OUTPUT_ENABLED
		aiDebugf2("[Cover] - CTaskCover::EnterCover_OnUpdate(), Ped: %s, waiting on sub task to finish\n",  AILogging::GetDynamicEntityNameSafe(&ped));
#endif
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::EnterCover_OnEnterClone()
{
	if (IsCoverFlagSet(CF_DesiredFacingLeft))
	{
		SetCoverFlag(CF_FacingLeft);
	}
	else
	{
		ClearCoverFlag(CF_FacingLeft);
	}

	Vector3 coverPos(VEC3_ZERO);

	if (!GetNetCoverPointPosition(*GetPed(), coverPos))
	{
		Assertf(0, "No cover position for %s when entering cover", GetPed()->GetNetworkObject()->GetLogName());
	}

	CClonedCoverIntroInfo *taskInfo = SafeCast(CClonedCoverIntroInfo, GetPed()->GetPedIntelligence()->GetQueriableInterface()->GetTaskInfoForTaskType(CTaskTypes::TASK_ENTER_COVER, PED_TASK_PRIORITY_MAX, false));
	
	Assertf(taskInfo, "No task info for %s when entering cover", GetPed()->GetNetworkObject()->GetLogName());

	CTaskEnterCover* pIntroTask = rage_new CTaskEnterCover(coverPos, taskInfo ? taskInfo->GetEndDirection() : 0.0f, false);
	SetNewTask(pIntroTask);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::EnterCover_OnUpdateClone()
{
	if (GetStateFromNetwork() == State_Finish)
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished) || !GetSubTask())
	{
		if (GetStateFromNetwork() != GetState())
		{
			SetState(GetStateFromNetwork());
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::UseCover_OnEnter()
{
	m_CoverFlags.SetFlag(CF_SpecifyInitialHeading);
	m_CoverFlags.SetFlag(CF_CanBlindFire);

	StartCoverNetwork(false, false, false);

	// Create the cover intro task, setup the cover intro subnetwork to be inserted when the main network enters the intro state
	CTaskInCover* pUseCoverTask = rage_new CTaskInCover(m_TaskCoverMoveNetworkHelper, m_TaskUseCoverMoveNetworkHelper, m_TaskMotionInCoverMoveNetworkHelper);
	pUseCoverTask->SetTimeInCover(m_fTimeInCover);
	SetNewTask(pUseCoverTask);

	AddBlockingObject(GetPed());

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::UseCover_OnUpdate()
{
#if FPS_MODE_SUPPORTED
	if(GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DISABLE_CAMERA_COLLISION_CONSTRAINT_FALLBACK_WHEN_IN_COVER, true);
		if (DISABLE_CAMERA_COLLISION_CONSTRAINT_FALLBACK_WHEN_IN_COVER)
		{
			bool bDisableCameraConstraintFallBackThisFrame = true;
			if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_IN_COVER)
			{
				if (GetSubTask()->GetState() == CTaskInCover::State_AimIntro)
				{
					bDisableCameraConstraintFallBackThisFrame = false;
				}
			}

			if (bDisableCameraConstraintFallBackThisFrame)
			{
				GetPed()->SetPedResetFlag(CPED_RESET_FLAG_DisableCameraConstraintFallBackThisFrame, true);
			}
		}

// 		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MIN_TIME_BEFORE_DISPLAY_HELP_TEXT, 1.0f, 0.0f, 10.0f, 0.01f);
// 		if (m_TimeBeforeDisplayHelpText > MIN_TIME_BEFORE_DISPLAY_HELP_TEXT && !CHelpMessage::DoesMessageTextExist(HELP_TEXT_SLOT_STANDARD))
// 		{
// 			TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DISPLAY_HELP_TEXT_FOREVER_IN_COVER, true);
// 			CHelpMessage::SetMessageTextAndAddToBrief(HELP_TEXT_SLOT_STANDARD, "FP_COVER_HLP", NULL, 0, NULL, 0, true, DISPLAY_HELP_TEXT_FOREVER_IN_COVER);
// 			m_bHelpTextNeedsClearing = true;
// 		}
// 		m_TimeBeforeDisplayHelpText += GetTimeStep();
	}
// 	else
// 	{
// 		m_TimeBeforeDisplayHelpText = 0.0f;
// 		ProcessClearFPSCoverHelpText();
// 	}
#endif // FPS_MODE_SUPPORTED

	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_TIME_IN_USE_COVER, 0.01f, 0.0f, 1.0f, 0.01f);

	if (m_eForcedExit == CTaskCover::FE_Aim && GetSubTask())
	{
		if (GetSubTask()->GetState() == CTaskInCover::State_Aim)
		{
			SetState(State_Finish);
			return FSM_Continue;
		}
	}

	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished) || (GetTimeInState() >= MIN_TIME_IN_USE_COVER && (m_eForcedExit != FE_None && m_eForcedExit !=FE_Aim)))
	{
		TUNE_GROUP_FLOAT(COVER_TUNE, TIME_IN_COVER_FROM_ENTRY_TO_ZERO_MBR_ON_EXIT, 0.1f, 0.0f, 1.0f, 0.01f);
		CPed& rPed = *GetPed();
		if (rPed.IsLocalPlayer() && GetPreviousState() == State_EnterCover && GetTimeInState() < TIME_IN_COVER_FROM_ENTRY_TO_ZERO_MBR_ON_EXIT)
		{
			// Ensure we are not classed as moving
			rPed.GetMotionData()->SetCurrentMoveBlendRatio(0.0f);
		}

		switch (m_eForcedExit)
		{
			case FE_Idle : m_eInCoverTerminationReason = TR_IdleExit; break;
			case FE_Corner : m_eInCoverTerminationReason = TR_CornerExit; break;
			default: break;
		}

		bool bShouldBlendOut = false;
#if FPS_MODE_SUPPORTED
		TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DONT_USE_IDLE_EXIT, true);
		if (DONT_USE_IDLE_EXIT && rPed.IsFirstPersonShooterModeEnabledForPlayer(false) && m_eInCoverTerminationReason == TR_IdleExit)
		{
			bShouldBlendOut = true;
		}
#endif // FPS_MODE_SUPPORTD

		if (bShouldBlendOut || !m_TaskCoverMoveNetworkHelper.IsNetworkActive() || m_eInCoverTerminationReason == TR_NormalExit || !CTaskExitCover::IsTaskValid(rPed))
		{
			CPedWeaponManager* pWeaponManager = GetPed()->GetWeaponManager();
			if (pWeaponManager )
			{
				CWeapon* pEquippedWeapon = pWeaponManager->GetEquippedWeapon();
				if (pEquippedWeapon && pEquippedWeapon->GetWeaponInfo()->GetIsUnarmed())
				{
					if (pWeaponManager->GetBackupWeapon() != 0)
					{
						pWeaponManager->GetWeaponSelector()->SetSelectedWeapon(&rPed, pWeaponManager->GetBackupWeapon()); //for some reason this has to be done here...
						pWeaponManager->RestoreBackupWeapon();						
					}
				}			
			}
			SetState(State_Finish);
			return FSM_Continue;
		}
		else
		{
			SetState(State_ExitCover);
			return FSM_Continue;
		}
	}

	// Check if locally owned non-player
	const CPed* pPed = GetPed();
	if( pPed && !pPed->IsPlayer() && !pPed->IsNetworkClone() )
	{
		// Check if lungs damaged
		const bool bLungsDamaged = pPed->IsBodyPartDamaged(CPed::DAMAGED_LUNGS);
		if( bLungsDamaged)
		{
			// Check if ped can be in hurt mode
			const bool bCanBeInHurt = pPed->CanBeInHurt();
			if( bCanBeInHurt )
			{
				// leave cover to go to hurt mode
				SetState(State_Finish);
				return FSM_Continue;
			}
		}
	}
	
	// If this is the top-level task, and we're supposed to be following the player, make sure we don't get stuck doing this forever. [6/13/2013 mdawe]
	if (GetTimeInState() > ms_Tunables.m_MaxSecondsAsTopLevelTask)
	{
		// Check to see if this is top level. Also, if this is a PriorityPrimary task, we were scripted to do it and shouldn't quit.
		if (GetParent() == NULL && (this != pPed->GetPedIntelligence()->GetTaskAtPriority(PED_TASK_PRIORITY_PRIMARY)))
		{
			// See if we're in the player's group.
			CPedGroup* pPedGroup = pPed->GetPedsGroup();
			if (pPedGroup && pPedGroup->GetGroupMembership() && pPedGroup->GetGroupMembership()->GetLeader() && pPedGroup->GetGroupMembership()->GetLeader()->IsPlayer())
			{
				SetState(State_Finish);
			}
		}
	}

	UpdateBlockingObject(GetPed());
	return FSM_Continue;
}

CTask::FSM_Return CTaskCover::UseCover_OnExit()
{
	//ProcessClearFPSCoverHelpText();
	RemoveBlockingObject();
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::UseCover_OnUpdateClone()
{
	CPed* pPed = GetPed();

	// we must wait until we get the task info update for the use cover state, so we can set up the task properly to accept network updates
	if(GetStateFromNetwork() == State_UseCover)
	{
		if (!GetSubTask() || GetSubTask()->GetTaskType() != CTaskTypes::TASK_IN_COVER)
		{
			CTaskInfo *taskInfo = pPed->GetPedIntelligence()->GetQueriableInterface()->GetTaskInfoForTaskType(CTaskTypes::TASK_IN_COVER, PED_TASK_PRIORITY_MAX);

			if(taskInfo)
			{
				UseCover_OnEnter();

				if (AssertVerify(GetNewTask()))
				{
					SafeCast(CTaskFSMClone, GetNewTask())->SetRunAsAClone(true);
					SafeCast(CTaskFSMClone, GetNewTask())->ReadQueriableState(static_cast<CClonedFSMTaskInfo *>(taskInfo));
				}
			}
		}
	}
	else if (GetStateFromNetwork() != State_EnterCover)
	{
		SetState(GetStateFromNetwork());		
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::ExitCover_OnEnter()
{
	if (m_TaskCoverMoveNetworkHelper.IsNetworkActive())
	{
		SetNewTask(rage_new CTaskExitCover(m_TaskCoverMoveNetworkHelper, m_TaskUseCoverMoveNetworkHelper, m_eInCoverTerminationReason));
	}
	else
	{
		return FSM_Quit;
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskCover::ExitCover_OnUpdate()
{
#if FPS_MODE_SUPPORTED
	if (GetPed()->IsLocalPlayer())
	{
		GetPed()->SetPlayerResetFlag(CPlayerResetFlags::PRF_DISABLE_CAMERA_VIEW_MODE_CYCLE);
	}
#endif // FPS_MODE_SUPPORTED

	if (CheckForCoverEntry() && GetPed()->GetCoverPoint())
	{
#if AI_DEBUG_OUTPUT_ENABLED
		aiDebugf2("[Cover] - ped: %s entering cover from exit cover state\n",  AILogging::GetDynamicEntityNameSafe(GetPed()));
#endif
		// Need to update this!!!!
		GetPed()->GetCoverPoint()->GetCoverPointPosition(m_vCoverCoors);
		m_vCoverCoors.z += 1.0f;
		SetState(State_EnterCover);
		return FSM_Continue;
	}

	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished) || !GetSubTask())
	{
		CPedWeaponManager* pWeaponManager = GetPed()->GetWeaponManager();
		if (pWeaponManager )
		{
			CWeapon* pEquippedWeapon = pWeaponManager->GetEquippedWeapon();
			if (pEquippedWeapon && pEquippedWeapon->GetWeaponInfo()->GetIsUnarmed())
			{
				if (pWeaponManager->GetBackupWeapon() != 0)
					pWeaponManager->RestoreBackupWeapon();
			}			
		}
		SetState(State_Finish);
		return FSM_Continue;
	}
	else
	{
#if AI_DEBUG_OUTPUT_ENABLED
		aiDebugf2("[Cover] - ExitCover_OnUpdate(), Waiting on sub task to finish for Ped: %s\n",  AILogging::GetDynamicEntityNameSafe(GetPed()));
#endif
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::StartCoverNetwork(bool bTagSync, bool bRestartMotionNetwork, bool bRestartTaskNetwork, bool bIgnoreMoverBlend, float fCustomBlendDuration)
{
	bool bSuccessful = true;
	CPed* pPed = GetPed();

	if (!m_TaskCoverMoveNetworkHelper.IsNetworkActive())
	{
		m_TaskCoverMoveNetworkHelper.CreateNetworkPlayer(pPed, CClipNetworkMoveInfo::ms_NetworkTaskCover);
	}

	if (bRestartTaskNetwork)
	{
		if (!RestartUseCoverNetwork(pPed))
		{
			bSuccessful = false;
		}
	}

	if (bRestartMotionNetwork)
	{
		RestartMotionInCoverNetwork(pPed);
	}

	// If the network hasn't been attached yet try to do so
	if (!m_TaskCoverMoveNetworkHelper.IsNetworkAttached())
	{
		// Start the cover network in the task network slot (instantly blend in if putting ped directly into cover)
		float fBlendDuration = IsCoverFlagSet(CTaskCover::CF_SkipIdleCoverTransition) ? m_fBlendInDuration : (fCustomBlendDuration > -1.0f ? fCustomBlendDuration : CTaskEnterCover::ms_Tunables.m_NetworkBlendInDuration);
		if (IsCoverFlagSet(CTaskCover::CF_SkipIdleCoverTransition) && pPed->GetPedResetFlag(CPED_RESET_FLAG_ForceExtraLongBlendInForPedSkipIdleCoverTransition))
		{
			TUNE_GROUP_FLOAT(COVER_TUNE, EXTRA_LONG_BLEND_DURATION_FOR_PLAYER_SWITCH_FROM_COVER, 10.0f, 0.0f, 50.0f, 0.01f);
			fBlendDuration = EXTRA_LONG_BLEND_DURATION_FOR_PLAYER_SWITCH_FROM_COVER;
		}
			
		// Clear the flag otherwise we'll continue to instantly blend and pop the heading when restarting bits of the network
		m_CoverFlags.ClearFlag(CTaskCover::CF_SkipIdleCoverTransition);

		if (!pPed->IsNetworkClone() && fBlendDuration == INSTANT_BLEND_DURATION)
		{
			if (pPed->GetCoverPoint())
			{
				if (!IsCoverFlagSet(CTaskCover::CF_SpecifyInitialHeading))
				{
					const bool bShouldFaceLeft = pPed->GetCoverPoint()->PedClosestToFacingLeft(*pPed);
					if (bShouldFaceLeft)
					{
						SetCoverFlag(CTaskCover::CF_FacingLeft);
					}
					else
					{
						ClearCoverFlag(CTaskCover::CF_FacingLeft);
					}
				}

				const float fEndHeading = GetDesiredHeadingForPedWithCoverPoint(pPed, pPed->GetCoverPoint());
				pPed->SetDesiredHeading(fEndHeading);
			}
		}	
		
		fwMvFilterId filter = FILTER_ID_INVALID;
		s32 iFlags = bTagSync ? CMovePed::Task_TagSyncTransition : 0;

		if (bIgnoreMoverBlend)
		{
			filter = ms_IgnoreMoverBlendFilterId;
		}

		pPed->GetMovePed().SetTaskNetwork(m_TaskCoverMoveNetworkHelper.GetNetworkPlayer(), fBlendDuration, iFlags, filter);
	}
	return bSuccessful;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::RestartUseCoverNetwork(CPed* pPed)
{
	if (!m_TaskCoverMoveNetworkHelper.GetNetworkPlayer())
		return false;

	fwMvClipSetId weaponHoldingClipSetId = GetWeaponHoldingClipSetForArmament(pPed);

	if (m_TaskUseCoverMoveNetworkHelper.IsNetworkActive())
	{
		m_TaskUseCoverMoveNetworkHelper.ReleaseNetworkPlayer();
	}

	if (!m_TaskUseCoverMoveNetworkHelper.IsNetworkActive())
	{
		m_TaskUseCoverMoveNetworkHelper.CreateNetworkPlayer(pPed, CClipNetworkMoveInfo::ms_NetworkTaskUseCover);		
		const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();
		const fwMvClipSetId coreMotionClipSetId = (pPed->IsPlayer() || !pWeaponInfo || pWeaponInfo->GetIsUnarmed() || pWeaponInfo->GetIsRpg()) ? CTaskMotionInCover::ms_Tunables.GetCoreMotionClipSetIdForPed(*pPed) : CTaskMotionInCover::ms_Tunables.m_CoreAIMotionClipSetId;
		
		if (taskVerifyf(coreMotionClipSetId != CLIP_SET_ID_INVALID, "Core motion clipset is invalid"))
		{
			if (taskVerifyf(CTaskCover::RequestCoverClipSetReturnIfLoaded(coreMotionClipSetId), "Core motion clipset %s isn't loaded", coreMotionClipSetId.GetCStr()))
			{
				m_TaskUseCoverMoveNetworkHelper.SetClipSet(coreMotionClipSetId, CTaskMotionInCover::ms_CoreMotionClipSetId);
			}
			else
			{
				return false;
			}
		}

		const fwMvClipSetId weaponClipSetId = GetWeaponClipSetForArmament(pPed, !pPed->IsAPlayerPed());
		if (weaponClipSetId != CLIP_SET_ID_INVALID && CTaskInCover::IsClipSetStreamedIn(weaponClipSetId))
		{
			if (CTaskCover::IsCoverClipSetLoaded(weaponClipSetId))
			{
				m_TaskUseCoverMoveNetworkHelper.SetClipSet(weaponClipSetId, CTaskMotionInCover::ms_WeaponClipSetId);
			}
		}

		if (weaponHoldingClipSetId != CLIP_SET_ID_INVALID)
		{
			m_TaskUseCoverMoveNetworkHelper.SetFlag(true, CTaskMotionInCover::ms_UseWeaponHoldingId);
			if (CTaskCover::IsCoverClipSetLoaded(weaponHoldingClipSetId))
			{
				m_TaskUseCoverMoveNetworkHelper.SetClipSet(weaponHoldingClipSetId, CTaskMotionInCover::ms_UpperBodyWeaponMotionClipSetId);
			}
			m_TaskUseCoverMoveNetworkHelper.SetFlag(false, fwMvFlagId("UseGripClip",0x72838804));
		}
		else
			CTaskMotionInCover::SetGripClip(pPed, m_TaskUseCoverMoveNetworkHelper);

#if FPS_MODE_SUPPORTED
		if(pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			m_TaskUseCoverMoveNetworkHelper.SetFlag(true, fwMvFlagId("FPSOutro",0x97DB016E));
		}
#endif
	}

	const fwMvFilterId weaponHoldingFilterId = CTaskMotionInCover::ms_Tunables.GetWeaponHoldingFilterIdForPed(*GetPed());
	if (weaponHoldingFilterId != FILTER_ID_INVALID)
	{
		crFrameFilter* pWeaponHoldingFrameFilter = g_FrameFilterDictionaryStore.FindFrameFilter(weaponHoldingFilterId);
		m_TaskUseCoverMoveNetworkHelper.SetFilter(pWeaponHoldingFrameFilter, CTaskMotionInCover::ms_WeaponHoldingFilterId);		
	}

#if FPS_MODE_SUPPORTED
	// Use custom blend durations when coming out to fire from peek vs non peek to account for the pose difference in first person
	if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && GetSubTask() && CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations
		&& (!CTaskCover::CanUseThirdPersonCoverInFirstPerson(*pPed)))
	{
		const bool bIsInHighCover = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
		float fBlendDuration = bIsInHighCover ? ms_Tunables.m_FPSDefaultBlendDurationHigh : ms_Tunables.m_FPSDefaultBlendDurationLow;
		if (GetSubTask()->GetPreviousState() == CTaskInCover::State_Peeking)
		{
			if (GetSubTask()->GetState() == CTaskInCover::State_BlindFiring)
			{
				fBlendDuration = bIsInHighCover ? ms_Tunables.m_FPSPeekToBlindFireBlendDurationHigh : ms_Tunables.m_FPSPeekToBlindFireBlendDurationLow;
			}
			else if (GetSubTask()->GetState() == CTaskInCover::State_AimIntro)
			{
				fBlendDuration = bIsInHighCover ? ms_Tunables.m_FPSPeekToAimBlendDurationHigh : ms_Tunables.m_FPSPeekToAimBlendDurationLow;
			}
		}
		m_TaskCoverMoveNetworkHelper.SetFloat(ms_TaskBlendDurationId, fBlendDuration);
		m_TaskCoverMoveNetworkHelper.SetFloat(ms_NoMotionTaskBlendDurationId, fBlendDuration);
		m_TaskUseCoverMoveNetworkHelper.SetFlag(true, CTaskMotionInCover::ms_IsFirstPersonFlagId);
	}
#endif // FPS_MODE_SUPPORTED
	m_TaskCoverMoveNetworkHelper.SendRequest(ms_TaskRequestId);
	m_TaskCoverMoveNetworkHelper.SetSubNetwork(m_TaskUseCoverMoveNetworkHelper.GetNetworkPlayer(), ms_PrimaryTaskNetworkId);
	return true;
}


////////////////////////////////////////////////////////////////////////////////

void CTaskCover::RestartMotionInCoverNetwork(CPed* pPed, bool bIgnoreMoverBlend)
{
	fwMvClipSetId weaponHoldingClipSetId = GetWeaponHoldingClipSetForArmament(pPed);

	if (m_TaskMotionInCoverMoveNetworkHelper.IsNetworkActive())
	{
		m_TaskMotionInCoverMoveNetworkHelper.ReleaseNetworkPlayer();
	}

	if (!m_TaskMotionInCoverMoveNetworkHelper.IsNetworkActive())
	{
		m_TaskMotionInCoverMoveNetworkHelper.CreateNetworkPlayer(pPed, CClipNetworkMoveInfo::ms_NetworkTaskMotionInCover);
		
		const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();
		const fwMvClipSetId coreMotionClipSetId = (pPed->IsPlayer() || !pWeaponInfo || pWeaponInfo->GetIsUnarmed() || pWeaponInfo->GetIsRpg()) ? CTaskMotionInCover::ms_Tunables.GetCoreMotionClipSetIdForPed(*pPed) : CTaskMotionInCover::ms_Tunables.m_CoreAIMotionClipSetId;
		if (coreMotionClipSetId != CLIP_SET_ID_INVALID)
		{
			m_TaskMotionInCoverMoveNetworkHelper.SetClipSet(coreMotionClipSetId, CTaskMotionInCover::ms_CoreMotionClipSetId);
		}

		if (weaponHoldingClipSetId != CLIP_SET_ID_INVALID)
		{
			if (!CTaskPlayerOnFoot::CheckForUseMobilePhone(*pPed))
			{
				m_TaskMotionInCoverMoveNetworkHelper.SetFlag(true, CTaskMotionInCover::ms_UseWeaponHoldingId);
				m_TaskMotionInCoverMoveNetworkHelper.SetClipSet(weaponHoldingClipSetId, CTaskMotionInCover::ms_UpperBodyWeaponMotionClipSetId);
			}			
		}
		else
		{			
			CTaskMotionInCover::SetGripClip(pPed, m_TaskMotionInCoverMoveNetworkHelper);		
		}

		m_TaskMotionInCoverMoveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_IdleFlagId);
		m_TaskMotionInCoverMoveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_PeekingFlagId);
		m_TaskMotionInCoverMoveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_AtEdgeFlagId);

#if FPS_MODE_SUPPORTED
		if (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonLocoAnimations)
		{
			m_TaskMotionInCoverMoveNetworkHelper.SetFlag(pPed->IsFirstPersonShooterModeEnabledForPlayer(false), CTaskMotionInCover::ms_IsFirstPersonFlagId);
		}
#endif // FPS_MODE_SUPPORTED

		m_TaskCoverMoveNetworkHelper.SendRequest(bIgnoreMoverBlend ? ms_MotionTaskIgnoreMoverBlendRequestId : ms_MotionTaskRequestId);
		m_TaskCoverMoveNetworkHelper.SetSubNetwork(m_TaskMotionInCoverMoveNetworkHelper.GetNetworkPlayer(), ms_MotionTaskNetworkId);
	}
}

////////////////////////////////////////////////////////////////////////////////
void CTaskCover::AddBlockingObject( CPed* pPed )
{
	// Add navmesh blocking bound to prevent wandering peds from walking over peds in cover
	if(m_iDynamicObjectIndex == DYNAMIC_OBJECT_INDEX_NONE || m_iDynamicObjectIndex == DYNAMIC_OBJECT_INDEX_UNABLE_TO_ADD)
	{
		const u32 iFlags = TDynamicObject::BLOCKINGOBJECT_ALL_PATH_TYPES;

		Vector3 vPos = VEC3V_TO_VECTOR3(GetPed()->GetTransform().GetPosition());
		Vector3 vSize = (pPed->GetBoundingBoxMax() - pPed->GetBoundingBoxMin())/2;
		float heading = pPed->GetTransform().GetHeading();
		m_iDynamicObjectIndex = CPathServerGta::AddBlockingObject(vPos, vSize, heading, iFlags);
		m_iDynamicObjectLastUpdateTime = fwTimer::GetTimeInMilliseconds();
	}
}

void CTaskCover::UpdateBlockingObject( CPed* pPed )
{
	static dev_s32 iUpdateInterval = 1000;
	if(m_iDynamicObjectIndex != DYNAMIC_OBJECT_INDEX_NONE && m_iDynamicObjectIndex != DYNAMIC_OBJECT_INDEX_UNABLE_TO_ADD &&
		fwTimer::GetTimeInMilliseconds()-m_iDynamicObjectLastUpdateTime >= iUpdateInterval)
	{
		Vector3 vPos = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		Vector3 vSize = (pPed->GetBoundingBoxMax() - pPed->GetBoundingBoxMin())/2;
		float heading = pPed->GetTransform().GetHeading();
		CPathServerGta::UpdateBlockingObject(m_iDynamicObjectIndex, vPos, vSize, heading, false);
		m_iDynamicObjectLastUpdateTime = fwTimer::GetTimeInMilliseconds();
	}
}

void CTaskCover::RemoveBlockingObject()
{
	//Clean up blocking object
	if(m_iDynamicObjectIndex != DYNAMIC_OBJECT_INDEX_NONE && m_iDynamicObjectIndex != DYNAMIC_OBJECT_INDEX_UNABLE_TO_ADD)
	{
		CPathServerGta::RemoveBlockingObject(m_iDynamicObjectIndex);
		m_iDynamicObjectIndex = DYNAMIC_OBJECT_INDEX_NONE;
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsWeaponClipSetLoaded(bool bSwitchingWeapons) const 
{ 
	const CPed& rPed = *GetPed();
	const CWeaponInfo* pWeaponInfo = rPed.GetCurrentWeaponInfoForHeldObject();
	if (!bSwitchingWeapons)
	{
		if (pWeaponInfo)
		{
			const fwMvClipSetId& weaponClipSet = pWeaponInfo->GetAppropriateWeaponClipSetId(&rPed);
			if(weaponClipSet != CLIP_SET_ID_INVALID)
			{
				const fwClipSet* pWeaponClipSet = fwClipSetManager::GetClipSet(weaponClipSet);
				if(taskVerifyf(pWeaponClipSet, "ClipSet [%s] does not exist", weaponClipSet.TryGetCStr()))
				{
					if(!pWeaponClipSet->IsStreamedIn_DEPRECATED())
					{
						return false;
					}
				}
			}
		}
	}
	
	fwMvClipSetId weaponAimingClipsetId = CTaskCover::GetWeaponClipSetForArmament(&rPed, !rPed.IsAPlayerPed());
	if (weaponAimingClipsetId == CLIP_SET_ID_INVALID || CTaskCover::IsCoverClipSetLoaded(weaponAimingClipsetId))
	{
		return true;
	}
#if __BANK
	SpewStreamingDebugToTTY(rPed, weaponAimingClipsetId);
#endif // __BANK

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsCurrentWeaponClipSetLoaded() const
{ 
	const CWeaponInfo* pCurrentWeaponInfo = GetPed()->GetCurrentWeaponInfoForHeldObject();
	if (pCurrentWeaponInfo)
	{
		fwMvClipSetId currentObjectWeaponAimingClipsetId = pCurrentWeaponInfo->GetPedCoverWeaponClipSetId(*GetPed());
		if (currentObjectWeaponAimingClipsetId == CLIP_SET_ID_INVALID || CTaskCover::IsCoverClipSetLoaded(currentObjectWeaponAimingClipsetId))
		{
			return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::GetCoverPointPosition(const Vector3 &vThreatPos, CPed* pPed, Vector3& vCoverCoors, Vector3& vVantagePos )
{
	taskFatalAssertf(pPed->GetCoverPoint(), "Null coverpoint passed into GetCoverPointPosition");
	Vector3 vDirection = vThreatPos - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	vDirection.z = 0.0f;
	vDirection.Normalize();
	if(CCover::FindCoordinatesCoverPoint(pPed->GetCoverPoint(), pPed,  vDirection, vCoverCoors, &vVantagePos ) )
	{
		// Pull the cover position up to the peds root position rather than the ground, as its mostly
		// used for comparison at that height
		vCoverCoors.z += 1.0f;
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::HasNavigationTaskFailed( CPed* pPed )
{
	CTaskComplexControlMovement* pControlMovementSubTask = static_cast<CTaskComplexControlMovement*>(FindSubTaskOfType(CTaskTypes::TASK_COMPLEX_CONTROL_MOVEMENT));
	if (pControlMovementSubTask)
	{
		aiTask* pMovementTask = pControlMovementSubTask->GetRunningMovementTask(pPed);
		if(pMovementTask && pMovementTask->GetTaskType() == CTaskTypes::TASK_MOVE_FOLLOW_NAVMESH)
		{
			// If the navmesh task is unable to find a route
			CTaskMoveFollowNavMesh* pNavmeshTask = static_cast<CTaskMoveFollowNavMesh*>(pMovementTask);
			if(pNavmeshTask->IsUnableToFindRoute())
			{
				return true;
			}

			if (m_CoverFlags.IsFlagSet(CF_PutPedDirectlyIntoCover))
			{
				return false;
			}

			// If script are putting a ped into cover, don't bother testing intersections along the route
			if (m_SeekCoverFlags.IsFlagSet(CF_ScriptedSeekCover))
			{
				return false;
			}

			if (m_fTestSpheresIntersectingRouteTimer < 0.0f)
			{
				m_fTestSpheresIntersectingRouteTimer = ms_Tunables.m_TimeBetweenTestSpheresIntersectingRoute;

				Vector3 vThreatPosition(Vector3::ZeroType);
				GetTarget().GetPosition(vThreatPosition);

				// When checking the distance we allow the ped to move 1m closer than current
				ScalarV scMinDist;
				if(m_fInitialDistToTarget < 0.0f)
				{
					Vec3V vecThreatPosition = RCC_VEC3V(vThreatPosition);
					Vec3V vPedToThreat = pPed->GetTransform().GetPosition() - vecThreatPosition;
					ScalarV scDistToThreat = Max(ScalarV(V_HALF), Mag(vPedToThreat) - ScalarV(V_ONE));
					scMinDist = ScalarVFromF32(CTaskCombat::ms_Tunables.m_TargetMinDistanceToRoute);
					if( IsLessThanAll(scDistToThreat, scMinDist ) )
					{
						scMinDist = scDistToThreat;
					}

					m_fInitialDistToTarget = scMinDist.Getf();
				}
				else
				{
					scMinDist = ScalarVFromF32(m_fInitialDistToTarget);
				}

				spdSphere pedSpheres[1];
				pedSpheres[0].Set( RCC_VEC3V(vThreatPosition), scMinDist);

#if DEBUG_DRAW
				TUNE_GROUP_BOOL(COVER_DEBUG, RENDER_THREAT_POSITION, false);
				if (RENDER_THREAT_POSITION)
				{
					CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vThreatPosition), scMinDist.Getf(), Color_red, 2000, 0, false);
				}
#endif // DEBUG_DRAW

				if(pNavmeshTask->TestSpheresIntersectingRoute(1, pedSpheres, true))
				{
					aiDebugf2("Failing ped 0x%p's route due to intersection", pPed);
					return true;
				}
			}
			else
			{
				m_fTestSpheresIntersectingRouteTimer -= GetTimeStep();
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::CheckForEnteringCover( CPed* pPed )
{
	taskFatalAssertf(pPed->GetCoverPoint(), "Valid coverpoint expected!");
	
	// If moving toward the final target, try to dive to the final point, this is only possible if
	// on the last stretch of the navigation route and the last line to the target is long enough to
	// play the dive clip
	CTaskComplexControlMovement* pControlMovementTask = static_cast<CTaskComplexControlMovement*>(FindSubTaskOfType(CTaskTypes::TASK_COMPLEX_CONTROL_MOVEMENT));
	if (!pControlMovementTask)
	{
		return false;
	}

	// Don't abort our ladder subtask to enter cover, we'll most likely end up falling off and the ped will endlessly try to get up
	// B*1877301
	if (pControlMovementTask->FindSubTaskOfType(CTaskTypes::TASK_USE_LADDER_ON_ROUTE))
	{
		return false;
	}

	if( !pPed->GetCoverPoint()->IsCoverPointMoving(0.01f) && pControlMovementTask)
	{
		Vector3 vCoverCoords(Vector3::ZeroType);
		if (!pPed->GetCoverPoint()->GetCoverPointPosition(vCoverCoords))
		{
			 return false;
		}

		// Find a pointer to the navmesh task
		aiTask* pMovementTask = pControlMovementTask->GetRunningMovementTask(pPed);
		if( pMovementTask && pMovementTask->GetTaskType() == CTaskTypes::TASK_MOVE_FOLLOW_NAVMESH )
		{
			CTaskMoveFollowNavMesh* pNavmeshTask = static_cast<CTaskMoveFollowNavMesh*>(pMovementTask);

			if ( pNavmeshTask->GetState() < CTaskMoveFollowNavMesh::NavBaseState_FollowingPath )
			{
				return false;
			}

			const Vector3 vPedPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
			const float fDistanceToCover =  ( vPedPosition - vCoverCoords ).XYMag();

			const float fCoverEntryMaxDistance = pPed->IsAPlayerPed() ? CTaskEnterCover::ms_Tunables.m_CoverEntryMaxDistance : CTaskEnterCover::ms_Tunables.m_CoverEntryMaxDistanceAI;
			if (CTaskEnterCover::ShouldPedUseAiEntryAnims(*pPed))
			{
				const float fStandEnterTestDistance = IsCoverFlagSet(CTaskCover::CF_StrafeToCover) ? CTaskEnterCover::ms_Tunables.m_CoverEntryStandStrafeDistance : CTaskEnterCover::ms_Tunables.m_CoverEntryStandDistance;
				if (fDistanceToCover <= fStandEnterTestDistance)
				{
					// Do standing entry
					return true;
				}
				else if (NetworkInterface::IsGameInProgress() || !IsCoverFlagSet(CTaskCover::CF_StrafeToCover))
				{
					// Force peds to use stand enters in network games and if we're not strafing to cover
					return false;
				}
				else if (IsCoverFlagSet(CTaskCover::CF_StrafeToCover) &&
					fDistanceToCover > CTaskEnterCover::ms_Tunables.m_CoverEntryMinDistanceAI && fDistanceToCover < fCoverEntryMaxDistance && 
					(CTaskEnterCover::IsPedAngleToCoverAcceptableForMovingEntry(*pPed) || CTaskEnterCover::ShouldPedDoStandingEntry(*pPed)))
				{
					// Do moving entry
					bool bWaitForFootPlant = CTaskEnterCover::ms_Tunables.m_WaitForFootPlant;

					if (bWaitForFootPlant && pPed->GetMotionData()->GetIsStill())
					{
						bWaitForFootPlant = false;
					}

					bool bCanEnter = false;
					Vector3 vTestPos = vCoverCoords + Vector3(0.0f,0.0f,1.0f);

					Vector3 vCapsuleZOffset(0.0f, 0.0f, ms_Tunables.m_CapsuleZOffset);
					Vector3 vPedPos = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
					if (bWaitForFootPlant)
					{
						CTaskMotionBase* pTask = pPed->GetCurrentMotionTask();
						if (pTask && pTask->GetTaskType() == CTaskTypes::TASK_MOTION_AIMING)
						{
							CMoveNetworkHelper& networkHelper = static_cast<CTaskMotionAiming*>(pTask)->GetMotionMoveNetworkHelper();
							if (networkHelper.IsNetworkActive())
							{
								m_bRightFootPlant = networkHelper.GetFootstep(CTaskHumanLocomotion::ms_AefFootHeelRId);
								if (m_bRightFootPlant || networkHelper.GetFootstep(CTaskHumanLocomotion::ms_AefFootHeelLId))
								{
									if (IsPathClearForPed(*pPed, vPedPos, vTestPos, vCapsuleZOffset, ArchetypeFlags::GTA_ALL_TYPES_MOVER))
									{
										bCanEnter = true;
									}
								}
							}
						}
					}
					else if (IsPathClearForPed(*pPed, vPedPos, vTestPos, vCapsuleZOffset, ArchetypeFlags::GTA_ALL_TYPES_MOVER))
					{
						bCanEnter = true;
					}

					return bCanEnter;
				}
			}

			// If the navmesh task is on the last phase of the route
			if( pNavmeshTask->GetProgress() == (pNavmeshTask->GetRouteSize()-1) )
			{
				Vector3 vStart, vEnd;
				// Check the distance to the target, if it is within 0.25m of the range of the dive clip, 
				// Dive to the finish
				if( pNavmeshTask->GetThisWaypointLine(pPed, vStart, vEnd ) )
				{
					// Always run on the last section if we're not strafing.
					if (!IsCoverFlagSet(CTaskCover::CF_StrafeToCover) && fDistanceToCover > CTaskEnterCover::ms_Tunables.m_CoverEntryMinDistance && fDistanceToCover < fCoverEntryMaxDistance && FindSubTaskOfType(CTaskTypes::TASK_ADDITIONAL_COMBAT_TASK))
					{
						((CTaskComplexControlMovement*)GetSubTask())->SetNewMainSubtask(rage_new CTaskDoNothing(-1));

						// At this point we need to make sure we are at least running as walking here looks bad
						if(m_fMoveBlendRatio < MOVEBLENDRATIO_RUN)
						{
							((CTaskComplexControlMovement*)GetSubTask())->SetMoveBlendRatio(pPed, MOVEBLENDRATIO_RUN);
						}
					}
					
					// If we're within range of the cover intro and facing in the general cover direction, trigger the cover intro
					if (!IsCoverFlagSet(CTaskCover::CF_StrafeToCover) && fDistanceToCover <= fCoverEntryMaxDistance)
					{
						Vector3 vHeading = vPedPosition - vEnd;
						vHeading.Normalize();
						if( DotProduct(vHeading, VEC3V_TO_VECTOR3(pPed->GetTransform().GetB())) < 0.0f )
						{
							return true;
						}
					}				
				}
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::ComputeFacingDirection(const Vector3& vThreatPosition, bool& bFoundCloseCorner, bool bTestNormalIsSimilar)
{
	CPed* pPed = GetPed();

	// Work out direction the ped would face when they reach the cover
	const Vector3 vPedPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	const Vector3 vToTarget = vThreatPosition - vPedPosition;
	Vector3 vecTargetDir = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector(&RCC_VEC3V(vToTarget)));
	bool bFacingRight = false;
	m_fEndHeading = CTaskEnterCover::ChooseEndDirectionForPed(pPed, vecTargetDir, m_vCoverCoors, bFacingRight, bFoundCloseCorner, bTestNormalIsSimilar);

	// Set the cover flag
	m_CoverFlags.ChangeFlag(CF_FacingLeft, !bFacingRight);
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsAtSearchPosition() const
{
	//Grab the ped.
	const CPed* pPed = GetPed();

	//Grab the ped position.
	Vec3V vPedPosition = pPed->GetTransform().GetPosition();

	//Grab the ped position (XY).
	Vec3V vPedPositionXY = vPedPosition;
	vPedPositionXY.SetZ(ScalarV(V_ZERO));

	//Grab the search position (XY).
	Vec3V vSearchPosition = VECTOR3_TO_VEC3V(m_vSearchPosition);
	Vec3V vSearchPositionXY = vSearchPosition;
	vSearchPositionXY.SetZ(ScalarV(V_ZERO));

	//Ensure the XY distance is within the threshold.
	float fMaxDistanceXY = CTaskMoveFollowNavMesh::ms_fTargetRadius;
	float fMaxDistanceXYSq = square(fMaxDistanceXY);
	ScalarV scMaxDistanceXYSq = ScalarVFromF32(fMaxDistanceXYSq);
	ScalarV scDistanceXYSq = DistSquared(vPedPositionXY, vSearchPositionXY);
	if(IsGreaterThanAll(scDistanceXYSq, scMaxDistanceXYSq))
	{
		return false;
	}

	//Grab the ped position (Z).
	ScalarV scPedPositionZ = vPedPosition.GetZ();

	//Grab the search position (Z).
	ScalarV scSearchPositionZ = vSearchPosition.GetZ();

	//Ensure the Z distance is within the threshold.
	float fMaxDistanceZ = 2.0f;
	ScalarV scMaxDistanceZ = ScalarVFromF32(fMaxDistanceZ);
	ScalarV scDistanceZ = Abs(Subtract(scPedPositionZ, scSearchPositionZ));
	if(IsGreaterThanAll(scDistanceZ, scMaxDistanceZ))
	{
		return false;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::CheckForCoverExit() const
{
	if (GetTimeInState() >= CTaskEnterCover::ms_Tunables.m_EnterCoverInterruptMinTime)
	{
		const CPed& ped = *GetPed();
		if (m_TaskCoverMoveNetworkHelper.IsNetworkActive() && ped.IsLocalPlayer() && ped.GetCoverPoint())
		{
			const CControl* pControl = ped.GetControlFromPlayer();
			if (pControl)
			{

				// Allow exiting if we pressed to exit			
				Vector2 vecStick(pControl->GetPedWalkLeftRight().GetNorm(), -pControl->GetPedWalkUpDown().GetNorm());
				vecStick *= 128.0f;
				static dev_float sf_MinStickThreshold = 80.0f*80.0f;
				const bool bExitCoverPressed = pControl->GetPedCover().IsPressed() 
					|| (pControl->GetValue(INPUT_SPRINT).IsDown() && (vecStick.Mag2() >= sf_MinStickThreshold));
				if (bExitCoverPressed)
				{
					Vector3 vCoverPosition(Vector3::ZeroType);
					if (ped.GetCoverPoint()->GetCoverPointPosition(vCoverPosition))
					{
						if (CTaskMotionInCover::IsPedCloseEnoughToCover(ped, vCoverPosition, CTaskEnterCover::ms_Tunables.m_EnterCoverInterruptDistanceTolerance))
						{
							Vector3 vCoverDirection = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector());
							if (CTaskMotionInCover::IsPedsheadingCloseEnoughToFacingDirection(ped, vCoverDirection, IsCoverFlagSet(CTaskCover::CF_FacingLeft), CTaskEnterCover::ms_Tunables.m_EnterCoverInterruptHeadingTolerance))
							{
								return true;
							}			
						}
					}
				}
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsLocalPlayerEnteringCloseCover() const
{
	const CPed* pPed = GetPed();
	if(!pPed->IsAPlayerPed())
	{
		CPed* pPlayerPed = CGameWorld::FindLocalPlayer();
		if(pPlayerPed && pPlayerPed->GetPedResetFlag(CPED_RESET_FLAG_IsEnteringCover) && pPlayerPed->GetCoverPoint() && pPed->GetCoverPoint())
		{
			Vector3 vMyCoverCoords(Vector3::ZeroType);
			Vector3 vPlayerCoverCoords(Vector3::ZeroType);
			if( pPed->GetCoverPoint()->GetCoverPointPosition(vMyCoverCoords) &&
				pPlayerPed->GetCoverPoint()->GetCoverPointPosition(vPlayerCoverCoords) )
			{
				ScalarV scCoverToCoverDistSq = DistSquared(VECTOR3_TO_VEC3V(vMyCoverCoords), VECTOR3_TO_VEC3V(vPlayerCoverCoords));
				ScalarV scMinCoverToCoverDistSq = ScalarVFromF32(ms_Tunables.m_MinCoverToPlayerCoverDist);
				scMinCoverToCoverDistSq = scMinCoverToCoverDistSq * scMinCoverToCoverDistSq;
				if(IsLessThanAll(scCoverToCoverDistSq, scMinCoverToCoverDistSq))
				{
					ScalarV scDistToMyCoverSq = DistSquared(VECTOR3_TO_VEC3V(vMyCoverCoords), pPed->GetTransform().GetPosition());
					ScalarV scMaxDistToCoverSq = ScalarVFromF32(ms_Tunables.m_MaxDistToCoverWhenPlayerIsClose);
					scMaxDistToCoverSq = scMaxDistToCoverSq * scMaxDistToCoverSq;
					if(IsGreaterThanAll(scDistToMyCoverSq, scMaxDistToCoverSq))
					{
						return true;
					}
				}
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::ActivateTimeslicing()
{
	TUNE_GROUP_BOOL(COVER, ACTIVATE_TIMESLICING, true);

	if(ACTIVATE_TIMESLICING)
	{
		GetPed()->GetPedAiLod().ClearBlockedLodFlag(CPedAILod::AL_LodTimesliceIntelligenceUpdate);
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskCover::ProcessClearFPSCoverHelpText()
{
	// Clear the help text
	if (m_bHelpTextNeedsClearing)
	{
		// Ideally there would be helper functions to query whether the label being shown is the one we started, resort to a string comparison...
		char TestString[2 * MAX_CHARS_IN_MESSAGE];
		char *pMainString = TheText.Get("FP_COVER_HLP");

		CMessages::InsertNumbersAndSubStringsIntoString(pMainString, 
			NULL, 0, 
			NULL, 0, 
			TestString, NELEM(TestString) );

		if (strcmp(TestString, CHelpMessage::GetMessageText(HELP_TEXT_SLOT_STANDARD)) == 0)
		{
			CHelpMessage::Clear(HELP_TEXT_SLOT_STANDARD, false);
		}
		m_bHelpTextNeedsClearing = false;
	}
}


float CTaskCover::GetDesiredHeadingForPedWithCoverPoint(const CPed* pPed, const CCoverPoint* pCoverPoint) const
{
	if(!taskVerifyf(pPed, "NULL ped passed in."))
	{
		return 0.0f;
	}

	if(!taskVerifyf(pCoverPoint, "NULL cover point passed in."))
	{
		return 0.0f;
	}

	const Vector3 vCoverDirection = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector());

	float fEndHeading = rage::Atan2f(-vCoverDirection.x, vCoverDirection.y);

	if (IsCoverFlagSet(CTaskCover::CF_SpecifyInitialHeading))
	{
		if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
		{
			fEndHeading += HALF_PI;
		}
		else
		{
			fEndHeading -= HALF_PI;
		}
	}
	else
	{
		const bool bShouldFaceLeft = pCoverPoint->PedClosestToFacingLeft(*pPed);
		if (bShouldFaceLeft)
		{
			fEndHeading += HALF_PI;
		}
		else
		{
			fEndHeading -= HALF_PI;
		}
	}

	return fwAngle::LimitRadianAngle(fEndHeading);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::CheckForCoverEntry()
{
	bool bWantsToDoCoverSearch = false; 

	const CPed& ped = *GetPed();
	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_TIME_IN_STATE_FOR_REENTRY, 0.25f, 0.0f, 1.0f, 0.01f);
	if (ped.IsLocalPlayer() && GetTimeInState() > MIN_TIME_IN_STATE_FOR_REENTRY)
	{
		const CControl *pControl = ped.GetControlFromPlayer();
		if(pControl)
		{
			CTaskPlayerOnFoot* pPlayerTask = static_cast<CTaskPlayerOnFoot*>(ped.GetPedIntelligence()->FindTaskDefaultByType(CTaskTypes::TASK_PLAYER_ON_FOOT));
			if (pPlayerTask)
			{
				if (pControl->GetPedCover().IsPressed())
				{
					pPlayerTask->SetLastTimeEnterCoverPressed(fwTimer::GetTimeInMilliseconds());
					bWantsToDoCoverSearch = true;
				}
				else
				{
					bWantsToDoCoverSearch = pPlayerTask->HasValidEnterCoverInput(*pControl);
				}
			}
		}
	}

	if (!bWantsToDoCoverSearch)
	{
		return false;
	}

	// Will need to recompute cover point as we probably don't want to re-enter the same cover point.
	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_EXIT_COVER)
	{
		if (GetSubTask()->GetState() == CTaskExitCover::State_CornerExit)
		{
			CPed& rPed = *GetPed();
			if (m_TaskUseCoverMoveNetworkHelper.IsNetworkActive() && m_TaskUseCoverMoveNetworkHelper.GetBoolean(ms_CoverSearchInterruptId) && rPed.IsLocalPlayer())
			{
				Vector3 vCurrentCoverPos;
				if (rPed.GetCoverPoint() && rPed.GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPos))
				{
					Vector3 vTestPos = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
					CCoverPoint newCoverPoint;
					bool bFoundNewCover = CPlayerInfo::ms_DynamicCoverHelper.FindNewCoverPoint(&newCoverPoint, &rPed, vTestPos);

					if (bFoundNewCover)
					{
						Vector3 vNewCoverPos;
						if (newCoverPoint.GetCoverPointPosition(vNewCoverPos))
						{
							bool bValidCover = true;

							TUNE_GROUP_FLOAT(PLAYER_COVER_TUNE, MIN_DIST_FROM_OLD_COVER, 1.0f, 0.0f, 4.0f, 0.01f);
							if (vNewCoverPos.Dist2(vCurrentCoverPos) < square(MIN_DIST_FROM_OLD_COVER))
							{
								// Don't accept cover in the same direction if it's really close
								Vector3 vCurrentCoverDir = VEC3V_TO_VECTOR3(rPed.GetCoverPoint()->GetCoverDirectionVector());
								Vector3 vNewCoverDir = VEC3V_TO_VECTOR3(newCoverPoint.GetCoverDirectionVector());
								TUNE_GROUP_FLOAT(PLAYER_COVER_TUNE, CLOSE_COVER_DIR_TOL, 0.85f, 0.0f, 1.0f, 0.01f);
								const float fCovDirDot = vNewCoverDir.Dot(vCurrentCoverDir);
								//aiDisplayf("fCovDirDot : %.2f", fCovDirDot);
								if (fCovDirDot > CLOSE_COVER_DIR_TOL)
								{
									bValidCover = false;
								}
							}

							if (bValidCover)
							{
								// Only accept cover that is roughly going forwards, going backwards from this pose doesn't look too good
								Vector3 vToNewCover = vNewCoverPos - vTestPos;
								vToNewCover.Normalize();
								Vector3 vPedForward = VEC3V_TO_VECTOR3(rPed.GetTransform().GetB());

								TUNE_GROUP_FLOAT(PLAYER_COVER_TUNE, ANGLE_FROM_PED_TOLERANCE, 0.65f, 0.0f, 1.0f, 0.01f);
								const float fDot = vToNewCover.Dot(vPedForward);
								//aiDisplayf("fDot : %.2f", fDot);
								if (fDot >= ANGLE_FROM_PED_TOLERANCE)
								{
									Vector3 vDesiredProtectionVector(0.0f, 1.0f, 0.0f);
									vDesiredProtectionVector.RotateZ(rPed.GetDesiredHeading());
									if (CTaskPlayerOnFoot::TestIfRouteToCoverPointIsClear(newCoverPoint, rPed, vDesiredProtectionVector))
									{
										rPed.SetCoverPoint(NULL);
										rPed.GetPlayerInfo()->GetDynamicCoverPoint()->Copy(newCoverPoint);
										rPed.SetCoverPoint(rPed.GetPlayerInfo()->GetDynamicCoverPoint());
										rPed.GetCoverPoint()->ReserveCoverPointForPed(&rPed);
										return true;
									}
								}
							}
						}
					}
				}
			}
			return false;
		}
	}

	if (m_TaskUseCoverMoveNetworkHelper.IsNetworkActive() && m_TaskUseCoverMoveNetworkHelper.GetBoolean(CTaskExitCover::ms_CoverBreakInterruptId))
	{
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::IsPathClearForPed(const CPed& ped, const Vector3& vStart, const Vector3& vEnd, const Vector3& vOffset, s32 iTypeFlags)
{
	if (ped.GetCapsuleInfo()->IsBiped())
	{
		return DoCapsuleTest(ped, vStart - vOffset, vEnd - vOffset, iTypeFlags) && DoCapsuleTest(ped, vStart + vOffset, vEnd + vOffset, iTypeFlags);
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskCover::DoCapsuleTest(const CPed& ped, const Vector3& vStart, const Vector3& vEnd, s32 iTypeFlags)
{
	float fRadius = ped.GetCapsuleInfo()->GetBipedCapsuleInfo()->GetRadius();
	WorldProbe::CShapeTestFixedResults<> capsuleResult;
	WorldProbe::CShapeTestCapsuleDesc capsuleDesc;
	capsuleDesc.SetResultsStructure(&capsuleResult);
	capsuleDesc.SetCapsule(vStart, vEnd, fRadius);
	capsuleDesc.SetIncludeFlags(iTypeFlags);
	capsuleDesc.SetExcludeEntity(&ped);	// Exclude ourself from the check
	capsuleDesc.SetTypeFlags(ArchetypeFlags::GTA_AI_TEST);
	capsuleDesc.SetIsDirected(true);
	capsuleDesc.SetDoInitialSphereCheck(true);
	WorldProbe::GetShapeTestManager()->SubmitTest(capsuleDesc);

	if (capsuleResult[0].GetHitDetected())
	{
#if DEBUG_DRAW
		CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), fRadius, Color_red, 2500, 0, false);
#endif // DEBUG_DRAW
		return false;
	}

#if DEBUG_DRAW
	CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), fRadius, Color_green, 2500, 0, false);
#endif // DEBUG_DRAW
	return true;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskCover::GetWeaponHoldingClipSetForArmament(const CPed* pPed, bool bIgnoreWeaponObjectCheck)
{
	if (pPed->GetMotionData()->GetOverrideMotionInCoverClipSet() != CLIP_SET_ID_INVALID)
	{
		return pPed->GetMotionData()->GetOverrideMotionInCoverClipSet();
	}

	if (weaponVerifyf(pPed->GetWeaponManager(), "NULL weapon manager for ped %s, should it be taking cover?", pPed->GetModelName()))
	{
		const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();

		if (pWeaponInfo && (bIgnoreWeaponObjectCheck || pPed->GetWeaponManager()->GetEquippedWeaponObject()))
		{
			return pWeaponInfo->GetCoverMovementClipSetHashForPed(*pPed);
		}
	}

	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskCover::GetWeaponHoldingExtraClipSetForArmament(const CPed& rPed)
{
	if (weaponVerifyf(rPed.GetWeaponManager(), "NULL weapon manager for ped %s, should it be taking cover?", rPed.GetModelName()))
	{
		const CWeaponInfo* pWeaponInfo = rPed.GetWeaponManager()->GetEquippedWeaponInfo();

		if (pWeaponInfo)
		{
			return pWeaponInfo->GetPedCoverMovementExtraClipSetId(rPed);
		}
	}

	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskCover::GetStreamedClipSetForArmament(const CPed* pPed, bool bForceUseOneHandedSetIfApplicable)
{
	if (weaponVerifyf(pPed->GetWeaponManager(), "NULL weapon manager for ped %s, should it be taking cover?", pPed->GetModelName()))
	{
		const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();

		if (pWeaponInfo)
		{
			if (!pWeaponInfo->GetIsMelee() && !pWeaponInfo->GetIsTwoHanded() && !pWeaponInfo->GetIsThrownWeapon() && (bForceUseOneHandedSetIfApplicable || !pPed->IsPlayer()))
			{ 
				return ms_Tunables.m_StreamedOneHandedCoverMovementClipSetId;
			}
			return pWeaponInfo->GetPedCoverMovementExtraClipSetId(*pPed);
		}
	}

	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskCover::GetWeaponClipSetForArmament(const CPed* pPed, bool bUseAIAimingAnims)
{
	if (bUseAIAimingAnims)
	{
		return GetAIAimingClipSetHashForArmament(pPed);
	}

	if (weaponVerifyf(pPed->GetWeaponManager(), "NULL weapon manager for ped %s, should it be taking cover?", pPed->GetModelName()))
	{
		const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();

		if (pWeaponInfo)
		{
			// B*2690251: Force third person animations on remote players
			return pWeaponInfo->GetPedCoverWeaponClipSetId(*pPed, pPed->IsNetworkClone() ? FPS_StreamThirdPerson : FPS_StreamDefault);
		}
	}

	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskCover::GetAIAimingClipSetHashForArmament(const CPed* pPed)
{
	weaponAssert(pPed->GetWeaponManager());
	const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();

	if (pWeaponInfo && pPed->GetWeaponManager()->GetEquippedWeaponObject())
	{
		if (pWeaponInfo->GetIsRpg())
		{
			return pWeaponInfo->GetPedCoverWeaponClipSetId(*pPed);
		}
		else if (pWeaponInfo->GetIs2HandedInCover() || pWeaponInfo->GetIsTwoHanded())
		{
			return ms_Tunables.m_AITwoHandedAimingClipSetId;
		}
		else if (pWeaponInfo->GetIsGun1Handed())
		{
			return ms_Tunables.m_AIOneHandedAimingClipSetId;
		}
	}

	return CLIP_SET_ID_INVALID;;
}

////////////////////////////////////////////////////////////////////////////////

int CTaskCover::ChooseStateToResumeTo() const
{
	//Check the previous state.
	int iPreviousState = GetPreviousState();
	switch(iPreviousState)
	{
		case State_MoveToCover:
		case State_MoveToSearchLocation:
		{
			return iPreviousState;
		}
		default:
		{
			return State_Start;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

#if !__FINAL
void CTaskCover::Debug() const
{
#if DEBUG_DRAW
	if (GetState() == State_EnterCover)
	{
		static Vec2V svStartPos(50.0f,100.0f);
		Vec2V vStartPos = svStartPos;
		char szText[256];
		Vector3 vCoverCoords;
		if (!GetPed()->IsNetworkClone())
		{
			vCoverCoords = m_vCoverCoors - Vector3(0.0f, 0.0f, 1.0f);
			formatf(szText, "m_vCoverCoords : (%.2f, %.2f, %.2f)", m_vCoverCoors.x, m_vCoverCoors.y, m_vCoverCoors.z);
		}
		else
		{
			if (GetNetCoverPointPosition(*GetPed(), vCoverCoords))
			{
				formatf(szText, "vNetCoverCoords : (%.2f, %.2f, %.2f)", vCoverCoords.x, vCoverCoords.y, vCoverCoords.z);
			}
			else
			{
				formatf(szText, "vNetCoverCoords : INVALID");
			}
		}
		grcDebugDraw::Text(vStartPos, DD_ePCS_Pixels, Color_green, szText);
		grcDebugDraw::Line(vCoverCoords, VEC3V_TO_VECTOR3(GetPed()->GetTransform().GetPosition()), Color_blue);
		grcDebugDraw::Sphere(vCoverCoords, 0.025f, Color_blue);
	}
#endif // DEBUG_DRAW

	static bool DRAW_DEBUG = false;
	if (DRAW_DEBUG)
	{
#if DEBUG_DRAW
	static Vec2V svStartPos(50.0f,75.0f);
	Vec2V vStartPos = svStartPos;
	static s32 iVerticalSpace = 10;

	u32 iNoTexts = 0;

	char szText[256];
	formatf(szText, "m_vCoverCoors  : (%.2f, %.2f, %.2f)", m_vCoverCoors.x, m_vCoverCoors.y, m_vCoverCoors.z);
	grcDebugDraw::Text(vStartPos, DD_ePCS_Pixels, Color_blue, szText);
	vStartPos.SetYf(svStartPos.GetYf() + ++iNoTexts*iVerticalSpace);

	const CPed* pPed = GetPed();

	if (pPed->IsLocalPlayer() && (GetState() == State_UseCover || GetState() == State_EnterCover))
	{
		CEntity* pEntity = CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity();
		if (pEntity)
		{
			char szText[128];
			formatf(szText, "Cover Entity : %s", pEntity->GetModelName());
			grcDebugDraw::Text(VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()), Color_blue, szText);
		}
		else
		{			
			grcDebugDraw::Text(VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()), Color_red, "No Cover Entity");
		}
	}

	grcDebugDraw::Sphere(m_vSearchPosition, 0.025f, Color_green);
	if (GetTarget().GetIsValid())
	{
		Vector3 vThreatPos(Vector3::ZeroType);
		if (GetTarget().GetPosition(vThreatPos))
		{
			grcDebugDraw::Sphere(vThreatPos, 0.025f, Color_red);
			grcDebugDraw::Line(pPed->GetTransform().GetPosition(), RCC_VEC3V(vThreatPos), Color_red);
		}
	}

	// Display the current cover point location
	Vector3 vCoverPos;
	Vector3 vDirUnused;
	if (CCover::FindCoverCoordinatesForPed(*pPed, vDirUnused, vCoverPos))
	{
		grcDebugDraw::Sphere(vCoverPos, 0.025f, Color_purple);
	}

	if (m_CoverFlags.IsFlagSet(CF_PutPedDirectlyIntoCover))
	{
		grcDebugDraw::Sphere(m_vSearchPosition, 0.025f, Color_green);
		grcDebugDraw::Line(GetPed()->GetTransform().GetPosition(), RCC_VEC3V(m_vSearchPosition), Color_green);
	}

	if (m_pCoverFinder && m_pCoverFinder->IsActive())
	{
		m_pCoverFinder->Debug(0);
	}
#endif // DEBUG_DRAW
}

	if (GetSubTask())
	{
		GetSubTask()->Debug();
	}
}
#endif // __FINAL

////////////////////////////////////////////////////////////////////////////////

// Statics
CTaskEnterCover::Tunables CTaskEnterCover::ms_Tunables;

IMPLEMENT_COMBAT_TASK_TUNABLES(CTaskEnterCover, 0xc78d6d74);

////////////////////////////////////////////////////////////////////////////////

const fwMvRequestId	CTaskEnterCover::ms_EnterCoverRequestId("EnterCover",0x1FC2024B);
const fwMvBooleanId CTaskEnterCover::ms_EnterCoverOnEnterId("EnterCover_OnEnter",0x800FA3A9);
const fwMvBooleanId CTaskEnterCover::ms_EnterCoverClipFinishedId("EnterCoverClipFinished",0xBA47CF1F);
const fwMvBooleanId CTaskEnterCover::ms_EnterCoverTransitionClipFinishedId("EnterCoverTransitionClipFinished",0x91558F68);
const fwMvBooleanId CTaskEnterCover::ms_EnterCoverInterruptId("EnterCoverInterrupt",0x6BCBBE1A);
const fwMvClipId	CTaskEnterCover::ms_EnterCoverClipId("EnterCoverClip",0xFB5431E5);
const fwMvClipId	CTaskEnterCover::ms_EnterCoverTransitionClipId("EnterCoverTransitionClip",0x18AFA88C);
const fwMvClipId	CTaskEnterCover::ms_EnterCoverWeaponClipId("EnterCoverWeaponClip",0xEC7E8C6D);
const fwMvClipId	CTaskEnterCover::ms_EnterCoverWeaponClip0Id("EnterCoverWeaponClip0",0x8C8F9DFA);
const fwMvClipId	CTaskEnterCover::ms_EnterCoverWeaponClip1Id("EnterCoverWeaponClip1",0xF5A9702C);
const fwMvClipId	CTaskEnterCover::ms_EnterCoverWeaponClip2Id("EnterCoverWeaponClip2",0xE7EBD4B1);
const fwMvFloatId	CTaskEnterCover::ms_EnterCoverClipInitialPhaseId("EnterCoverClipInitialPhase",0x5F40A7FA);
const fwMvFloatId	CTaskEnterCover::ms_EnterCoverClipCurrentPhaseId("EnterCoverClipCurrentPhase",0xDDA71587);
const fwMvFloatId	CTaskEnterCover::ms_EnterCoverClipRateId("EnterCoverClipRate",0x80BB236E);
const fwMvFloatId	CTaskEnterCover::ms_AngleToCoverId("AngleToCover",0x78C49F1C);
const fwMvFlagId	CTaskEnterCover::ms_AIEntryFlagId("AIEntry",0x4841CA10);
const fwMvFlagId	CTaskEnterCover::ms_FromStandFlagId("FromStand",0xFBEB7D55);
const fwMvRequestId CTaskEnterCover::ms_AITransitionId("AITransition",0x5C6DECA9);
const fwMvFloatId	CTaskEnterCover::ms_AIEntryRateId("AIEntryRate",0xA7C6A93);

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskEnterCover::Tunables::GetSlidingEnterCoverAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (CTaskMotionInCover::ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_SlidingEnterCoverAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_SlidingEnterCoverAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskEnterCover::Tunables::GetPlayerStandEnterCoverAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (CTaskMotionInCover::ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_PlayerStandEnterCoverAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_PlayerStandEnterCoverAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::IsPedAngleToCoverAcceptableForMovingEntry(const CPed& ped)
{
	const CCoverPoint* pCoverPoint = ped.GetCoverPoint();
	if (pCoverPoint)
	{
		Vector3 vCoverPos(Vector3::ZeroType);
		if (pCoverPoint->GetCoverPointPosition(vCoverPos))
		{
			const Vector3 vPedPos = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
			Vector3 vToCover = vPedPos - vCoverPos;
#if DEBUG_DRAW
			const float fToCoverMag = vToCover.Mag();
#endif 
			Vector3 vCoverDir = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector());
			vToCover.Normalize();

			for (s32 i=0; i<3; ++i)
			{
				vCoverDir.RotateZ(HALF_PI);
#if DEBUG_DRAW
				Vector3 vExtentLine = vCoverDir;
				vExtentLine.RotateZ(-ms_Tunables.m_AiEntryHalfAngleTolerance);
				vExtentLine.Scale(fToCoverMag);
				CTask::ms_debugDraw.AddLine(VECTOR3_TO_VEC3V(vCoverPos), VECTOR3_TO_VEC3V(vCoverPos + vExtentLine), Color_blue, 2000);
				vExtentLine = vCoverDir;
				vExtentLine.RotateZ(ms_Tunables.m_AiEntryHalfAngleTolerance);
				vExtentLine.Scale(fToCoverMag);
				CTask::ms_debugDraw.AddLine(VECTOR3_TO_VEC3V(vCoverPos), VECTOR3_TO_VEC3V(vCoverPos + vExtentLine), Color_blue, 2000);
#endif
				const float fDot = vToCover.Dot(vCoverDir);
				const float fAngle = Abs(rage::AcosfSafe(fDot));
				if (fAngle < ms_Tunables.m_AiEntryHalfAngleTolerance)
				{
#if DEBUG_DRAW
					CTask::ms_debugDraw.AddLine(VECTOR3_TO_VEC3V(vPedPos), VECTOR3_TO_VEC3V(vCoverPos), Color_green, 2000);
#endif
					return true;
				}
			}

#if DEBUG_DRAW
			CTask::ms_debugDraw.AddLine(VECTOR3_TO_VEC3V(vPedPos), VECTOR3_TO_VEC3V(vCoverPos), Color_red, 2000);
#endif
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::ShouldPedDoStandingEntry(const CPed& ped)
{
	const CCoverPoint* pCoverPoint = ped.GetCoverPoint();
	if (pCoverPoint)
	{
		Vector3 vCoverPos(Vector3::ZeroType);
		if (pCoverPoint->GetCoverPointPosition(vCoverPos))
		{
			const Vector3 vPedPos = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
			Vector3 vToCover = vPedPos - vCoverPos;

			// Ignore angle check if really close to cover
			const float fToCoverMag = vToCover.Mag();
			if (fToCoverMag < ms_Tunables.m_CoverEntryMinDistance)
			{
				return true;
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::GetFacingDirectionIfEdgeCover(const CCoverPoint& coverPoint, bool& bShouldFaceLeft)
{
	if (coverPoint.GetUsage() == CCoverPoint::COVUSE_WALLTOLEFT)
	{
		bShouldFaceLeft = false;
		return true;
	}
	else if (coverPoint.GetUsage() == CCoverPoint::COVUSE_WALLTORIGHT)
	{
		bShouldFaceLeft = true;
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::GetFacingDirectionIfBlocked(const CPed& ped, const Vector3& vCoverPosition, const Vector3& vDir, bool& bShouldFaceLeft, bool bIsLowCover, bool bReturnFalseIfNotBlockedLaterally)
{
	taskAssertf(ped.IsLocalPlayer(), "Ped isn't local player");

	// Test left
	Vector3 vLeft = vDir;
	vLeft.RotateZ(HALF_PI);

	s32 iClosestLeftLateralObstructionDetectedIndex = -1;
	s32 iClosestRightLateralObstructionDetectedIndex = -1;
	s32 iClosestLeftForwardClearIndex = -1;
	s32 iClosestRightForwardClearIndex = -1;

	TUNE_GROUP_INT(COVER_TUNE, MAX_INDEX_TO_CONSIDER_DOOR_DIRECTION, 2, 0, 10, 1);
	TUNE_GROUP_INT(COVER_TUNE, NUM_TESTS_PER_SIDE, 3, 0, 10, 1);
	TUNE_GROUP_FLOAT(COVER_TUNE, SIDE_OFFSET_INTERVAL, 0.75f, 0.0f, 2.0f, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, TEST_DEPTH, 2.0f, 0.0f, 10.0f, 0.1f);
	TUNE_GROUP_FLOAT(COVER_TUNE, LATERAL_Z_OFFSET, 0.2f, 0.0f, 1.0f, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, FORWARD_Z_OFFSET, 0.8f, 0.0f, 1.0f, 0.01f);
	Vector3 vPreviousStartPosition(Vector3::ZeroType);
	Vector3 vIntersectionPos(Vector3::ZeroType);

	for (s32 i=0; i<NUM_TESTS_PER_SIDE; ++i)
	{
		Vector3 vStart = vCoverPosition + vLeft * SIDE_OFFSET_INTERVAL * float(i) - Vector3(0.0f, 0.0f, LATERAL_Z_OFFSET);

		if (i > 0)
		{
			s32 iHitComponentIndex = -1;
			const phInst* pHitInst = CDynamicCoverHelper::DoLineProbeTest(vPreviousStartPosition, vStart, vIntersectionPos, &iHitComponentIndex);
			if (CheckIfHitVehicleCoverDoor(*pHitInst, iHitComponentIndex))
			{
				pHitInst = NULL;
			}

#if DEBUG_DRAW
			CCoverDebug::ms_searchDebugDraw.AddLine(RCC_VEC3V(vPreviousStartPosition), RCC_VEC3V(vStart), pHitInst ? Color_red : Color_green, 2000);
#endif // DEBUG_DRAW
			if (pHitInst)
			{
				iClosestLeftLateralObstructionDetectedIndex = i;
				break;
			}
		}

		vPreviousStartPosition = vStart;

		if (i > 0)
		{
			Vector3 vEnd = vStart + vDir * TEST_DEPTH;
			vStart.z += FORWARD_Z_OFFSET;
			vEnd.z += FORWARD_Z_OFFSET;
			const phInst* pHitInst2 = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPos);
			if (i < MAX_INDEX_TO_CONSIDER_DOOR_DIRECTION && CheckIfHitDoor(*pHitInst2))
			{
				bShouldFaceLeft = true;
				return true;
			}
#if DEBUG_DRAW
			CCoverDebug::ms_searchDebugDraw.AddLine(RCC_VEC3V(vStart), pHitInst2 ? RCC_VEC3V(vIntersectionPos) : RCC_VEC3V(vEnd), pHitInst2 ? Color_red : Color_green, 2000);
#endif // DEBUG_DRAW
			if (!pHitInst2 && iClosestLeftForwardClearIndex < 0)
			{
				iClosestLeftForwardClearIndex = i;
			}
		}
	}

	// Test right
	Vector3 vRight = vDir;
	vRight.RotateZ(-HALF_PI);
	for (s32 i=0; i<NUM_TESTS_PER_SIDE; ++i)
	{
		Vector3 vStart = vCoverPosition + vRight * SIDE_OFFSET_INTERVAL * float(i) - Vector3(0.0f, 0.0f, LATERAL_Z_OFFSET);

		if (i > 0)
		{
			s32 iHitComponentIndex = -1;
			const phInst* pHitInst = CDynamicCoverHelper::DoLineProbeTest(vPreviousStartPosition, vStart, vIntersectionPos, &iHitComponentIndex);
			if (CheckIfHitVehicleCoverDoor(*pHitInst, iHitComponentIndex))
			{
				pHitInst = NULL;
			}
#if DEBUG_DRAW
			CCoverDebug::ms_searchDebugDraw.AddLine(RCC_VEC3V(vPreviousStartPosition), RCC_VEC3V(vStart), pHitInst ? Color_red : Color_green, 2000);
#endif // DEBUG_DRAW
			if (pHitInst)
			{
				iClosestRightLateralObstructionDetectedIndex = i;
				break;
			}
		}

		vPreviousStartPosition = vStart;

		if (i > 0)
		{
			Vector3 vEnd = vStart + vDir * TEST_DEPTH;
			vStart.z += FORWARD_Z_OFFSET;
			vEnd.z += FORWARD_Z_OFFSET;
			const phInst* pHitInst2 = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPos);
			if (i < MAX_INDEX_TO_CONSIDER_DOOR_DIRECTION && CheckIfHitDoor(*pHitInst2))
			{
				bShouldFaceLeft = false;
				return true;
			}
	#if DEBUG_DRAW
			CCoverDebug::ms_searchDebugDraw.AddLine(RCC_VEC3V(vStart), pHitInst2 ? RCC_VEC3V(vIntersectionPos) : RCC_VEC3V(vEnd), pHitInst2 ? Color_red : Color_blue, 2000);
	#endif // DEBUG_DRAW
			if (!pHitInst2 && iClosestRightForwardClearIndex < 0)
			{
				iClosestRightForwardClearIndex = i;
			}
		}
	}

	TUNE_GROUP_INT(COVER_TUNE, MAX_CLEAR_INDEX_TO_CHOOSE_OPPOSITE_OBSTRUCTED, 3, 0, 4, 1);
	// See if we detected a left obstruction and no right obstruction, we'll face right in this case
	if (iClosestLeftLateralObstructionDetectedIndex > 0 && iClosestRightLateralObstructionDetectedIndex < 0)
	{
		// If no nearby forward obstructions were detected to the right, face right
		if (iClosestRightForwardClearIndex > -1 && iClosestRightForwardClearIndex < MAX_CLEAR_INDEX_TO_CHOOSE_OPPOSITE_OBSTRUCTED)
		{
			bShouldFaceLeft = false;
			return true;
		}
	}
	
	// See if we detected a right obstruction and no left obstruction, we'll face left in this case
	if (iClosestRightLateralObstructionDetectedIndex > 0 && iClosestLeftLateralObstructionDetectedIndex < 0)
	{
		// If no nearby forward obstructions were detected to the left, face left
		if (iClosestLeftForwardClearIndex > -1 && iClosestLeftForwardClearIndex < MAX_CLEAR_INDEX_TO_CHOOSE_OPPOSITE_OBSTRUCTED)
		{
			bShouldFaceLeft = true;
			return true;
		}
	}

	if (bReturnFalseIfNotBlockedLaterally)
	{
		return false;
	}
	
	CEntity* pCoverEntity = CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity();
	if (!pCoverEntity || !pCoverEntity->GetIsTypeVehicle())
	{
		if (bShouldFaceLeft)
		{
			// If no forward obstructions were detected to the left, face left
			if (iClosestLeftForwardClearIndex == 1)
			{
				bShouldFaceLeft = true;
				return true;
			}

			// If no forward obstructions were detected to the right, face right
			if (iClosestRightForwardClearIndex == 1)
			{
				bShouldFaceLeft = false;
				return true;
			}
		}
		else
		{			
			// Tie-break, don't choose facing direction
			if (NetworkInterface::IsGameInProgress() && bIsLowCover && iClosestRightForwardClearIndex == iClosestLeftForwardClearIndex)
			{
				return false;
			}

			// If no forward obstructions were detected to the right, face right
			if (iClosestRightForwardClearIndex == 1)
			{
				bShouldFaceLeft = false;
				return true;
			}

			// If no forward obstructions were detected to the left, face left
			if (iClosestLeftForwardClearIndex == 1)
			{
				bShouldFaceLeft = true;
				return true;
			}
		}
	}

	if (ped.GetCoverPoint() && ped.GetCoverPoint()->GetHeight() == CCoverPoint::COVHEIGHT_TOOHIGH)
	{
		TUNE_GROUP_INT(COVER_TUNE, MAX_CLEAR_INDEX_TO_CHOOSE_CURRENT_DIRECTION, 2, 0, 4, 1);
		// If we're going to face left, but the right is clear at some point
		// check and see if the left is kinda clear too, if not, face right
		if (bShouldFaceLeft && iClosestRightForwardClearIndex > -1 && iClosestRightForwardClearIndex < NUM_TESTS_PER_SIDE)
		{
			if (iClosestLeftForwardClearIndex < 0 || iClosestLeftForwardClearIndex > MAX_CLEAR_INDEX_TO_CHOOSE_CURRENT_DIRECTION)
			{
				bShouldFaceLeft = false;
			}
		}
		// If we're going to face right, but the left is clear at some point
		// check and see if the right is kinda clear too, if not, face left
		else if (iClosestLeftForwardClearIndex > -1 && iClosestLeftForwardClearIndex < NUM_TESTS_PER_SIDE)
		{
			if (iClosestRightForwardClearIndex < 0 || iClosestRightForwardClearIndex > MAX_CLEAR_INDEX_TO_CHOOSE_CURRENT_DIRECTION)
			{
				bShouldFaceLeft = true;
			}
		}
		return true;
	}

	// See if we detected obstructions in both directions, choose the direction with the furthest away obstruction
	if (iClosestLeftLateralObstructionDetectedIndex > 0 && iClosestRightLateralObstructionDetectedIndex > 0)
	{
		bShouldFaceLeft = iClosestLeftLateralObstructionDetectedIndex > iClosestRightLateralObstructionDetectedIndex ? true : false;
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::CheckIfHitVehicleCoverDoor(const phInst& rHitInst, s32 iHitComponentIndex)
{
	CEntity* pCoverEntity = CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity();
	if (pCoverEntity && pCoverEntity->GetIsTypeVehicle())
	{
		const CEntity* pHitEntity = static_cast<const CEntity*>(CPhysics::GetEntityFromInst(&rHitInst));
		if (pHitEntity == pCoverEntity && iHitComponentIndex > -1)
		{
			CVehicle& rVeh = *static_cast<CVehicle*>(pCoverEntity);
			fragInst* thisFragInst = rVeh.GetFragInst();
			if (thisFragInst)
			{
				// Check to see if the impact is with any of the door components
				for (s32 i=0; i<CVehicle::MAX_NUM_DOOR_COMPONENTS; i++)
				{
					const s32 iBoneIndex = rVeh.GetBoneIndex(CVehicle::ms_aDoorComponentIds[i]);
					if (iHitComponentIndex == thisFragInst->GetComponentFromBoneIndex(iBoneIndex))
					{
						// Ensure the door is open
						const CCarDoor* pCarDoor = rVeh.GetDoorFromBoneIndex(iBoneIndex);
						if (pCarDoor && pCarDoor->GetDoorRatio() > CTaskEnterVehicle::ms_Tunables.m_DoorRatioToConsiderDoorOpen)
						{
							return true;
						}
					}
				}
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::CheckIfHitDoor(const phInst& rHitInst)
{
	const CEntity* pHitEntity = static_cast<const CEntity*>(CPhysics::GetEntityFromInst(&rHitInst));
	if (pHitEntity && pHitEntity->GetIsTypeObject() && ((CObject*)pHitEntity)->IsADoor())
	{
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::PrestreamAiCoverEntryAnims(const CPed& ped)
{
	if (!ped.IsAPlayerPed())
	{		
		const fwMvClipSetId aimingEntryClipset = CTaskEnterCover::GetAiEntryClipsetFromWeapon(ped);
		CTaskCover::RequestCoverClipSet(aimingEntryClipset, SP_High);
		const fwMvClipSetId transitionClipset = CTaskEnterCover::GetAiTransitionClipsetFromWeapon(ped);
		CTaskCover::RequestCoverClipSet(transitionClipset, SP_High);
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::AreCoreCoverClipsetsLoaded(CPed* pPed)
{
	// If out weapon holding clipset is invalid return true (e.g. when using the base set only)
	fwMvClipSetId weaponHoldingClipsetId = CTaskCover::GetWeaponHoldingClipSetForArmament(pPed);
	if (weaponHoldingClipsetId != CLIP_SET_ID_INVALID)
	{
		if (!CTaskCover::IsCoverClipSetLoaded(weaponHoldingClipsetId))
		{
			return false;
		}
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::AreAICoverEntryClipsetsLoaded(const CPed& ped)
{
	if (ms_Tunables.m_DisableAiCoverEntryStreamCheck)
		return false;

	if (!NetworkInterface::IsGameInProgress())
	{
		fwMvClipSetId aimingEntryClipset = GetAiEntryClipsetFromWeapon(ped);
		if (!CTaskCover::IsCoverClipSetLoaded(aimingEntryClipset))
		{
			return false;
		}
	}

	fwMvClipSetId transitionClipset = GetAiTransitionClipsetFromWeapon(ped);
	if (!CTaskCover::IsCoverClipSetLoaded(transitionClipset))
	{
		return false;
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskEnterCover::ChooseEndDirectionForPed( CPed* pPed, Vector3& vCoverDir, const Vector3& UNUSED_PARAM(vCoverCoords), bool& bOutFacingRight, bool& bFoundCloseCorner, bool bTestNormalIsSimilar )
{
	float fEndHeading = rage::Atan2f(-vCoverDir.x, vCoverDir.y);
	bFoundCloseCorner = false;

	bool bIsDynamicCoverPoint = pPed->IsLocalPlayer() && pPed->GetPlayerInfo()->GetDynamicCoverPoint() == pPed->GetCoverPoint();
	// Estimate the correct direction to enter cover
	if( pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTORIGHT )
	{
		bOutFacingRight = false;
		fEndHeading += HALF_PI;
		return fEndHeading;
	}
	else if( pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTOLEFT )
	{
		bOutFacingRight = true;
		fEndHeading -= HALF_PI;
		return fEndHeading;
	}
	// We don't know which direction to face based on this coverpoint.
	// So try to find a nearby coverpoint that's facing in a particular direction
	else if( bIsDynamicCoverPoint )
	{
		Vector3 vThisCoverPointPos;
		pPed->GetCoverPoint()->GetCoverPointPosition(vThisCoverPointPos);
		Vector3 vTarget = (vCoverDir*10.0f) + vThisCoverPointPos;
		Vector3 vTargetDir = vCoverDir;
		CCoverPoint* pCoverPoint = CCover::FindClosestCoverPoint( pPed, vThisCoverPointPos, &vTarget, CCover::CS_ANY, CCoverPoint::COVTYPE_NONE, NULL, false );
		if( pCoverPoint && pCoverPoint->GetType() != CCoverPoint::COVTYPE_OBJECT )
		{
			Vector3 vDirection;
			Vector3 vPosition;
			pCoverPoint->GetCoverPointPosition(vPosition);
			vDirection = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector(&RCC_VEC3V(vTarget)));

			bool bCanUseStaticCoverDirection = true;
			if (bTestNormalIsSimilar)
			{
				Vector3 vPlayerCoverDirection = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector(&RCC_VEC3V(vTarget)));
				TUNE_GROUP_FLOAT(COVER_TUNE, ACCEPT_STATIC_COVER_DIR_DOT, 0.75f, -1.0f, 1.0f, 0.01f);
				const float fPlayerVsStaticDot = vPlayerCoverDirection.Dot(vDirection);
				if (fPlayerVsStaticDot < ACCEPT_STATIC_COVER_DIR_DOT)
				{
					bCanUseStaticCoverDirection = false;
					aiDisplayf("Frame %i: Not using static cover point direction because it's not orientated in the same direction as our own, dot %.2f", fwTimer::GetFrameCount(), fPlayerVsStaticDot);
				}
			}

			if (bCanUseStaticCoverDirection)
			{
				Vector3 vCoverRight = vTargetDir;
				vCoverRight.RotateZ(HALF_PI);
				Vector3 vToCover = vPosition - vThisCoverPointPos;
				vToCover.z = 0.0f;
				vToCover.Normalize();

				dev_float NEARBY_COVER_SIDEWAYS_DOT_TOLERANCE = 0.707f;
				dev_float NEARBY_COVER_FORWARDS_DOT_TOLERANCE = 0.707f;
				dev_float NEARBY_COVER_DISTANCE = 3.0f;
				if( ABS(vToCover.Dot(vTargetDir)) < NEARBY_COVER_SIDEWAYS_DOT_TOLERANCE &&
					vPosition.Dist2(vThisCoverPointPos) < rage::square(NEARBY_COVER_DISTANCE) )
				{
					if( vDirection.Dot(vTargetDir) > NEARBY_COVER_FORWARDS_DOT_TOLERANCE )
					{
						if( pCoverPoint->GetUsage() == CCoverPoint::COVUSE_WALLTORIGHT && vToCover.Dot(vCoverRight) > 0.0f)
						{
							bOutFacingRight = false;
							bFoundCloseCorner = true;
							fEndHeading += HALF_PI;
							return fEndHeading;
						}
						else if( pCoverPoint->GetUsage() == CCoverPoint::COVUSE_WALLTOLEFT && vToCover.Dot(vCoverRight) < 0.0f)
						{
							bOutFacingRight = true;
							bFoundCloseCorner = true;
							fEndHeading -= HALF_PI;
							return fEndHeading;
						}
					}
				}
			}
		}
	}

	//bool bApproachRight = false;

// 	if (!CTaskCover::ms_Tunables.m_UseNewDirectionalEntries)
// 	{
// 		// Wall to both or wall to neither, use the approach direction if we're not close
// 		if (vCoverCoords.Dist2(VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition())) > CTaskEnterCover::ms_Tunables.m_CoverEntryMinDistance*CTaskEnterCover::ms_Tunables.m_CoverEntryMinDistance)
// 		{
// 			ComputeApproachDirectionForPed(pPed, vCoverDir, vCoverCoords, bApproachRight);
// 			// Approaching from the right means we should face to the left
// 			bOutFacingRight = !bApproachRight;
// 		}
// 		else
// 		{
// 			// If we're close and just going to blend, base the facing direction on the peds facing direction
// 			ComputeCloseFacingDirectionForPed(pPed, vCoverDir, bOutFacingRight);
// 		}
// 	}

	if (bOutFacingRight)
	{
		fEndHeading -= HALF_PI;
	}
	else
	{
		fEndHeading += HALF_PI;
	}

	return fEndHeading;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ComputeApproachDirectionForPed(CPed* pPed, Vector3& vCoverDir, const Vector3& vCoverCoords, bool& bApproachFromRight)
{
	// Calculate the direction based on the peds position relative to the cover (if approaching from the right, end up facing right)
	Vector3 vCoverNormal = vCoverDir;
	vCoverNormal.z = 0.0f;
	vCoverNormal.Normalize();

	Vector3 vPedToCover = vCoverCoords - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	vPedToCover.z = 0.0f;
	vPedToCover.Normalize();

	// Use the z component of the vector at right angles to the normal and to cover vector to determine the approach direction
	vCoverNormal.Cross(vPedToCover);

	if (vCoverNormal.z < 0.0f)
	{
		bApproachFromRight = false;
	}
	else
	{
		bApproachFromRight = true;
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ComputeCloseFacingDirectionForPed(CPed* pPed, const Vector3& vCoverDir, bool& bFacingRight)
{
	// Calculate the facing direction based on the peds direction relative to the cover (if facing to the right, end up facing right)
	Vector3 vCoverNormal = vCoverDir;
	vCoverNormal.Normalize();

	Vector3 vPedForward = VEC3V_TO_VECTOR3(pPed->GetTransform().GetB());
	vPedForward.Normalize();

	// Use the z component of the vector at right angles to the normal and peds forward vector to determine the facing direction
	vCoverNormal.Cross(vPedForward);

	if (vCoverNormal.z < 0.0f)
	{
		bFacingRight = false;
	}
	else
	{
		bFacingRight = true;
	}
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipId CTaskEnterCover::FindAIIntroClipFromFlags(const atArray<EnterClip>& aEnterClips, s32 flags)
{
	for (s32 i=0; i<aEnterClips.GetCount(); i++)
	{
		if (aEnterClips[i].m_Flags == flags)
		{
			return aEnterClips[i].m_EnterClipId;
		}
	}
	return CLIP_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::FindStandIntroClipFromFlags(const atArray<StandingEnterClips>& aEnterClips, atArray<fwMvClipId>& aClipIdsOut, s32 flags)
{
	for (s32 i=0; i<aEnterClips.GetCount(); i++)
	{
		if (aEnterClips[i].m_Flags == flags)
		{
			aClipIdsOut.PushAndGrow(aEnterClips[i].m_StandClip0Id);
			aClipIdsOut.PushAndGrow(aEnterClips[i].m_StandClip1Id);
			aClipIdsOut.PushAndGrow(aEnterClips[i].m_StandClip2Id);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

s32 CTaskEnterCover::ComputeEnterCoverDirection(Vec3V_ConstRef vPedPos, Vec3V_ConstRef vCoverPos, Vec3V_ConstRef vCoverDir)
{
#if DEBUG_DRAW
	Vec3V vDebugCoverPos = vCoverPos;
	vDebugCoverPos.SetZf(vDebugCoverPos.GetZf() + 1.0f);
	CTask::ms_debugDraw.AddSphere(vDebugCoverPos, 0.05f, Color_orange, 2000);
	CTask::ms_debugDraw.AddLine(vDebugCoverPos, vPedPos, Color_blue, 2000);
	CTask::ms_debugDraw.AddSphere(vPedPos, 0.05f, Color_green, 2000);
	CTask::ms_debugDraw.AddLine(vDebugCoverPos, vDebugCoverPos + vCoverDir, Color_purple, 2000);
#endif

	// Zero out the z components
	Vec3V vFlatCoverPos = vCoverPos;
	vFlatCoverPos.SetZ(ScalarV(V_ZERO));
	
	Vec3V vFlatPedPos = vPedPos;
	vFlatPedPos.SetZ(ScalarV(V_ZERO));

	// Compute the xy vector from ped to cover
	Vec3V vToCover = Normalize(vFlatCoverPos - vFlatPedPos);

	// Compute the cosine of the angle between the cover direction and the ped to cover direction
	ScalarV scDotCoverToPed = Dot(vToCover, vCoverDir);

	// If we're quite perpendicular to the cover, use the central enter
	ScalarV scDotThresholdForCenterEnter = ScalarVFromF32(ms_Tunables.m_DotThresholdForCenterEnter);
	if (IsGreaterThanAll(scDotCoverToPed, scDotThresholdForCenterEnter))
	{
		return CTaskCover::AF_EnterCenter;
	}

	// Otherwise we are coming in from the left or right, determine which by considering the direction of 
	// the vector perpendicular to the cover direction and the ped to cover direction
	Vec3V vCrossCoverToPed = Cross(vToCover, vCoverDir);

#if DEBUG_DRAW
	CTask::ms_debugDraw.AddLine(vDebugCoverPos, vDebugCoverPos + vCrossCoverToPed, Color_purple, 2000);
#endif

	// We'll get back a vector pointing up or down depending on the direction we're at
	if (IsGreaterThanAll(vCrossCoverToPed.GetZ(), ScalarV(V_ZERO)))
	{
		return CTaskCover::AF_EnterLeft;
	}

	return 0;
}

////////////////////////////////////////////////////////////////////////////////

s32 CTaskEnterCover::ComputeStandingEnterCoverDirection(Vec3V_ConstRef vPedDir, Vec3V_ConstRef vCoverDir, float& fAngle, bool bUseFacingDirection)
{
	if (IsCoverFlagSet(CTaskCover::CF_SpecifyInitialHeading))
	{
		if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
		{
			return CTaskCover::AF_EnterLeft;
		}
		else
		{
			return 0;
		}
	}

	Vec3V vCoverDirection = vCoverDir;
	if (bUseFacingDirection)
	{
		static float ROTATE_ANGLE = HALF_PI;
		if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
		{
			vCoverDirection = RotateAboutZAxis(vCoverDirection, ScalarVFromF32(ROTATE_ANGLE));
		}
		else
		{
			vCoverDirection = RotateAboutZAxis(vCoverDirection, ScalarVFromF32(-ROTATE_ANGLE));
		}
	}

	// Compute the angle to cover
	const float fDot = Dot(vPedDir, vCoverDirection).Getf();
	//Displayf("Dot : %.4f", fDot);
	fAngle = AcosfSafe(fDot);
	//Displayf("Angle : %.4f", fAngle);

	Vec3V vCrossCoverDirPedDir = Cross(vPedDir, vCoverDirection);

	// We'll get back a vector pointing up or down depending on the direction we're at
	if (IsLessThanAll(vCrossCoverDirPedDir.GetZ(), ScalarV(V_ZERO)))
	{
		fAngle *= -1.0f;
		return CTaskCover::AF_EnterLeft;
	}
	return 0;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskEnterCover::GetAiEntryClipsetFromWeapon(const CPed& ped)
{
	if (weaponVerifyf(ped.GetWeaponManager(), "Ped %s doesn't have a weapon manager", ped.GetDebugName()))
	{
		const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfo();

		if (pWeaponInfo)
		{
			static bool USE_MODEL_TO_DETERMINE_CLIPSET = true;
			if (pWeaponInfo->GetIs2HandedInCover() || pWeaponInfo->GetIsTwoHanded())
			{
				if (USE_MODEL_TO_DETERMINE_CLIPSET)
				{
					return CPedType::IsSwatType(ped.GetPedType()) ? ms_Tunables.m_EnterCoverAIAimingSwat2H : ms_Tunables.m_EnterCoverAIAimingBase2H;
				}
				return ms_Tunables.m_EnableUseSwatClipSet ? ms_Tunables.m_EnterCoverAIAimingSwat2H : ms_Tunables.m_EnterCoverAIAimingBase2H;
			}
			else if (pWeaponInfo->GetIsGun1Handed())
			{
				if (USE_MODEL_TO_DETERMINE_CLIPSET)
				{
					return CPedType::IsSwatType(ped.GetPedType()) ? ms_Tunables.m_EnterCoverAIAimingSwat1H : ms_Tunables.m_EnterCoverAIAimingBase1H;
				}
				return ms_Tunables.m_EnableUseSwatClipSet ? ms_Tunables.m_EnterCoverAIAimingSwat1H : ms_Tunables.m_EnterCoverAIAimingBase1H;
			}
		}
	}

	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskEnterCover::GetAiTransitionClipsetFromWeapon(const CPed& ped)
{
	weaponAssert(ped.GetWeaponManager());
	const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfo();

	if (pWeaponInfo)
	{
		if (pWeaponInfo->GetIs2HandedInCover() || pWeaponInfo->GetIsTwoHanded())
		{
			return ms_Tunables.m_EnterCoverAITransition2H;
		}
		else if (pWeaponInfo->GetIsGun1Handed())
		{
			return ms_Tunables.m_EnterCoverAITransition1H;
		}
	}

	return CLIP_SET_ID_INVALID;;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::ShouldPedUseAiEntryAnims(const CPed& ped)
{
	if (!ms_Tunables.m_EnableNewAICoverEntry)
	{
		return false;
	}

	if (ped.GetPedResetFlag(CPED_RESET_FLAG_BlockCustomAIEntryAnims))
	{
		return false;
	}

	if (!ped.IsAPlayerPed() && AreAICoverEntryClipsetsLoaded(ped))
	{
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::CheckForPlayerExit(const CPed& ped, const Vector3& vCoverPosition, const Vector3& vCoverDirection)
{
	if (ped.IsLocalPlayer() && !ped.GetPlayerInfo()->AreControlsDisabled())
	{
		// Make sure we're close enough to the cover to consider exiting
		Vector3 vPedPosition = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
		if ((vCoverPosition-vPedPosition).XYMag2() > rage::square(ms_Tunables.m_FromCoverExitDistance))
		{
			return false;
		}

		const CControl* pControl = ped.GetControlFromPlayer();
		if (pControl)
		{
			Vector2 vecStick(pControl->GetPedWalkLeftRight().GetNorm(), -pControl->GetPedWalkUpDown().GetNorm());
			vecStick *= 128.0f;

			// Allow exiting if we pressed to exit
			static dev_float sf_MinStickThreshold = 80.0f*80.0f;
			if (pControl->GetPedCover().IsPressed() || (pControl->GetValue(INPUT_SPRINT).IsDown() && (vecStick.Mag2() >= sf_MinStickThreshold) ))
			{
				return true;
			}

			// Allow exiting if we're pulling away from the cover
			vecStick.Rotate(camInterface::GetGameplayDirector().GetFrame().ComputeHeading());
			vecStick.Rotate(-rage::Atan2f(-vCoverDirection.x, vCoverDirection.y));
			if (vecStick.y < CTaskInCover::ms_Tunables.m_InputYAxisQuitValue)
			{
				return true;
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

const CPed* CTaskEnterCover::GetPedBlockingMyCover(const CPed& rPed, const Vector3& vPedCoverPos, bool bUsePedPosition)
{
	const Vector3 vMyPedPos = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
	const bool bNetworkGame = NetworkInterface::IsGameInProgress();
	const CEntityScannerIterator it = rPed.GetPedIntelligence()->GetNearbyPeds();
	for (const CEntity* pEntity = it.GetFirst(); pEntity; pEntity = it.GetNext())
	{
		if (pEntity->GetIsTypePed())
		{
			bool bTestDistance = false;

			Vector3 vOtherPedTestPos;
			const CPed& rOtherPed = *static_cast<const CPed*>(pEntity);
			const Vector3 vOtherPedPos = VEC3V_TO_VECTOR3(rOtherPed.GetTransform().GetPosition());
			if (bNetworkGame && rOtherPed.IsNetworkClone())
			{
				if (bUsePedPosition)
				{
					vOtherPedTestPos = vOtherPedPos;
				}
				else
				{
					const CTaskEnterCover* pEnterCoverTask = static_cast<const CTaskEnterCover*>(rOtherPed.GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_ENTER_COVER));
					if (pEnterCoverTask)
					{
						vOtherPedTestPos = pEnterCoverTask->GetCoverPosition();		
					}
					else
					{
						const CTaskInCover* pInCoverTask = static_cast<const CTaskInCover*>(rOtherPed.GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_IN_COVER));
						if (pInCoverTask)
						{
							vOtherPedTestPos = pInCoverTask->GetCoverCoords();
						}
						else
						{
							vOtherPedTestPos = vOtherPedPos;
						}
					}
				}
				bTestDistance = true;
			}
			else if (rOtherPed.GetPedResetFlag(CPED_RESET_FLAG_IsEnteringCover))
			{
				bTestDistance = true;
				if (rOtherPed.GetCoverPoint())
				{		
					rOtherPed.GetCoverPoint()->GetCoverPointPosition(vOtherPedTestPos);
					bUsePedPosition = false;
				}
				else
				{
					vOtherPedTestPos = vOtherPedPos;
				}
			}

			if (bTestDistance)
			{
				// If the other peds cover and the player cover are close enough we might end up overlapping, see if the other ped is going into cover
				// if they're within 1.5m abort going into cover
				const Vector3 vDiffBetweenOtherPositionAndPedCover = vOtherPedTestPos - vPedCoverPos;
				if (bUsePedPosition || vDiffBetweenOtherPositionAndPedCover.Mag2() < rage::square(CTaskPlayerOnFoot::sm_Tunables.m_DistanceBetweenAiPedsCoverAndPlayersCover))
				{
					const Vector3 vDistToCover = vOtherPedTestPos - vOtherPedPos;
					if (bUsePedPosition || vDistToCover.Mag2() < rage::square(CTaskPlayerOnFoot::sm_Tunables.m_MaxDistanceAiPedFromTheirCoverToAbortPlayerEnterCover))
					{
						if (bNetworkGame && rOtherPed.IsNetworkClone())
						{
							// If we are closer, then don't abort
							const Vector3 vMyDistToCover = vMyPedPos - vPedCoverPos;
							const Vector3 vOtherDistToCover = vOtherPedPos - vPedCoverPos;
							if (vMyDistToCover.Mag2() < vOtherDistToCover.Mag2())
							{
								continue;
							}
						}
						return &rOtherPed;
					}
				}
			}
		}
	}
	return NULL;
}

////////////////////////////////////////////////////////////////////////////////

CTaskEnterCover::CTaskEnterCover(const Vector3& vPosition, const float endDirection, const bool bCheckCoverDistance )
: m_vTargetPos(vPosition)
, m_fEndDirection(endDirection)
, m_fEnterDirection(0.0f)
, m_fInitialHeading(0.0f)
, m_fInitialPhase(-1.0f)
, m_fTranslationFixUpStartPhase(-1.0f)
, m_fTranslationFixUpEndPhase(-1.0f)
, m_fRotationFixUpStartPhase(-1.0f)
, m_fRotationFixUpEndPhase(-1.0f)
, m_bCheckCoverDistance(bCheckCoverDistance)
, m_bHasReachedHeading(false)
, m_bHasReachedPosition(false)
, m_vInitialPosition(Vector3::ZeroType)
, m_pMoveNetworkHelper(NULL)
, m_bUseShortestRotationAngle(false)
, m_vInitialPos(V_ZERO)
, m_vIdealInitialPos(V_ZERO)
, m_qInitialRot(V_IDENTITY)
, m_qIdealInitialRot(V_IDENTITY)
, m_bComputedIdealStartTransform(false)
, m_fBlendedInPhase(1.0f)
, m_fEstBlendedInPhase(-1.0f)
, m_bRightFootPlant(false)
, m_bUseFastRate(false)
, m_bForceCloneQuit(false)
, m_bApproachLeft(false)
, m_bSetApproachDirection(false)
, m_bShouldDoInitialHeadingLerp(false)
, m_fTimeNotMovingToTarget(0.0f)
#if FPS_MODE_SUPPORTED
, m_fTimeSinceEnteringCameraLerpRange(0.0f)
#endif // FPS_MODE_SUPPORTED
{
	SetInternalTaskType(CTaskTypes::TASK_ENTER_COVER);
}

////////////////////////////////////////////////////////////////////////////////

CTaskEnterCover::CTaskEnterCover()
: m_vTargetPos(VEC3_ZERO)
, m_fEndDirection(0.0f)
, m_fEnterDirection(0.0f)
, m_fInitialHeading(0.0f)
, m_fInitialPhase(-1.0f)
, m_fTranslationFixUpStartPhase(-1.0f)
, m_fTranslationFixUpEndPhase(-1.0f)
, m_fRotationFixUpStartPhase(-1.0f)
, m_fRotationFixUpEndPhase(-1.0f)
, m_bCheckCoverDistance(false)
, m_bHasReachedHeading(false)
, m_bHasReachedPosition(false)
, m_vInitialPosition(Vector3::ZeroType)
, m_pMoveNetworkHelper(NULL)
, m_bUseShortestRotationAngle(false)
, m_vInitialPos(V_ZERO)
, m_vIdealInitialPos(V_ZERO)
, m_qInitialRot(V_IDENTITY)
, m_qIdealInitialRot(V_IDENTITY)
, m_bComputedIdealStartTransform(false)
, m_fBlendedInPhase(1.0f)
, m_fEstBlendedInPhase(-1.0f)
, m_bRightFootPlant(false)
, m_bUseFastRate(false)
, m_bForceCloneQuit(false)
, m_bApproachLeft(false)
, m_bSetApproachDirection(false)
, m_bShouldDoInitialHeadingLerp(false)
, m_fTimeNotMovingToTarget(0.0f)
#if FPS_MODE_SUPPORTED
, m_fTimeSinceEnteringCameraLerpRange(0.0f)
#endif // FPS_MODE_SUPPORTED
{
	SetInternalTaskType(CTaskTypes::TASK_ENTER_COVER);
}

////////////////////////////////////////////////////////////////////////////////

CTaskEnterCover::~CTaskEnterCover()
{

}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::CleanUp()
{
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::ProcessPreFSM()
{
#if __ASSERT
	if (!taskVerifyf(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_COVER, "Parent task wans't CTaskCover"))
	{
		return FSM_Quit;
	}
#endif // __ASSERT

	CPed* pPed = GetPed();
	if (!pPed->IsNetworkClone() && !pPed->GetCoverPoint())
	{
		return FSM_Quit;
	}

	// Update the clone's target pos if the local ped is stood on a vehicle
	if (pPed->IsNetworkClone())
	{
		Vector3 vCoverPos(VEC3_ZERO);
		if (GetNetIsStoodOnVehicle(*pPed) && GetNetCoverPointPosition(*pPed, vCoverPos))
		{
			m_vTargetPos = vCoverPos;
		}
	}

	if (m_pMoveNetworkHelper && m_pMoveNetworkHelper->IsNetworkAttached())
	{
		// Overide the rate at which we play the clips
		//m_pMoveNetworkHelper->SetFloat(ms_IntroRateId, pPed->IsPlayer() ? ms_Tunables.m_CoverEntryRatePlayer : ms_Tunables.m_CoverEntryRateAI);
	}

	m_CoreStreamedClipsetRequestHelper.Request(CTaskCover::ms_Tunables.GetStreamedUnarmedCoverMovementClipSetIdForPed(*pPed));

	fwMvClipSetId weaponStreamedClipsetId = CTaskCover::GetStreamedClipSetForArmament(pPed, true);
	if (weaponStreamedClipsetId != CLIP_SET_ID_INVALID)
	{
		m_WeaponStreamedClipsetRequestHelper.Request(weaponStreamedClipsetId);
	}

	if (CTaskEnterCover::ShouldPedUseAiEntryAnims(*pPed))
	{
		CTaskEnterCover::PrestreamAiCoverEntryAnims(*pPed);
	}

	pPed->SetPedResetFlag( CPED_RESET_FLAG_DisableCellphoneAnimations, true);
	pPed->SetPedResetFlag( CPED_RESET_FLAG_DisableGaitReduction, true);
	pPed->SetPedResetFlag( CPED_RESET_FLAG_DisableDynamicCapsuleRadius, true);	
	pPed->SetPedResetFlag( CPED_RESET_FLAG_DisableSteeringAroundVehicles, true);
	pPed->SetPedResetFlag( CPED_RESET_FLAG_DisableSteeringAroundObjects, true);
	pPed->SetPedResetFlag( CPED_RESET_FLAG_DisableSteeringAroundNavMeshEdges, true);
	pPed->SetPedResetFlag( CPED_RESET_FLAG_IsEnteringCover, true);
	pPed->SetPedResetFlag( CPED_RESET_FLAG_ProcessPreRender2, true );
	pPed->SetPedResetFlag( CPED_RESET_FLAG_DisableIndependentMoverFrame, true );
	
	ProcessCheckForWeaponReload();

	if (!pPed->IsAPlayerPed())
	{
		pPed->SetPedResetFlag( CPED_RESET_FLAG_AICoverEntryRunning, true);
	}

	if(CPedAILodManager::IsTimeslicingEnabled())
	{
		pPed->GetPedAiLod().SetForceNoTimesliceIntelligenceUpdate(true);
	}

	if (pPed->IsLocalPlayer())
	{
		if (GetState() == State_Sliding)
		{
			TUNE_GROUP_FLOAT(COVER_TUNE, MIN_DIST_TO_COVER_TO_CHECK_FOR_BREAK_OUT, 2.0f, 0.0f, 5.0f, 0.01f);
			Vector3 vPedPos = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
			const float fToCoverDistSqd = vPedPos.Dist2(m_vTargetPos);
			if (fToCoverDistSqd > square(MIN_DIST_TO_COVER_TO_CHECK_FOR_BREAK_OUT))
			{
				TUNE_GROUP_FLOAT(COVER_TUNE, VEL_DIFF_TO_CONSIDER_NOT_MOVING, 1.0f, 0.0f, 5.0f, 0.01f);
				const float fVelSqd = pPed->GetVelocity().Mag2() + square(VEL_DIFF_TO_CONSIDER_NOT_MOVING);
				const float fDesiredVelSqd = pPed->GetDesiredVelocity().Mag2();
				if (fVelSqd < fDesiredVelSqd)
				{
					m_fTimeNotMovingToTarget += fwTimer::GetTimeStep();
				}
			}
		}	

#if FPS_MODE_SUPPORTED
		Vector3 vPedPos = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		const float fToCoverDistSqd = vPedPos.Dist2(m_vTargetPos);
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MIN_DIST_TO_COVER_TO_DO_CAMERA_LERP_LOW, 1.0f, 0.0f, 10.0f, 0.01f);
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MIN_DIST_TO_COVER_TO_DO_CAMERA_LERP_HIGH, 0.7f, 0.0f, 10.0f, 0.01f);
		const float fMinDistToDoCameraLerp = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) ? MIN_DIST_TO_COVER_TO_DO_CAMERA_LERP_HIGH : MIN_DIST_TO_COVER_TO_DO_CAMERA_LERP_LOW;
		if (fToCoverDistSqd < square(fMinDistToDoCameraLerp))
		{
			m_fTimeSinceEnteringCameraLerpRange += fwTimer::GetTimeStep();
		}
		else
		{
			m_fTimeSinceEnteringCameraLerpRange = 0.0f;
		}

		if (m_pMoveNetworkHelper && m_pMoveNetworkHelper->IsNetworkActive())
		{
			const float fMvCamHeading = CTaskCover::ComputeMvCamHeadingForPed(*pPed);
			m_pMoveNetworkHelper->SetFloat(CTaskMotionInCover::ms_CamHeadingId, IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? fMvCamHeading : 1.0f - fMvCamHeading);
		}
#endif // FPS_MODE_SUPPORTED

		//update cover direction if this is round cover
		if (!m_bHasReachedPosition && pPed->GetPlayerInfo()->IsRoundCover())
		{
			float fCachedEndDirection = m_fEndDirection;
			Vector3 vCoverDirection = CPlayerInfo::ms_DynamicCoverHelper.ProcessRoundCoverDirection(pPed, pPed->GetPlayerInfo()->GetRoundCoverCenter());
			m_fEndDirection = rage::Atan2f(-vCoverDirection.x, vCoverDirection.y);
			m_fEndDirection += IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? HALF_PI : -HALF_PI;
			m_fEndDirection = fwAngle::LimitRadianAngle(m_fEndDirection);

			//Don't change direction if the change is too drastic
			TUNE_GROUP_FLOAT(COVER_TUNE, fThreshold, 1.0f, -10.0f, 10.0f, 0.1f);

			float fDiff = fwAngle::LimitRadianAngle(fCachedEndDirection - m_fEndDirection);
			if ((fDiff > fThreshold) || (fDiff < (fThreshold * -1.0f)))
			{
				m_fEndDirection = fCachedEndDirection;
			}
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ProcessPreRender2()
{
	CTaskCover::UpdateLeftHandIk(GetPed());
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::UpdateFSM( const s32 iState, const FSM_Event iEvent )
{
	FSM_Begin

		FSM_State(State_Start)
			FSM_OnUpdate
				return Start_OnUpdate();	

		FSM_State(State_StreamAssets)
			FSM_OnUpdate
				return StreamAssets_OnUpdate();

		FSM_State(State_OrientateToCover)
			FSM_OnUpdate
				return OrientateToCover_OnUpdate();

		FSM_State(State_StartCoverNetwork)
			FSM_OnEnter
				return StartCoverNetwork_OnEnter();
			FSM_OnUpdate
				return StartCoverNetwork_OnUpdate();

		FSM_State(State_Sliding)
			FSM_OnEnter
				return Sliding_OnEnter();
			FSM_OnUpdate
				return Sliding_OnUpdate();

		FSM_State(State_StandEntry)
			FSM_OnEnter
				return StandEntry_OnEnter();
			FSM_OnUpdate
				return StandEntry_OnUpdate();

		FSM_State(State_MovingEntry)
			FSM_OnEnter
				return MovingEntry_OnEnter();
			FSM_OnUpdate
				return MovingEntry_OnUpdate();

		FSM_State(State_TransitionToIdle)
			FSM_OnEnter
				return TransitionToIdle_OnEnter();
			FSM_OnUpdate
				return TransitionToIdle_OnUpdate();
		
		FSM_State(State_Finish)
			FSM_OnUpdate
				return Finish_OnUpdate();

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

CTaskInfo* CTaskEnterCover::CreateQueriableState() const
{
	return rage_new CClonedCoverIntroInfo(m_fEndDirection, m_bUseFastRate);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ReadQueriableState(CClonedFSMTaskInfo* pTaskInfo)
{
	Assert( pTaskInfo->GetTaskInfoType() == CTaskInfo::INFO_TYPE_COVER_INTRO_CLONED_FSM );
	CTaskFSMClone::ReadQueriableState(pTaskInfo);

	CClonedCoverIntroInfo* pIntroInfo = SafeCast(CClonedCoverIntroInfo, pTaskInfo);

	m_fEndDirection = pIntroInfo->GetEndDirection();

	m_bUseFastRate = pIntroInfo->GetUseFastRate();
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::FindMoverFixUpPhases(const crClip* pClip)
{
	if (!pClip)
		return false;

	bool bFoundTranslationFixup = false;

	if (m_fTranslationFixUpStartPhase < 0.0f)
	{
		if (!CClipEventTags::FindMoverFixUpStartEndPhases(pClip, m_fTranslationFixUpStartPhase, m_fTranslationFixUpEndPhase, true))
		{
			m_fTranslationFixUpStartPhase = 0.0f;
			m_fTranslationFixUpEndPhase = 0.8f;
		}
		else
		{
			bFoundTranslationFixup = true;
		}
	}

	if (m_fRotationFixUpStartPhase < 0.0f)
	{
		if (!CClipEventTags::FindMoverFixUpStartEndPhases(pClip, m_fRotationFixUpStartPhase, m_fRotationFixUpEndPhase, false))
		{
			m_fRotationFixUpStartPhase = 0.8f;
			m_fRotationFixUpEndPhase = 1.0f;
		}
	}
	return bFoundTranslationFixup;
};

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ScaleTranslationalVelocity(float& fDesiredSpeed, const crClip* pClip, float fClipPhase, float fDistToCover)
{
	if (!pClip)
		return;

	if (!m_bHasReachedPosition && fDistToCover > ms_Tunables.m_CoverEntryPositionReachedTol)
	{
		Vector3 vTranslation = fwAnimHelpers::GetMoverTrackTranslationDiff(*pClip, fClipPhase, 1.0f);
		float fClipDist = vTranslation.Mag();

		float fScale = 0.0f;

		if (fClipDist > ms_Tunables.m_MinDistToScale)
		{
			//Displayf("Dist To Cover : %.4f, Remaining In Clip : %.4f, Phase : %.4f", fDistToCover, fClipDist, fClipPhase);
			fScale = fDistToCover / fClipDist;
			//Displayf("Scale : %.4f", fScale);
			fScale = rage::Clamp(fScale, ms_Tunables.m_MinTransScale, ms_Tunables.m_MaxTransScale);
			//Displayf("Scale Clamped : %.4f", fScale);
		}

		//Displayf("Speed : %.4f / Scaled Speed : %.4f", fDesiredSpeed, fScale*fDesiredSpeed);
		fDesiredSpeed *= fScale;
	}
	else
	{
		fDesiredSpeed = 0.0f;
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ScaleRotationalVelocity(float& fDesiredAngSpeed, const crClip* pClip, float fClipPhase, const Vector3& vToTarget, float fTimeStep, bool bLeftApproach, float fAngToCover, bool bUsingShortestAngleRotation)
{
	if (!pClip)
	{
		return;
	}

	CPed* pPed = GetPed();

	// During the initial blend in we force the ped to face cover
	if (ms_Tunables.m_DoInitialHeadingBlend && fClipPhase < m_fRotationFixUpStartPhase && !bUsingShortestAngleRotation)
	{
		const float fToCoverHeading = rage::Atan2f(-vToTarget.x, vToTarget.y);
		float fHeadingDiff = fToCoverHeading - pPed->GetCurrentHeading();
		fHeadingDiff = fwAngle::LimitRadianAngle(fHeadingDiff);
		const float fBlendInDuration = ms_Tunables.m_NetworkBlendInDuration;
		const float fCurrentDuration = fClipPhase * pClip->GetDuration();
		const float fInitialDuration = m_fInitialPhase * pClip->GetDuration();
		const float fRotationFixUpDuration = m_fRotationFixUpStartPhase * pClip->GetDuration();
		const float fRemainingBlendInDuration = rage::Min(fBlendInDuration - (fCurrentDuration - fInitialDuration), (fRotationFixUpDuration - fCurrentDuration));

		if (fRemainingBlendInDuration > 0.0f)
		{
			fDesiredAngSpeed = rage::Min(fHeadingDiff/fRemainingBlendInDuration, Abs(fHeadingDiff / fTimeStep));
			pPed->SetDesiredHeading(fToCoverHeading);
		}
		else
		{
			fDesiredAngSpeed = 0.0f;
		}
	}
	else if (ms_Tunables.m_DoFinalHeadingFixUp)
	{
		if (!m_bHasReachedHeading)
		{
			//Displayf("Angle To Cover : %.4f", fAngToCover);

			const float fDir = bLeftApproach ? -1.0f : 1.0f;

			// Make it go in the correct direction
			fDesiredAngSpeed = fDir * Min(Abs(fDesiredAngSpeed), Abs(fAngToCover/fTimeStep));

			const float fRemainingRotAnimTime = (m_fRotationFixUpEndPhase - fClipPhase) * pClip->GetDuration();
			//Displayf("Rot Time remaining : %.4f", fRemainingRotAnimTime);

			// Get the remaining orientation change left in the clip
			Quaternion qClipTotalRot(fwAnimHelpers::GetMoverTrackRotation(*pClip, fClipPhase));
			qClipTotalRot.Inverse();
			qClipTotalRot.Multiply(fwAnimHelpers::GetMoverTrackRotation(*pClip, 1.f));		

			// For rotation we're only interested in the heading
			Vector3 vClipRotEulers(Vector3::ZeroType);
			qClipTotalRot.ToEulers(vClipRotEulers);
			const float fRemainingRotation = fwAngle::LimitRadianAngle(vClipRotEulers.z);
			//Displayf("Remaining Rotation : %.4f", fRemainingRotation);

			if (fClipPhase >= m_fRotationFixUpStartPhase && (Abs(fRemainingRotation) >= ms_Tunables.m_CoverEntryMinAngleToScale))
			{
				float fScale = Abs(fAngToCover / fRemainingRotation);
				//Displayf("Rot Scale: %.4f", fScale);
				fScale = rage::Clamp(fScale, ms_Tunables.m_MinRotScale, ms_Tunables.m_MaxRotScale);
				//Displayf("Clamped Rot Scale: %.4f", fScale);
				fDesiredAngSpeed *= fScale;
			}
			else if (fClipPhase >= m_fRotationFixUpEndPhase && (Abs(fRemainingRotation) < ms_Tunables.m_CoverEntryMinAngleToScale))
			{
				fDesiredAngSpeed = fAngToCover / Max(fTimeStep, fRemainingRotAnimTime);
			}

			pPed->SetDesiredHeading(m_fEndDirection);
		}
		else
		{
			fDesiredAngSpeed = 0.0f;
		}
	}

	fDesiredAngSpeed = rage::Clamp(fDesiredAngSpeed, -ms_Tunables.m_MaxRotSpeed, ms_Tunables.m_MaxRotSpeed);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ComputeIdealStartTransformRelativeToTarget(Vec3V_Ref vIdealStartPosOffset, QuatV_Ref qIdealStartRotOffset, const crClip* pClip, float fStartPhase)
{
	if (taskVerifyf(pClip && m_fInitialPhase >= 0.0f, "Clip was null : %s, or initial phase invalid %.2f", pClip ? "FALSE" : "TRUE", m_fInitialPhase))
	{
		vIdealStartPosOffset = VECTOR3_TO_VEC3V(fwAnimHelpers::GetMoverTrackTranslationDiff(*pClip, 1.0f, fStartPhase));
		QuatV qStartRotation = QUATERNION_TO_QUATV(fwAnimHelpers::GetMoverTrackRotation(*pClip, fStartPhase));
		ScalarV scInitialHeadingOffset = -QuatVTwistAngle(qStartRotation, Vec3V(V_Z_AXIS_WONE));
		// Account for any initial z rotation
		vIdealStartPosOffset = RotateAboutZAxis(vIdealStartPosOffset, scInitialHeadingOffset);
		// Get the total z axis rotation over the course of the anim excluding the initial rotation
		QuatV qRotTotal = QUATERNION_TO_QUATV(fwAnimHelpers::GetMoverTrackRotationDiff(*pClip, 1.0f, fStartPhase));	
		ScalarV scTotalHeadingRotation = QuatVTwistAngle(qRotTotal, Vec3V(V_Z_AXIS_WONE));
		vIdealStartPosOffset = RotateAboutZAxis(vIdealStartPosOffset, scTotalHeadingRotation);
		qIdealStartRotOffset = QuatVFromZAxisAngle(scTotalHeadingRotation);
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ComputeTransformFromOffsetsSplat(Vec3V_Ref vPosOffsetInGlobalOut, QuatV_Ref qRotOffsetInGlobalOut, Mat34V_ConstRef targetMtx)
{
	vPosOffsetInGlobalOut = Transform(targetMtx, vPosOffsetInGlobalOut);
	QuatV qRotParent = QuatVFromMat34V(targetMtx);
	qRotOffsetInGlobalOut = Multiply(qRotOffsetInGlobalOut, qRotParent);
}

////////////////////////////////////////////////////////////////////////////////

Mat34V CTaskEnterCover::ComputeTargetMatrix(Vec3V_ConstRef vCoverPos, QuatV_Ref qTargetRot)
{
	// Get the cover point transform (raised up by 1m), rotate by 180 degrees as AI will end up facing away from cover
	Vec3V vTargetPos = vCoverPos + Vec3V(V_Z_AXIS_WZERO);
	qTargetRot = QuatVFromZAxisAngle(ScalarVFromF32(fwAngle::LimitRadianAngle(m_fEndDirection + PI)));

	// Create target matrix
	Mat34V targetMtx;
	Mat34VFromQuatV(targetMtx, qTargetRot, vTargetPos);
	return targetMtx;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::CheckForPlayerInterrupt() const
{
	const CPed& ped = *GetPed();
	if (ped.IsLocalPlayer() && m_pMoveNetworkHelper->GetBoolean(ms_EnterCoverInterruptId))
	{
		if (ped.GetCoverPoint())
		{
			Vector3 vCoverPosition(Vector3::ZeroType);
			if (ped.GetCoverPoint()->GetCoverPointPosition(vCoverPosition))
			{
				const Vector3 vCoverDirection = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector());
				const bool bIsFacingLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
				const Vector2 vStickInput = CTaskCover::ComputeStickInput(ped);
				bool bDisallowTurnUntilInputZeroed = false;
				if (CTaskMotionInCover::IsPedCloseEnoughToCover(ped, vCoverPosition, ms_Tunables.m_EnterCoverAimInterruptDistanceTolerance) &&
					CTaskMotionInCover::IsPedsheadingCloseEnoughToFacingDirection(ped, vCoverDirection, bIsFacingLeft, ms_Tunables.m_EnterCoverAimInterruptHeadingTolerance) &&
					(CTaskMotionInCover::PlayerCheckForMovingAbout(ped, bIsFacingLeft, vStickInput) ||
					CTaskMotionInCover::PlayerCheckForTurning(ped, bIsFacingLeft, IsCoverFlagSet(CTaskCover::CF_AtCorner), false, vStickInput, CTaskCover::ComputeCameraHeadingVec(ped), IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), false, bDisallowTurnUntilInputZeroed) ||
					CheckForPlayerExit(ped, vCoverPosition, vCoverDirection) ||
					ped.GetPlayerInfo()->IsAiming() ||
					ped.GetPlayerInfo()->IsFiring() ||
					static_cast<const CTaskCover*>(GetParent())->GetWantedToReloadDuringEntry()))
				{
					return true;
				}
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::CheckForNetworkInterrupt() const
{
	const CPed& ped = *GetPed();
	if (ped.IsNetworkClone() && m_pMoveNetworkHelper->GetBoolean(ms_EnterCoverInterruptId))
	{
		// quit the enter cover as soon as we can, so that we can catch up with what the main ped is doing
		if (!ped.GetPedIntelligence()->GetQueriableInterface()->IsTaskCurrentlyRunning(CTaskTypes::TASK_ENTER_COVER))
		{
			if (CTaskMotionInCover::IsPedCloseEnoughToCover(ped, m_vTargetPos, ms_Tunables.m_EnterCoverAimInterruptDistanceTolerance))
			{
				const float fHeadingDiff = fwAngle::LimitRadianAngle(m_fEndDirection - ped.GetCurrentHeading());

				if (Abs(fHeadingDiff) < 0.1f)
				{
					return true;
				}
			}
		}
	}
	return false;
}

//////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::CheckForWeaponRemoval(CPed* pPed, float fClipPhase)
{	
	// If the current weapon we have isn't usable in cover, be unarmed
#if !HACK_RDR3	
	const crClip* pClip = m_pMoveNetworkHelper->GetClip(ms_EnterCoverClipId);
	float fClearWeaponPhase = 0.5f;
	if (pClip)
	{
		CClipEventTags::FindEventPhase<crPropertyAttributeBool>(pClip, CClipEventTags::Object, CClipEventTags::Destroy, true, fClearWeaponPhase);	
	}

	// When the reload anim event happens, create the projectile 	
	if(fClipPhase >= fClearWeaponPhase && !pPed->IsNetworkClone())
	{
		const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();
		if (pWeaponInfo && !pWeaponInfo->GetUsableInCover())
		{
			//if (pWeaponInfo->GetIsMelee() || !pPed->GetWeaponManager()->EquipBestWeapon(true)) //now go unarmed B* 1357300
			{
				pPed->GetWeaponManager()->ClearBackupWeapon();
				pPed->GetWeaponManager()->BackupEquippedWeapon();
				pPed->GetWeaponManager()->EquipWeapon( pPed->GetDefaultUnarmedWeaponHash(), -1, true);
				m_pMoveNetworkHelper->SetFlag(false, fwMvFlagId("UseGripClip",0x72838804));
			}
		}
	}	
#endif
}

//////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ScaleDesiredVelocityToPreventOvershoot(const CPed& rPed, Vector3& vDesiredVelocity, const crClip* pClip, float fClipPhase, float fTimeStep)
{
	Vec3V vPedPos = rPed.GetTransform().GetPosition();
	// Compute flat xy vector to the cover point
	Vector3 vToTarget = m_vTargetPos - VEC3V_TO_VECTOR3(vPedPos);
	vToTarget.z = 0.0f;	
	const float fDistToCover = vToTarget.Mag();

	// Compute new direction to cover if we apply this velocity
	Vector3 vNewPos = VEC3V_TO_VECTOR3(vPedPos) + vDesiredVelocity*fTimeStep;
	Vector3 vNewToCover = m_vTargetPos - vNewPos;
	vNewToCover.z = 0.0f;

	float fNewDistToCover = vNewToCover.Mag();
	vNewToCover.Normalize();

	// Compute the initial direction to cover
	Vector3 vInitialToCover = m_vTargetPos - m_vInitialPosition;
	vInitialToCover.z = 0.0f;
	vInitialToCover.Normalize();

	// If the current to target is opposite from the initial we must have overshot the target position,
	// so scale it to go to the cover
	if (m_bHasReachedPosition || fNewDistToCover >= fDistToCover || vNewToCover.Dot(vInitialToCover) < 0.0f)
	{
		if (fDistToCover < ms_Tunables.m_InCoverTolerance)
		{
			vDesiredVelocity = VEC3_ZERO;
		}
		else if (pClip)
		{
			TUNE_GROUP_FLOAT(COVER_TUNE, PHASE_TO_COMPLETE_TRANSLATION, 0.9f, 0.0f, 1.0f, 0.01f);
			const float fRemainingPhase = rage::Clamp(PHASE_TO_COMPLETE_TRANSLATION - fClipPhase, 0.0f, 1.0f);
			float fRemainingTime = pClip->ConvertPhaseToTime(fRemainingPhase);
			float fSpeed = 0.0f;
			if (fRemainingTime > SMALL_FLOAT)
			{
				fSpeed = rage::Clamp(fDistToCover/fRemainingTime, 0.0f, ms_Tunables.m_MaxSpeed);
			}
			else
			{
				fSpeed = rage::Clamp(fDistToCover/fTimeStep, 0.0f, ms_Tunables.m_MaxSpeed);
			}
			vDesiredVelocity = vToTarget;
			vDesiredVelocity.Normalize();
			vDesiredVelocity.Scale(fSpeed);
		}
		m_bHasReachedPosition = true;
	}
}

//////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ProcessCheckForWeaponReload()
{
	const CPed& rPed = *GetPed();
	if (rPed.IsLocalPlayer())
	{
		const CWeapon* pWeapon = rPed.GetWeaponManager()->GetEquippedWeapon();
		if (pWeapon && pWeapon->GetCanReload())
		{
			const CControl* pControl = rPed.GetControlFromPlayer();
			if (pControl->GetPedReload().IsPressed() && !static_cast<CTaskCover*>(GetParent())->GetWantedToReloadDuringEntry())
			{
				const Vector3 vPedPosition = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
				if ((vPedPosition - m_vTargetPos).XYMag2() < square(ms_Tunables.m_DistFromCoverToAllowReloadCache))
				{
					static_cast<CTaskCover*>(GetParent())->SetWantedToReloadDuringEntry(true);
				}
			}
			else if (rPed.GetPlayerInfo()->IsAiming(false))
			{
				static_cast<CTaskCover*>(GetParent())->SetWantedToReloadDuringEntry(false);
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::SetClipsFromAnimStateInfo(s32 flags, bool bWillSlide)
{
	CPed& rPed = *GetPed();
	const atArray<CTaskCover::CoverAnimStateInfo>& aEnterCoverAnimStateInfos = GetState() == State_StandEntry ? ms_Tunables.GetPlayerStandEnterCoverAnimStateInfoForPed(rPed) : ms_Tunables.GetSlidingEnterCoverAnimStateInfoForPed(rPed);
	const CTaskCover::CoverAnimStateInfo* pAnimStateInfo = CTaskCover::GetAnimStateInfoForState(aEnterCoverAnimStateInfos, flags);
	if (!pAnimStateInfo)
	{
		taskAssertf(0, "Couldn't find anim state info for flags %i", flags);
		return false;
	}

	fwMvClipSetId coreClipSetId = m_pMoveNetworkHelper->GetClipSetId(CTaskMotionInCover::ms_CoreMotionClipSetId);
	
	const s32 iNumClips = pAnimStateInfo->m_Clips.GetCount();
	if (iNumClips <= 0)
	{
		taskAssertf(0, "Couldn't find any enter cover clips");
		return false;
	}

	for (s32 i=0; i<iNumClips; ++i)
	{	
		taskAssert(pAnimStateInfo->m_Clips[i] != CLIP_ID_INVALID);
		const crClip* pCoreClip = fwClipSetManager::GetClip(coreClipSetId, pAnimStateInfo->m_Clips[i]);
		if (pCoreClip)
		{
			if (bWillSlide && i== 0)
			{
				ComputeInitialPhase(pCoreClip);
			}
			else if (GetState() == State_StandEntry && i==1)
			{
				if (!FindMoverFixUpPhases(pCoreClip))
				{
					m_fTranslationFixUpStartPhase = ms_Tunables.m_DefaultPlayerStandEntryStartMovementPhase;
					m_fTranslationFixUpEndPhase = ms_Tunables.m_DefaultPlayerStandEntryEndMovementPhase;
				}
			}
			m_pMoveNetworkHelper->SetClip(pCoreClip, CTaskMotionInCover::GetCoreClipIdFromIndex(i));
		}

		fwMvClipSetId weaponHoldingClipSetId = m_pMoveNetworkHelper->GetClipSetId(CTaskMotionInCover::ms_UpperBodyWeaponMotionClipSetId);
		const crClip* pWeaponClip = NULL;
		if (weaponHoldingClipSetId != CLIP_SET_ID_INVALID)
		{
			pWeaponClip = fwClipSetManager::GetClip(weaponHoldingClipSetId, pAnimStateInfo->m_Clips[i]);
		}

		m_pMoveNetworkHelper->SetClip(pWeaponClip, CTaskInCover::GetWeaponClipIdForIndex(i));	
	}	

	return true;
}

//////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::ProcessPhysics( float fTimeStep, int UNUSED_PARAM(nTimeSlice) )
{
	CPed* pPed = GetPed();

	m_vTargetPos += VEC3V_TO_VECTOR3(pPed->GetGroundVelocityIntegrated()) * fTimeStep;

	if (GetState() == State_StandEntry)
	{
		Vec3V vPedPos = pPed->GetTransform().GetPosition();
		// Compute flat xy vector to the cover point
		Vector3 vToTarget = m_vTargetPos - VEC3V_TO_VECTOR3(vPedPos);
		vToTarget.z = 0.0f;	
		const float fDistToTarget = vToTarget.Mag();
		// Compute the speed, we'll force the direction to go towards cover
		Vector3 vDesiredVelocity = VEC3V_TO_VECTOR3(NMovingGround::GetPedDesiredVelocity(pPed));
		float fDesiredZVelocity = vDesiredVelocity.z;
		float fSpeed = vDesiredVelocity.Mag();

		const bool bRotatingLeft = m_pMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip0BlendWeightId) > 0.0f ? true : false;
		const bool bRotatingRight = m_pMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip2BlendWeightId) > 0.0f ? true : false;

		Vector3 vDesiredAngularVelocity = VEC3V_TO_VECTOR3(NMovingGround::GetPedDesiredAngularVelocity(pPed));
		aiFatalAssertf(FPIsFinite(m_fEndDirection), "m_fEndDirection wasn't finite");
		aiFatalAssertf(FPIsFinite(pPed->GetCurrentHeading()), "pPed->GetCurrentHeading() wasn't finite");
		const float fCurrentHeadingDiff = fwAngle::LimitRadianAngle(m_fEndDirection - pPed->GetCurrentHeading());
		const float fPredictedPedHeading = pPed->GetCurrentHeading() + vDesiredVelocity.z*fTimeStep;
		aiFatalAssertf(FPIsFinite(fPredictedPedHeading), "fPredictedPedHeading wasn't finite");
		const float fPredictedHeadingDiff = fwAngle::LimitRadianAngle(m_fEndDirection - fPredictedPedHeading);

		bool bAchievedHeadingThisFrame = false;
		if (bRotatingLeft)
		{
			if (fPredictedHeadingDiff < 0.0f)
			{
				vDesiredAngularVelocity.z = fCurrentHeadingDiff / fTimeStep;
				NMovingGround::SetPedDesiredAngularVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredAngularVelocity));
				bAchievedHeadingThisFrame = true;
			}
			else
			{
				vDesiredAngularVelocity.z = Abs(vDesiredAngularVelocity.z);
				NMovingGround::SetPedDesiredAngularVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredAngularVelocity));
			}
		}
		else if (bRotatingRight)
		{
			if (fPredictedHeadingDiff > 0.0f)
			{
				vDesiredAngularVelocity.z = fCurrentHeadingDiff / fTimeStep;
				NMovingGround::SetPedDesiredAngularVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredAngularVelocity));
				bAchievedHeadingThisFrame = true;
			}
			else
			{
				vDesiredAngularVelocity.z = -Abs(vDesiredAngularVelocity.z);
				NMovingGround::SetPedDesiredAngularVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredAngularVelocity));
			}
		}

		const float fClipPhase = m_pMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip1PhaseId);
		const crClip* pClip = m_pMoveNetworkHelper->GetClip(ms_EnterCoverClipId);
		if (pClip)
		{
			if (fClipPhase >= m_fTranslationFixUpStartPhase)
			{
				const float fRemainingMovementPhase = rage::Clamp(m_fTranslationFixUpEndPhase - fClipPhase, 0.0f, 1.0f);
				const float fRemainingTime = pClip->ConvertPhaseToTime(fRemainingMovementPhase);
				if (fRemainingTime > 0.01f)
				{
					fSpeed = fDistToTarget / fRemainingTime;
				}
				else
				{							
					CTaskInCover::SlidePedIntoCover(*pPed, NULL, m_vTargetPos);
				}
				fSpeed = rage::Clamp(fSpeed, 0.0f, 15.0f);

				if (!bAchievedHeadingThisFrame && Abs(NMovingGround::GetPedDesiredAngularVelocity(pPed).GetZf()) <= ms_Tunables.m_MaxAngleToBeginRotationScale)
				{
					if (fRemainingTime > 0.01f)
					{
						vDesiredAngularVelocity.z = rage::Clamp(fCurrentHeadingDiff / fRemainingTime, -10.0f, 10.0f);
						NMovingGround::SetPedDesiredAngularVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredAngularVelocity));
					}
					else
					{
						const float fOneFrameVelocity = fCurrentHeadingDiff / fTimeStep;
						const float fMaxDefaultVelocity = Sign(fCurrentHeadingDiff) * ms_Tunables.m_MaxDefaultAngularVelocity;
						vDesiredAngularVelocity.z = Abs(fOneFrameVelocity) < Abs(fMaxDefaultVelocity) ? fOneFrameVelocity : fMaxDefaultVelocity;
						NMovingGround::SetPedDesiredAngularVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredAngularVelocity));
					}
				}
			}
		}

		// Compute the speed, we'll force the direction to go towards cover
		vDesiredVelocity = vToTarget;
		vDesiredVelocity.Normalize();
		vDesiredVelocity.Scale(fSpeed);

		if (ms_Tunables.m_PreventTranslationOvershoot)
		{
			ScaleDesiredVelocityToPreventOvershoot(*pPed, vDesiredVelocity, pClip, fClipPhase, fTimeStep);
		}

		// Reapply
		vDesiredVelocity.z = fDesiredZVelocity;
		NMovingGround::SetPedDesiredVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredVelocity));
		NMovingGround::SetPedVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredVelocity));


		return true;
	}

	TUNE_GROUP_BOOL(COVER_TUNE, KILL_MOVER_ON_TRANSITION, true);
	if (KILL_MOVER_ON_TRANSITION && GetState() == State_TransitionToIdle)
	{
		NMovingGround::SetPedDesiredVelocity(pPed, Vec3V(V_ZERO));
		NMovingGround::SetPedVelocity(pPed, Vec3V(V_ZERO));
		return true;
	}

	if (!pPed->IsAPlayerPed() && GetState() != State_Sliding)
	{
		Vec3V vPedPos = pPed->GetTransform().GetPosition();
		// Compute flat xy vector to the cover point
		Vector3 vToTarget = m_vTargetPos - VEC3V_TO_VECTOR3(vPedPos);
		vToTarget.z = 0.0f;	
		const float fDistToTarget = vToTarget.Mag();
		// Compute the speed, we'll force the direction to go towards cover
		Vector3 vDesiredVelocity = VEC3V_TO_VECTOR3(NMovingGround::GetPedDesiredVelocity(pPed));
		float fSpeed = vDesiredVelocity.Mag();

		if (GetState() == State_MovingEntry)
		{
			const float fClipPhase = m_pMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip0PhaseId);
			TUNE_GROUP_BOOL(COVER_TUNE, APPLY_INTIAL_HEADING_BLEND, true);

			Vector3 vCoverPos(Vector3::ZeroType);
			if (GetPed()->IsNetworkClone())
			{
				vCoverPos = m_vTargetPos;
			}
			else if (!GetPed()->GetCoverPoint() || !GetPed()->GetCoverPoint()->GetCoverPointPosition(vCoverPos))
			{
				return false;
			}

			if (!m_bComputedIdealStartTransform && APPLY_INTIAL_HEADING_BLEND && fClipPhase >= 0.0f)
			{
				const float fStartLerpPhase = m_fInitialPhase;
				const float fEndLerpPhase = m_fEstBlendedInPhase;
				const float fLerpRatio = Clamp((fClipPhase - fStartLerpPhase) / (fEndLerpPhase - fStartLerpPhase), 0.f, 1.f);
				//Displayf("Heading Lerp Ratio : %.4f", fLerpRatio);
				QuatV qTargetRot;
				ComputeTargetMatrix(RCC_VEC3V(vCoverPos), qTargetRot);
				ScalarV scHeading = QuatVTwistAngle(qTargetRot, Vec3V(V_Z_AXIS_WZERO));
				const float fTargetAngle = scHeading.Getf() + PI;
				const float fDesiredAngle = fwAngle::LerpTowards(m_fInitialHeading, fTargetAngle, fLerpRatio);
				aiFatalAssertf(FPIsFinite(fTargetAngle), "fTargetAngle wasn't finite");
				aiFatalAssertf(FPIsFinite(fDesiredAngle), "fDesiredAngle wasn't finite");
				pPed->SetDesiredHeading(fwAngle::LimitRadianAngle(fTargetAngle));
				pPed->SetHeading(fwAngle::LimitRadianAngle(fDesiredAngle));

				TUNE_GROUP_BOOL(COVER_TUNE, FORCE_INITIAL_DIRECTION, true);
				if (FORCE_INITIAL_DIRECTION)
				{
					vDesiredVelocity = vToTarget;
					vDesiredVelocity.Normalize();
					vDesiredVelocity.Scale(fSpeed);
					NMovingGround::SetPedDesiredVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredVelocity));
					NMovingGround::SetPedVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredVelocity));
					return true;
				}
			}

			TUNE_GROUP_BOOL(COVER_TUNE, FORCE_DESIRED_VELOCITY, false);
			if (!FORCE_DESIRED_VELOCITY && m_pMoveNetworkHelper)
			{
				TUNE_GROUP_BOOL(COVER_TUNE, APPLY_ERROR_CORRECTION, true);
				const crClip* pClip = m_pMoveNetworkHelper->GetClip(CClipScalingHelper::ms_Clip0Id);
				if (APPLY_ERROR_CORRECTION)
				{
					if (m_bComputedIdealStartTransform && fClipPhase >= 0.0f)
					{
						// Remove error
						Vec3V vIdealInitialPos = m_vIdealInitialPos;
						QuatV qIdealInitialRot = m_qIdealInitialRot;
						Vec3V vInitialPos = m_vInitialPos;
						QuatV qInitialRot = m_qInitialRot;

						QuatV qTargetRot;
						Mat34V targetMtx = ComputeTargetMatrix(RCC_VEC3V(vCoverPos), qTargetRot);

						// Convert to global space
						ComputeTransformFromOffsetsSplat(vIdealInitialPos, qIdealInitialRot, targetMtx);
						ComputeTransformFromOffsetsSplat(vInitialPos, qInitialRot, targetMtx);
						Vec3V vPosError = vIdealInitialPos - vInitialPos;

						TUNE_GROUP_FLOAT(COVER_TUNE, FIXED_ERROR_BLEND_DURATION, 0.25f, 0.0f, 5.0f, 0.01f);
						const float fStartLerpPhase = m_fBlendedInPhase;
						float fEndLerpPhase = m_fBlendedInPhase + pClip->ConvertTimeToPhase(FIXED_ERROR_BLEND_DURATION);
						TUNE_GROUP_BOOL(COVER_TUNE, USE_FULL_ERROR_BLEND, true);
						if (USE_FULL_ERROR_BLEND)
						{
							TUNE_GROUP_FLOAT(COVER_TUNE, ERROR_PHASE_COMPLETE, 0.20f, 0.0f, 1.0f, 0.01f);
							fEndLerpPhase = 1.0f - ERROR_PHASE_COMPLETE;
						}
						const float fLerpRatio = Clamp((fClipPhase - fStartLerpPhase) / (fEndLerpPhase - fStartLerpPhase), 0.f, 1.f);
						//Displayf("Error Lerp Ratio : %.4f", fLerpRatio)
						FastAssert(FPIsFinite(fLerpRatio));

						Vector3 vDesiredVelocity = VEC3V_TO_VECTOR3(NMovingGround::GetPedDesiredVelocity(pPed));
						FastAssert(IsFiniteAll(RCC_VEC3V(vDesiredVelocity)));

						vPosError = Scale(vPosError, ScalarVFromF32(fLerpRatio));
						TUNE_GROUP_BOOL(COVER_TUNE, SCALE_BY_TIMESTEP, false);
						if (SCALE_BY_TIMESTEP)
						{
							vPosError = Scale(vPosError, ScalarVFromF32(1.0f/fTimeStep));
						}
						FastAssert(IsFiniteAll(vPosError));

#if DEBUG_DRAW
						// Update the initial position sans the correction this timestep, this should tend the initial pos to the ideal initial pos
						Vec3V vErrorCorrection = vPosError;//Scale(vPosError, ScalarVFromF32(fTimeStep));

						static bool DRAW_ERROR = false;
						if (DRAW_ERROR)
							CTask::ms_debugDraw.AddArrow(vPedPos, vPedPos + vErrorCorrection, 0.1f, Color_purple, 1000);
#endif 

						// 					vErrorCorrection = UnTransformFull(targetMtx, vErrorCorrection);
						// 					m_vInitialPos -= vErrorCorrection;

						vDesiredVelocity += VEC3V_TO_VECTOR3(vPosError);
						vDesiredVelocity.ClampMag(0.f, DEFAULT_MAX_SPEED - 0.01f);

						TUNE_GROUP_FLOAT(COVER_TUNE, FORCE_DIRECTION_DIST, 2.0f, 0.0f, 5.0f, 0.01f);
						if (fDistToTarget < FORCE_DIRECTION_DIST)
						{
							// Compute the speed, we'll force the direction to go towards cover
							float fSpeed = vDesiredVelocity.Mag();
							vDesiredVelocity = vToTarget;
							vDesiredVelocity.Normalize();
							vDesiredVelocity.Scale(fSpeed);
						}

						NMovingGround::SetPedDesiredVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredVelocity));
						NMovingGround::SetPedVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredVelocity));
						return true;
					}
				}
			}
			return false;
		}

		vDesiredVelocity = vToTarget;
		vDesiredVelocity.Normalize();
		vDesiredVelocity.Scale(fSpeed);

		NMovingGround::SetPedDesiredVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredVelocity));

		float fCoverDirection = m_fEndDirection;

		TUNE_GROUP_FLOAT(COVER_TUNE, ROTATE_ANGLE, 0.0f, -PI, PI, 0.01f);
		if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
		{
			fCoverDirection -= ROTATE_ANGLE;
		}
		else 
		{
			fCoverDirection += ROTATE_ANGLE;
		}
		
		if (m_pMoveNetworkHelper && m_pMoveNetworkHelper->IsNetworkAttached())
		{
			static dev_float PHASE_TO_FINISH_HEADING_LERP = 0.3f;
			float fClipPhase = rage::Clamp(m_pMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip0PhaseId), 0.0f, 1.0f);
			if (fClipPhase <= PHASE_TO_FINISH_HEADING_LERP + 0.1f)
			{
				const float fRatio = rage::Clamp(fClipPhase  / PHASE_TO_FINISH_HEADING_LERP, 0.0f, 1.0f);
				float fNewHeading = fwAngle::LerpTowards(m_fInitialHeading, fCoverDirection, fRatio);
				pPed->SetDesiredHeading(fCoverDirection);
				pPed->SetHeading(fNewHeading);
			}
		}
	
		
		return true;
	}

	// Get the translational velocity about to be applied to the ped
	Vector3 vDesiredVelocity = VEC3V_TO_VECTOR3(NMovingGround::GetPedDesiredVelocity(pPed));
	float fDesiredZVelocity = vDesiredVelocity.z;

	// Compute the speed, we'll force the direction to go towards cover (would be better with turn anims)
	float fSpeed = vDesiredVelocity.Mag();

	Vector3 vPedPosition = VEC3V_TO_VECTOR3(GetPed()->GetTransform().GetPosition());

	// Compute flat xy vector to the cover point
	Vector3 vToTarget = m_vTargetPos - vPedPosition;
	vToTarget.z = 0.0f;	

	// Compute total distance away from the cover
	const float fDistToCover = vToTarget.Mag();

	float fClipPhase = 0.0f;
	const crClip* pClip = NULL;

	if (m_pMoveNetworkHelper && m_pMoveNetworkHelper->IsNetworkAttached())
	{
		pClip = m_pMoveNetworkHelper->GetClip(ms_EnterCoverClipId);
		fClipPhase = rage::Clamp(m_pMoveNetworkHelper->GetFloat(ms_EnterCoverClipCurrentPhaseId), 0.0f, 1.0f);
		//Displayf("Phase : %.4f", fClipPhase);
		FindMoverFixUpPhases(pClip);
	}

	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_DIST_TO_COVER, 0.05f, 0.0f, 1.0f, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_SPEED, 0.1f, 0.0f, 10.0f, 0.01f);
	const bool bLocalPedWithValidCoverPoint = !pPed->IsNetworkClone() && GetTarget().GetIsValid() && pPed->GetCoverPoint();
	if ((m_bHasReachedPosition || fSpeed < MIN_SPEED || fDistToCover < MIN_DIST_TO_COVER) && fClipPhase > m_fTranslationFixUpEndPhase && (pPed->IsNetworkClone() || bLocalPedWithValidCoverPoint))
	{
		Vector3 vCoverDirection(Vector3::ZeroType);	
		Vector3 vCoverCoords(Vector3::ZeroType);	
		if (bLocalPedWithValidCoverPoint)
		{
			Vector3 vTargetPosition;
			GetTarget().GetPosition(vTargetPosition);	
			vCoverDirection = vTargetPosition - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
			vCoverDirection.z = 0.0f;
			vCoverDirection.Normalize();
			CCover::FindCoverCoordinatesForPed(*pPed, vCoverDirection, vCoverCoords);
		}
		else
		{
			vCoverCoords = m_vTargetPos;
		}

		CTaskInCover::SlidePedIntoCover(*pPed, NULL, vCoverCoords);
	}
	else
	{
		// Scale the desired velocity to get us to the cover position
		if (ms_Tunables.m_EnableTranslationScaling)
		{
			ScaleTranslationalVelocity(fSpeed, pClip, fClipPhase, fDistToCover);
		}

		float maxSpeed = ms_Tunables.m_MaxSpeed;

		// Force the velocity in the direction of cover
		if (ms_Tunables.m_ForceToTarget)
		{
			vDesiredVelocity = vToTarget;
			vDesiredVelocity.Normalize();
			//Displayf("Speed : %.4f", fSpeed);
			fSpeed = rage::Clamp(fSpeed, 0.0f, maxSpeed);
			//Displayf("Clamped Speed : %.4f", fSpeed);
			vDesiredVelocity.Scale(fSpeed);
		}

		// Try to prevent overshooting the cover position
		if (ms_Tunables.m_PreventTranslationOvershoot)
		{
			ScaleDesiredVelocityToPreventOvershoot(*pPed, vDesiredVelocity, pClip, fClipPhase, fTimeStep);
		}

		// Apply to ped
		vDesiredVelocity.z = fDesiredZVelocity;
		NMovingGround::SetPedDesiredVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredVelocity));
		if (vDesiredVelocity.IsEqual(VEC3_ZERO))
		{
			NMovingGround::SetPedVelocity(pPed, Vec3V(V_ZERO));
		}
	}


	TUNE_GROUP_BOOL(COVER_TUNE, LERP_HEADING, true);
	if (LERP_HEADING && pPed->IsPlayer() && m_bShouldDoInitialHeadingLerp)
	{
		TUNE_GROUP_FLOAT(COVER_TUNE, LERP_TIME, 0.25f, 0.0f, 2.0f, 0.01f);
		//float fClipPhase = rage::Clamp(m_pMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip0PhaseId), 0.0f, 1.0f);
		aiDebugf1("GetTimeInState %.2f, Set Approach Dir ? %s", GetTimeInState(), m_bSetApproachDirection ? "TRUE" : "FALSE");
		if (GetTimeInState() <= LERP_TIME)
		{
			Vec3V vPedPos = pPed->GetTransform().GetPosition();
			// Compute flat xy vector to the cover point
			Vector3 vToTarget = m_vTargetPos - VEC3V_TO_VECTOR3(vPedPos);
			const float fToCover = rage::Atan2f(-vToTarget.x, vToTarget.y);
			const float fRatio = rage::Clamp(GetTimeInState()  / LERP_TIME, 0.0f, 1.0f);
			float fNewHeading = fwAngle::LerpTowards(m_fInitialHeading, fToCover, fRatio);

			// Keep the ped going in that direction to avoid swinging back on ourself
			//const float fLeftAngle = CClipHelper::ComputeHeadingDeltaFromLeft(fNewHeading, fToCover);
			//const float fRightAngle = CClipHelper::ComputeHeadingDeltaFromRight(fNewHeading, fToCover);
			bool bLeftApproach = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? false : true;
			aiDebugf1("1 m_bSetApproachDirection TRUE, approach left ? %s", bLeftApproach ? "TRUE" : "FALSE");
			m_bApproachLeft = bLeftApproach;
			m_bSetApproachDirection = true;

			pPed->SetDesiredHeading(fToCover);
			pPed->SetHeading(fNewHeading);
			return true;
		}
	}

	// For the rotation we try to initially face towards the cover before fixing up the rotation at the end
	float fAngZSpeed = NMovingGround::GetPedDesiredAngularVelocity(pPed).GetZf();

	const float fCurrentHeading = fwAngle::LimitRadianAngle(pPed->GetCurrentHeading());
	const float fLeftAngle = CClipHelper::ComputeHeadingDeltaFromLeft(fCurrentHeading, m_fEndDirection);
	const float fRightAngle = CClipHelper::ComputeHeadingDeltaFromRight(fCurrentHeading, m_fEndDirection);
	aiDebugf2("Frame: %i, Left Delta : %.2f", fwTimer::GetFrameCount(), fLeftAngle);
	aiDebugf2("Frame: %i, Right Delta : %.2f", fwTimer::GetFrameCount(), fRightAngle);
	aiDebugf2("Frame: %i, Phase : %.2f", fwTimer::GetFrameCount(), fClipPhase);
	aiDebugf2("Frame: %i, Rotation Fixup : %.2f, Facing Left ? %s", fwTimer::GetFrameCount(), m_fRotationFixUpStartPhase, IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? "TRUE":"FALSE");
	const float fSmallDelta = Abs(fLeftAngle) <= Abs(fRightAngle) ? fLeftAngle : fRightAngle;
	bool bLeftApproach = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? false : true;

	// Prevent using the wrong direction
	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_ANGLE_TO_USE, 3.14f, 0.0f, TWO_PI, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_ANGLE_TO_USE, 3.14f, 0.0f, TWO_PI, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_ANGLE_TO_USE_INITIAL, 4.14f, 0.0f, TWO_PI, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_ANGLE_TO_USE_INITIAL, 4.14f, 0.0f, TWO_PI, 0.01f);
	const float fMinAngle = m_bShouldDoInitialHeadingLerp ? MIN_ANGLE_TO_USE_INITIAL : MIN_ANGLE_TO_USE;
	const float fMaxAngle = m_bShouldDoInitialHeadingLerp ? MAX_ANGLE_TO_USE_INITIAL : MAX_ANGLE_TO_USE;
	const bool bMoreThanMinAngle = (Abs(fLeftAngle) >= fMinAngle || Abs(fRightAngle) >= fMinAngle);
	const bool bMoreThanMaxAngle = (Abs(fLeftAngle) >= fMaxAngle || Abs(fRightAngle) >= fMaxAngle);
	if (fClipPhase > 0.0f && (fClipPhase >= m_fRotationFixUpStartPhase || bMoreThanMaxAngle))
	{
		if (!m_bUseShortestRotationAngle && bMoreThanMinAngle)
		{
			aiDebugf1("m_bUseShortestRotationAngle TRUE");
			m_bUseShortestRotationAngle = true;
		}
	}

	// When we're close we might already be facing the correct direction already, in this case force the rotation in the smallest angle direction
	if (ms_Tunables.m_UseShortDistAngleRotation && (m_bUseShortestRotationAngle || Abs(fSmallDelta) < ms_Tunables.m_MinRotDelta))
	{
		if (Abs(fLeftAngle) <= Abs(fRightAngle))
		{
			bLeftApproach = true;
		}
		else
		{
			bLeftApproach = false;
		}
	}
	else if (m_bSetApproachDirection)
	{
		bLeftApproach = m_bApproachLeft;
	}

	if (!m_bSetApproachDirection)
	{
		aiDebugf1("m_bSetApproachDirection TRUE, aproach left ? %s", bLeftApproach ? "TRUE" : "FALSE");
		m_bApproachLeft = bLeftApproach;
		m_bSetApproachDirection = true;
	}

	const float fAngToCover = bLeftApproach ? fLeftAngle : fRightAngle;
	aiDebugf2("Frame: %i, Approach Left ? %s", fwTimer::GetFrameCount(), bLeftApproach ? "TRUE":"FALSE");
	aiDebugf2("Frame: %i, fAngToCover %.2f", fwTimer::GetFrameCount(), fAngToCover);

	if (ms_Tunables.m_EnableRotationScaling)
	{
		ScaleRotationalVelocity(fAngZSpeed, pClip, fClipPhase, vToTarget, fTimeStep, bLeftApproach, fAngToCover, m_bUseShortestRotationAngle);
	}

	// When we've reached the heading, we don't want to apply anymore angular velocity
	if (fClipPhase >= m_fRotationFixUpStartPhase && Abs(fAngToCover) < ms_Tunables.m_CoverEntryHeadingReachedTol)
	{
		m_bHasReachedHeading = true;
	}

	if (ms_Tunables.m_PreventRotationOvershoot && fClipPhase >= m_fRotationFixUpStartPhase && m_fRotationFixUpStartPhase > 0.0f)
	{
		// See if we'll overshoot if we apply this rotation and clamp it if needed
		const float fPredictedNewHeading = fwAngle::LimitRadianAngle(fCurrentHeading + fAngZSpeed * fTimeStep);
		const float fPredictedHeadingDelta = bLeftApproach ? CClipHelper::ComputeHeadingDeltaFromLeft(fPredictedNewHeading, m_fEndDirection) : CClipHelper::ComputeHeadingDeltaFromRight(fPredictedNewHeading, m_fEndDirection);

		bool bRotateToTargetThisFrame = false;
		if (Abs(fAngToCover) < ms_Tunables.m_MaxAngleToSetDirectly && Abs(fPredictedHeadingDelta) > (Abs(fAngToCover) + Abs(ms_Tunables.m_DeltaTolerance)))
		{
			bRotateToTargetThisFrame = true;
			//Displayf("Rot to Target : %u", fwTimer::GetFrameCount());
		}

		if (bRotateToTargetThisFrame || m_bHasReachedHeading)
		{
			//Displayf("Set heading diff : %.4f", Abs(fwAngle::LimitRadianAngle(m_fEndDirection - fCurrentHeading)));
			m_bHasReachedHeading = true;
			fAngZSpeed = 0.0f;
			pPed->SetHeading(m_fEndDirection);
		}
	}

	Vec3V vDesiredAngVelocity(0.f, 0.f, fAngZSpeed);
	NMovingGround::SetPedDesiredAngularVelocity(pPed, vDesiredAngVelocity);
	if (IsZeroAll(vDesiredAngVelocity))
	{
		NMovingGround::SetPedAngVelocity(pPed, Vec3V(V_ZERO));
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

CTaskEnterCover::FSM_Return CTaskEnterCover::UpdateClonedFSM(const s32 iState, const FSM_Event iEvent)
{
	if (m_bForceCloneQuit && iEvent == OnUpdate)
	{
		SetState(State_Finish);
	}

	return UpdateFSM(iState, iEvent);
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::Start_OnUpdate()
{
	CPed* pPed = GetPed();

	if (pPed->IsLocalPlayer())
	{
		if (pPed->GetPlayerInfo() && pPed->GetPlayerInfo()->GetPlayerDataSprintControlCounter() > 1.0f)
		{
			m_bUseFastRate = true;
		}

		if (NetworkInterface::IsGameInProgress() && pPed->GetNetworkObject())
		{
			CNetObjPed* pPedObj = SafeCast(CNetObjPed, pPed->GetNetworkObject());
			//Since motion state is InFrequent make sure we have the latest up-to-date position / task info to decide whether we should abort
			pPedObj->ForceResendAllData();
		}
	}

	m_fInitialHeading = pPed->GetCurrentHeading();

	Vec3V vPedPos = pPed->GetTransform().GetPosition();
	// Compute flat xy vector to the cover point
	Vector3 vToTarget = m_vTargetPos - VEC3V_TO_VECTOR3(vPedPos);
	vToTarget.z = 0.0f;	
	const float fDistToTarget = vToTarget.Mag();

	m_pMoveNetworkHelper = static_cast<CTaskCover*>(GetParent())->GetMoveNetworkHelper();
	if (!taskVerifyf(m_pMoveNetworkHelper, "NULL parent network helper"))
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	const bool bDoMovingEntry = !NetworkInterface::IsGameInProgress() && ShouldPedUseAiEntryAnims(*pPed) && fDistToTarget >= ms_Tunables.m_MinDistToPlayEntryAnim;

	// These ai entry anims leave the ped facing directly away from the cover direction, rather than at 90 degrees
	if (!pPed->IsNetworkClone())
	{
		if (!bDoMovingEntry)
		{
			if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
			{
				m_fEndDirection += HALF_PI;
			}
			else 
			{
				m_fEndDirection -= HALF_PI;
			}
		}
	}

	m_vInitialPosition = VEC3V_TO_VECTOR3(GetPed()->GetTransform().GetPosition());
	m_fEndDirection = fwAngle::LimitRadianAngle(m_fEndDirection);

	if (bDoMovingEntry)
	{
		SetState(State_MovingEntry);
		return FSM_Continue;
	}

	// If the ped needs to turn as they are facing away from cover, let them do so before starting the cover network
	CTaskMotionBasicLocomotion* pLocomotionTask = static_cast<CTaskMotionBasicLocomotion*>(GetPed()->GetPedIntelligence()->FindTaskActiveMotionByType(CTaskTypes::TASK_MOTION_BASIC_LOCOMOTION));
	if (pLocomotionTask && pLocomotionTask->GetState() == CTaskMotionBasicLocomotion::State_MoveTurn)
	{
		SetState(State_OrientateToCover);
		return FSM_Continue;
	}
	else
	{
		SetState(State_StreamAssets);
		return FSM_Continue;
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return  CTaskEnterCover::StreamAssets_OnUpdate()
{
	const CPed* pPed = GetPed();
	fwMvClipSetId weaponHoldingClipsetId = CTaskCover::GetWeaponHoldingClipSetForArmament(pPed);
	if (weaponHoldingClipsetId == CLIP_SET_ID_INVALID || CTaskCover::IsCoverClipSetLoaded(weaponHoldingClipsetId))
	{
		SetState(State_StartCoverNetwork);
		return FSM_Continue;
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::OrientateToCover_OnUpdate()
{
	CPed* pPed = GetPed();

	// Flag the move do nothing task not to null out the mbr
	pPed->SetPedResetFlag(CPED_RESET_FLAG_DontChangeMbrInSimpleMoveDoNothing, true);

	// Set the desired heading to be the direction to cover
	Vector3 vToTarget = m_vTargetPos - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	vToTarget.z = 0.0f;	

	const float fToCoverHeading = rage::Atan2f(-vToTarget.x, vToTarget.y);
 	pPed->SetDesiredHeading(fToCoverHeading);

	// Wait until the turn is complete
	CTaskMotionBasicLocomotion* pLocomotionTask = static_cast<CTaskMotionBasicLocomotion*>(GetPed()->GetPedIntelligence()->FindTaskActiveMotionByType(CTaskTypes::TASK_MOTION_BASIC_LOCOMOTION));
	if (pLocomotionTask && pLocomotionTask->GetState() != CTaskMotionBasicLocomotion::State_MoveTurn)
	{
		SetState(State_StreamAssets);
		return FSM_Continue;
	}
	else
	{
#if AI_DEBUG_OUTPUT_ENABLED
		aiDebugf2("[Cover] - CTaskEnterCover::OrientateToCover_OnUpdate(), ped: %s is waiting for loco task to leave State_MoveTurn\n", AILogging::GetDynamicEntityNameSafe(pPed));
#endif
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::StartCoverNetwork_OnEnter()
{
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::StartCoverNetwork_OnUpdate()
{
#if __BANK
	TUNE_GROUP_BOOL(COVER_TUNE, DISPLAY_ENTER_TEXT, FALSE);
	if( DISPLAY_ENTER_TEXT )
	{
		Vector3 vPedPos = VEC3V_TO_VECTOR3(GetPed()->GetTransform().GetPosition());
		ms_debugDraw.AddLine(RCC_VEC3V(vPedPos), RCC_VEC3V(m_vTargetPos), Color_green, 5000);
		Vector3 vDiff = m_vTargetPos - vPedPos;
		char szText[128];
		formatf(szText, "%.2f", vDiff.Mag());
		ms_debugDraw.AddText(RCC_VEC3V(vPedPos), 0, 0, szText, Color_green, 5000);
		if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
			formatf(szText, "Left");
		else
			formatf(szText, "Right");
		ms_debugDraw.AddText(RCC_VEC3V(vPedPos), 0, 10, szText, Color_green, 5000);
		if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
			formatf(szText, "Low");
		else
			formatf(szText, "High");
		ms_debugDraw.AddText(RCC_VEC3V(vPedPos), 0, 20, szText, Color_green, 5000);
	}
#endif // __BANK


	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_DIST_TO_PLAY_PLAYER_STAND_ANIMS_CLOSE, 0.5f, 0.0f, 3.0f, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_DIST_TO_PLAY_PLAYER_STAND_ANIMS, 1.5f, 0.0f, 3.0f, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_DIST_TO_PLAY_AI_STAND_ANIMS, 1.25f, 0.0f, 3.0f, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_DIST_TO_PLAY_AI_STAND_ANIMS_FROM_STAND, 0.75f, 0.0f, 3.0f, 0.01f);
	CPed* pPed = GetPed();
	Vec3V vPedPosition = pPed->GetTransform().GetPosition();
	// Compute flat xy vector to the cover point
	Vector3 vToTarget = m_vTargetPos - VEC3V_TO_VECTOR3(vPedPosition);
	vToTarget.z = 0.0f;	
	float fMaxDistToPlayStandAnims = pPed->GetMotionData()->GetCurrentMbrY() < MOVEBLENDRATIO_WALK ? MAX_DIST_TO_PLAY_PLAYER_STAND_ANIMS_CLOSE : MAX_DIST_TO_PLAY_PLAYER_STAND_ANIMS;
	if (!pPed->IsAPlayerPed())
	{
		fMaxDistToPlayStandAnims = pPed->GetVelocity().Mag2() < 0.1f ? MAX_DIST_TO_PLAY_AI_STAND_ANIMS_FROM_STAND : MAX_DIST_TO_PLAY_AI_STAND_ANIMS;
	}

	const bool bWillSlide = vToTarget.Mag2() >= rage::square(fMaxDistToPlayStandAnims);

	bool bIgnoreMoverBlend = false;

	if (bWillSlide)
	{
		const Vector3 vPedFwd = VEC3V_TO_VECTOR3(pPed->GetTransform().GetB());
		vToTarget.Normalize();
		const float fPedCoverDot = vToTarget.Dot(vPedFwd);
		if (fPedCoverDot < 0.0f)
		{
			bIgnoreMoverBlend = true;
		}
	}

	// Start the cover network, setup the intro to be inserted
	CTaskCover* pCoverTask = static_cast<CTaskCover*>(GetParent());

	// Initialize blend in duration to be invalid, unless our parent task has a non instant blend duration
	float fBlendInDuration = pCoverTask->GetBlendInDuration() != INSTANT_BLEND_DURATION ? pCoverTask->GetBlendInDuration() : -1.0f;
	if (!pCoverTask->StartCoverNetwork(ms_Tunables.m_EnableFootTagSyncing, false, true, bIgnoreMoverBlend, fBlendInDuration))
	{
		return FSM_Continue;
	}

	if (!m_pMoveNetworkHelper)
	{
		m_pMoveNetworkHelper = pCoverTask->GetMoveNetworkHelper();
	}

	m_pMoveNetworkHelper->WaitForTargetState(ms_EnterCoverOnEnterId);

	// Request_DEPRECATED to go into the intro state and set the task
	m_pMoveNetworkHelper->SendRequest(ms_EnterCoverRequestId);

	s32 flags = 0;

	if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		flags |= CTaskCover::AF_FaceLeft;
	}

	if (IsCoverFlagSet(CTaskCover::CF_EnterLeft))
	{
		flags |= CTaskCover::AF_EnterLeft;
	}

	if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		flags |= CTaskCover::AF_Low;
	}

	if (!SetClipsFromAnimStateInfo(flags, bWillSlide))
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	pPed->GetPedAudioEntity()->GetFootStepAudio().SetMoveBlendRatioWhenGoingIntoCover(pPed->GetMotionData()->GetCurrentMbrY());
	if (m_bUseFastRate)
	{
		m_pMoveNetworkHelper->SetFloat(ms_EnterCoverClipRateId, ms_Tunables.m_PlayerSprintEntryRate);
	}

	if (bWillSlide)
	{
		SetState(State_Sliding);
	}
	else
	{
		SetState(State_StandEntry);
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::Sliding_OnEnter()
{
	CPed& rPed = *GetPed();
	if (rPed.IsPlayer())
	{
		TUNE_GROUP_FLOAT(COVER_TUNE, MIN_DIST_TO_LERP_INITIAL_HEADING, 1.5f, 0.0f, 10.0f, 0.01f);
		Vec3V vPedPos = rPed.GetTransform().GetPosition();
		// Compute flat xy vector to the cover point
		Vector3 vToTarget = m_vTargetPos - VEC3V_TO_VECTOR3(vPedPos);
		vToTarget.z = 0.0f;	
		const float fDistToTarget = vToTarget.Mag();
		aiDisplayf("Distance Delta: %.2f", fDistToTarget);
		if (fDistToTarget > MIN_DIST_TO_LERP_INITIAL_HEADING)
		{
			aiDisplayf("m_bShouldDoInitialHeadingLerp TRUE");
			m_bShouldDoInitialHeadingLerp = true;
		}
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::Sliding_OnUpdate()
{
	CPed* pPed = GetPed();
	if (pPed->IsLocalPlayer() && !taskVerifyf(GetTimeInState() < 10.0f, "Local player has been in sliding state for more than 10 seconds, probably out of sync move network, aborting"))
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	if (!m_pMoveNetworkHelper->IsInTargetState())
	{
#if AI_DEBUG_OUTPUT_ENABLED
		aiDebugf2("[Cover] - CTaskEnterCover::Sliding_OnUpdate(), move network not in target state yet for ped: %s\n", AILogging::GetDynamicEntityNameSafe(pPed));
#endif
		return FSM_Continue;
	}

	if (m_pMoveNetworkHelper->GetBoolean(ms_EnterCoverClipFinishedId))
	{
		SetState(State_Finish);
		return FSM_Continue;
	}
	aiDebugf2("[Cover] - CTaskEnterCover::Sliding_OnUpdate(), ms_EnterCoverClipFinishedId = %s\n", m_pMoveNetworkHelper->GetBoolean(ms_EnterCoverClipFinishedId) ? "True" : "Flase");
	CheckForWeaponRemoval(pPed, m_pMoveNetworkHelper->GetFloat(ms_EnterCoverClipCurrentPhaseId));
	
	CTaskCover* pCoverTask = static_cast<CTaskCover*>(GetParent());
	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_TIME_NOT_MOVING_TO_ABORT, 0.1f, 0.0f, 2.0f, 0.01f);
	if (CheckForPlayerInterrupt() || CheckForNetworkInterrupt() ||  pCoverTask->CheckForMovingCover(pPed) || m_fTimeNotMovingToTarget > MIN_TIME_NOT_MOVING_TO_ABORT)
	{
		SetState(State_Finish); 
		return FSM_Continue;
	}

	// Tell the ped we need to call ProcessPhysics for this task
	pPed->SetPedResetFlag( CPED_RESET_FLAG_ProcessPhysicsTasks, true );

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::StandEntry_OnEnter()
{
	// Start the cover network, setup the intro to be inserted
	CTaskCover* pCoverTask = static_cast<CTaskCover*>(GetParent());
	float fBlendInDuration = pCoverTask->GetBlendInDuration() != INSTANT_BLEND_DURATION ? pCoverTask->GetBlendInDuration() : -1.0f;
	pCoverTask->StartCoverNetwork(false, false, true, true, fBlendInDuration);

	if (!m_pMoveNetworkHelper)
	{
		m_pMoveNetworkHelper = pCoverTask->GetMoveNetworkHelper();
	}

	m_pMoveNetworkHelper->WaitForTargetState(ms_EnterCoverOnEnterId);

	// Request_DEPRECATED to go into the intro state and set the task
	m_pMoveNetworkHelper->SendRequest(ms_EnterCoverRequestId);
	m_pMoveNetworkHelper->SetFlag(true, ms_FromStandFlagId);

	CPed& ped = *GetPed();
	NMovingGround::SetPedAngVelocity(&ped, Vec3V(V_ZERO));
	NMovingGround::SetPedDesiredAngularVelocity(&ped, Vec3V(V_ZERO));

	Vector3 vCoverPos;
	Vector3 vCoverDir;
	s32 flags = 0;

	if (GetNetCoverPointPosition(ped, vCoverPos))
	{
		GetNetCoverPointDirection(ped, vCoverDir);
		
		m_fEnterDirection = 0.0f;
		flags = ComputeStandingEnterCoverDirection(ped.GetTransform().GetB(), RCC_VEC3V(vCoverDir), m_fEnterDirection, true);

#if DEBUG_DRAW
		Vec3V vFacingDirection = RCC_VEC3V(vCoverDir);

		static float ROTATE_ANGLE = HALF_PI;
		if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
		{
			vFacingDirection = RotateAboutZAxis(vFacingDirection, ScalarVFromF32(ROTATE_ANGLE));
		}
		else
		{
			vFacingDirection = RotateAboutZAxis(vFacingDirection, ScalarVFromF32(-ROTATE_ANGLE));
		}

		Vec3V vCoverPosition = RCC_VEC3V(vCoverPos);
		Vec3V vFacingPosition = vCoverPosition + vFacingDirection;
		ms_debugDraw.AddArrow(vCoverPosition, vFacingPosition, 0.25f, Color_green, 2000);
#endif

		m_fEnterDirection = 1.0f - (rage::Clamp(m_fEnterDirection/PI, -1.0f, 1.0f) + 1.0f ) * 0.5f;
	}

	m_pMoveNetworkHelper->SetFloat(ms_AngleToCoverId, m_fEnterDirection);

	if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		flags |= CTaskCover::AF_FaceLeft;
	}
	if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		flags |= CTaskCover::AF_Low;
	}
	if (flags & CTaskCover::AF_EnterLeft)
	{
		flags &= ~CTaskCover::AF_EnterLeft;
	}

	if (!SetClipsFromAnimStateInfo(flags, false))
	{
		return FSM_Quit;
	}

	fwMvClipSetId weaponHoldingClipSetId = m_pMoveNetworkHelper->GetClipSetId(CTaskMotionInCover::ms_UpperBodyWeaponMotionClipSetId);

	m_pMoveNetworkHelper->SetFlag(false, ms_AIEntryFlagId);
	
	if (weaponHoldingClipSetId != CLIP_SET_ID_INVALID)
	{
		m_pMoveNetworkHelper->SetFlag(true, CTaskMotionInCover::ms_UseWeaponHoldingId);
		m_pMoveNetworkHelper->SetFlag(false, CTaskMotionInCover::ms_UseGripClipId);
	}
	else
		CTaskMotionInCover::SetGripClip(&ped, *m_pMoveNetworkHelper);	
		
	m_fInitialHeading = ped.GetCurrentHeading();
	//m_fEstBlendedInPhase = m_fInitialPhase + pClip->ConvertTimeToPhase(ms_Tunables.m_NetworkBlendInDuration);
	//Displayf("EstBlendInPhase : %.2f", m_fEstBlendedInPhase);

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::StandEntry_OnUpdate()
{
	GetPed()->SetPedResetFlag( CPED_RESET_FLAG_ProcessPhysicsTasks, true );

	if (!m_pMoveNetworkHelper->IsInTargetState())
	{
#if AI_DEBUG_OUTPUT_ENABLED
		aiDebugf2("[Cover] - CTaskEnterCover::StandEntry_OnUpdate(), move network not in target state for ped: %s\n", AILogging::GetDynamicEntityNameSafe(GetPed()));
#endif
		return FSM_Continue;
	}

	if (CheckForPlayerInterrupt() || CheckForNetworkInterrupt())
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	CheckForWeaponRemoval(GetPed(), CClipScalingHelper::GetPhase(*m_pMoveNetworkHelper, 1));

	bool bAllClipsFinished = true;

	for (s32 i=0; i<3; ++i)
	{
		if (CClipScalingHelper::GetPhase(*m_pMoveNetworkHelper, i) < 1.0f)
		{
			bAllClipsFinished = false;
			break;
		}
	}

	if (bAllClipsFinished)
	{
		SetState(State_Finish);
		return FSM_Continue;
	}
	else
	{
#if AI_DEBUG_OUTPUT_ENABLED
		aiDebugf2("[Cover] - CTaskEnterCover::StandEntry_OnUpdate(), all clips not finished for ped: %s\n", AILogging::GetDynamicEntityNameSafe(GetPed()));
#endif
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::MovingEntry_OnEnter()
{
	// Start the cover network, setup the intro to be inserted
	CTaskCover* pCoverTask = static_cast<CTaskCover*>(GetParent());
	pCoverTask->StartCoverNetwork(false, false);

	if (!m_pMoveNetworkHelper)
	{
		m_pMoveNetworkHelper = pCoverTask->GetMoveNetworkHelper();
	}

	m_pMoveNetworkHelper->WaitForTargetState(ms_EnterCoverOnEnterId);

	// Request_DEPRECATED to go into the intro state and set the task
	m_pMoveNetworkHelper->SendRequest(ms_EnterCoverRequestId);
	const float fRate = fwRandom::GetRandomNumberInRange(ms_Tunables.m_AiEntryMinRate, ms_Tunables.m_AiEntryMaxRate);
	m_pMoveNetworkHelper->SetFloat(ms_AIEntryRateId, fRate);

	CPed& ped = *GetPed();

	Vector3 vCoverPos;
	Vector3 vCoverDir;

	if (GetNetCoverPointPosition(ped, vCoverPos))
	{
		GetNetCoverPointDirection(ped, vCoverDir);

		s32 flags = ComputeEnterCoverDirection(ped.GetTransform().GetPosition(), RCC_VEC3V(vCoverPos), RCC_VEC3V(vCoverDir));

		if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
		{
			flags |= CTaskCover::AF_Low;
		}

		fwMvClipId clipId = FindAIIntroClipFromFlags(ms_Tunables.m_AIEnterCoverClips, flags);
		fwMvClipSetId clipSetId = GetAiEntryClipsetFromWeapon(*GetPed());
		const crClip* pClip = fwClipSetManager::GetClip(clipSetId, clipId);

		if (!taskVerifyf(pClip, "Couldn't find valid clip for clipset %s", clipSetId.GetCStr()))
		{
			SetState(State_Finish);
			return FSM_Continue;
		}
		
		static bool ENABLE_DISTANCE_TAG_USAGE = true;
		if (ENABLE_DISTANCE_TAG_USAGE)
		{
			ComputeInitialPhase(pClip);
		}

		if (ms_Tunables.m_WaitForFootPlant)
		{
			RecomputeInitialPhaseFromFootPlant(pClip);
		}
		m_pMoveNetworkHelper->SetClip(pClip, ms_EnterCoverClipId);
		m_pMoveNetworkHelper->SetFlag(true, ms_AIEntryFlagId);
		m_fInitialHeading = ped.GetCurrentHeading();
		m_fEstBlendedInPhase = m_fInitialPhase + pClip->ConvertTimeToPhase(ms_Tunables.m_NetworkBlendInDuration);
		//Displayf("EstBlendInPhase : %.2f", m_fEstBlendedInPhase);
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::MovingEntry_OnUpdate()
{
	CPed* pPed = GetPed();
	pPed->SetPedResetFlag( CPED_RESET_FLAG_ProcessPhysicsTasks, true );
	TUNE_GROUP_BOOL(COVER_TUNE, FORCE_STRAFE, true);
	if (FORCE_STRAFE && !pPed->GetMovePed().IsTaskNetworkFullyBlended())
		pPed->SetIsStrafing(true);

	if (/*!m_bComputedIdealStartTransform &&*/ m_pMoveNetworkHelper && m_pMoveNetworkHelper->IsNetworkAttached() && pPed->GetMovePed().IsTaskNetworkFullyBlended())
	{
		const crClip* pClip = m_pMoveNetworkHelper->GetClip(CClipScalingHelper::ms_Clip0Id);
		if (pClip)
		{
			Vector3 vCoverPos(Vector3::ZeroType);

			if (GetNetCoverPointPosition(*pPed, vCoverPos))
			{
				// Compute target matrix
				QuatV qTargetRot;
				Mat34V targetMtx = ComputeTargetMatrix(RCC_VEC3V(vCoverPos), qTargetRot);
				
				// Store initial transform as an offset to the target transform
				m_vInitialPos = pPed->GetTransform().GetPosition();
				m_vInitialPos = UnTransformFull(targetMtx, m_vInitialPos);
				const QuatV qCovRotInv = Invert(qTargetRot);
				m_qInitialRot = Multiply(qCovRotInv, QuatVFromMat34V(pPed->GetTransform().GetMatrix()));

				// Compute where we should be playing the anim from (offset from the target)
				const float fCurrentPhase = m_pMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip0PhaseId);
				if (!m_bComputedIdealStartTransform)
				{
					m_fBlendedInPhase = fCurrentPhase;
					m_fInitialHeading = pPed->GetCurrentHeading();
				}

				ComputeIdealStartTransformRelativeToTarget(m_vIdealInitialPos, m_qIdealInitialRot, pClip, fCurrentPhase);
				m_bComputedIdealStartTransform = true;

				TUNE_GROUP_BOOL(COVER_TUNE, WARP_TO_IDEAL_POSITION, false);
				if (WARP_TO_IDEAL_POSITION)
				{
					Vec3V vGlobalIdealPos = m_vIdealInitialPos;
					QuatV qGlobalIdealRot = m_qIdealInitialRot;
					ComputeTransformFromOffsetsSplat(vGlobalIdealPos, qGlobalIdealRot, targetMtx);
					ScalarV scHeading = QuatVTwistAngle(qGlobalIdealRot, Vec3V(V_Z_AXIS_WONE));

					TUNE_GROUP_BOOL(COVER_TUNE, WARP_ROTATION_ONLY, true);
					if (WARP_ROTATION_ONLY)
					{
						pPed->Teleport(VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()), fwAngle::LimitRadianAngle(scHeading.Getf()));
					}
					else
					{
						pPed->Teleport(VEC3V_TO_VECTOR3(vGlobalIdealPos), fwAngle::LimitRadianAngle(scHeading.Getf()));
					}
				}

	#if DEBUG_DRAW
				TUNE_GROUP_BOOL(COVER_TUNE, RENDER_MATRICES, false);
				if (RENDER_MATRICES)
				{
					// Render initial ped transform
					RenderRelativeAxisInGlobalSpace(m_vInitialPos, m_qInitialRot, targetMtx);
					// Render ideal initial ped transform
					RenderRelativeAxisInGlobalSpace(m_vIdealInitialPos, m_qIdealInitialRot, targetMtx);
					// Render target transform
					RenderRelativeAxisInGlobalSpace(targetMtx.GetCol3(), qTargetRot, Mat34V(V_IDENTITY));
				}
	#endif
			}
		}
	}

	if (!m_pMoveNetworkHelper->IsInTargetState())
	{
#if AI_DEBUG_OUTPUT_ENABLED
		aiDebugf2("[Cover] - CTaskEnterCover::MovingEntry_OnUpdate(), move network not in target state for ped: %s\n", AILogging::GetDynamicEntityNameSafe(pPed));
#endif
		return FSM_Continue;
	}

	if (m_pMoveNetworkHelper->GetBoolean(ms_EnterCoverClipFinishedId))
	{
		SetState(State_TransitionToIdle);
		return FSM_Continue;
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::TransitionToIdle_OnEnter()
{
	// Test
	s32 flags = 0;

	if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		flags |= CTaskCover::AF_FaceLeft;
	}

	if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		flags |= CTaskCover::AF_Low;
	}

	fwMvClipId clipId = FindAIIntroClipFromFlags(ms_Tunables.m_AIEnterTransitionClips, flags);
	fwMvClipSetId clipSetId = GetAiTransitionClipsetFromWeapon(*GetPed());
	const crClip* pClip = fwClipSetManager::GetClip(clipSetId, clipId);

	if (!taskVerifyf(pClip, "Couldn't find valid clip for clipset %s", clipSetId.GetCStr()))
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	m_pMoveNetworkHelper->SetClip(pClip, ms_EnterCoverTransitionClipId);
	m_pMoveNetworkHelper->SendRequest(ms_AITransitionId);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::TransitionToIdle_OnUpdate()
{
	GetPed()->SetPedResetFlag( CPED_RESET_FLAG_ProcessPhysicsTasks, true );

	if (!m_pMoveNetworkHelper->IsInTargetState())
	{
#if AI_DEBUG_OUTPUT_ENABLED
		aiDebugf2("[Cover] - CTaskEnterCover::TransitionToIdle_OnUpdate(), move network not in target state for ped: %s\n", AILogging::GetDynamicEntityNameSafe(GetPed()));
#endif
		return FSM_Continue;
	}

	if (m_pMoveNetworkHelper->GetBoolean(ms_EnterCoverTransitionClipFinishedId))
	{
		SetState(State_Finish);
		return FSM_Continue;
	}
	aiDebugf2("[Cover] - CTaskEnterCover::TransitionToIdle_OnUpdate(), ms_EnterCoverTransitionClipFinishedId = %s\n", m_pMoveNetworkHelper->GetBoolean(ms_EnterCoverTransitionClipFinishedId) ? "True" : "Flase");

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskEnterCover::Finish_OnUpdate()
{
	CPed* pPed = GetPed();

	// Set the correct crouch status
	bool bShouldCrouch = !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);

		if (bShouldCrouch)
		{
			pPed->SetIsCrouching(true, 1000);
		}
		else
		{
			pPed->SetIsCrouching(false);
		}

	if (m_bCheckCoverDistance)
	{
		static float s_fMaxDistAwayFromCoverPoint = 1.0f;
		
		if ((VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()) - m_vTargetPos).XYMag2() > rage::square(s_fMaxDistAwayFromCoverPoint))
		{
			pPed->ReleaseCoverPoint();
		}
	}

	if (pPed->GetCoverPoint())
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_InCoverFacingLeft, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
		pPed->SetIsInCover(1);
	}

	return FSM_Quit;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskEnterCover::StreamAssets()
{
	bool bClipSetLoaded = false;

	fwMvClipSetId clipSetId(CTaskCover::GetWeaponHoldingClipSetForArmament(GetPed()));

	fwClipSet* pClipSet = fwClipSetManager::GetClipSet(clipSetId);
	if (pClipSet && taskVerifyf(pClipSet->IsStreamedIn_DEPRECATED(), "Clipset %s wasn't streamed in", clipSetId.GetCStr()))
	{
		bClipSetLoaded = true;
	}

	return bClipSetLoaded;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::ComputeInitialPhase(const crClip* pClip)
{
	taskAssert(m_fInitialPhase < 0.0f);

	CPed* pPed = GetPed();
	if (pClip)
	{
		// Compute flat xy vector to the cover point
		Vector3 vToTarget = m_vTargetPos - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		vToTarget.z = 0.0f;	

		// Compute total distance away from the cover
		const float fDistToCover = vToTarget.Mag();

// 		if (fDistToCover <= ms_Tunables.m_DistToUseShortestRotation)
// 		{
// 			m_bUseShortestRotationAngle = true;
// 		}

		float fFirstPhase = 0.0f;
		float fLastPhase = 0.0f;

		float fFirstDist = -1.0f;
		float fLastDist = 99.0f;

		if (pClip->HasTags())
		{
			// Create an iterator to find the tag with the closest distance to our actual distance from cover
			CClipEventTags::CTagIteratorAttribute<CClipEventTags::CDistanceMarkerTag, crPropertyAttributeFloat> it(*pClip->GetTags(), CClipEventTags::DistanceMarker, CClipEventTags::Distance);

			while (*it)
			{
				const float fTagDistance = (*it)->GetData()->GetDistance();
				if (fTagDistance < fDistToCover)
				{
					if (fTagDistance > fFirstDist)
					{
						fFirstDist = fTagDistance;
						fFirstPhase = (*it)->GetMid();
					}
				}
				else
				{
					if (fTagDistance < fLastDist)
					{
						fLastDist = fTagDistance;
						fLastPhase = (*it)->GetMid();
					}
				}
				++it;
			}
		}

		// Select the phase of the closest tag to start off at
		if (taskVerifyf(fFirstDist > 0.0f || fLastDist < 99.0f, "Couldn't find valid distance marker tags"))
		{
			if (fLastDist >= 99.0f)
			{
				m_fInitialPhase = fFirstPhase;
			}
			else if (fFirstDist < 0.0f)
			{
				m_fInitialPhase = fLastPhase;
			}
			else
			{
				m_fInitialPhase = Abs(fDistToCover - fFirstDist) < Abs(fDistToCover - fLastDist) ? fFirstPhase : fLastPhase;
			}

			// Set the initial intro phase and force an instant clip update to get the pose change this frame
			// this is done once at the beginning of the intro
			m_pMoveNetworkHelper->SetFloat(ms_EnterCoverClipInitialPhaseId, m_fInitialPhase);
// 			pPed->SetPedResetFlag(CPED_RESET_FLAG_ForcePostCameraAIUpdate, true);
// 			pPed->SetPedResetFlag(CPED_RESET_FLAG_ForcePostCameraAnimUpdate, true);
		}
		else
		{
			m_fInitialPhase = 0.0f;
		}

#if __DEV
		TUNE_GROUP_BOOL(COVER_TUNE, DISPLAY_DISTANCE_TAG_DEBUG, false); 
		if (DISPLAY_DISTANCE_TAG_DEBUG)
		{
			Displayf("============================================");
			Displayf("Initial Dist To Cover : %.2f", fDistToCover);
			Displayf("Initial Phase : %.2f", m_fInitialPhase);
			Displayf("First Dist/Phase = (%.2f/%.2f) : Last Dist/Phase = (%.2f/%.2f)", fFirstDist, fFirstPhase, fLastDist, fLastPhase);
			Displayf("============================================");
		}
#endif // __DEV
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskEnterCover::RecomputeInitialPhaseFromFootPlant(const crClip* pClip)
{
	if (pClip)
	{
		if (pClip->HasTags())
		{
			const crTags* pTags = pClip->GetTags();
			if (pTags)
			{
				float fFirstTagPhase = 0.0f;
				float fLastTagPhase = 1.0f;

				s32 iNumTags = pTags->GetNumTags();
				for (s32 i = 0; i < iNumTags; i++)
				{
					const crTag* pTag = pTags->GetTag(i);
					if (pTag && pTag->GetKey() == CClipEventTags::Foot)
					{
						const crPropertyAttributeBool* pAttribRight = static_cast<const crPropertyAttributeBool*>(pTag->GetProperty().GetAttribute(CClipEventTags::Right.GetHash()));
						if (pAttribRight && pAttribRight->GetBool() == m_bRightFootPlant)
						{
							if (pTag->GetStart() < m_fInitialPhase && pTag->GetStart() > fFirstTagPhase)
							{
								fFirstTagPhase = pTag->GetStart(); 
							}
							else if (pTag->GetStart() >= m_fInitialPhase && pTag->GetStart() < fLastTagPhase)
							{
								fLastTagPhase = pTag->GetStart(); 
							}
						}
					}
				}

				//Displayf("First Tag Phase: %.2f, Last Tag Phase: %.2f, Initial Phase : %.2f", fFirstTagPhase, fLastTagPhase, m_fInitialPhase);
				if (Abs(m_fInitialPhase - fFirstTagPhase) < Abs(fLastTagPhase - m_fInitialPhase))
				{
					m_fInitialPhase = fFirstTagPhase;
				}
				else
				{
					m_fInitialPhase = fLastTagPhase;
				}
				//Displayf("Initial Phase : %.2f", m_fInitialPhase);
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

#if DEBUG_DRAW
void CTaskEnterCover::RenderRelativeAxisInGlobalSpace(Vec3V_ConstRef vPosOffset, QuatV_ConstRef qRotOffset, Mat34V_ConstRef parentMtx)
{
	Vec3V vPosOffsetTemp = vPosOffset;
	QuatV qRotOffsetTemp = qRotOffset;
	ComputeTransformFromOffsetsSplat(vPosOffsetTemp, qRotOffsetTemp, parentMtx);
	Mat34V mtx;
	Mat34VFromQuatV(mtx, qRotOffsetTemp, vPosOffsetTemp);
	CTask::ms_debugDraw.AddAxis(mtx, 0.5f, true, 4000);
}
#endif // DEBUG_DRAW

#if !__FINAL
void CTaskEnterCover::Debug() const
{
#if __BANK

	const CPed& ped = *GetPed();
	if (ped.IsLocalPlayer())
	{
		Vector3 vCoverCoords = m_vTargetPos;
		vCoverCoords.z -= 1.0f;
		// Print out the previous frames cover coords
		grcDebugDraw::AddDebugOutput(Color_orange, "vCoverCoords : (%.2f, %.2f, %.2f)", vCoverCoords.x, vCoverCoords.y, vCoverCoords.z);
		grcDebugDraw::Line(vCoverCoords, VEC3V_TO_VECTOR3(GetPed()->GetTransform().GetPosition()), Color_green);
		grcDebugDraw::Sphere(vCoverCoords, 0.025f, Color_green);

		if (ped.GetCoverPoint())
		{
			Vector3 vCoverPosition(Vector3::ZeroType);
			if (ped.GetCoverPoint()->GetCoverPointPosition(vCoverPosition))
			{
				Vector3 vPosClose = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition()) + Vector3(0.0f, 0.0f, 1.0f);
				Vector3 vHeadClose = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition()) + Vector3(0.0f, 0.0f, 1.25f);
				const Vector3 vCoverDirection = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector());
				const bool bIsFacingLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
				//const Vector2 vStickInput = CTaskCover::ComputeStickInput(ped);

				const bool bPositionCloseEnough = CTaskMotionInCover::IsPedCloseEnoughToCover(ped, vCoverPosition);
				const bool bHeadingCloseEnough = CTaskMotionInCover::IsPedsheadingCloseEnoughToFacingDirection(ped, vCoverDirection, bIsFacingLeft);
			
				grcDebugDraw::Sphere(vPosClose, 0.05f, bPositionCloseEnough ? Color_green : Color_red);
				grcDebugDraw::Sphere(vHeadClose, 0.05f, bHeadingCloseEnough ? Color_green : Color_red);
			}
		}
	}

	grcDebugDraw::Sphere(m_vTargetPos, 0.025f, Color_orange);

	Vector3 vForward(0.0f, 1.0f, 0.0f);
	vForward.RotateZ(m_fEndDirection);
	vForward += m_vTargetPos;
	
	grcDebugDraw::Line(RCC_VEC3V(m_vTargetPos), RCC_VEC3V(vForward), Color_red);

	if (GetPed()->GetCoverPoint())
	{
		Vector3 vCoverDir = VEC3V_TO_VECTOR3(GetPed()->GetCoverPoint()->GetCoverDirectionVector());
		Vector3 vCoverRight = vCoverDir;
		vCoverRight.RotateZ(-HALF_PI);

		vCoverDir += m_vTargetPos;
		grcDebugDraw::Line(RCC_VEC3V(m_vTargetPos), RCC_VEC3V(vCoverDir), Color_blue);

		vCoverRight += m_vTargetPos;
		grcDebugDraw::Line(RCC_VEC3V(m_vTargetPos), RCC_VEC3V(vCoverRight), Color_purple);
		}
#endif // __BANK
}
#endif // !__FINAL

////////////////////////////////////////////////////////////////////////////////

// Statics
CTaskExitCover::Tunables CTaskExitCover::ms_Tunables;

const fwMvRequestId	CTaskExitCover::ms_ExitCoverRequestId("ExitCover",0x4ED2895);
const fwMvBooleanId	CTaskExitCover::ms_ExitCoverOnEnterId("ExitCover_OnEnter",0xD9C51C3C);
const fwMvBooleanId	CTaskExitCover::ms_ExitCoverClipFinishedId("ExitCoverClipFinished",0x88E69B55);
const fwMvBooleanId	CTaskExitCover::ms_CoverExitInterruptId("CoverExitInterrupt",0xAF5DD23D);
const fwMvBooleanId	CTaskExitCover::ms_CoverExitSprintInterruptId("CoverExitSprintInterrupt",0xC9D2A3BD);
const fwMvBooleanId CTaskExitCover::ms_CoverExitPhaseOutId("CoverExitPhaseOut",0xDD79C587);
const fwMvBooleanId CTaskExitCover::ms_CoverBreakInterruptId("CoverBreakInterrupt",0xB7346B4F);
const fwMvBooleanId CTaskExitCover::ms_CanAdjustHeadingInterruptId("CanAdjustHeadingInterrupt",0x37C25C53);
const fwMvClipId	CTaskExitCover::ms_ExitCoverClipId("ExitCoverClip",0x2D811C1B);
const fwMvClipId	CTaskExitCover::ms_ExitCoverWeaponClipId("ExitCoverWeaponClip",0xE008960C);
const fwMvClipId	CTaskExitCover::ms_ExitCoverWeaponClip0Id("ExitCoverWeaponClip0",0x39615DE9);
const fwMvClipId	CTaskExitCover::ms_ExitCoverWeaponClip1Id("ExitCoverWeaponClip1",0x4716F954);
const fwMvClipId	CTaskExitCover::ms_ExitCoverWeaponClip2Id("ExitCoverWeaponClip2",0x14E794F6);
const fwMvFloatId	CTaskExitCover::ms_AngleToCoverId("AngleToCover",0x78C49F1C);
const fwMvFlagId	CTaskExitCover::ms_DirectionalFlagId("Directional",0xC5EFF7DB);

IMPLEMENT_COMBAT_TASK_TUNABLES(CTaskExitCover, 0x27c523f4);

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskExitCover::Tunables::GetExitCoverBaseClipSetIdForPed(const CPed& rPed)
{
	FPS_MODE_SUPPORTED_ONLY( if (CTaskMotionInCover::ShouldUseFirstPersonLocoAnimations(rPed)) return m_ExitCoverBaseFPSClipSetId; )
		return m_ExitCoverBaseClipSetId;
}

fwMvClipSetId CTaskExitCover::Tunables::GetExitCoverExtraClipSetIdForPed(const CPed& rPed)
{
	FPS_MODE_SUPPORTED_ONLY( if (CTaskMotionInCover::ShouldUseFirstPersonLocoAnimations(rPed)) return m_ExitCoverExtraFPSClipSetId; )
		return m_ExitCoverExtraClipSetId;
}

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskExitCover::Tunables::GetStandExitCoverAnimStateInfoForPed(const CPed& rPed)
{
	FPS_MODE_SUPPORTED_ONLY( if (CTaskMotionInCover::ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_StandExitAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_StandExitAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskExitCover::CanPedUseCornerExit(const CPed& ped, bool bIsFacingLeft)
{
	if (ped.IsLocalPlayer())
	{
		if (!ped.GetCoverPoint() || !ped.GetCoverPoint()->IsEdgeCoverPoint(bIsFacingLeft))
		{
			return false;
		}

		const CControl *pControl = ped.GetControlFromPlayer();
		if(pControl)
		{
			Vector3 vStickInput(pControl->GetPedWalkLeftRight().GetNorm(), -pControl->GetPedWalkUpDown().GetNorm(), 0.0f);
			if(vStickInput.Mag2() > 0.f)
			{
				// Don't let us go back in on ourselve
				if (bIsFacingLeft)
				{
					vStickInput.x = Clamp(vStickInput.x, -1.0f, 0.0f);
				}
				else
				{
					vStickInput.x = Clamp(vStickInput.x, 0.0f, 1.0f);
				}
				
				float fCamOrient = camInterface::GetPlayerControlCamHeading(ped);
				float fStickAngle = rage::Atan2f(-vStickInput.x, vStickInput.y);
				fStickAngle = fStickAngle + fCamOrient;
				fStickAngle = fwAngle::LimitRadianAngle(fStickAngle);
				Vector3 vForward = VEC3V_TO_VECTOR3(ped.GetTransform().GetB());
				Vector3 vStart = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition()) + vForward * ms_Tunables.m_ExitCornerYOffset;
				Vector3 vDirection = YAXIS;
				vDirection.RotateZ(fStickAngle);
				vDirection.Scale(ms_Tunables.m_ExitCornerDirOffset);
				Vector3 vEnd = vStart + vDirection;
				Vector3 vZOffset(0.0f, 0.0f, ms_Tunables.m_ExitCornerZOffset);

				// Do a couple of capsule tests high and low to check the area we want to move to is clear
				if (CTaskCover::IsPathClearForPed(ped, vStart, vEnd, vZOffset, ArchetypeFlags::GTA_ALL_TYPES_MOVER) &&
					CTaskCover::IsPathClearForPed(ped, vStart, vEnd, vZOffset, ArchetypeFlags::GTA_ALL_TYPES_MOVER))
				{
					return true;
				}
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskExitCover::IsTaskValid(const CPed& ped)
{
	if (ped.IsLocalPlayer())
	{
		if (!CTaskCover::IsCoverClipSetLoaded(CTaskCover::ms_Tunables.GetStreamedUnarmedCoverMovementClipSetIdForPed(ped)))
		{
			return false;
		}

		fwMvClipSetId streamedClipsetId = CTaskCover::GetWeaponHoldingExtraClipSetForArmament(ped);
		if (streamedClipsetId != CLIP_SET_ID_INVALID && !CTaskCover::IsCoverClipSetLoaded(streamedClipsetId))
		{
			return false;
		}
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipId CTaskExitCover::FindExitClipFromFlags(s32 flags)
{
	const atArray<ExitClip>& exitClipArray = ms_Tunables.m_CornerExitClips;

	for (s32 i=0; i<exitClipArray.GetCount(); ++i)
	{
		if (exitClipArray[i].m_Flags == flags)
		{
			return exitClipArray[i].m_ExitClipId;
		}
	}
	taskAssertf(0, "Couldn't find exit clip: flags %i",  flags);
	return CLIP_ID_INVALID;
}


////////////////////////////////////////////////////////////////////////////////

CTaskExitCover::CTaskExitCover(CMoveNetworkHelper& coverMoveNetworkHelper, CMoveNetworkHelper& useCoverMoveNetworkHelper, CTaskCover::eInCoverTerminationReason eExitType)
: m_coverMoveNetworkHelper(coverMoveNetworkHelper)
, m_useCoverMoveNetworkHelper(useCoverMoveNetworkHelper)
, m_eExitType(eExitType)
, m_fCoverExitInterruptPhase(-1.0f)
, m_fCoverExitSprintInterruptPhase(-1.0f)
, m_fCoverExitPhaseOutPhase(-1.0f)
, m_fCoverExitDirection(-1.0f)
, m_fCoverExitInitialHeading(0)
, m_bInterruptPhasesLoaded(false)
{
	SetInternalTaskType(CTaskTypes::TASK_EXIT_COVER);
}

////////////////////////////////////////////////////////////////////////////////

CTaskExitCover::~CTaskExitCover()
{

}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskExitCover::ProcessPreFSM()
{
	CPed& ped = *GetPed();
	ped.ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);
	ped.SetPedResetFlag( CPED_RESET_FLAG_ProcessPreRender2, true );
	ped.SetPedResetFlag( CPED_RESET_FLAG_IsExitingCover, true );

#if FPS_MODE_SUPPORTED
	if (m_useCoverMoveNetworkHelper.IsNetworkActive())
	{
		const float fMvCamHeading = CTaskCover::ComputeMvCamHeadingForPed(ped);
		m_useCoverMoveNetworkHelper.SetFloat(CTaskMotionInCover::ms_CamHeadingId, IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? fMvCamHeading : 1.0f - fMvCamHeading);
	}
#endif // FPS_MODE_SUPPORTED

	return FSM_Continue;
}

void CTaskExitCover::ProcessPreRender2()
{
	CTaskCover::UpdateLeftHandIk(GetPed());
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskExitCover::UpdateFSM( const s32 iState, const FSM_Event iEvent )
{
	FSM_Begin

		FSM_State(State_Start)
			FSM_OnUpdate
				return Start_OnUpdate();	

		FSM_State(State_StreamAssets)
			FSM_OnUpdate
				return StreamAssets_OnUpdate();	

		FSM_State(State_IdleExit)
			FSM_OnEnter
				return IdleExit_OnEnter();
			FSM_OnUpdate
				return IdleExit_OnUpdate();
	
		FSM_State(State_CornerExit)
			FSM_OnEnter
				return CornerExit_OnEnter();
			FSM_OnUpdate
				return CornerExit_OnUpdate();

		FSM_State(State_Finish)
			FSM_OnUpdate
				return FSM_Quit;

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskExitCover::Start_OnUpdate()
{
	taskAssertf(m_eExitType != CTaskCover::TR_NormalExit, "Invalid exit type");
	SetState(State_StreamAssets);
	return FSM_Continue;
}
////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskExitCover::StreamAssets_OnUpdate()
{
	CPed& ped = *GetPed();
	eExitClipType exitType = (m_eExitType == CTaskCover::TR_IdleExit) ? ET_Idle : ET_Corner;
	fwMvClipSetId baseClipSetId = GetBaseClipSetId(exitType, ped);
	fwMvClipSetId weaponHoldingClipSetId = GetWeaponHoldingClipSetId(ped, exitType);

	if (baseClipSetId == CLIP_SET_ID_INVALID)
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	const bool bBaseClipSetConditionPassed = m_BaseClipSetRequestHelper.Request(baseClipSetId);
	const bool bWeaponClipSetConditionPassed = weaponHoldingClipSetId == CLIP_SET_ID_INVALID ? true : m_WeaponClipSetRequestHelper.Request(weaponHoldingClipSetId);
	if (bBaseClipSetConditionPassed && bWeaponClipSetConditionPassed)
	{
		if (!static_cast<CTaskCover*>(GetParent())->RestartUseCoverNetwork(&ped))
		{
			SetState(State_Finish);
			return FSM_Continue;
		}

		if (m_eExitType == CTaskCover::TR_IdleExit)
		{
			SetState(State_IdleExit);
			return FSM_Continue;
		}
		else
		{
			SetState(State_CornerExit);
			return FSM_Continue;
		}
	}
	return FSM_Continue;
}


CTask::FSM_Return CTaskExitCover::IdleExit_OnEnter()
{
	CPed& ped = *GetPed(); 

	// Send exit request/send move params
	SetUpCoverExit(ped, ET_Idle);

	// We always end up stood up, so force the underlying crouch status
	ped.SetIsCrouching(false);

	m_fCoverExitDirection = -1.0f;
	UpdateExitDirection(ped);
	return FSM_Continue;
}


////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskExitCover::IdleExit_OnUpdate()
{
	CPed& ped = *GetPed();
	ped.SetPedResetFlag(CPED_RESET_FLAG_SyncDesiredHeadingToCurrentHeading, false);

	if (!m_useCoverMoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	if (!m_bInterruptPhasesLoaded) //load interrupt phases if needed
	{
		//tags are stored on the _00
		const crClip* pZeroClip = CClipScalingHelper::GetClip(m_useCoverMoveNetworkHelper, 1);
		if (pZeroClip)
		{
			m_bInterruptPhasesLoaded = true;
			static const atHashString ms_BlendOutRootIkSlopeFixup("BlendOutRootIkSlopeFixup",0xA5690A9E);
			if (!CClipEventTags::FindEventPhase<crPropertyAttributeHashString>(pZeroClip, CClipEventTags::MoveEvent, CClipEventTags::MoveEvent, ms_CoverExitInterruptId, m_fCoverExitInterruptPhase))
			{
				m_fCoverExitInterruptPhase = 0.476f;
				m_bInterruptPhasesLoaded = false;
			}
			if (!CClipEventTags::FindEventPhase<crPropertyAttributeHashString>(pZeroClip, CClipEventTags::MoveEvent, CClipEventTags::MoveEvent, ms_CoverExitSprintInterruptId, m_fCoverExitSprintInterruptPhase))
			{
				m_fCoverExitSprintInterruptPhase = 0.238f;
				m_bInterruptPhasesLoaded = false;
			}
			if (!CClipEventTags::FindEventPhase<crPropertyAttributeHashString>(pZeroClip, CClipEventTags::MoveEvent, CClipEventTags::MoveEvent, ms_CoverExitPhaseOutId, m_fCoverExitPhaseOutPhase))
			{
				m_fCoverExitPhaseOutPhase = 0.810f;
				m_bInterruptPhasesLoaded = false;
			}
		}
	}

	float interruptPhase = 0;
	bool bAllClipsFinished = true;
	float phase;
	for (s32 i=0; i<3; ++i)
	{
		phase = CClipScalingHelper::GetPhase(m_useCoverMoveNetworkHelper, i);
		interruptPhase = Max(phase, interruptPhase);
		if (phase < 1.0f)
		{
			bAllClipsFinished = false;
			break;
		}
	}

	static dev_float s_fMaxDirectionChangePhase = 0.9f;
	if (interruptPhase <= s_fMaxDirectionChangePhase && !ped.GetPedConfigFlag(CPED_CONFIG_FLAG_VaultFromCover))
	{
		UpdateExitDirection(ped);
	}

	if (bAllClipsFinished || interruptPhase >= m_fCoverExitPhaseOutPhase)
	{
		if (ped.GetPedConfigFlag(CPED_CONFIG_FLAG_VaultFromCover))
		{
			CTaskJumpVault::WillVault(&ped, JF_ForceVault|JF_DisableJumpingIfNoClimb|JF_UseCachedHandhold);
		}
		SetState(State_Finish);
	}

	Vector2 vecStick;
	const CControl *pControl = NULL;
	//Update player MBR so it's ready when this task is done
	if (ped.IsLocalPlayer())
	{
		pControl = ped.GetControlFromPlayer();
		if(pControl)
		{
			vecStick.Set(pControl->GetPedWalkLeftRight().GetNorm(), pControl->GetPedWalkUpDown().GetNorm());
			if (vecStick.Mag2() < 0.1f)
				ped.GetMotionData()->SetCurrentMoveBlendRatio(0.0f);
		}
	}

	//Early abort	
	if (interruptPhase >= m_fCoverExitSprintInterruptPhase && ped.IsLocalPlayer())
	{
		if(pControl)
		{
			if (vecStick.Mag2() > ms_Tunables.m_MinInputToInterruptIdle)
			{
				TUNE_GROUP_FLOAT(COVER_EXIT_TUNE, MIN_MBR_TO_DO_RUN, 0.4f, 0.0f, 1.0f, 0.01f);
				CTaskCover::eInCoverTerminationReason eTerminationReason = ped.GetMotionData()->GetCurrentMbrY() > MIN_MBR_TO_DO_RUN ? CTaskCover::TR_IdleExitToRun : CTaskCover::TR_IdleExitToRunStart;
				static_cast<CTaskCover*>(GetParent())->SetInCoverTerminationReason(eTerminationReason);	
				//ped.ForceMotionStateThisFrame(eTerminationReason == (CTaskCover::TR_IdleExitToRun ? CPedMotionStates::MotionState_Run : CPedMotionStates::MotionState_Idle);
				ped.ForceMotionStateThisFrame(pControl->GetPedSprintIsDown() ? CPedMotionStates::MotionState_Run : CPedMotionStates::MotionState_Walk);
				SetState(State_Finish);
				return FSM_Continue;
			}
		}
	}

	//Late abort	
	if (interruptPhase >= m_fCoverExitInterruptPhase)
	{
		bool bInterrupt = false;

		if (ped.IsLocalPlayer())
		{
			if ( ped.GetPlayerInfo()->IsAiming() || ped.IsUsingActionMode() || ped.IsUsingStealthMode())
			{
				bInterrupt = true;
				ped.SetDesiredHeading(ped.GetCurrentHeading());
			}

			if (!bInterrupt)
			{
				if(pControl)
				{
					if (pControl->GetPedCover().IsPressed() || pControl->GetPedSprintIsPressed())
					{
						bInterrupt = true;
					}
					if (!bInterrupt)
					{						
						if(vecStick.Mag2() > ms_Tunables.m_MinInputToInterruptIdle)
						{
							bInterrupt = true;
						}
					}
				}
			}
		}
		else
		{
			bInterrupt = true;
		}

		if (bInterrupt)
		{
			if (ped.GetPedConfigFlag(CPED_CONFIG_FLAG_VaultFromCover))
			{
				CTaskJumpVault::WillVault(&ped, JF_ForceVault|JF_DisableJumpingIfNoClimb|JF_UseCachedHandhold);
			}
			ped.ForceMotionStateThisFrame(CPedMotionStates::MotionState_Idle);
			SetState(State_Finish);
			return FSM_Continue;
		}
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskExitCover::CornerExit_OnEnter()
{
	CPed& ped = *GetPed();

	// Send exit request/send move params
	SetUpCoverExit(ped, ET_Corner);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskExitCover::CornerExit_OnUpdate()
{
	CPed& ped = *GetPed();
	ped.ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);

	if (GetTimeInState() > 5.0f)
	{
		AI_LOG_WITH_ARGS("[Cover] - CornerExit_OnUpdate(), Ped: %s, finishing state due to time out. IsInTargetState is: %s", AILogging::GetDynamicEntityNameSafe(&ped), m_useCoverMoveNetworkHelper.IsInTargetState() ? "TRUE" : "FALSE");		
		SetState(State_Finish);
	}

	if (!m_useCoverMoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	if (m_useCoverMoveNetworkHelper.GetBoolean(ms_CanAdjustHeadingInterruptId))
	{
		const CControl *pControl = ped.GetControlFromPlayer();
		if(pControl)
		{
			Vector3 vStickInput(pControl->GetPedWalkLeftRight().GetNorm(), -pControl->GetPedWalkUpDown().GetNorm(), 0.0f);
			if(vStickInput.Mag2() > 0.f)
			{
				float fCamOrient = camInterface::GetPlayerControlCamHeading(ped);
				float fStickAngle = rage::Atan2f(-vStickInput.x, vStickInput.y);
				fStickAngle = fStickAngle + fCamOrient;
				fStickAngle = fwAngle::LimitRadianAngle(fStickAngle);
				ped.SetDesiredHeading(fStickAngle);

				CTaskMotionBase* pTask = ped.GetCurrentMotionTask();
				float desiredHeading = pTask ? pTask->CalcDesiredDirection(): 0.0f;	
				ped.GetMotionData()->SetExtraHeadingChangeThisFrame(desiredHeading * ms_Tunables.m_CornerExitHeadingModifier * GetTimeStep());
			}
		}
	}

	bool bAimInterrupt = false;
	bool bInterrupt = false;
	if (m_useCoverMoveNetworkHelper.GetBoolean(ms_CoverBreakInterruptId))
	{
		if (ped.IsLocalPlayer() && ped.GetEquippedWeaponInfo() && (ped.GetEquippedWeaponInfo()->GetIsGunOrCanBeFiredLikeGun() || ped.GetEquippedWeaponInfo()->GetCanBeAimedLikeGunWithoutFiring()))
		{
			if (ped.GetPlayerInfo()->IsAiming() || ped.GetPlayerInfo()->IsFiring())
			{
				bInterrupt = true;
				bAimInterrupt = true;
			}
		}
	}

	if (bInterrupt || m_useCoverMoveNetworkHelper.GetBoolean(ms_ExitCoverClipFinishedId) || m_useCoverMoveNetworkHelper.GetBoolean(ms_CoverExitPhaseOutId))
	{				
		if (bAimInterrupt)
		{
			ped.ForceMotionStateThisFrame(CPedMotionStates::MotionState_Aiming);
		}
		else
		{
			ped.ForceMotionStateThisFrame(CPedMotionStates::MotionState_Run);
		}
		if (ped.IsLocalPlayer())
		{
			ped.SetCoverPoint(NULL);
		}
		SetState(State_Finish);
		return FSM_Continue;
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

s32 CTaskExitCover::GetCoverFlags() const
{
	s32 iFlags = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? CTaskCover::AF_FaceLeft : 0;
	if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		iFlags |= CTaskCover::AF_Low;
	}
	return iFlags;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskExitCover::SetUpCoverExit(CPed& ped, eExitClipType exitType)
{
	s32 flags = GetCoverFlags();
	m_useCoverMoveNetworkHelper.SendRequest(ms_ExitCoverRequestId);
	m_useCoverMoveNetworkHelper.WaitForTargetState(ms_ExitCoverOnEnterId);	
	fwMvClipSetId baseClipSetId = GetBaseClipSetId(exitType, ped);
		
	fwMvClipSetId weaponHoldingClipSetId = GetWeaponHoldingClipSetId(ped, exitType);
	if (fwClipSetManager::IsStreamedIn_DEPRECATED(baseClipSetId) &&
		(weaponHoldingClipSetId == CLIP_SET_ID_INVALID || fwClipSetManager::IsStreamedIn_DEPRECATED(weaponHoldingClipSetId)))
	{
		if (exitType == ET_Idle)
		{
			m_useCoverMoveNetworkHelper.SetFlag(true, ms_DirectionalFlagId);
			const atArray<CTaskCover::CoverAnimStateInfo>& aCoverAnimStateInfos = ms_Tunables.GetStandExitCoverAnimStateInfoForPed(ped);
			const CTaskCover::CoverAnimStateInfo* pAnimStateInfo = CTaskCover::GetAnimStateInfoForState(aCoverAnimStateInfos, flags);	
			if (!pAnimStateInfo)
			{
				taskAssert(0);
				return;
			}
			taskAssert(pAnimStateInfo->m_Clips.GetCount() > 0);
			for (s32 i=0; i<pAnimStateInfo->m_Clips.GetCount(); ++i)
			{
				const crClip* pClip = fwClipSetManager::GetClip(baseClipSetId, pAnimStateInfo->m_Clips[i]);

				if (!taskVerifyf(pClip, "Couldn't find valid clip in clipset %s for clip %s", baseClipSetId.GetCStr(), pAnimStateInfo->m_Clips[i].GetCStr()))
				{					
					return;
				}

 				const crClip* pWeaponHoldingClip = NULL; 
 				if (weaponHoldingClipSetId != CLIP_SET_ID_INVALID)
 				{
 					pWeaponHoldingClip = fwClipSetManager::GetClip(weaponHoldingClipSetId, pAnimStateInfo->m_Clips[i]);
					if (i<3)
					{
						m_useCoverMoveNetworkHelper.SetClip(pWeaponHoldingClip, GetWeaponClipId(i));
					}
					
					m_useCoverMoveNetworkHelper.SetFlag(true, CTaskMotionInCover::ms_UseWeaponHoldingId);
					m_useCoverMoveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_UseGripClipId);
				}	
				else
					CTaskMotionInCover::SetGripClip(&ped, m_useCoverMoveNetworkHelper);			
				m_useCoverMoveNetworkHelper.SetClip(pClip, CClipScalingHelper::GetClipId(i));
			}

		}
		else 
		{
			fwMvClipId clipId = FindExitClipFromFlags(flags);
			if (clipId != CLIP_ID_INVALID)
			{
				m_useCoverMoveNetworkHelper.SetFlag(false, ms_DirectionalFlagId);
				const crClip* pBaseClip = fwClipSetManager::GetClip(baseClipSetId, clipId);
				const crClip* pWeaponHoldingClip = NULL;
				
				if (weaponHoldingClipSetId != CLIP_SET_ID_INVALID)
				{
					pWeaponHoldingClip = fwClipSetManager::GetClip(weaponHoldingClipSetId, clipId);
				}

				m_useCoverMoveNetworkHelper.SetClip(pBaseClip, ms_ExitCoverClipId);

				if (pWeaponHoldingClip)
				{
					m_useCoverMoveNetworkHelper.SetClip(pWeaponHoldingClip, ms_ExitCoverWeaponClipId);
					m_useCoverMoveNetworkHelper.SetFlag(true, CTaskMotionInCover::ms_UseWeaponHoldingId);
					m_useCoverMoveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_UseGripClipId);
				}
				else
				{
					CTaskMotionInCover::SetGripClip(&ped, m_useCoverMoveNetworkHelper);		
					m_useCoverMoveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_UseWeaponHoldingId);
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
const fwMvClipId CTaskExitCover::GetWeaponClipId(s32 i) const
{
	switch (i)
	{
	case 0 : return ms_ExitCoverWeaponClip0Id;
	case 1 : return ms_ExitCoverWeaponClip1Id;
	case 2 : return ms_ExitCoverWeaponClip2Id;
	default: taskAssertf(0, "Unhandled clip index");
	}
	return CLIP_ID_INVALID;
}


void CTaskExitCover::UpdateExitDirection(CPed &ped) 
{
	//Compute angle of exit	
	Vector3 vCoverPos;
	float fExitDirection = 0.0f;
	if (ped.GetCoverPoint())
	{
		ped.GetCoverPoint()->GetCoverPointPosition(vCoverPos);
		Vec3V vCoverDir = ped.GetCoverPoint()->GetCoverDirectionVector();
		vCoverDir = Normalize(vCoverDir);		
		if (GetCoverFlags() & CTaskCover::AF_Low || ped.GetPedConfigFlag(CPED_CONFIG_FLAG_VaultFromCover))
			vCoverDir = Negate(vCoverDir);
		float fExitHeading = rage::Atan2f(vCoverDir.GetXf(), -vCoverDir.GetYf());

		//stick
		if (ped.IsLocalPlayer())
		{
			CControl *pControl = ped.GetControlFromPlayer();			
			Vector3 vecStick(pControl->GetPedWalkLeftRight().GetNorm(), -pControl->GetPedWalkUpDown().GetNorm(), 0);
			if (vecStick.Mag2() > ms_Tunables.m_MinInputToInterruptIdle && !ped.GetPedConfigFlag(CPED_CONFIG_FLAG_VaultFromCover))
			{				
				float fCamOrient = camInterface::GetPlayerControlCamHeading(ped);
				fExitHeading = rage::Atan2f(-vecStick.x, vecStick.y) + fCamOrient;
				fExitHeading = fwAngle::LimitRadianAngle(fExitHeading);						
			} 
		}
		ped.SetDesiredHeading(fExitHeading);
		
		float fPedHeading;
		if (m_fCoverExitDirection<0)
		{
			fPedHeading = ped.GetTransform().GetHeading();
			m_fCoverExitInitialHeading = fPedHeading;
		}
		else
		{
			fPedHeading = m_fCoverExitInitialHeading;
		}
		
		fExitDirection = fPedHeading - fExitHeading;
		//Displayf("%f - %f = %f", fPedHeading, fExitHeading, fExitDirection);
		fExitDirection = fwAngle::LimitRadianAngle(fExitDirection);

#if DEBUG_DRAW		
		Vec3V vCoverPosition = RCC_VEC3V(vCoverPos);
		Vector3 ed = Vector3(0.0f, 1.0f, 0.0f);
		ed.RotateZ(fExitHeading);
		Vec3V vExitDirDir = RCC_VEC3V(ed);
		Vec3V vFacingPosition = vCoverPosition + vExitDirDir;
		ms_debugDraw.AddArrow(vCoverPosition, vFacingPosition, 0.25f, Color_purple, 2000);
#endif
		fExitDirection = 1.0f - (rage::Clamp(fExitDirection/PI, -1.0f, 1.0f) + 1.0f ) * 0.5f;
		//Displayf("Parameter: %.4f ", fExitDirection);
	}
	static dev_float s_fExitDirectionApproachRate = 3.0f;
	if (m_fCoverExitDirection<0)
	{
		m_fCoverExitDirection = fExitDirection;
	} else
		Approach(m_fCoverExitDirection, fExitDirection, s_fExitDirectionApproachRate, fwTimer::GetTimeStep());
	m_useCoverMoveNetworkHelper.SetFloat(ms_AngleToCoverId, m_fCoverExitDirection);
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskExitCover::GetBaseClipSetId(eExitClipType exitType, const CPed& rPed)
{
	return exitType==ET_Idle ? ms_Tunables.GetExitCoverBaseClipSetIdForPed(rPed) : ms_Tunables.GetExitCoverExtraClipSetIdForPed(rPed);
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskExitCover::GetWeaponHoldingClipSetId(const CPed& ped, eExitClipType exitType)
{
	if (exitType == ET_Idle)
	{
		return CTaskCover::GetWeaponHoldingClipSetForArmament(&ped);
	}	
	else if (ped.GetWeaponManager())
	{
		const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfo();
		if (pWeaponInfo)
		{			
			if (pWeaponInfo->GetIsGun2Handed() || pWeaponInfo->ShouldPedUseAlternateCoverClipSet(ped))
			{
				return pWeaponInfo->GetPedCoverMovementExtraClipSetId(ped);
			}
		}
	}
	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

// Statics
CTaskInCover::Tunables CTaskInCover::ms_Tunables;

IMPLEMENT_COMBAT_TASK_TUNABLES(CTaskInCover, 0xfd3503da);

CCoverPoint CTaskInCover::ms_aPlayerCoverPoints[3];

////////////////////////////////////////////////////////////////////////////////

const fwMvBooleanId CTaskInCover::ms_AimIntroOnEnterId("AimIntro_OnEnter",0x19A13C4);
const fwMvBooleanId CTaskInCover::ms_AimOutroOnEnterId("AimOutro_OnEnter",0x61A9BDAE);
const fwMvBooleanId CTaskInCover::ms_BlindFiringOnEnterId("BlindFiring_OnEnter",0xBC3B1DD1);

const fwMvRequestId CTaskInCover::ms_AimIntroRequestId("AimIntro",0xAA6165EF);
const fwMvRequestId CTaskInCover::ms_AimOutroRequestId("AimOutro",0xD8F9CDBE);

const fwMvRequestId CTaskInCover::ms_BlindFiringRequestId("BlindFiring",0x2FE716CD);
const fwMvRequestId CTaskInCover::ms_ReloadingRequestId("ReloadWeapon",0xA4C018AA);
const fwMvRequestId CTaskInCover::ms_SwapWeaponRequestId("SwapWeapon",0x22EAEF82);
const fwMvBooleanId CTaskInCover::ms_ReloadOnEnterId("Reload_OnEnter",0x63CD5A69);
const fwMvBooleanId CTaskInCover::ms_WeaponSwapOnEnterId("SwapWeapon_OnEnter",0x108A0846);

const fwMvFloatId CTaskInCover::ms_MoveBackFromFiringRateId("MoveBackFromFiringRate",0xF285C26);
const fwMvFloatId CTaskInCover::ms_MoveOutToFireRateId("MoveOutToFireRate",0xCCE5A7D2);
const fwMvFloatId CTaskInCover::ms_IntroPhaseId("IntroPhase",0xE8C2B9F8);
const fwMvFloatId CTaskInCover::ms_AimIntroRateId("AimIntroRate",0xE4706446);
const fwMvFloatId CTaskInCover::ms_AimOutroRateId("AimOutroRate",0x6693E405);
const fwMvFloatId CTaskInCover::ms_PitchId("Pitch",0x3F4BB8CC);
const fwMvFlagId  CTaskInCover::ms_IsCrouchedFlagId("IsCrouched",0x236D194B);
const fwMvFilterId CTaskInCover::ms_AimIntroFilterId("AimIntroFilter",0x3F7DCFCE);
atHashWithStringNotFinal CTaskInCover::ms_FullFilter("BONEMASK_ALL",0x540BB62);
atHashWithStringNotFinal CTaskInCover::ms_NoMoverFilter("NoMover_filter",0x30DFE311);

const fwMvNetworkId CTaskInCover::ms_ReloadNetworkId("ReloadNetwork",0x9E14BBCF);
const fwMvNetworkId CTaskInCover::ms_WeaponSwapNetworkId("SwapWeaponNetwork",0xB42BAE88);

const fwMvFloatId	CTaskInCover::ms_Clip1BlendId("Clip1Blend",0xD2793EF0);

const fwMvClipId CTaskInCover::ms_Clip0Id("Clip0",0xF416C5E4);
const fwMvClipId CTaskInCover::ms_Clip1Id("Clip1",0xD60C89C4);
const fwMvClipId CTaskInCover::ms_Clip2Id("Clip2",0xB58F45C);
const fwMvClipId CTaskInCover::ms_Clip3Id("Clip3",0xb193c0d3);
const fwMvClipId CTaskInCover::ms_WeaponClip4Id("WeaponClip4",0xc4c7d192);
const fwMvClipId CTaskInCover::ms_WeaponClip5Id("WeaponClip5",0xb291ad26);

const fwMvClipId CTaskInCover::ms_WeaponClip0Id("WeaponClip0",0x7290AD29);
const fwMvClipId CTaskInCover::ms_WeaponClip1Id("WeaponClip1",0x5F6786D7);
const fwMvClipId CTaskInCover::ms_WeaponClip2Id("WeaponClip2",0xCE2DE462);
const fwMvClipId CTaskInCover::ms_WeaponClip3Id("WeaponClip3",0xbcd941b9);

////////////////////////////////////////////////////////////////////////////////

dev_float EDGE_CAPSULE_RADIUS		= 0.2f;
DEV_ONLY(dev_bool DEBUG_BLINDFIRE_TEST = false;)
DEV_ONLY(dev_bool TURN_IK_OFFSETS_OFF = false;)

dev_float DIM_IK_TOLERANCE = 0.4f;
dev_float BLIND_FIRE_OVER_MIN_PITCH = 0.0f;
dev_float BLIND_FIRE_OVER_MAX_PITCH = CTorsoIkSolver::ms_torsoInfo.maxPitch;


const float g_TargetDistanceFromCameraForAimIk	= 20.0f;

static const float MAX_SLIDE_ACCEL_LIMIT = 10.0f;

////////////////////////////////////////////////////////////////////////////////


CClonedCoverInfo::CClonedCoverInfo() 
:
  m_bHasCoverPoint(false)
, m_vCoverPosition(VEC3_ZERO)
, m_vCoverDirection(YAXIS)
, m_coverUsage(0)
, m_coverFlags(0)
, m_bIsLowCorner(false)
, m_eTerminationReason(CTaskCover::TR_IdleExit)
, m_VehicleStoodOn(NULL)
{
}

CClonedCoverInfo::CClonedCoverInfo(const CWeaponTarget* pTarget, const CPed* pPed, s32 coverState, u32 iFlags, bool bIsLowCorner, u32 eTerminationReason, const CVehicle* pVehicleStoodOn) 
  :
    m_bHasCoverPoint(false)
  , m_weaponTargetHelper(pTarget)
  , m_vCoverPosition(VEC3_ZERO)
  , m_vCoverDirection(YAXIS)
  , m_coverUsage(0)
  , m_coverFlags(iFlags)
  , m_bIsLowCorner(bIsLowCorner)
  , m_eTerminationReason(eTerminationReason)
  , m_VehicleStoodOn(const_cast<CVehicle*>(pVehicleStoodOn))
  , m_bHasVehicleStoodOn(pVehicleStoodOn != NULL)
{
	SetStatusFromMainTaskState(coverState);

	const CCoverPoint* pCoverPoint = pPed->GetCoverPoint();

	if (pCoverPoint && pCoverPoint->GetCoverPointPosition(m_vCoverPosition))
	{
		if (m_VehicleStoodOn.GetVehicle())
		{
			//aiDisplayf("Frame : %i, Ped %s(%p) syncing world cover position (%.2f,%.2f,%.2f)", fwTimer::GetFrameCount(), pPed->GetDebugName(), pPed, m_vCoverPosition.x, m_vCoverPosition.y, m_vCoverPosition.z);
			Vec3V vCoverPosTemp = VECTOR3_TO_VEC3V(m_vCoverPosition);
			vCoverPosTemp = m_VehicleStoodOn.GetVehicle()->GetTransform().UnTransform(vCoverPosTemp);
			m_vCoverPosition = VEC3V_TO_VECTOR3(vCoverPosTemp);
			//aiDisplayf("Frame : %i, Ped %s(%p) syncing relative cover position (%.2f,%.2f,%.2f)", fwTimer::GetFrameCount(), pPed->GetDebugName(), pPed, m_vCoverPosition.x, m_vCoverPosition.y, m_vCoverPosition.z);
		}

		const Vector3 vPedPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());

		Vector3 vTargetDirection = m_vCoverPosition - vPedPosition;
		vTargetDirection.NormalizeSafe(YAXIS);
		m_vCoverDirection = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector(&RCC_VEC3V(vTargetDirection)));
		m_vCoverDirection.Normalize();

		m_coverUsage = static_cast<s32>(pCoverPoint->GetUsage());

		m_bHasCoverPoint = true;
	}

	// ignore the cover flags we are not interested in
	m_coverFlags &= (1<<SIZEOF_COVERFLAGS)-1;
}

CClonedCoverInfo::~CClonedCoverInfo()
{
}

CTaskFSMClone* CClonedCoverInfo::CreateCloneFSMTask()
{
	CWeaponTarget target;
	m_weaponTargetHelper.UpdateTarget(target);

	CTaskCover* pCoverTask = rage_new CTaskCover(target, m_coverFlags);
	return pCoverTask;
}

CTaskFSMClone* CClonedCoverInfo::CreateLocalTask(fwEntity* UNUSED_PARAM(pEntity))
{
	return CreateCloneFSMTask();
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskInCover::Tunables::GetThrowProjectileClipSetIdForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed), bool bForceThirdPerson) const
{
#if FPS_MODE_SUPPORTED
	return (!bForceThirdPerson && CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations && rPed.IsFirstPersonShooterModeEnabledForPlayer(false)) ? m_ThrowProjectileFPSClipSetId : m_ThrowProjectileClipSetId;
#else // FPS_MODE_SUPPORTED
	return m_ThrowProjectileClipSetId;
#endif // FPS_MODE_SUPPORTED
}

////////////////////////////////////////////////////////////////////////////////

CCoverPoint& CTaskInCover::GetStaticCoverPointForPlayer(CPed* pPed)
{
	switch (pPed->GetPedType())
	{
		case PEDTYPE_PLAYER_0 : return ms_aPlayerCoverPoints[0];
		case PEDTYPE_PLAYER_1 : return ms_aPlayerCoverPoints[1];
		case PEDTYPE_PLAYER_2 : return ms_aPlayerCoverPoints[2];
		default: break;
	}

	taskAssertf(0, "Ped type (%s) isn't a single player ped", CPedType::GetPedTypeNameFromId(pPed->GetPedType()));
	return ms_aPlayerCoverPoints[0];
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::SlidePedIntoCover(CPed& rPed, CTaskInCover* pInCoverTask, const Vector3& vCoverCoords)
{
	bool bIsRoundCover = false;
	Vector3 vCoverPos = vCoverCoords;

	if (rPed.IsNetworkClone() && pInCoverTask && pInCoverTask->HasNetCoverPoint(rPed))
	{
		pInCoverTask->GetNetCoverPointPosition(rPed, vCoverPos);
	}

	Vector3 vDiff;
	vDiff = vCoverPos - VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
	Vector3 vFlatDist = vDiff;
	vFlatDist.z=0;
	const float fDist2=vFlatDist.Mag2();	

	if (pInCoverTask)
	{
		if (pInCoverTask->IsInMotionState(CTaskMotionInCover::State_CoverToCover))
		{
			const CTaskMotionInCover* pMotionTask = static_cast<const CTaskMotionInCover*>(pInCoverTask->GetSubTask());
			if (!pMotionTask || !pMotionTask->GetStoppedScalingCTCTranslation())
			{
				return;
			}
		}
		if (pInCoverTask->IsInMotionState(CTaskMotionInCover::State_PlayingIdleVariation))
		{
			return;
		}

		//Compute side distance
		Vector3 vSlideNormal = vFlatDist; vSlideNormal.Normalize();
		float fModulate = vSlideNormal.Dot(VEC3V_TO_VECTOR3(rPed.GetTransform().GetForward()));
		float fSideDist2 = fabs(fModulate) * fDist2;

		const CPlayerInfo* playerInfo = rPed.GetPlayerInfo();
		bIsRoundCover = playerInfo && playerInfo->IsRoundCover();
		static dev_float sf_MinAnimatedSpeedForStepping = 0.01f * 0.01f;		
		if (pInCoverTask->IsInMotionState(CTaskMotionInCover::State_AtEdge))
		{			
			if (!bIsRoundCover && fSideDist2 >= rage::square(ms_Tunables.m_DesiredDistanceToCoverToRequestStep) && rPed.IsLocalPlayer() && rPed.GetAnimatedVelocity().Mag2() < sf_MinAnimatedSpeedForStepping 
				&& pInCoverTask->RequestStepping()) 
			{
				return;
			}
		}

		if (!rPed.IsNetworkClone())
		{

#if FPS_MODE_SUPPORTED
			const bool bAllowSlide = rPed.IsFirstPersonShooterModeEnabledForPlayer(false);
#endif // FPS_MODE_SUPPPORTED

			const bool bStoppingAtEdge = pInCoverTask->WasInMotionState(CTaskMotionInCover::State_StoppingAtInsideEdge) || pInCoverTask->WasInMotionState(CTaskMotionInCover::State_StoppingAtEdge);
			if (pInCoverTask->IsInMotionState(CTaskMotionInCover::State_Idle) || pInCoverTask->IsInMotionState(CTaskMotionInCover::State_Peeking) || pInCoverTask->IsInMotionState(CTaskMotionInCover::State_Settle))
			{
				if (!bIsRoundCover)
				{
					if (bStoppingAtEdge && fSideDist2 >= rage::square(ms_Tunables.m_DesiredDistanceToCoverToRequestStep) && rPed.IsLocalPlayer() && rPed.GetAnimatedVelocity().Mag2() < sf_MinAnimatedSpeedForStepping
						&& pInCoverTask->RequestStepping())
					{
						return;
					}
					else if (!bStoppingAtEdge FPS_MODE_SUPPORTED_ONLY(&& bAllowSlide))
						return;
				}	
			}
		}


		CTaskCover* pCoverTask = static_cast<CTaskCover*>(pInCoverTask->GetParent());
		if (pCoverTask->CheckForMovingCover(&rPed))
			return;
	}


	rPed.SetAnimatedVelocity(VEC3_ZERO);

	//Set the extracted velocity of the ped to safely get him to the target point.
	// If outside the distance the ped can move in a single update
	if (fDist2 >= rage::square(ms_Tunables.m_DesiredDistanceToCover))
	{
		Vector3 w = vDiff;
		w *= pInCoverTask ? ms_Tunables.m_InCoverMovementSpeed : ms_Tunables.m_InCoverMovementSpeedEnterCover;
		Vec3V w3V(w);
		const float wy=Dot(w3V, rPed.GetTransform().GetB()).Getf();
		const float wx=Dot(w3V, rPed.GetTransform().GetA()).Getf();
		Vector3 extractedVelocity(rPed.GetAnimatedVelocity());
		static dev_float MAX_VELOCITY = 10.0f;
		extractedVelocity.x = rage::Clamp(wx, -MAX_VELOCITY, MAX_VELOCITY);
		extractedVelocity.y = rage::Clamp(wy, -MAX_VELOCITY, MAX_VELOCITY);
		Vec3V vDesiredVelocity = rPed.GetTransform().Transform3x3(VECTOR3_TO_VEC3V(extractedVelocity));
		NMovingGround::SetPedDesiredVelocityClamped(&rPed, vDesiredVelocity, MAX_SLIDE_ACCEL_LIMIT);
		//Displayf("ExtractedVelocity x: %.2f, y: %.2f", wx, wy);

		// Make sure we don't do timeslicing the next frame, because we are still sliding
		// and it may look bad if we don't do so on every frame.
		rPed.GetPedAiLod().SetForceNoTimesliceIntelligenceUpdate(true);

		return;
	}
	else
	{	
		// Ok we're in cover... ish
		NMovingGround::SetPedDesiredVelocity(&rPed, Vec3V(V_ZERO));

		if (rPed.IsNetworkClone() && !pInCoverTask)
		{
			vCoverPos.z += rPed.GetCapsuleInfo()->GetGroundToRootOffset();

			float pedZ = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition()).z;
			float zDiff = Abs(vCoverPos.z - pedZ);

			// don't allow the Z of the ped to be altered by too much, this is to fix a bug where a bad cover point under the map forced a clone ped under
			// the map too.
			if (zDiff > 0.5f)
			{
				vCoverPos.z = pedZ;
			}

			rPed.SetPosition(vCoverPos);
		}
		return;
	}
}

////////////////////////////////////////////////////////////////////////////////

CTaskInCover::CTaskInCover(CMoveNetworkHelper& taskCoverMoveNetworkHelper, CMoveNetworkHelper& taskUseCoverMoveNetworkHelper, CMoveNetworkHelper& taskMotionInCoverMoveNetworkHelper )
: m_TaskCoverMoveNetworkHelper(taskCoverMoveNetworkHelper)
, m_TaskUseCoverMoveNetworkHelper(taskUseCoverMoveNetworkHelper)
, m_TaskMotionInCoverMoveNetworkHelper(taskMotionInCoverMoveNetworkHelper)
, m_fTimeSinceLastCrouchChange(999.0f)
, m_vCoverOffset(Vector3::ZeroType)
, m_fTimeSinceLastDynamicCoverCheck(0.0f)
, m_vecStick(0.0f, 0.0f)
, m_bStickHeadingLockEnabled(false)
, m_fLockedStickHeading(-1.0f)
, m_vCoverDirection(Vector3::ZeroType)
, m_vCoverCoords(Vector3::ZeroType)
, m_fProjectileCookingTime(0.0f)
, m_fTimeToSpendInState(0.0f)
, m_fCachedStickAngle(0.0f)
, m_bCachedStickValid(false)
, m_iTimeNextPeekAllowed(0)
, m_bWaitingForInitialState(false)
, m_bSmokeGrenadeThrowRequested(false)
, m_bSmokeGrenadeThrowInProgress(false)
, m_fTimeInCover(-1.0f)
, m_bOutroToReload(false)
, m_bReactToFire(false)
, m_bWantsToExit(false)
, m_AimIntroFilterId(FILTER_ID_INVALID)
, m_pAimIntroFilter(NULL)
, m_fLastHeadingChangeRate(10.0f)
, m_fLastAngleDelta(0)
, m_fNoTaskBlendDuration(0.25f)
, m_fTimeUntilReturnToIdleFromAimedAt(-1.0f)
, m_uPreviousWeaponHash(0)
, m_CoverStepClipId(CLIP_ID_INVALID)
, m_bWantsToTriggerStep(false)
, m_bWantsToReload(false)
, m_bLeftHandIkActive(false)
, m_iPreviousCoverStepNodeIndex(-1)
, m_iCurrentCoverStepNodeIndex(-1)
, m_vInitialPosition(Vector3::ZeroType)
, m_vClipTranslation(Vector3::ZeroType)
, m_uBlindFireBreakGlass(BF_WINDOWBREAK_NONE)
, m_fExtraTranslation(0.0f)
, m_bForceFireBullet(false)
, m_uReleasedAimControlsTime(0)
, m_bForwardAimBlocked(false)
, m_bSideAimBlocked(false)
, m_bForcedBlockAimDirectly(false)
, m_bStoodUpToFire(false)
, m_bLetGoOfAimAfterStartingReload(false)
, m_bAimWithoutAmmo(false)
, m_bDelayedExit(false)
, m_bForcedStepBack(false)
, m_bBlindFireWithAim(false)
, m_uWeaponHash(0)
, m_ShouldReloadWeaponDelay(0)
, m_bSteppedOutToAim(false)
, m_bDelayedBlindFireExit(false)
#if FPS_MODE_SUPPORTED
, m_fPelvisOffset(0.0f)
, m_bPeekToggleEnabled(false)
, m_bNeedToPopHeading(false)
, m_WasScopedDuringAim(false)
, m_pFirstPersonIkHelper(NULL)
#endif // FPS_MODE_SUPPORTED
{
	SetInternalTaskType(CTaskTypes::TASK_IN_COVER);
}

////////////////////////////////////////////////////////////////////////////////

CTaskInCover::~CTaskInCover()
{
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::UpdateTarget(CPed* pPed)
{
	if(pPed && pPed->IsPlayer())
	{
		weaponAssert(pPed->GetWeaponManager());
		if(pPed->IsNetworkClone())
		{
			if (static_cast<CNetObjPlayer*>(pPed->GetNetworkObject())->HasValidTarget())
			{
				GetTarget().SetPosition(pPed->GetWeaponManager()->GetWeaponAimPosition());
			}
		}
		else
		{
			GetTarget().Update(pPed);

			Vector3 vTargetPosition;
			if(GetTarget().GetIsValid() && GetTarget().GetPositionWithFiringOffsets(pPed, vTargetPosition))
			{
				pPed->GetWeaponManager()->SetWeaponAimPosition(vTargetPosition);
			}
			if (!GetTarget().GetIsValid() && CTaskPlayerOnFoot::CheckForUseMobilePhone(*pPed))
			{//don't want target invalidated causing cover to end B* 1474090
				Vector3 vDir = VEC3V_TO_VECTOR3(pPed->GetTransform().GetB());
				Vector3 vThreatPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()) + (vDir * 10.0f);		
				GetTarget().SetPosition(vThreatPosition);
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ActivateTimeslicing()
{
	TUNE_GROUP_BOOL(IN_COVER, ACTIVATE_TIMESLICING, true);

	if(ACTIVATE_TIMESLICING)
	{
		GetPed()->GetPedAiLod().ClearBlockedLodFlag(CPedAILod::AL_LodTimesliceIntelligenceUpdate);
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::IsCoverPointTooHigh() const
{
	const CPed* pPed = GetPed();

	if (pPed->IsNetworkClone())
		return IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);

	return pPed->GetCoverPoint() && (pPed->GetCoverPoint()->GetHeight() == CCoverPoint::COVHEIGHT_TOOHIGH);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::CheckForBlockedAim()
{
	m_bForwardAimBlocked = false;
	m_bSideAimBlocked = false;

	// Cache Blocked Aim Results
	if (GetPed()->IsLocalPlayer())
	{
		CTaskAimGunFromCoverIntro::CheckForBlockedAimPosition(m_bForwardAimBlocked, m_bSideAimBlocked, *GetPed(), IsCoverFlagSet(CTaskCover::CF_FacingLeft), IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint));
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::RestorePreviousEquippedWeapon()
{
	if (m_uPreviousWeaponHash != 0)
	{
		CPed& ped = *GetPed();
		ped.GetWeaponManager()->EquipWeapon(m_uPreviousWeaponHash);
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::AreTaskAssetsLoaded(CPed& ped, bool bRequireWeaponAssets)
{
	bool bAllAssetsLoaded = true;
	fwMvClipSetId weaponHoldingClipsetId = CTaskCover::GetWeaponHoldingClipSetForArmament(&ped);
	if (weaponHoldingClipsetId != CLIP_SET_ID_INVALID)
	{
		bAllAssetsLoaded = CTaskCover::IsCoverClipSetLoaded(weaponHoldingClipsetId);
	}
	bool bWeaponAssetsLoaded = true;
	
	if (bRequireWeaponAssets)
	{
		fwMvClipSetId weaponAimingClipsetId = CTaskCover::GetWeaponClipSetForArmament(&ped, !ped.IsAPlayerPed());
		if (weaponAimingClipsetId != CLIP_SET_ID_INVALID)
		{
			bAllAssetsLoaded = bWeaponAssetsLoaded;
		}
	}
	return bAllAssetsLoaded;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::CleanUp()
{
	CPed* pPed = GetPed();

#if FPS_MODE_SUPPORTED
	if (m_pFirstPersonIkHelper)
	{
		delete m_pFirstPersonIkHelper;
		m_pFirstPersonIkHelper = NULL;
	}

	// Need to clear this regardless of whether we're in fps mode as we can toggle the camera
	pPed->GetIkManager().SetExternallyDrivenPelvisOffset(0.0f);

	const int viewMode = camControlHelper::GetViewModeForContext(camControlHelperMetadataViewMode::ON_FOOT);
	if (pPed->IsLocalPlayer() && viewMode == camControlHelperMetadataViewMode::FIRST_PERSON && CTaskCover::CanUseThirdPersonCoverInFirstPerson(*pPed))
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_ForcePreCameraAiAnimUpdateIfFirstPerson, true);
		pPed->GetPlayerInfo()->SetSwitchedToOrFromFirstPersonThisFrame(true);
		pPed->GetPlayerInfo()->SetSwitchedFirstPersonFromThirdPersonCoverCount();
	}
#endif // FPS_MODE_SUPPORTED

	// Flag that we are not using a cover point
	pPed->SetPedConfigFlag( CPED_CONFIG_FLAG_UsingCoverPoint, false );

	// Clear any old filter
	if(m_pAimIntroFilter)
	{
		m_pAimIntroFilter->Release();
		m_pAimIntroFilter = NULL;
	}

	if (pPed->IsLocalPlayer())
	{
		CPlayerCoverClipVariationHelper::GetInstance().ClearClipVariationStreaming();
	}

	//Reload anim swap
	CTask* pTask = pPed->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN);
	if (pTask)	
	{
		static_cast<CTaskReloadGun*>(pTask)->RequestAnimSwap();
	}

	//Cleanup IK	
	if (m_bLeftHandIkActive)
	{
		// Setting this flag will result in a call to ProcessLeftHandGripIk()
		// before the next calls to CTask::ProcessPreRender2(). It's done
		// like this since CleanUp() can be called from a part of the frame where
		// getting the global matrices in ProcessLeftHandGripIk() would result
		// in a stall.
		pPed->SetPedResetFlag(CPED_RESET_FLAG_CancelLeftHandGripIk, true);

		// Don't do this if CleanUp() is called again without having reactivated the IK.
		m_bLeftHandIkActive = false;
	}

	pPed->SetPedResetFlag( CPED_RESET_FLAG_IsInLowCover, false );
}

////////////////////////////////////////////////////////////////////////////////
bool CTaskInCover::ComputeCoverAimPositionAndHeading(Vector3& vAimPos, float& fAimHeading, bool& bAimDirectly, bool bShouldConsiderTurningDirection, bool bReturnMoverPosition) const
{
	const CPed& ped = *GetPed();

	if (bReturnMoverPosition)
	{
		vAimPos = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
		return true;
	}
	CTaskInCover* pCoverTask = static_cast<CTaskInCover*>(ped.GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_IN_COVER));

	if (pCoverTask && pCoverTask->GetTarget().GetIsValid() && pCoverTask->GetTarget().GetPositionWithFiringOffsets(&ped, vAimPos))
	{
		const bool bHigh = pCoverTask->IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
		bool bForcedBlockAimDirectly = false;
		float fOverlapTolerance = 0.0f;
		bAimDirectly = ShouldAimDirectly(ped, bHigh, bForcedBlockAimDirectly, fOverlapTolerance);

		const CObject* pWeaponObject = ped.GetWeaponManager()->GetEquippedWeaponObject();
		const CWeapon* pWeapon = ped.GetWeaponManager()->GetEquippedWeapon();

		if (pWeapon && pWeaponObject)
		{
			//bool bForceStepBack = !bAimDirectly && ShouldStepBack(pWeaponObject, pWeapon);

			bool bFacingLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
			if (bShouldConsiderTurningDirection && IsInMotionState(CTaskMotionInCover::State_Turning, false))
			{
				bFacingLeft = IsCoverFlagSet(CTaskCover::CF_TurningLeft);
			}

			bool bInHighCoverNotAtEdge = m_bForcedStepBack || (!IsCoverFlagSet(CTaskCover::CF_AtCorner) && bHigh);
			if (IsCoverFlagSet(CTaskCover::CF_CloseToPossibleCorner))
			{
				bInHighCoverNotAtEdge = false;
			}
			ComputeTargetIntroPositionAndHeading(ped, bFacingLeft, !bHigh, vAimPos, fAimHeading, bInHighCoverNotAtEdge, IsCoverFlagSet(CTaskCover::CF_CloseToPossibleCorner));
			return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::ShouldAimDirectly(const CPed& ped, bool bIsHighCover, bool& bForcedBlockAimDirectly, float fTolerance, bool bLastResult, bool bIsBlindFire) 
{
	if (ped.IsLocalPlayer() && ped.GetCoverPoint())
	{	
		if (ped.GetPlayerInfo()->AreControlsDisabled())
		{
			return false;
		}
		bForcedBlockAimDirectly = false;

		Vector3 vCoverDirection = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector());
		const float fBlindFireLimitAngle = bIsHighCover ? CTaskAimGunBlindFire::ms_Tunables.m_HighBlindFireAimingDirectlyLimitAngle : CTaskAimGunBlindFire::ms_Tunables.m_LowBlindFireAimingDirectlyLimitAngle;
		Vector3 vLeftLimit = vCoverDirection;;
		vLeftLimit.RotateZ(fBlindFireLimitAngle);
		Vector3 vRightLimit = vCoverDirection;
		vRightLimit.RotateZ(-fBlindFireLimitAngle);
		const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
		Vector3 vCamFront = aimCameraFrame.GetFront();
		vCamFront.z = 0.0f;
		vCamFront.Normalize();
		const float fLeftCross = vLeftLimit.CrossZ(vCamFront);
		const float fRightCross = vRightLimit.CrossZ(vCamFront);
		const bool bShouldAimDirectly = (fLeftCross < 0.0f && fRightCross > 0.0f) ? false : true;
		if (bLastResult!=bShouldAimDirectly && fabs(fLeftCross)<fTolerance)
		{
			return bLastResult;
		}

		// If we're going to aim directly we need to see if we're gonna be blocked
		if (!bIsHighCover)
		{
			if (bIsBlindFire && !bShouldAimDirectly)
			{
				return false;
			}

			if (bShouldAimDirectly)
			{
				// We'd need to raise the gun up, so lets just stand up
				CTaskInCover* pCoverTask = static_cast<CTaskInCover*>(ped.GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_IN_COVER));

				if (!bForcedBlockAimDirectly && (pCoverTask && pCoverTask->GetState() != State_Aim && ped.GetPedResetFlag(CPED_RESET_FLAG_UseAlternativeWhenBlock)))
				{
					bForcedBlockAimDirectly = true;
					return false;
				}

				Vector3 vCameraFront = CTaskCover::GetCamFrontForCover();
				Vector3 vStart = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
				TUNE_GROUP_FLOAT(COVER_TUNE, CAM_PULL_OUT_AIM_DIRECTLY, 2.0f, 0.0f, 5.0f, 0.01f);
				TUNE_GROUP_FLOAT(COVER_TUNE, EXTRA_START_Z_OFFSET_AIM, -0.5f, -5.0f, 5.0f, 0.01f);
				TUNE_GROUP_FLOAT(COVER_TUNE, EXTRA_END_Z_OFFSET_AIM, -0.5f, -5.0f, 5.0f, 0.01f)
				Vector3 vEnd = CTaskCover::GetCamPosForCover() + vCameraFront * CAM_PULL_OUT_AIM_DIRECTLY;
				vEnd.z = vStart.z;
				vStart.z += EXTRA_START_Z_OFFSET_AIM;
				vEnd.z += EXTRA_END_Z_OFFSET_AIM;
				Vector3 vUnused;
				if (CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vUnused))
				{
					bForcedBlockAimDirectly = true;
					return false;
				}
			}
		}
		return bShouldAimDirectly;		
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::SetAimIntroFilter(const atHashWithStringNotFinal& newFilter)
{
	// Clear any old filter
	if(m_pAimIntroFilter)
	{
		m_pAimIntroFilter->Release();
		m_pAimIntroFilter = NULL;
	}

	// Find and set the new filter
	m_pAimIntroFilter = CGtaAnimManager::FindFrameFilter(newFilter, GetPed());
	if(m_pAimIntroFilter)
	{
		m_pAimIntroFilter->AddRef();
	}

	m_TaskUseCoverMoveNetworkHelper.SetFilter(m_pAimIntroFilter, ms_AimIntroFilterId);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::OnCallForCover(const CEventCallForCover& rEvent)
{
	//Make sure the ped is in a state capable of providing cover fire.
	s32 iState = GetState();
	if((iState == State_Idle) || (iState == State_Peeking) || (iState == State_Aim))
	{
		//Say the audio.
		GetPed()->NewSay("COVER_YOU");

		//Set the cover fire flag.
		SetCoverFlag(CTaskCover::CF_CoverFire);
		
		//Grab the ped calling for cover.
		CPed* pPed = rEvent.GetPedCallingForCover();
		if(pPed)
		{
			//Notify the ped calling for cover that we are providing cover.
			CEventProvidingCover event(GetPed());
			pPed->GetPedIntelligence()->AddEvent(event);
		}
	}
}

//////////////////////////////////////////////////////////////////////////

void CTaskInCover::OnBulletEvent()
{
	s32 iState = GetState();
	if(iState == State_Aim)
	{
		CTaskGun* pGunTask = static_cast<CTaskGun*>(FindSubTaskOfType(CTaskTypes::TASK_GUN));
		if(pGunTask)
		{
			if(pGunTask->GetDuration() > ms_Tunables.m_MaxReactToFireDelay)
			{
				pGunTask->SetDuration(fwRandom::GetRandomNumberInRange(0.0f, ms_Tunables.m_MaxReactToFireDelay));
			}

			m_bReactToFire = true;
		}
		else
		{
			SetCoverFlag(CTaskCover::CF_ShouldReturnToIdle);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::ComputeAimModifier(const CPed& ped, Vector3& vAimAtDirection, float& fTargetHeading, Vector3& vCoverCoords, Vector3& vCoverDir)
{
	if (ped.IsLocalPlayer())
	{
		if(!ped.GetUsingRagdoll() && !ped.GetPlayerInfo()->AreControlsDisabled())
		{
			const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
			fTargetHeading = aimCameraFrame.ComputeHeading();
			vAimAtDirection = aimCameraFrame.GetFront();
			vAimAtDirection.Normalize();
		}
	}
	else
	{
		fTargetHeading = rage::Atan2f(-vAimAtDirection.x, vAimAtDirection.y);
	}

	// Get the cover coordinates based on the target direction

	if (!CCover::FindCoordinatesCoverPoint(ped.GetCoverPoint(), &ped, vAimAtDirection, vCoverCoords))
	{
		taskAssertf(0, "Couldn't find cover coords");
		return -1.0f;
	}

	// Get the cover direction (into the wall)
	vCoverDir = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector(&RCC_VEC3V(vAimAtDirection)));

	Vector3 vCoverRight;
	vCoverRight.Cross(vCoverDir, Vector3(0.0f, 0.0f, 1.0f));

	return vCoverRight.Dot(vAimAtDirection); // = cos(angle between vCoverRight and vAimAtDirection)
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ComputeTargetIntroPositionAndHeading(const CPed& ped, bool bIsFacingLeft, bool bIsLowCover, Vector3& vTargetPosition, float& fTargetHeading, bool bInHighCoverNotAtEdge, bool bHighCloseToEdge, bool bForceShortStep)
{
	if (!ped.GetCoverPoint() && !ped.IsNetworkClone())
		return;

	//Vector3 vPedPosition = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
	Vector3 vCoverDirection(Vector3::ZeroType);
	Vector3 vCoverPosition(Vector3::ZeroType);
	bool bLowCorner = false;

	if (ped.IsNetworkClone())
	{
		// get the cover information from the cover task info
		CTaskInfo *taskInfo = ped.GetPedIntelligence()->GetQueriableInterface()->GetTaskInfoForTaskType(CTaskTypes::TASK_COVER, PED_TASK_PRIORITY_MAX);
		if(!taskInfo)
		{
			return;
		}

		Vector3 vDirUnused;
		if (!CCover::FindCoverCoordinatesForPed(ped, vDirUnused, vCoverPosition) || !CCover::FindCoverDirectionForPed(ped, vCoverDirection, vDirUnused))
		{
			return;
		}

		CClonedCoverInfo* pCoverInfo = static_cast<CClonedCoverInfo*>(taskInfo);
		bLowCorner = pCoverInfo->GetIsLowCorner();
	}
	else
	{
		CCoverPoint& rCoverPoint = *ped.GetCoverPoint();

		if (rCoverPoint.GetCoverPointPosition(vCoverPosition))
		{
			vCoverDirection = VEC3V_TO_VECTOR3(rCoverPoint.GetCoverDirectionVector());
			bLowCorner = rCoverPoint.GetFlag(CCoverPoint::COVFLAGS_IsLowCorner);
		}
		else
		{
			return;
		}
	}

	// Ai only due use this to compute the intro position if using low corner cover
	bool bForcedStepOutDueToLowCorner = !ped.IsAPlayerPed() && bLowCorner;
	if (!ped.IsAPlayerPed() && !bForcedStepOutDueToLowCorner)
		return;

	Vector3 vSide = vCoverDirection;
	Vector3 vRight = vSide;
	vRight.RotateZ(-HALF_PI);
	Vector3 vLeft = vSide;
	vLeft.RotateZ(HALF_PI);

	Vector3 vCamFront(Vector3::ZeroType);
	float fDot = 0.0f;

	if (ped.IsLocalPlayer())
	{
		const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
		vCamFront = aimCameraFrame.GetFront();
		vCamFront.z = 0.0f;
		vCamFront.Normalize();
		// Want to face the direction of the camera
		fTargetHeading = aimCameraFrame.ComputeHeading();
		fDot = rage::Clamp(vCamFront.Dot(vCoverDirection), 0.0f, 1.0f);
	}
	else
	{
		vCamFront = Vector3(0.0f, 1.0f, 0.0f);
		const float fDesiredHeading = ped.GetNetworkObject() ? static_cast<CNetObjPed*>(ped.GetNetworkObject())->GetDesiredHeading() : ped.GetDesiredHeading();
		vCamFront.RotateZ(fDesiredHeading);
		fTargetHeading = fDesiredHeading;
		fDot = rage::Clamp(vCamFront.Dot(vCoverDirection), 0.0f, 1.0f);
	}

	if (!bIsLowCover)
	{
		const float fCoverHeading = fwAngle::LimitRadianAngle(rage::Atan2f(-vCoverDirection.x, vCoverDirection.y));
		const CTaskAimGunFromCoverIntro::AimStepInfoSet& aimStepInfoSet = CTaskAimGunFromCoverIntro::ms_Tunables.GetAimStepInfoSet(bIsFacingLeft);

		s32 iArcToUse = -1;
		for (s32 i=0; i<aimStepInfoSet.m_StepInfos.GetCount(); ++i)
		{
			// In first person we force the player to use the short step distance for consistent aim framing
			if (bForceShortStep)
			{
				iArcToUse = 1;
				break;
			}
			float fPedCoverHeading = bIsFacingLeft ? fwAngle::LimitRadianAngle(fCoverHeading + HALF_PI) : fwAngle::LimitRadianAngle(fCoverHeading - HALF_PI);
			const float fAngleMin = ComputeStepTransitionMinAngle(ped, i, bIsFacingLeft, fwAngle::LimitRadianAngle(fPedCoverHeading + aimStepInfoSet.m_StepInfos[i].m_StepTransitionMinAngle));
			const float fAngleMax = fwAngle::LimitRadianAngle(fPedCoverHeading + aimStepInfoSet.m_StepInfos[i].m_StepTransitionMaxAngle);
			Vector3 vPedHeading(0.0f, 1.0f, 0.0f);
			vPedHeading.RotateZ(ped.GetCurrentHeading());
			Vector3 vMinArc(0.0f, 1.0f, 0.0f);
			vMinArc.RotateZ(fAngleMin);
			Vector3 vMaxArc(0.0f, 1.0f, 0.0f);
			vMaxArc.RotateZ(fAngleMax);

			const float fMinCrossZCam = vMinArc.CrossZ(vCamFront);
			const float fMaxCrossZCam = vMaxArc.CrossZ(vCamFront);

			if ((fMinCrossZCam >= 0.0f && fMaxCrossZCam <= 0.0f))
			{
				iArcToUse = i;
				break;
			}
		}

		if (iArcToUse > -1)
		{
#if FPS_MODE_SUPPORTED
			bool bIsFPSMode = ped.IsFirstPersonShooterModeEnabledForPlayer(false);
			INSTANTIATE_TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DISABLE_AUTO_STEP_AROUND);
			if (DISABLE_AUTO_STEP_AROUND && bIsFPSMode && iArcToUse == 2)
			{
				iArcToUse = 1;
			}
#endif // FPS_MODE_SUPPORTED

			vCoverPosition.z += 1.0f;

			if (bIsFacingLeft)
				vSide = vLeft;
			else
				vSide = vRight;


			// Pull the player to the side when aiming to the side, or more backwards when aiming towards the front
			if (ped.IsAPlayerPed() && bInHighCoverNotAtEdge FPS_MODE_SUPPORTED_ONLY(&& !bIsFPSMode))
			{
				Vector3 vCoverDir(0.0f, 1.0f, 0.0f);
				vCoverDir.RotateZ(fCoverHeading);
				float fSideMult = 1.0f;
				const float fCamCrossCov = vCoverDir.CrossZ(vCamFront);
				if (bIsFacingLeft && fCamCrossCov > 0.0f)
				{
					fSideMult *= -1.0f;
				}
				else if (!bIsFacingLeft && fCamCrossCov < 0.0f)
				{
					fSideMult *= -1.0f;
				}
				// Possibly need per weapon / weapon size offsets :(
				TUNE_GROUP_FLOAT(COVER_TUNE, HIGH_CENTER_STEP_FIXED_BACK_DISTANCE, 0.3f, 0.0f, 2.0f, 0.01f);
				TUNE_GROUP_FLOAT(COVER_TUNE, HIGH_CENTER_STEP_EXTRA_BACK_DISTANCE, 0.5f, 0.0f, 2.0f, 0.01f);
				TUNE_GROUP_FLOAT(COVER_TUNE, HIGH_CENTER_STEP_OUT_DISTANCE, 0.5f, 0.0f, 2.0f, 0.01f);
				vTargetPosition = vCoverPosition + (1.0f - fDot) * fSideMult * vSide * HIGH_CENTER_STEP_OUT_DISTANCE - vCoverDirection * (HIGH_CENTER_STEP_FIXED_BACK_DISTANCE + fDot * HIGH_CENTER_STEP_EXTRA_BACK_DISTANCE);
			}
			else
			{
				vTargetPosition = vCoverPosition + aimStepInfoSet.m_StepInfos[iArcToUse].m_StepOutX * vSide - aimStepInfoSet.m_StepInfos[iArcToUse].m_StepOutY * vCoverDirection;

				if (bHighCloseToEdge FPS_MODE_SUPPORTED_ONLY(&& !bIsFPSMode))
				{
					TUNE_GROUP_FLOAT(COVER_TUNE, HIGH_CLOSE_TO_EDGE_STEP_EXTRA_BACK_DISTANCE, 0.5f, 0.0f, 2.0f, 0.01f);
					vTargetPosition -= vCoverDirection * HIGH_CLOSE_TO_EDGE_STEP_EXTRA_BACK_DISTANCE;
				}
			}
		}
		else
		{
			taskWarningf("Couldn't find valid aim arc");
			vTargetPosition = vCoverPosition;
		}
	}
	else
	{
		float fSideOffset = bIsFacingLeft ? CTaskAimGunFromCoverIntro::ms_Tunables.m_LowLeftStep.x : CTaskAimGunFromCoverIntro::ms_Tunables.m_LowRightStep.x;
		float fBackwardOffset = bIsFacingLeft ? CTaskAimGunFromCoverIntro::ms_Tunables.m_LowLeftStep.y : CTaskAimGunFromCoverIntro::ms_Tunables.m_LowRightStep.y;

		// Pull the player to the side when aiming to the side, or more backwards when aiming towards the front
		if (ped.IsAPlayerPed())
		{
			fSideOffset *= (1.0f - fDot);
			fBackwardOffset *= fDot;
		}

		CTaskInCover* pAimInCoverTask = static_cast<CTaskInCover*>(ped.GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_IN_COVER));
		const bool bForwardAimBlocked = pAimInCoverTask ? pAimInCoverTask->IsForwardAimBlocked() : false;
		const bool bSideAimBlocked = pAimInCoverTask ? pAimInCoverTask->IsSideAimBlocked() : false;
		const bool bStepOut = bForcedStepOutDueToLowCorner || (bForwardAimBlocked && !bSideAimBlocked);
		const bool bStepBack = bForwardAimBlocked && bSideAimBlocked;

		if (bIsFacingLeft)
		{
			vSide = vLeft;
			if (bStepOut || bStepBack)
			{
				fSideOffset = bStepOut ? CTaskAimGunFromCoverIntro::ms_Tunables.m_LowStepOutLeftXBlocked : CTaskAimGunFromCoverIntro::ms_Tunables.m_LowStepBackLeftXBlocked;
				fBackwardOffset = bStepOut ? CTaskAimGunFromCoverIntro::ms_Tunables.m_LowStepOutLeftYBlocked : CTaskAimGunFromCoverIntro::ms_Tunables.m_LowStepBackLeftYBlocked;
			}
		}
		else
		{
			vSide = vRight;
			if (bStepOut || bStepBack)
			{
				fSideOffset = bStepOut ? CTaskAimGunFromCoverIntro::ms_Tunables.m_LowStepOutRightXBlocked : CTaskAimGunFromCoverIntro::ms_Tunables.m_LowStepBackRightXBlocked;
				fBackwardOffset = bStepOut ? CTaskAimGunFromCoverIntro::ms_Tunables.m_LowStepOutLeftYBlocked : CTaskAimGunFromCoverIntro::ms_Tunables.m_LowStepBackLeftYBlocked;
			}
		}

		vCoverPosition.z += 1.0f;
		vTargetPosition = vCoverPosition + fSideOffset * vSide - fBackwardOffset * vCoverDirection;
	}
}

////////////////////////////////////////////////////////////////////////////////

s32 CTaskInCover::ComputeDesiredArc(const CPed& ped, bool bIsFacingLeft, s32 iCurrentIndex)
{
	s32 iArcToUse = -1;

#if FPS_MODE_SUPPORTED
	INSTANTIATE_TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DISABLE_AUTO_STEP_AROUND);
	bool bIsFPSMode = ped.IsFirstPersonShooterModeEnabledForPlayer(false, false, false, false);
	if (DISABLE_AUTO_STEP_AROUND && bIsFPSMode && !ped.GetPlayerInfo()->IsAiming(false))
	{
		iArcToUse = 0;
	}
	else
#endif // FPS_MODE_SUPPORTED
	if (ped.IsAPlayerPed())
	{
		Vector3 vCoverDirection(Vector3::ZeroType);
		Vector3 vCoverPosition(Vector3::ZeroType);
		Vector3 vDirUnused;
		if (CCover::FindCoverCoordinatesForPed(ped, vDirUnused, vCoverPosition) && CCover::FindCoverDirectionForPed(ped, vCoverDirection, vDirUnused))
		{
			Vector3 vCamFront(0.0f, 1.0f, 0.0f);
			if (ped.IsLocalPlayer())
			{
				const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
				vCamFront = aimCameraFrame.GetFront();
				vCamFront.z = 0.0f;
				vCamFront.Normalize();
			}
			else
			{
				const float fDesiredHeading = ped.GetNetworkObject() ? static_cast<CNetObjPed*>(ped.GetNetworkObject())->GetDesiredHeading() : ped.GetDesiredHeading();
				vCamFront.RotateZ(fDesiredHeading);
			}

			const CTaskAimGunFromCoverIntro::AimStepInfoSet& aimStepInfoSet = CTaskAimGunFromCoverIntro::ms_Tunables.GetAimStepInfoSet(bIsFacingLeft);

			// Go round each step info from the current node (so we get an overlap behaviour both ways)
			const s32 iStartIndex = iCurrentIndex > -1 ? iCurrentIndex : 0;
			s32 iIndex = iStartIndex;
			do
			{
				float fCoverHeading = fwAngle::LimitRadianAngle(rage::Atan2f(-vCoverDirection.x, vCoverDirection.y));
				float fPedCoverHeading = bIsFacingLeft ? fwAngle::LimitRadianAngle(fCoverHeading + HALF_PI) : fwAngle::LimitRadianAngle(fCoverHeading - HALF_PI);
				const float fAngleMin = ComputeStepTransitionMinAngle(ped, iIndex, bIsFacingLeft, fwAngle::LimitRadianAngle(fPedCoverHeading + aimStepInfoSet.m_StepInfos[iIndex].m_StepTransitionMinAngle));
				const float fAngleMax = fwAngle::LimitRadianAngle(fPedCoverHeading + aimStepInfoSet.m_StepInfos[iIndex].m_StepTransitionMaxAngle);
				Vector3 vMinArc(0.0f, 1.0f, 0.0f);
				vMinArc.RotateZ(fAngleMin);
				Vector3 vMaxArc(0.0f, 1.0f, 0.0f);
				vMaxArc.RotateZ(fAngleMax);
				const float fMinCrossZCam = vMinArc.CrossZ(vCamFront);
				const float fMaxCrossZCam = vMaxArc.CrossZ(vCamFront);
				if (fMinCrossZCam >= 0.0f && fMaxCrossZCam <= 0.0f)
				{
					iArcToUse = iIndex;
					break;
				}
				++iIndex;
				if (iIndex == aimStepInfoSet.m_StepInfos.GetCount())
				{
					iIndex = 0;
				}
			} while (iIndex != iStartIndex);
		}
	}

#if FPS_MODE_SUPPORTED
	INSTANTIATE_TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DISABLE_AUTO_STEP_AROUND);
	if (DISABLE_AUTO_STEP_AROUND && bIsFPSMode && iArcToUse == 2)
	{
		iArcToUse = 1;
	}
#endif // FPS_MODE_SUPPORTED
	return iArcToUse;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::DetermineIfDesiredNodeIsNextNode(bool bIsFacingLeft, s32 iCurrentNode, s32 iDesiredNode)
{
	const s32 iMaxNodes = CTaskAimGunFromCoverIntro::ms_Tunables.GetAimStepInfoSet(bIsFacingLeft).m_StepInfos.GetCount() - 1;
	if (iCurrentNode == 0 && iDesiredNode == iMaxNodes)
	{
		return false;
	}
	else if (iCurrentNode == iMaxNodes && iDesiredNode == 0)
	{
		return true;
	}
	else
	{
		return iCurrentNode < iDesiredNode ? true : false;
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::IsClipSetStreamedIn(const fwMvClipSetId& clipsetId)
{
	const fwClipSet* pClipset = fwClipSetManager::GetClipSet(clipsetId);
	if (pClipset && pClipset->IsStreamedIn_DEPRECATED())
	{
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::ShouldBeginFacingLeft(const Vector3& vTargetPos, const CPed& ped)
{
	Vector3 vToTarget = vTargetPos - VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
	vToTarget.z = 0.0f;
	vToTarget.Normalize();
	Vector3 vPedSide = VEC3V_TO_VECTOR3(ped.GetTransform().GetA());	// Peds side vector will point away from cover dir
	vPedSide.z = 0.0f;
	vPedSide.Normalize();

	vToTarget.Cross(vPedSide);

	static dev_float TURN_MIN_MAG = 0.1f;
	if (Abs(vToTarget.z) > TURN_MIN_MAG &&  vToTarget.z > 0.0f)
	{
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::ProcessPreFSM()
{
	CPed* pPed = GetPed();

	if (pPed->IsLocalPlayer())
	{
#if __BANK
		CCoverDebug::ms_debugDraw.ClearAll();
#endif 
		CPlayerCoverClipVariationHelper::GetInstance().UpdateClipVariationStreaming(*pPed);

#if FPS_MODE_SUPPORTED
		if (!pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			pPed->GetIkManager().SetExternallyDrivenPelvisOffset(0.0f);
		}
		else if (m_TaskUseCoverMoveNetworkHelper.IsNetworkActive())
		{
			float fMvCamHeading = CTaskCover::ComputeMvCamHeadingForPed(*pPed);
			m_TaskUseCoverMoveNetworkHelper.SetFloat(CTaskMotionInCover::ms_CamHeadingId, IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? fMvCamHeading : 1.0f - fMvCamHeading);
		}

		if (GetState() != State_Idle)
		{
			pPed->SetPlayerResetFlag(CPlayerResetFlags::PRF_DISABLE_CAMERA_VIEW_MODE_CYCLE);
		}
#endif // FPS_MODE_SUPPORTED
	}

	UpdateTarget( pPed );

	if (!pPed->IsNetworkClone())
	{
		if (m_fTimeInCover > 0.0f && GetTimeRunning() >= m_fTimeInCover)
		{
			return FSM_Quit;
		}

		if (!pPed->GetCoverPoint())
		{
			if(pPed->IsLocalPlayer())
			{
				AI_LOG_WITH_ARGS("[Cover] Ped %s (%p) quit cover task because m_pCoverPoint is NULL\n", AILogging::GetDynamicEntityNameSafe(pPed), pPed);
				return FSM_Quit;
			}

			if(GetState() == State_Idle && FindParentTaskOfType(CTaskTypes::TASK_COMBAT))
			{
				SetCoverFlag(CTaskCover::CF_AimIntroRequested);
			}
			else if(GetState() != State_AimIntro)
			{
				return FSM_Quit;
			}
		}

		if (pPed->IsLocalPlayer() && NetworkInterface::IsGameInProgress() && pPed->GetCoverPoint())
		{
			const CVehicle* pVehicleStoodOnLast = static_cast<const CTaskCover*>(GetParent())->GetVehicleStoodOn();
			const CVehicle* pVehicleStoodOn = NULL;
			if (pPed && pPed->GetGroundPhysical() && pPed->GetGroundPhysical()->GetIsTypeVehicle())
			{
				pVehicleStoodOn = static_cast<const CVehicle*>(pPed->GetGroundPhysical());
			}

			if (pVehicleStoodOnLast && (!pVehicleStoodOn || pVehicleStoodOnLast != pVehicleStoodOn))
			{
				AI_LOG_WITH_ARGS("[Cover] Ped %s (%p) quit cover task because no longer stood on vehicle\n", AILogging::GetDynamicEntityNameSafe(pPed), pPed);
				return FSM_Quit;
			}

			// B*2237237: Break out of cover if ped is standing on a vehicle which is moving and cover entity is not the stood-on vehicle entity (ie not a train).
			CEntity* pCoverEntity = CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity();
			if (pVehicleStoodOn)
			{
				float fVehicleVelocity = pVehicleStoodOn->GetVelocity().Mag();
				static dev_float fVelocityLimit = 0.1f;
				if (fVehicleVelocity > fVelocityLimit)
				{
					// Ensure cover entity isn't the vehicle entity.
					if (!pCoverEntity || (pCoverEntity && ((!pCoverEntity->GetIsTypeVehicle()) || (pCoverEntity->GetIsTypeVehicle() && static_cast<CVehicle*>(pCoverEntity) != pVehicleStoodOn))))
					{
						aiDisplayf("Frame %i:, Ped %s (%p) quit cover task because ped is standing on moving vehicle and cover entity isn't the vehicle entity", fwTimer::GetFrameCount(), pPed->GetModelName(), pPed);
						return FSM_Quit;

					}
				}
			}

			// B*2503521: Do a distance check between ped and cover point positions while on a train, break out if ped moves to far from it
			if (pCoverEntity && pCoverEntity->GetIsTypeVehicle())
			{
				const CVehicle* pCoverVehicle = static_cast<const CVehicle*>(pCoverEntity);
				if (pCoverVehicle->InheritsFromTrain())
				{
					Vector3 vCoverPointPosition;
					pPed->GetCoverPoint()->GetCoverPointPosition(vCoverPointPosition);
					Vector3 vPedPos = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());

					TUNE_GROUP_FLOAT(COVER_TUNE, MAX_DIST_TO_COVER_BEFORE_BREAK_ON_TRAIN, 2.5f,0.0f,10.f,0.5f);
					if ( vCoverPointPosition.Dist2(vPedPos) > square(MAX_DIST_TO_COVER_BEFORE_BREAK_ON_TRAIN))
					{
						aiDisplayf("Frame %i:, Ped %s (%p) quit cover task because ped is standing on moving train and his position is too far from the cover point's", fwTimer::GetFrameCount(), pPed->GetModelName(), pPed);
						return FSM_Quit;
					}
				}
			}

			Vector3 vCoverPos;
			TUNE_GROUP_FLOAT(COVER_TUNE, MAX_TIME_IN_COVER_TASK_TO_ALLOW_ABORT_FOR_OTHER_PED, 1.0f, 0.0f, 2.0f, 0.01f);
			if (pPed->GetCoverPoint()->GetCoverPointPosition(vCoverPos) && GetTimeRunning() < MAX_TIME_IN_COVER_TASK_TO_ALLOW_ABORT_FOR_OTHER_PED)
			{
				if (!CTaskCover::IsCoverPositionValid(vCoverPos, *pPed))
				{
					AI_LOG_WITH_ARGS("[Cover] Ped %s (%p) quit cover task because cover position not valid\n", AILogging::GetDynamicEntityNameSafe(pPed), pPed);
					return FSM_Quit;
				}
			}
		}

		// Get the cover position and direction
		CalculateCoverPosition();

		if (!pPed->IsLocalPlayer())
		{
			TUNE_GROUP_FLOAT(COVER_TUNE, MAX_Z_DELTA, 3.0f, 0.0, 5.0f, 0.01f);
			const float fZDelta = Abs(m_vCoverCoords.z - pPed->GetTransform().GetPosition().GetZf());
			if (fZDelta > MAX_Z_DELTA)
			{
				AI_LOG_WITH_ARGS("[Cover] Ped quit cover task because z delta too large %.2f\n", fZDelta);
				return FSM_Quit;
			}
		}

		if (pPed->IsLocalPlayer())
		{
			// No cover movement while using camera
			if (!CPhoneMgr::CamGetState())
			{
				// Update the players input
				UpdatePlayerInput(pPed);
				// Update the players lock on and targeting
				UpdatePlayerTargetting();
				// Compute new MBR
				ProcessMovement();
				// Process reseting cached stick input after movement
				float fMag = 0.0f;
				float fAngle = 0.0f;
				if (!ComputeStickInputPolarForm(m_vecStick, fMag, fAngle))
				{
					m_bCachedStickValid = false;
				}
			}
		}
		else
		{
			if (!CCover::CheckForTargetsInVehicle(pPed->GetCoverPoint(), pPed))
			{
				return FSM_Quit;
			}

			if(m_iTimeNextPeekAllowed == 0)
			{
				m_iTimeNextPeekAllowed = CalculateTimeNextPeekAllowed();
			}
		}

		if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_RELOAD_GUN)
		{
			// Force a reload if we have just finished the reload task
			CWeapon* pWeapon = pPed->GetWeaponManager() ? pPed->GetWeaponManager()->GetEquippedWeapon() : NULL;
			if(pWeapon && pWeapon->GetState() != CWeapon::STATE_READY)
			{
				pWeapon->DoReload();
			}
		}

		StoreCoverInformation();
	}

	SetCorrectCrouchStatus();

	// Reset physics processing flags, we must explicitly set this in the update functions
	ClearCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);
	ClearCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);
	ClearCoverFlag(CTaskCover::CF_ShouldSlidePedAgainstCover);

	pPed->SetPedResetFlag( CPED_RESET_FLAG_ProcessPreRender2, true ); // reset pre-task
	pPed->SetPedResetFlag( CPED_RESET_FLAG_KeepCoverPoint, true ); // reset pre-task
	pPed->SetPedResetFlag( CPED_RESET_FLAG_DisableGaitReduction, true); // post physics, only used in other task updates
	pPed->SetPedResetFlag( CPED_RESET_FLAG_InCoverTaskActive, true ); // reset pre-task

	if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_IsInLowCover, true); // reset pre-task
	}

	bool bUseKinematicPhysics = false;

	if (pPed->IsLocalPlayer())
	{
		// Prevent the local player from being easily pushed around in cover by other players
		if (NetworkInterface::IsGameInProgress() && GetState() != State_Idle)
		{
			bUseKinematicPhysics = true;
		}
	}
	else if (GetState() >= State_AimIntro && GetState() <= State_ThrowingProjectile)
	{
		// Prevent ai peds from being easily pushed around in cover
		if (pPed->GetCoverPoint() && (!pPed->GetCoverPoint()->m_pEntity || !pPed->GetCoverPoint()->m_pEntity->GetIsDynamic()))
		{
			bUseKinematicPhysics = true;
		}
	}

	if (bUseKinematicPhysics)
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_TaskUseKinematicPhysics, true); // reset pre-task
	}

	//Process the audio.
	ProcessAudio();

	//Check if we are in cover on a vehicle.
	if(pPed->GetCoverPoint() && pPed->GetCoverPoint()->m_pEntity && pPed->GetCoverPoint()->m_pEntity->GetIsTypeVehicle())
	{
		//Note that a ped is in cover.
		static_cast<CVehicle *>(pPed->GetCoverPoint()->m_pEntity.Get())->GetIntelligence()->PedIsInCover();
	}

	// Clones don't go through weapon swap task so need to restart the weapon holding anims separately
	// Script can also force a weapon into the peds hands which requires us to restart the weapon holding anims
	if (NetworkInterface::IsGameInProgress())
	{
		if (pPed->GetWeaponManager())
		{
			// We need to restart if our desired weapon holding clipset isn't the same as the one we're currently using
			// and the desired clipset is streamed in
			const fwMvClipSetId desiredWeaponHoldingClipSetId = CTaskCover::GetWeaponHoldingClipSetForArmament(pPed, true);
			const fwMvClipSetId currentWeaponHoldingClipSetId = m_TaskMotionInCoverMoveNetworkHelper.GetClipSetId(CTaskMotionInCover::ms_UpperBodyWeaponMotionClipSetId);
			if (currentWeaponHoldingClipSetId != desiredWeaponHoldingClipSetId)
			{
				if (desiredWeaponHoldingClipSetId == CLIP_SET_ID_INVALID || CTaskCover::RequestCoverClipSetReturnIfLoaded(desiredWeaponHoldingClipSetId, SP_High))
				{
					RestartWeaponHolding();
				}
			}
		}
	}

	// Need this in all states
	RequestProcessMoveSignalCalls();

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::UpdateFSM(const s32 iState, const FSM_Event iEvent )
{
	FSM_Begin

		FSM_State(State_Start)
			FSM_OnEnter
				return Start_OnEnter();
			FSM_OnUpdate
				return Start_OnUpdate();		

		FSM_State(State_StreamAssets)
			FSM_OnUpdate
				return StreamAssets_OnUpdate();		

		FSM_State(State_Idle)
			FSM_OnEnter
				Idle_OnEnter();
			FSM_OnUpdate
				return Idle_OnUpdate();
			FSM_OnExit
				Idle_OnExit();

		FSM_State(State_Peeking)
			FSM_OnEnter
				Peeking_OnEnter();
			FSM_OnUpdate
				return Peeking_OnUpdate();
			FSM_OnExit
				Peeking_OnExit();

		FSM_State(State_PeekingToReload)
			FSM_OnEnter
				PeekingToReload_OnEnter();
			FSM_OnUpdate
				return PeekingToReload_OnUpdate();

		FSM_State(State_BlindFiring)
			FSM_OnEnter
				BlindFiring_OnEnter();
			FSM_OnUpdate
				return BlindFiring_OnUpdate();
			FSM_OnExit
				return BlindFiring_OnExit();

		FSM_State(State_AimIntro)
			FSM_OnEnter
				return AimIntro_OnEnter();
			FSM_OnUpdate
				return AimIntro_OnUpdate();
			FSM_OnExit
				return AimIntro_OnExit();

		FSM_State(State_Aim)
			FSM_OnEnter
				Aim_OnEnter();
			FSM_OnUpdate
				return Aim_OnUpdate();
			FSM_OnExit
				Aim_OnExit();

		FSM_State(State_AimOutro)
			FSM_OnEnter
				return AimOutro_OnEnter();
			FSM_OnUpdate
				return AimOutro_OnUpdate();
			FSM_OnExit
				return AimOutro_OnExit();

		FSM_State(State_ThrowingProjectile)
			FSM_OnEnter
				ThrowingProjectile_OnEnter();
			FSM_OnUpdate
				return ThrowingProjectile_OnUpdate();
			FSM_OnExit
				ThrowingProjectile_OnExit();

		FSM_State(State_Reloading)
			FSM_OnEnter
				Reloading_OnEnter();
			FSM_OnUpdate
				return Reloading_OnUpdate();
			FSM_OnExit
				Reloading_OnExit();

		FSM_State(State_SwapWeapon)
			FSM_OnEnter
				SwapWeapon_OnEnter();
			FSM_OnUpdate
				return SwapWeapon_OnUpdate();
			FSM_OnExit
				SwapWeapon_OnExit();

		FSM_State(State_UseMobile)
			FSM_OnEnter
				UseMobile_OnEnter();
			FSM_OnUpdate
				return UseMobile_OnUpdate();

		FSM_State(State_Finish)
			FSM_OnUpdate
				return FSM_Quit;

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::ProcessPostFSM()
{
	CPed* pPed = GetPed();

	if (!pPed->IsNetworkClone() && !pPed->GetCoverPoint())
	{
		if(pPed->IsLocalPlayer())
		{
			return FSM_Quit;
		}

		if( GetState() != State_AimIntro &&
			(GetState() != State_Idle || !FindParentTaskOfType(CTaskTypes::TASK_COMBAT)) )
		{
			return FSM_Quit;
		}
	}

	if (m_TaskUseCoverMoveNetworkHelper.IsNetworkActive())
	{
		TUNE_GROUP_FLOAT(TASK_COVER, MOVE_OUT_TO_FIRE_RATE, 1.0f, 0.0f, 10.0f, 0.1f);
		m_TaskUseCoverMoveNetworkHelper.SetFloat( ms_MoveOutToFireRateId, MOVE_OUT_TO_FIRE_RATE);

		TUNE_GROUP_FLOAT(TASK_COVER, MOVE_BACK_FROM_FIRING_RATE, 1.0f, 0.0f, 10.0f, 0.1f);
		m_TaskUseCoverMoveNetworkHelper.SetFloat( ms_MoveBackFromFiringRateId, MOVE_BACK_FROM_FIRING_RATE);
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::ProcessMoveSignals()
{
	CPed* pPed = GetPed();
	if( pPed )
	{
		// Set flags that get reset or expire.
		pPed->SetIsInCover(1);
		pPed->SetPedResetFlag( CPED_RESET_FLAG_ProcessPhysicsTasks, true ); // reset every frame
		pPed->SetPedResetFlag( CPED_RESET_FLAG_InCoverFacingLeft, IsFacingLeft() ); // reset every frame
		pPed->SetPedResetFlag( CPED_RESET_FLAG_IsHigherPriorityClipControllingPed, true ); // reset every frame
	}
	
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::ProcessPhysics(float fTimeStep, int UNUSED_PARAM(nTimeSlice))
{
	CPed *pPed = GetPed(); 

	if (pPed->IsLocalPlayer() && !pPed->GetCoverPoint())
		return false;

	if (GetState() == State_Aim)
	{
		// Compute the heading we would like the ped to be at 
		const bool bForcedStepOut = !pPed->IsLocalPlayer() && pPed->GetCoverPoint() && pPed->GetCoverPoint()->GetFlag(CCoverPoint::COVFLAGS_IsLowCorner);
		if (!m_bForcedBlockAimDirectly && (pPed->IsAPlayerPed() || bForcedStepOut))
		{
			CTaskMotionAiming* pMotionAimingTask = static_cast<CTaskMotionAiming*>(pPed->GetPedIntelligence()->FindTaskActiveMotionByType(CTaskTypes::TASK_MOTION_AIMING));
			if (pMotionAimingTask && pMotionAimingTask->GetState() != CTaskMotionAiming::State_CoverStep)
			{
				Vector3 vTargetIntroPosition(Vector3::ZeroType);
				float fTargetIntroHeading = 0.0f;

				bool bInHighCoverNotAtEdge = !IsCoverFlagSet(CTaskCover::CF_AtCorner) && IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
				if (IsCoverFlagSet(CTaskCover::CF_CloseToPossibleCorner))
				{
					bInHighCoverNotAtEdge = false;
				}
				CTaskInCover::ComputeTargetIntroPositionAndHeading(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), vTargetIntroPosition, fTargetIntroHeading, bInHighCoverNotAtEdge, IsCoverFlagSet(CTaskCover::CF_CloseToPossibleCorner));	
				CTaskAimGunFromCoverIntro::ApplyDesiredVelocityTowardsTarget(*pPed, vTargetIntroPosition, fTimeStep);
			}
		}
	}

#if __DEV
	static dev_bool sb_DisableExtraMovement = false;
	if (sb_DisableExtraMovement)
		return true;
#endif

	const bool bCanFixPosition = (pPed->GetAttachState() == ATTACH_STATE_PED_ON_GROUND) ? false : true;

	const bool bPedCanSlideIntoCover = (bCanFixPosition && !pPed->IsNetworkClone()) || 
		(!IsInMotionState(CTaskMotionInCover::State_Moving) &&
		 !IsInMotionState(CTaskMotionInCover::State_TurnEnter) && 
		 !IsInMotionState(CTaskMotionInCover::State_TurnEnd) &&
		 !IsInMotionState(CTaskMotionInCover::State_Stepping) &&
		 !IsInMotionState(CTaskMotionInCover::State_WalkStart));

	if (!FPIsFinite(m_vCoverCoords.x) || !FPIsFinite(m_vCoverCoords.y) || !FPIsFinite(m_vCoverCoords.z))
	{
		m_vCoverCoords = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		return false;
	}

	if (bPedCanSlideIntoCover)
	{
		if (IsCoverFlagSet(CTaskCover::CF_ShouldSlidePedIntoCover))		
			SlidePedIntoCover(*pPed, this, m_vCoverCoords);
	}

	if (!pPed->IsNetworkClone() && bCanFixPosition)
	{
		if (IsCoverFlagSet(CTaskCover::CF_ShouldSlidePedAgainstCover))
			SlidePedAgainstCover();
	}

	if (IsCoverFlagSet(CTaskCover::CF_FacePedInCorrectDirection) && !IsInMotionState(CTaskMotionInCover::State_EdgeTurn))
		FacePedInCorrectDirection(fTimeStep);

	static dev_float sf_MinVelocityForPhysicsUpdate = 0.01f * 0.01f;
	if (pPed->GetDesiredVelocity().Mag2() > sf_MinVelocityForPhysicsUpdate)
		return true;
	else
		return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::ProcessPostCamera()
{
	CPed& ped = *GetPed();

	// Update desired heading and ik target
	if (ped.IsAPlayerPed())
	{
#if FPS_MODE_SUPPORTED
		TUNE_GROUP_BOOL(FIRST_PERSON_BLINDFIRE, USE_FPS_IK, true);
		if (ped.IsFirstPersonShooterModeEnabledForPlayer(false) && USE_FPS_IK)
		{
			const bool bShouldProcessFPSIk = IsValidForFPSIk(ped);

			if (bShouldProcessFPSIk)
			{
				const CWeaponInfo* pWeaponInfo = CTaskMotionPed::GetWeaponInfo(&ped);
				if (pWeaponInfo)
				{
					if (m_pFirstPersonIkHelper == NULL)
					{
						m_pFirstPersonIkHelper = rage_new CFirstPersonIkHelper(CFirstPersonIkHelper::FP_OnFootDriveBy);
						m_pFirstPersonIkHelper->SetArm(CFirstPersonIkHelper::FP_ArmRight);
					}

					if (m_pFirstPersonIkHelper)
					{
						Vector3 vTargetOffset(Vector3::ZeroType);

						// Apply offset when using 2H weapon fire with a 1H cover animation to improve framing position
						if (pWeaponInfo->GetIsTwoHanded() && pWeaponInfo->GetIs1HandedInCover())
						{
							vTargetOffset = Vector3(0.0f, -0.1f, 0.0f);
						}

#if __BANK			// Allow override of values for tweaking purposes
						TUNE_GROUP_BOOL(FIRST_PERSON_BLINDFIRE, bOverrideOffsetValues, false);
						TUNE_GROUP_FLOAT(FIRST_PERSON_BLINDFIRE, fOverrideOffsetX, vTargetOffset.x, -10.0f, 10.0f, 0.01f);
						TUNE_GROUP_FLOAT(FIRST_PERSON_BLINDFIRE, fOverrideOffsetY, vTargetOffset.y, -10.0f, 10.0f, 0.01f);
						TUNE_GROUP_FLOAT(FIRST_PERSON_BLINDFIRE, fOverrideOffsetZ, vTargetOffset.z, -10.0f, 10.0f, 0.01f);
						if (bOverrideOffsetValues)
						{
							vTargetOffset = Vector3(fOverrideOffsetX, fOverrideOffsetY, fOverrideOffsetZ);
						}
#endif // __BANK
						TUNE_GROUP_FLOAT(FIRST_PERSON_BLINDFIRE, MIN_FPS_IK_YAW, -PI, -PI, PI, 0.01f);
						TUNE_GROUP_FLOAT(FIRST_PERSON_BLINDFIRE, MAX_FPS_IK_YAW, PI, -PI, PI, 0.01f);
						TUNE_GROUP_INT(FIRST_PERSON_BLINDFIRE, BLEND_OUT_RATE, 3, 0, 5, 1);
						m_pFirstPersonIkHelper->SetOffset(RCC_VEC3V(vTargetOffset));
						m_pFirstPersonIkHelper->SetMinMaxDriveByYaw(MIN_FPS_IK_YAW, MAX_FPS_IK_YAW);
						TUNE_GROUP_BOOL(FIRST_PERSON_BLINDFIRE, SET_BLEND_OUT_RATE, true);
						if (SET_BLEND_OUT_RATE)
							m_pFirstPersonIkHelper->SetBlendOutRate((ArmIkBlendRate)BLEND_OUT_RATE);
						m_pFirstPersonIkHelper->Process(&ped);
					}
				}
			}
		}
#endif // FPS_MODE_SUPPORTED

		bool bShouldPointGun = false;
		Vector3 vTargetPos;
		if (!ped.IsNetworkClone())
		{
			if (!ped.GetUsingRagdoll() && !ped.GetPlayerInfo()->AreControlsDisabled())
			{
				// Attempt to update the ped's orientation and IK aim target *after* the camera system has updated, but before the aim IK is updated
				const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
				if(camInterface::GetGameplayDirector().IsThirdPersonAiming(&ped))
				{
					//Force an update of the point gun target for the ped to avoid a frame of lag.
					const Matrix34& aimCameraWorldMatrix = aimCameraFrame.GetWorldMatrix();
					vTargetPos = aimCameraWorldMatrix.d + (aimCameraWorldMatrix.b * CTaskAimGunOnFoot::ms_fTargetDistanceFromCameraForAimIk);
					bShouldPointGun = true;
				}
			}
		}
		else if (GetTarget().GetIsValid() && GetTarget().GetPositionWithFiringOffsets(&ped, vTargetPos))
		{
			bShouldPointGun = true;
		}

		if (bShouldPointGun)
		{
			// Enable torso ik to fix up yaw during aim intro
			// Need to also set this when we first go into aim state to prevent torso ik from beginning to blend out
			TUNE_GROUP_FLOAT(COVER_TUNE, TIME_TO_APPLYTORSO_IK_IN_AIM_STATE, 0.25f, 0.0f, 1.0f, 0.01f);
			if (GetState() == State_AimIntro || (GetState() == State_Aim && GetTimeInState() < TIME_TO_APPLYTORSO_IK_IN_AIM_STATE))
			{
				//const float fBlendRatio = rage::Clamp(GetTimeInState() / CTaskAimGunFromCoverIntro::ms_Tunables.m_IntroMovementDuration, 0.0f, 1.0f);
				ped.GetIkManager().PointGunAtPosition(vTargetPos, -1.0f /*fBlendRatio*/);
			}
		}
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Start_OnEnter()
{
	CPed* pPed = GetPed();

	// Flag that we are using a cover point
	pPed->SetPedConfigFlag( CPED_CONFIG_FLAG_UsingCoverPoint, true );

	// If the current weapon we have isn't usable in cover be unarmed
#if !HACK_RDR3
	const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();
	if (pWeaponInfo && !pWeaponInfo->GetUsableInCover())
	{
		//if (pWeaponInfo->GetIsMelee() || !pPed->GetWeaponManager()->EquipBestWeapon(true)) //now just go unarmed B* 1357300
		{
			pPed->GetWeaponManager()->ClearBackupWeapon();
			pPed->GetWeaponManager()->BackupEquippedWeapon();
			pPed->GetWeaponManager()->EquipWeapon( pPed->GetDefaultUnarmedWeaponHash(), -1, true);
		}
	}
#endif

	// Reset our random variance for the time between bursts
	ResetTimeBetweenBurstsRandomness();

	m_ShouldReloadWeaponDelay = 0; //ensure this is reset on start

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Start_OnUpdate()
{
	if (!IsCoverFlagSet(CTaskCover::CF_SpecifyInitialHeading))
		CalculateInitialHeadingDir();

	if (GetParent()->GetTimeInState() > 0.0f)
	{
		FindCoverEdgeAndUpdateCoverPosition();
	}

	// Update cover variables after setting a new cover point
	if (!CalculateCoverPosition())
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	CheckForBlockedBlindFire();

	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);	

	SetState(State_StreamAssets);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Start_OnUpdateClone()
{
	SetState(State_StreamAssets);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::StreamAssets_OnUpdate()
{
	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);	

	// B*1797981
	if (!GetPed()->IsLocalPlayer() && CheckForExit())
	{
		if (IsPedsVehicleCoverOnFire(*GetPed()))
		{
			SetState(State_Finish);
			return FSM_Continue;
		}
		return FSM_Continue;
	}
	else if (AreTaskAssetsLoaded(*GetPed(), false))
	{
		SetState(State_Idle);
		return FSM_Continue;
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::StreamAssets_OnUpdateClone()
{
	if (AreTaskAssetsLoaded(*GetPed(), false))
	{
		SetState(State_Idle);
		return FSM_Continue;
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::Idle_OnEnter()
{
	if (GetPreviousState() != State_Peeking)
	{		
		SetNewTask(rage_new CTaskMotionInCover(m_TaskCoverMoveNetworkHelper, m_TaskMotionInCoverMoveNetworkHelper));
	}

#if FPS_MODE_SUPPORTED
	// Ensure we zero out the pelvis offset as we're not aiming
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		GetPed()->GetIkManager().SetExternallyDrivenPelvisOffset(0.0f);
	}
#endif // FPS_MODE_SUPPORTED

	m_ShouldReloadWeaponDelay = 0; //ensure this is reset when idle
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Idle_OnUpdate()
{
	ProcessReloadSecondaryTask();
	ProcessWeaponSwapSecondaryTask();

	CPed* pPed = GetPed();

	bool bIsFPSMode = false;

#if FPS_MODE_SUPPORTED
	bIsFPSMode = pPed->IsFirstPersonShooterModeEnabledForPlayer(false);
	if (bIsFPSMode)
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_DisableReticuleInCoverThisFrame, true);

		// Fix for heading pop when interrupting aim outro, need to prevent the motion
		// task from transitioning back to loco (to prevent the human loco sprint breakout logic)
		if ((GetPreviousState() == State_AimOutro || GetPreviousState() == State_ThrowingProjectile))
		{
			pPed->ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);
		}
	}
#endif // FPS_MODE_SUPPORTED

	CTaskMotionInCover* pMotionInCoverTask = static_cast<CTaskMotionInCover*>(GetSubTask());

	if (CheckForExit())
	{
		// Ensure we are not classed as moving
		if(pMotionInCoverTask && pMotionInCoverTask->IsIdle())
		{
			pPed->GetMotionData()->SetCurrentMoveBlendRatio(0.0f);
		}
		return FSM_Continue;
	}

	bool bAimChecksOnly = false;
	if (pMotionInCoverTask)
	{
		taskAssertf(GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER, "Subtask wasn't of type TASK_MOTION_IN_COVER");
		const s32 iMotionState = pMotionInCoverTask->GetState();
		// Wait until the movement network has been inserted before allowing transitions
		if (iMotionState <= CTaskMotionInCover::State_Start || 
			iMotionState == CTaskMotionInCover::State_Stepping ||
			iMotionState == CTaskMotionInCover::State_Turning || 
			iMotionState == CTaskMotionInCover::State_TurnEnter || 			
			// Turns take much longer in first person so we need to wait longer before aiming
			((!pPed->IsPlayer() FPS_MODE_SUPPORTED_ONLY(|| bIsFPSMode)) && iMotionState == CTaskMotionInCover::State_TurnEnd) ||
			iMotionState == CTaskMotionInCover::State_CoverToCover ||
			iMotionState == CTaskMotionInCover::State_EdgeTurn)
		{
			return FSM_Continue;
		}

		if (iMotionState == CTaskMotionInCover::State_TurnEnd )
		{
			bAimChecksOnly = true;
		}
	}

	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished))
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	//Vector3 vCamHeading = GetCameraHeadingVec();
	s32 newFiringState;

	// Check for task state transitions
	const CWeaponInfo* pWeaponInfo = pPed->GetEquippedWeaponInfo();
	if (IsCoverFlagSet(CTaskCover::CF_AimIntroRequested) && AreWeaponClipsetsLoadedForPed(*pPed) && pWeaponInfo && (pWeaponInfo->GetIsGunOrCanBeFiredLikeGun() || pWeaponInfo->GetCanBeAimedLikeGunWithoutFiring()))
	{
		const CWeaponInfo* pObjectWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfoFromObject(); 
		if (pObjectWeaponInfo && pObjectWeaponInfo!=pWeaponInfo)
		{ //verify object in hand is in synch (or non-existant)) B* 1500172
			ClearCoverFlag(CTaskCover::CF_AimIntroRequested);
			return FSM_Continue;
		}
#if __ASSERT
		const fwMvClipSetId weaponClipSetId = CTaskCover::GetWeaponClipSetForArmament(pPed, !pPed->IsAPlayerPed());
		const bool bClipSetLoaded = CTaskCover::IsCoverClipSetLoaded(weaponClipSetId);
		aiDisplayf("Frame : %i, Clipset %s %s for ai ped %s", fwTimer::GetFrameCount(), weaponClipSetId.GetCStr(), bClipSetLoaded ? "LOADED" : "NOT LOADED", pPed->GetDebugName());		
		if (pWeaponInfo)
		{
			fwMvClipSetId clipset = pWeaponInfo->GetPedCoverWeaponClipSetId(*pPed);
			if (clipset != CLIP_SET_ID_INVALID)
			{
				const bool bClipSetLoaded = CTaskCover::IsCoverClipSetLoaded(clipset);
				aiDisplayf("Frame : %i, Clipset %s %s for ai ped %s", fwTimer::GetFrameCount(), clipset.GetCStr(), bClipSetLoaded ? "LOADED" : "NOT LOADED", pPed->GetDebugName());
			}
		}
#endif // __ASSERT

		SetState(State_AimIntro);
		return FSM_Continue;
	}
	else if (CheckForMovingOutToFire(newFiringState))
	{
		if (bAimChecksOnly && newFiringState==State_BlindFiring) //can't interrupt turn to blindfire
			return FSM_Continue;

#if __ASSERT
		if (newFiringState == State_AimIntro)
		{
			const fwMvClipSetId weaponClipSetId = CTaskCover::GetWeaponClipSetForArmament(GetPed(), !GetPed()->IsAPlayerPed());
			const bool bClipSetLoaded = CTaskCover::IsCoverClipSetLoaded(weaponClipSetId);
			aiDisplayf("1 : Frame : %i, Clipset %s %s for ped %s", fwTimer::GetFrameCount(), weaponClipSetId.GetCStr(), bClipSetLoaded ? "LOADED":"NOT LOADED", GetPed()->GetDebugName());			
			if (pWeaponInfo)
			{
				fwMvClipSetId clipset = pWeaponInfo->GetPedCoverWeaponClipSetId(*pPed);
				if (clipset != CLIP_SET_ID_INVALID)
				{
					const bool bClipSetLoaded = CTaskCover::IsCoverClipSetLoaded(clipset);
					aiDisplayf("Frame : %i, Clipset %s %s for ai ped %s", fwTimer::GetFrameCount(), clipset.GetCStr(), bClipSetLoaded ? "LOADED" : "NOT LOADED", pPed->GetDebugName());
				}
			}
		}
#endif // __ASSERT
		SetState(newFiringState);
		return FSM_Continue;
	}
	else if (bAimChecksOnly)
	{
		return FSM_Continue;
	}
	else if (!pPed->IsAPlayerPed() && CheckForSwitchingWeapon())
	{
		SetState(State_SwapWeapon);
		return FSM_Continue;
	}
	else if (CheckForReload() && (!pPed->IsAPlayerPed() || !ms_Tunables.m_EnableReloadingWhilstMovingInCover))
	{
		m_bOutroToReload = false;
		SetState(State_Reloading);
		return FSM_Continue;
	}
	else if ( pPed->GetPedIntelligence()->CanBePinnedDown() &&
			  ( pPed->GetPedIntelligence()->GetAmountPinnedDown() > ms_Tunables.m_PinnedDownTakeCoverAmount ||
			  (fwTimer::GetTimeInMilliseconds() - pPed->GetPedIntelligence()->GetLastPinnedDownTime()) < ms_Tunables.m_MinTimeToBePinnedDown ) )
	{
		if(CheckDesiredPinnedDownState(newFiringState))
		{
			SetState(newFiringState);
		}

		return FSM_Continue;
	}	
	else if (CheckForThrowingProjectile())
	{
		SetStateThrowingProjectile(0.0f);
		return FSM_Continue;
	} 
	else if (CheckForPeeking() && (!pPed->IsLocalPlayer() || (pMotionInCoverTask && pMotionInCoverTask->GetPlayerPeekReset())))
	{
		SetState(State_Peeking);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}

	ActivateTimeslicing();

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Idle_OnUpdateClone()
{
	ProcessReloadSecondaryTask();
	ProcessWeaponSwapSecondaryTask();

	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		// Wait until the movement network has been inserted before allowing transitions
		if (GetSubTask()->GetState() <= CTaskMotionInCover::State_Start)
		{
			return FSM_Continue;
		}
	}

	SetNextStateFromNetwork();

	if (GetState() == State_Peeking)
	{
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
	}

    // we can timeslice this ped if the state hasn't changed
    if(GetState() == State_Idle)
    {
        ActivateTimeslicing();
    }

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::Idle_OnExit()
{
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::Peeking_OnEnter()
{
#if FPS_MODE_SUPPORTED
	CPed& rPed = *GetPed();

	INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, INITIAL_Z_OFFSET_FOR_PEEK_PROBE, -1.0f, 1.0f, 0.01f);
	INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, PEEK_PROBE_LENGTH, 0.0f, 5.0f, 0.01f);
	INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, FINAL_Z_OFFSET_FOR_PEEK_PROBE, -1.0f, 1.0f, 0.01f);
	INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, Z_INCREMENT_BETWEEN_PEEK_PROBES, 0.0f, 1.0f, 0.001f);
	rPed.ComputeLowCoverHeightOffsetFromMover(INITIAL_Z_OFFSET_FOR_PEEK_PROBE, FINAL_Z_OFFSET_FOR_PEEK_PROBE, Z_INCREMENT_BETWEEN_PEEK_PROBES, PEEK_PROBE_LENGTH);

	m_bPeekToggleEnabled = true;
#endif // FPS_MODE_SUPPORTED

	m_fTimeToSpendInState = 0.6f * fwRandom::GetRandomNumberInRange(.9f, 1.1f);

	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		CTaskMotionInCover* pMotionTask = static_cast<CTaskMotionInCover*>(GetSubTask());
		if (pMotionTask->GetState() != CTaskMotionInCover::State_Peeking)
		{
			pMotionTask->ResetEnteredPeekState();
			pMotionTask->ResetPeekVariationState();
		}
	}

	if (GetPreviousState() == State_AimOutro || GetPreviousState() == State_BlindFiring || GetPreviousState() == State_ThrowingProjectile)
	{
		SetNewTask(rage_new CTaskMotionInCover(m_TaskCoverMoveNetworkHelper, m_TaskMotionInCoverMoveNetworkHelper));
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Peeking_OnUpdate()
{
	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);

	ProcessReloadSecondaryTask();
	ProcessWeaponSwapSecondaryTask();

	CPed* pPed = GetPed();

	pPed->SetPedResetFlag(CPED_RESET_FLAG_IsPeekingFromCover, true);

#if FPS_MODE_SUPPORTED
	ProcessPelvisOffset();

	if (m_bPeekToggleEnabled && pPed->IsLocalPlayer() && GetTimeInState() > 0.25f)
	{
		const CControl* pControl = pPed->GetControlFromPlayer();
		if (pControl && pControl->GetPedLookBehind().IsPressed())
		{
			m_bPeekToggleEnabled = false;
		}
	}
#endif // FPS_MODE_SUPPORTED

	// Block weapon switching when peeking
	if (!ms_Tunables.m_UseAutoPeekAimFromCoverControls)
		pPed->SetPedResetFlag(CPED_RESET_FLAG_TemporarilyBlockWeaponSwitching, true);

	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		CTaskMotionInCover* pMotionTask = static_cast<CTaskMotionInCover*>(GetSubTask());
		if (!pMotionTask->GetEnteredPeekState() && !IsInMotionState(CTaskMotionInCover::State_PlayingIdleVariation))
		{
			if (IsInMotionState(CTaskMotionInCover::State_Moving))
			{
				SetState(State_Idle);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				return FSM_Continue;
			}

			ActivateTimeslicing();
			return FSM_Continue;
		}

		// If we're running a peek variation, wait until it has finished before changing state
		if (pMotionTask->GetPeekVariationStarted())
		{
			if (!pMotionTask->GetPeekVariationFinished())
			{
				ActivateTimeslicing();
				return FSM_Continue;
			}
		}
	}

	//Vector3 vCameraHeading = GetCameraHeadingVec();

	// Check for task state transitions
	if (IsCoverFlagSet(CTaskCover::CF_AimIntroRequested))
	{
		SetState(State_Idle);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForExit())
	{
		return FSM_Continue;
	}
	else if (!pPed->GetPedResetFlag( CPED_RESET_FLAG_ForcePeekFromCover ))
	{
		s32 newFiringState;

		if (!CheckForPeeking())
		{
			SetState(State_Idle);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (CheckForThrowingProjectile())
		{
			SetStateThrowingProjectile( GetTimeInState() );
			return FSM_Continue;
		}
		else if (CTaskPlayerOnFoot::CheckForUseMobilePhone(*pPed))
		{
			SetState(State_Idle);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (CheckForSwitchingWeapon())
		{
			SetState(State_Idle);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (CheckForMovingOutToFire(newFiringState))
		{
#if __ASSERT
			if (newFiringState == State_AimIntro)
			{
				const fwMvClipSetId weaponClipSetId = CTaskCover::GetWeaponClipSetForArmament(GetPed(), !GetPed()->IsAPlayerPed());
				const bool bClipSetLoaded = CTaskCover::IsCoverClipSetLoaded(weaponClipSetId);
				aiDisplayf("2 : Frame : %i, Clipset %s %s for ped %s", fwTimer::GetFrameCount(), weaponClipSetId.GetCStr(), bClipSetLoaded ? "LOADED":"NOT LOADED", GetPed()->GetDebugName());
			}
#endif // __ASSERT
			SetState(newFiringState);
			return FSM_Continue;
		}
		else if (CheckForReload() && (!pPed->IsAPlayerPed() || !ms_Tunables.m_EnableReloadingWhilstMovingInCover))
		{
			//SetState(State_PeekingToReload);
			SetState(State_Reloading);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (ms_Tunables.m_UseAutoPeekAimFromCoverControls && pPed->IsLocalPlayer())
		{
			if (!IsInMotionState(CTaskMotionInCover::State_Peeking) && !IsInMotionState(CTaskMotionInCover::State_PlayingIdleVariation))
			{
				SetState(State_Idle);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				return FSM_Continue;
			}
		}
	}

	ActivateTimeslicing();
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::Peeking_OnExit()
{
	m_iTimeNextPeekAllowed = CalculateTimeNextPeekAllowed();
#if FPS_MODE_SUPPORTED
	m_bPeekToggleEnabled = false;
#endif // FPS_MODE_SUPPORTED
	CPed* pPed = GetPed();
	if( pPed )
	{
		// clear initial peek flag now that peek has finished
		pPed->SetPedConfigFlag(CPED_CONFIG_FLAG_ForceInitialPeekInCover, false);
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Peeking_OnUpdateClone()
{
	ProcessReloadSecondaryTask();
	ProcessWeaponSwapSecondaryTask();

	SetNextStateFromNetwork();

	if (GetState() == State_Idle && GetPreviousState() == State_Peeking)
	{
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
	}

    // if the state hasn't changed we can timeslice this ped
    if(GetState() == State_Peeking)
    {
	    ActivateTimeslicing();
    }

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::PeekingToReload_OnEnter()
{
	SetNewTask(rage_new CTaskMotionInCover(m_TaskCoverMoveNetworkHelper, m_TaskMotionInCoverMoveNetworkHelper));
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::PeekingToReload_OnUpdate()
{
	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);	

	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		// Wait until the movement network has been inserted before allowing transitions
		if (GetSubTask()->GetState() <= CTaskMotionInCover::State_Start)
		{
			return FSM_Continue;
		}
	}

	SetState(State_Reloading);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::BlindFiring_OnEnter()
{
	CPed* pPed = GetPed();

#if FPS_MODE_SUPPORTED
	if (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations)
	{
		INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, INITIAL_Z_OFFSET_FOR_PEEK_PROBE, -1.0f, 1.0f, 0.01f);
		INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, PEEK_PROBE_LENGTH, 0.0f, 5.0f, 0.01f);
		INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, FINAL_Z_OFFSET_FOR_PEEK_PROBE, -1.0f, 1.0f, 0.01f);
		INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, Z_INCREMENT_BETWEEN_PEEK_PROBES, 0.0f, 1.0f, 0.001f);
		pPed->ComputeLowCoverHeightOffsetFromMover(INITIAL_Z_OFFSET_FOR_PEEK_PROBE, FINAL_Z_OFFSET_FOR_PEEK_PROBE, Z_INCREMENT_BETWEEN_PEEK_PROBES, PEEK_PROBE_LENGTH);
	}
#endif // FPS_MODE_SUPPORTED

	static_cast<CTaskCover*>(GetParent())->SetWantedToReloadDuringEntry(false);
	// Reset our random variance for the time between bursts
	ResetTimeBetweenBurstsRandomness();

	pPed->SetLocalOffsetToCoverPoint(VEC3_ZERO);
	CTaskGun* pGunTask = CreateBlindFireGunTask();
	taskFatalAssertf(pGunTask, "NULL gun task pointer");

	static_cast<CTaskCover*>(GetParent())->RestartUseCoverNetwork(GetPed());

	// Update the cover point
	if (pPed->IsLocalPlayer())
	{
		CTaskMotionInCover::FindNewDynamicCoverPoint(pPed, 0.0f, IsCoverFlagSet(CTaskCover::CF_FacingLeft), false, true);
	}

	// Send the request to transition to the reload state in the main network
	m_TaskMotionInCoverMoveNetworkHelper.SendRequest(CTaskMotionInCover::ms_StillRequestId);
	m_TaskUseCoverMoveNetworkHelper.SendRequest(ms_BlindFiringRequestId);
	// This request is delayed a frame on clones (I think because of the way the gun task creates the clone subtasks), so we need to send this here
	if (pPed->IsNetworkClone())
		m_TaskUseCoverMoveNetworkHelper.SendRequest(CTaskAimGunBlindFire::ms_NewBlindFireSolutionRequestId);
	m_TaskUseCoverMoveNetworkHelper.WaitForTargetState(ms_BlindFiringOnEnterId);
	SetNewTask(pGunTask);
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::BlindFiring_OnUpdate()
{
	CPed& rPed = *GetPed();
	rPed.ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);

#if FPS_MODE_SUPPORTED
	ProcessPelvisOffset();
#endif // FPS_MODE_SUPPORTED

	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);	

	if (!m_TaskUseCoverMoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

#if __DEV
	if(DEBUG_BLINDFIRE_TEST)
		CheckForBlockedBlindFire();
#endif

	if (rPed.IsLocalPlayer())
	{
		CTaskAimGunBlindFire* pBlindFireTask = static_cast<CTaskAimGunBlindFire*>(FindSubTaskOfType(CTaskTypes::TASK_AIM_GUN_BLIND_FIRE));
		if (pBlindFireTask && pBlindFireTask->GetState() >= CTaskAimGunBlindFire::State_IntroNew && (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) || pBlindFireTask->UsingOverTheTopFiring()))	// No to peek transitions for low corners
		{
			if (CheckForReload(true))
			{
				m_bOutroToReload = true;
			}

#if FPS_MODE_SUPPORTED
			TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MIN_TIME_IN_FIRE_STATE_TO_ALLOW_DIRECT_PEEK, 0.5f, 0.0f, 1.0f, 0.01f);
			if (CTaskMotionInCover::ms_Tunables.m_EnableBlindFireToPeek && GetTimeInState() > MIN_TIME_IN_FIRE_STATE_TO_ALLOW_DIRECT_PEEK && rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
			{
				bool bCanInterruptToPeek = false;
				if (pBlindFireTask->GetState() == CTaskAimGunBlindFire::State_FireNew || pBlindFireTask->GetState() == CTaskAimGunBlindFire::State_OutroNew)
				{
					const CWeaponInfo* pWeaponInfo = rPed.GetWeaponManager()->GetEquippedWeaponInfo();
					const bool bNeedsCocking = pWeaponInfo && pWeaponInfo->GetNeedsGunCockingInCover();

					if (bNeedsCocking && pBlindFireTask->GetFiredOnce())
					{
						bCanInterruptToPeek = true;
					}
					else
					{
						bool bContinueFireLoopUntilEnd = pBlindFireTask->GetGunFlags().IsFlagSet(GF_OnlyExitFireLoopAtEnd) && pWeaponInfo->GetForceFullFireAnimation();
						WeaponControllerState controllerState = pBlindFireTask->GetWeaponControllerState(&rPed);
						bCanInterruptToPeek = (controllerState != WCS_Fire && controllerState != WCS_FireHeld && !bContinueFireLoopUntilEnd);
					}
				}
				
				if (bCanInterruptToPeek && CheckForPeeking())
				{
					SetState(State_Peeking);
					return FSM_Continue;
				}
			}
#endif // FPS_MODE_SUPPORTED
		}

		if (m_bOutroToReload && m_TaskUseCoverMoveNetworkHelper.GetBoolean(CTaskAimGunBlindFire::ms_BlindFireOutroInterruptId))
		{
			ProcessReloadSecondaryTask();
		}
	}

	// Tell the accuracy system we are blindfiring
	weaponAssert(rPed.GetWeaponManager());
	rPed.GetWeaponManager()->GetAccuracy().GetResetVars().SetFlag(CPedAccuracyResetVariables::Flag_BlindFiring);

	bool bWantToWeaponSwitch = rPed.IsLocalPlayer() && rPed.GetWeaponManager()->GetRequiresWeaponSwitch();
	if (bWantToWeaponSwitch || !GetSubTask() || GetIsFlagSet(aiTaskFlags::SubTaskFinished) || IsCoverFlagSet(CTaskCover::CF_AimIntroRequested))
	{
		SetState(State_Idle);
		return FSM_Continue;
	}
	else
	{
		ProcessBlindFireBreakGlass(&rPed);

		if( CheckForExit() )
		{
			SetState(State_Finish);
			return FSM_Continue;
		}
		else if( (rPed.GetIkManager().GetTorsoSolverStatus() & CIkManager::IK_SOLVER_UNREACHABLE_YAW) || (rPed.GetIkManager().GetTorsoSolverStatus() & CIkManager::IK_SOLVER_UNREACHABLE_PITCH) )
		{
			if(( rPed.GetIkManager().GetTorsoPitch() <= ( rPed.GetIkManager().GetTorsoMinPitch() - DIM_IK_TOLERANCE ) ) || 
				( rPed.GetIkManager().GetTorsoPitch() >= ( rPed.GetIkManager().GetTorsoMaxPitch() + DIM_IK_TOLERANCE ) ) ||
				( rPed.GetIkManager().GetTorsoYaw() <= ( rPed.GetIkManager().GetTorsoMinYaw() - DIM_IK_TOLERANCE ) ) ||
				( rPed.GetIkManager().GetTorsoYaw() >= ( rPed.GetIkManager().GetTorsoMaxYaw() + DIM_IK_TOLERANCE ) ))
			{
				rPed.SetPedResetFlag( CPED_RESET_FLAG_DimTargetReticule, true );
			}
		}
	}

	return FSM_Continue;
}


////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::BlindFiring_OnUpdateClone()
{
	CPed& rPed = *GetPed();
	rPed.ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);

	SetNextStateFromNetwork();

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::BlindFiring_OnExit()
{
	m_TaskCoverMoveNetworkHelper.SendRequest(CTaskCover::ms_NoTaskRequestId);

#if FPS_MODE_SUPPORTED
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false) && CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations)
	{
		GetPed()->SetLowCoverHeightOffsetFromMover(0.0f);
	}
#endif // FPS_MODE_SUPPORTED

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

#if FPS_MODE_SUPPORTED
REGISTER_TUNE_GROUP_FLOAT(MOVER_TO_PELVIS_OFFSET, -0.4f);
REGISTER_TUNE_GROUP_BOOL(ENABLE_PELVIS_OFFSET_FOR_FPS, false);
#endif // FPS_MODE_SUPPORTED

CTask::FSM_Return CTaskInCover::AimIntro_OnEnter()
{
	m_bSteppedOutToAim = false;

	CPed* pPed = GetPed();

	static_cast<CTaskCover*>(GetParent())->SetWantedToReloadDuringEntry(false);
	CheckForBlockedAim();

	// Reset our random variance for the time between bursts
	ResetTimeBetweenBurstsRandomness();

	if (pPed->IsLocalPlayer() && pPed->GetPlayerInfo() && pPed->GetPlayerInfo()->IsCoverGeneratedByDynamicEntity() && pPed->GetCoverPoint())
	{
		Vector3 vCoverPosition(Vector3::ZeroType);
		if (pPed->GetCoverPoint()->GetCoverPointPosition(vCoverPosition))
		{
			pPed->GetPlayerInfo()->SetDynamicCoverPointLastKnownPosition(vCoverPosition);
		}
	}

	Vector3 vTargetPosition;

	if (GetTarget().GetIsValid())
		taskVerifyf(GetTarget().GetPositionWithFiringOffsets(pPed, vTargetPosition), "Could get weapon target position");	

	weaponAssert(pPed->GetWeaponManager());
	const CObject* pWeaponObject = pPed->GetWeaponManager()->GetEquippedWeaponObject();
	const CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();

	const bool bInHighCoverNotAtEdge = (!IsCoverFlagSet(CTaskCover::CF_AtCorner) && IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint)) || m_bForcedStepBack;
	bool bForceStepBack = false;
	if ((bInHighCoverNotAtEdge || (!IsCoverFlagSet(CTaskCover::CF_CanBlindFire) && (!IsCoverFlagSet(CTaskCover::CF_AtCorner) || IsCoverFlagSet(CTaskCover::CF_UseOverTheTopFiring)))))
	{
		bForceStepBack = true;
	}
	else if( pWeapon && pWeaponObject && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		ClearCoverFlag(CTaskCover::CF_AtCorner);
		bForceStepBack = ShouldStepBack(pWeaponObject, pWeapon);
	}

	static_cast<CTaskCover*>(GetParent())->RestartUseCoverNetwork(GetPed());

	// Send the request to transition to the reload state in the main network
	m_TaskUseCoverMoveNetworkHelper.SetFloat(ms_AimIntroRateId, CalculateRateForAimIntro());
	m_TaskUseCoverMoveNetworkHelper.SendRequest(ms_AimIntroRequestId);
	m_TaskUseCoverMoveNetworkHelper.WaitForTargetState(ms_AimIntroOnEnterId);

	m_TaskCoverMoveNetworkHelper.SendRequest(CTaskCover::ms_NoMotionTaskRequestId);

	s32 iFlags = bForceStepBack ? CTaskAimGunFromCoverIntro::CAF_MoveAwayFromCover : 0;

	if (IsCoverFlagSet(CTaskCover::CF_AimDirectly))
	{
		m_bStoodUpToFire = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
		iFlags |= CTaskAimGunFromCoverIntro::CAF_NoStep;
	}
	else
	{
		m_bStoodUpToFire = true;
		if (!pPed->IsAPlayerPed())
		{
			iFlags |= CTaskAimGunFromCoverIntro::CAF_ShortStep;
		}
		else
		{
			const s32 iCurrentArcIndex = pPed->IsNetworkClone() ? m_iCurrentCoverStepNodeIndex : -1;
			s32 iDesiredArc = ComputeDesiredArc(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), iCurrentArcIndex);
			if (iDesiredArc > -1)
			{
				if (iDesiredArc == 2 || bInHighCoverNotAtEdge)
				{
					iFlags |= CTaskAimGunFromCoverIntro::CAF_LongStep;
				}
				else
				{
					iFlags |= CTaskAimGunFromCoverIntro::CAF_ShortStep;
				}
				m_iCurrentCoverStepNodeIndex = iDesiredArc;
			}
			// Big hack for B*1573233, due to the rpg override in ComputeStepTransitionMinAngle we can end up with an invalid index
			// and not set a step flag, which is needed to correctly compute the rotation
			else if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
			{
				if (pPed->GetEquippedWeaponInfo() && pPed->GetEquippedWeaponInfo()->GetIsRpg())
				{
					iFlags |= CTaskAimGunFromCoverIntro::CAF_ShortStep;
				}
			}
		}
	}

	taskAssertf(static_cast<CTaskCover*>(GetParent())->IsWeaponClipSetLoaded(), "Weapon clipset wasn't loaded for ped %s, Previous State %s", GetPed()->GetDebugName(), GetStaticStateName(GetState()));

	ProcessCoverSwitchDirection(*pPed, 0.0f, false, false);

	// We use the full body filter until we start blending out of the task network at which point
	// we set the no mover filter to prevent any extra motion from the intro
	SetAimIntroFilter(ms_FullFilter);
	SetNewTask(rage_new CTaskAimGunFromCoverIntro(vTargetPosition, iFlags, m_TaskUseCoverMoveNetworkHelper));
	m_bOutroToReload = false;

#if FPS_MODE_SUPPORTED
	INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, INITIAL_Z_OFFSET_FOR_PEEK_PROBE, -1.0f, 1.0f, 0.01f);
	INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, PEEK_PROBE_LENGTH, 0.0f, 5.0f, 0.01f);
	INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, FINAL_Z_OFFSET_FOR_PEEK_PROBE, -1.0f, 1.0f, 0.01f);
	INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, Z_INCREMENT_BETWEEN_PEEK_PROBES, 0.0f, 1.0f, 0.001f);
	pPed->ComputeLowCoverHeightOffsetFromMover(INITIAL_Z_OFFSET_FOR_PEEK_PROBE, FINAL_Z_OFFSET_FOR_PEEK_PROBE, Z_INCREMENT_BETWEEN_PEEK_PROBES, PEEK_PROBE_LENGTH);
#endif // FPS_MODE_SUPPORTED
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::AimIntro_OnUpdate()
{
#if FPS_MODE_SUPPORTED
	ProcessPelvisOffset();
#endif // FPS_MODE_SUPPORTED

	// Block weapon switching when moving out to aim
	CPed* pPed = GetPed();
	pPed->SetPedResetFlag(CPED_RESET_FLAG_IsAimingFromCover, true);
	pPed->SetPedResetFlag( CPED_RESET_FLAG_ProcessPostCamera, true );

	// Make CStaticMovementScanner do some work whenever we are in this state, to
	// replace a check it used to do to see if this task was running.
	pPed->SetPedResetFlag(CPED_RESET_FLAG_ForceMovementScannerCheck, true);

	if (pPed->IsLocalPlayer() && pPed->GetPlayerInfo() && pPed->GetPlayerInfo()->IsFiring())
	{
		m_bForceFireBullet = true;
	}

	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_TIME_IN_AIM_INTRO_STATE_TO_ABORT, 2.5f, 0.0f, 5.0f, 0.01f);
	if (GetTimeInState() > MAX_TIME_IN_AIM_INTRO_STATE_TO_ABORT)
	{
		NOTFINAL_ONLY(aiWarningf("Ped %s (%p) is aborting cover task abnormally due to being stuck in aim intro state for longer than %.2f seconds, in target state ? %s, previous state %s", 
			pPed->GetModelName(), pPed, MAX_TIME_IN_AIM_INTRO_STATE_TO_ABORT, m_TaskUseCoverMoveNetworkHelper.IsInTargetState() ? "TRUE" : "FALSE", GetStaticStateName(GetPreviousState())));
		SetState(State_Finish);
		return FSM_Continue;
	}

	if (!m_TaskUseCoverMoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	if (GetIsSubtaskFinished(CTaskTypes::TASK_AIM_GUN_FROM_COVER_INTRO))
	{
		pPed->SetIsStrafing(true);
		SetState(State_Aim);
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::AimIntro_OnExit()
{
	// Set the flag back to false since we are leaving the state. It does get
	// reset on each update, but it may be safer to keep it more immediately up
	// to date to preserve existing behavior.
	GetPed()->SetPedResetFlag(CPED_RESET_FLAG_ForceMovementScannerCheck, false);

	ClearCoverFlag(CTaskCover::CF_AimIntroRequested);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Aim_OnEnter()
{
	CPed* pPed = GetPed();
	fwDynamicEntityComponent *dynComp = pPed->GetDynamicComponent();

	if (dynComp)
	{
		dynComp->SetAnimatedAngularVelocity(0.0f);
		dynComp->SetAnimatedVelocity(VEC3_ZERO);
	}	

	m_uReleasedAimControlsTime = 0;
	
	NMovingGround::SetPedAngVelocity(pPed, Vec3V(V_ZERO));
	NMovingGround::SetPedVelocity(pPed, Vec3V(V_ZERO));
	SetNewTask(CreateFireTask());

	// Need to set the timer if blocking weapon fire or they'll never return to cover
	if (pPed->GetPedResetFlag(CPED_RESET_FLAG_BlockWeaponFire))
	{
		const float fMinTimeUntilReturnToIdleFromAim = ms_Tunables.m_MinTimeUntilReturnToIdleFromAimDefault;
		const float fMaxTimeUntilReturnToIdleFromAim = ms_Tunables.m_MaxTimeUntilReturnToIdleFromAimDefault;
		m_fTimeUntilReturnToIdleFromAimedAt = fwRandom::GetRandomNumberInRange(fMinTimeUntilReturnToIdleFromAim, fMaxTimeUntilReturnToIdleFromAim);
	}

	pPed->GetMovePed().ClearTaskNetwork(m_TaskCoverMoveNetworkHelper, ms_Tunables.m_AimIntroTaskBlendOutDuration);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Aim_OnUpdate()
{
	CPed* pPed = GetPed();

#if FPS_MODE_SUPPORTED
	ProcessPelvisOffset();

	if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, POP_HEADING_IN_HIGH_COVER_AIM, true);
		if (POP_HEADING_IN_HIGH_COVER_AIM && IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AimDirectly))
		{
			TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, TIME_BEFORE_POPPING_HEADING, 0.0f, 0.0f, 1.0f, 0.01f);
			if (GetTimeInState() > TIME_BEFORE_POPPING_HEADING)
			{
				GetPed()->SetHeading(GetPed()->GetDesiredHeading());
				m_bNeedToPopHeading = false;
			}
			else
			{
				m_bNeedToPopHeading = true;
			}
		}

		//ProcessCoverSwitchDirection(*GetPed(), 0.2f, true, true);
	}
#endif // FPS_MODE_SUPPORTED

	pPed->SetIsStrafing(true);
	pPed->SetPedResetFlag(CPED_RESET_FLAG_IsAimingFromCover, true);
	pPed->SetPedResetFlag(CPED_RESET_FLAG_ProcessPostCamera, true);

	if (m_iCurrentCoverStepNodeIndex != -1 && m_iCurrentCoverStepNodeIndex != 0)
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_ApplyCoverWeaponBlockingOffsets, true);
	}

	//If we are in cover and cover is not too high then we'll want to use the alternative aim anims
	if(!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AimDirectly) )
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_UseAlternativeWhenBlock, true);
	}

	CTaskMotionAiming* pMotionAimingTask = static_cast<CTaskMotionAiming*>(pPed->GetPedIntelligence()->FindTaskActiveMotionByType(CTaskTypes::TASK_MOTION_AIMING));
	bool bCanDoOutro = true;
	if (m_bWantsToTriggerStep || (pMotionAimingTask && pMotionAimingTask->GetState() == CTaskMotionAiming::State_CoverStep))
	{
		bCanDoOutro = false;
	}

	// Decide if we should come back from aiming because are aiming situation needs to be changed
	bool bShouldDoOutroDueToAimChange = false;
	bool bForceDueToAimDirectly = false;
	bool bShouldAimDirectly = false;
	bool bFirstPersonModeEnabled = false;
	bool bNotAiming = false;

	if (pPed->IsLocalPlayer())
	{
		const bool bWantsToAim = pPed->GetPlayerInfo()->IsAiming(false);
		const bool bIsFiring = pPed->GetPlayerInfo()->IsFiring();
		const bool bWantsToBlindFire = pPed->GetPlayerInfo()->IsFiring() && !bWantsToAim;

		static dev_float fOverlapTolerance = 0.1f;
		bool bShouldComeOutToAimFromBlindFire = false;
		if (bWantsToAim FPS_MODE_SUPPORTED_ONLY(|| pPed->IsFirstPersonShooterModeEnabledForPlayer(false)))
		{
			// If we want to aim then we'll only aim directly if we aren't blocked, otherwise we'll force a stand up
			bShouldAimDirectly = CTaskInCover::ShouldAimDirectly(*pPed, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), m_bForcedBlockAimDirectly, fOverlapTolerance, IsCoverFlagSet(CTaskCover::CF_AimDirectly)) && !m_bForcedBlockAimDirectly;
		}
		else if (bWantsToBlindFire)
		{
			// If we want to blindfire then we need to make sure we only blindfire if we don't want to aim directly, or stand up
			bShouldAimDirectly = CTaskInCover::ShouldAimDirectly(*pPed, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), m_bForcedBlockAimDirectly, fOverlapTolerance, true) && !m_bForcedBlockAimDirectly;
			bShouldComeOutToAimFromBlindFire = bShouldAimDirectly || m_bForcedBlockAimDirectly;
		}

		if (bCanDoOutro)
		{
#if FPS_MODE_SUPPORTED
			// If we want to blind fire and aren't trying to aim and aren't going to be blocked if we need to aim directly, we need to outro
			bFirstPersonModeEnabled = pPed->IsFirstPersonShooterModeEnabledForPlayer(false);
			bForceDueToAimDirectly = ForceAimDueToDirectAimInFPM(bShouldAimDirectly);

			if (bFirstPersonModeEnabled)
			{
				// Prevent aborting primary reload task, as it can be exploited to get a free reload
				if (FindSubTaskOfType(CTaskTypes::TASK_RELOAD_GUN))
				{
					bCanDoOutro = false;
				}

				if (bShouldAimDirectly && !bForceDueToAimDirectly)
				{
					bShouldDoOutroDueToAimChange = true;
				}
				else if (pPed->GetWeaponManager()->GetRequiresWeaponSwitch() && !bShouldAimDirectly && !FindSubTaskOfType(CTaskTypes::TASK_AIM_AND_THROW_PROJECTILE))
				{
					bShouldDoOutroDueToAimChange = true;
				}
			}
			INSTANTIATE_TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DISABLE_AUTO_STEP_AROUND);
#endif // FPS_MODE_SUPPORTED

			const bool bInHighCover = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
			const bool bComeBackInWhenAimDirectChangesInHighCover = ms_Tunables.m_ComeBackInWhenAimDirectChangeInHighCover FPS_MODE_SUPPORTED_ONLY(|| (DISABLE_AUTO_STEP_AROUND && bFirstPersonModeEnabled && !bWantsToAim));
			if (!bForceDueToAimDirectly && !bWantsToAim && bWantsToBlindFire && !bShouldComeOutToAimFromBlindFire)
			{
				bShouldDoOutroDueToAimChange = true;
			}
			else if (!bFirstPersonModeEnabled)
			{
				// If we were aiming directly but can no longer do so, go back to decide again
				if ((!bShouldAimDirectly || m_bForcedBlockAimDirectly) && IsCoverFlagSet(CTaskCover::CF_AimDirectly) && (!bInHighCover || (!bIsFiring && bComeBackInWhenAimDirectChangesInHighCover)))
				{
					bShouldDoOutroDueToAimChange = true;
				}
				else
				{
					// We want to do the outro if we're switching between aiming directly in high cover
					if (bInHighCover && ms_Tunables.m_ComeBackInWhenAimDirectChangeInHighCover)
					{
						if ((!bIsFiring && bShouldAimDirectly && !IsCoverFlagSet(CTaskCover::CF_AimDirectly)))
						{
							bShouldDoOutroDueToAimChange = true;
						}
					}
					// If we stood up to fire, stay stood up to avoid coming back in to aim directly whilst trying to fire at someone
					// We want to do the outro if we're switching between aiming directly in low cover and we aren't going to be blocked if we do so
					else if (!m_bStoodUpToFire)
					{
						if ((!bIsFiring && bShouldAimDirectly && !IsCoverFlagSet(CTaskCover::CF_AimDirectly) && !m_bForcedBlockAimDirectly))
						{
							bShouldDoOutroDueToAimChange = true;
						}
					}
				}
			}
		}

		if (ms_Tunables.m_UseAutoPeekAimFromCoverControls)
		{
			bNotAiming = !bForceDueToAimDirectly && !pPed->GetPlayerInfo()->IsAiming(false) && !pPed->GetPlayerInfo()->IsFiring();
		}
		else
		{	
			bNotAiming = !bForceDueToAimDirectly && !pPed->GetPlayerInfo()->IsFiring();
		}

		//! DMKH. Do a small timeout before returning to cover.
		if(bCanDoOutro && 
			bNotAiming && 
			!bShouldDoOutroDueToAimChange && 
			!pPed->GetPedIntelligence()->GetFiringPattern().HasBurstFinishedThisFrame())
		{
			if(m_uReleasedAimControlsTime == 0)
			{
				m_uReleasedAimControlsTime = fwTimer::GetTimeInMilliseconds();
			}
			u32 uAimOutroDelay = ms_Tunables.m_AimOutroDelayTime;
#if FPS_MODE_SUPPORTED
			if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
			{
				if (!ms_Tunables.m_EnableAimOutroDelay)
				{
					if (pPed->GetMotionData()->GetIsFPSScope())
					{
						uAimOutroDelay = ms_Tunables.m_AimOutroDelayTimeFPSScope;
					}
				}
				else
				{
					if (!ms_Tunables.m_AimOutroDelayWhenPeekingOnly || CheckForPeeking())
					{
						uAimOutroDelay = pPed->GetMotionData()->GetIsFPSScope() ? ms_Tunables.m_AimOutroDelayTimeFPSScope : ms_Tunables.m_AimOutroDelayTimeFPS;
					}
				}
			}
#endif // FPS_MODE_SUPPORTED

			if(fwTimer::GetTimeInMilliseconds() >= (m_uReleasedAimControlsTime + uAimOutroDelay) )
			{
				bCanDoOutro = true;
			}
			else
			{
				bCanDoOutro = false;
			}
		}
		else
		{
			m_uReleasedAimControlsTime = 0;
		}
	}

	bool bArmedMelee = pPed->GetWeaponManager() && pPed->GetWeaponManager()->GetIsArmedMelee();
	bool bBurstFinished = !bArmedMelee && pPed->GetPedIntelligence()->GetFiringPattern().HasBurstFinishedThisFrame();
	TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DONT_DO_OUTRO_DUE_TO_BURST_FINISHED, true);
	if (DONT_DO_OUTRO_DUE_TO_BURST_FINISHED && bFirstPersonModeEnabled)
	{
		bBurstFinished = false;
	}

	if (CheckForExit())
	{
		SetState(State_Finish);
		return FSM_Continue;
	}
	else if ((!bForceDueToAimDirectly && bBurstFinished && !pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ThrowingGrenadeWhileAiming)) ||
		bNotAiming || GetIsSubtaskFinished(CTaskTypes::TASK_GUN) || bShouldDoOutroDueToAimChange)
	{
		if(!m_bReactToFire)
		{
			m_bOutroToReload = CheckForReload() ? true : false;
		}

		if (!m_bOutroToReload)
		{
			if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_GUN)
			{
#if FPS_MODE_SUPPORTED
				if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
				{
					 if (GetSubTask()->GetState() != CTaskGun::State_Reload)
					 {
						m_bOutroToReload = static_cast<CTaskGun*>(GetSubTask())->GetWantsToReload();
					 }
				}
				else
#endif // FPS_MODE_SUPPORTED
				{
					m_bOutroToReload = static_cast<CTaskGun*>(GetSubTask())->GetWantsToReload();
				}
			}
		}

		if (NetworkInterface::IsGameInProgress())
		{
			if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
			{
				// See if there are nearby peds with a certain distance from the cover point
				Vector3 vPos;
				pPed->GetCoverPoint()->GetCoverPointPosition(vPos);
				Vector3 vPedCoverPos(vPos.x, vPos.y, vPos.z + 1.0f); // Add one to z height as cover position is on the ground
				if (CTaskEnterCover::GetPedBlockingMyCover(*pPed, vPedCoverPos, true))
				{
					SetState(State_Finish);
					return FSM_Continue;
				}
			}
		}

		if (bCanDoOutro)
		{
			aiDebugf1("OUTRO 1 : m_iCurrentCoverStepNodeIndex : %i", m_iCurrentCoverStepNodeIndex);
			
#if __BANK
			if (pPed->IsAPlayerPed())
			{
				const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfoFromObject() ? pPed->GetWeaponManager()->GetEquippedWeaponInfoFromObject() : pPed->GetWeaponManager()->GetEquippedWeaponInfo();
				const fwMvClipSetId coverWeaponClipSetId = pWeaponInfo ? pWeaponInfo->GetPedCoverWeaponClipSetId(*pPed) : CLIP_SET_ID_INVALID;
				if (!CTaskCover::IsCoverClipSetLoaded(coverWeaponClipSetId))
				{
					AI_LOG_WITH_ARGS("[Cover] - Weapon clipset %s isn't loaded for ped %s before transition to aim outro, weapon info %s", coverWeaponClipSetId.GetCStr(), AILogging::GetDynamicEntityNameSafe(pPed), pWeaponInfo ? pWeaponInfo->GetName() : "NULL");
				}
			}
#endif // __BANK
			SetState(State_AimOutro);
			return FSM_Continue;
		}
	}
	else if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_GUN)
	{
		//Check if the time until return to idle is valid.
		bool bShouldReturnToIdle = pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForcedToStayInCover) || pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForcedToStayInCoverDueToPlayerSwitch);
		if(m_fTimeUntilReturnToIdleFromAimedAt > 0.0f)
		{
			//Decrease the time.
			m_fTimeUntilReturnToIdleFromAimedAt -= GetTimeStep();
			if(m_fTimeUntilReturnToIdleFromAimedAt <= 0.0f)
			{
				bShouldReturnToIdle = true;
			}
		}
				
		if ( bShouldReturnToIdle ||
			 IsCoverFlagSet(CTaskCover::CF_ShouldReturnToIdle))
		{			
			if (bCanDoOutro)
			{
				m_bReactToFire = !pPed->IsPlayer();
				aiDebugf1("OUTRO 2 : m_iCurrentCoverStepNodeIndex : %i", m_iCurrentCoverStepNodeIndex);
#if __BANK
				if (pPed->IsAPlayerPed())
				{
					const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfoFromObject() ? pPed->GetWeaponManager()->GetEquippedWeaponInfoFromObject() : pPed->GetWeaponManager()->GetEquippedWeaponInfo();
					const fwMvClipSetId coverWeaponClipSetId = pWeaponInfo ? pWeaponInfo->GetPedCoverWeaponClipSetId(*pPed) : CLIP_SET_ID_INVALID;
					if (!CTaskCover::IsCoverClipSetLoaded(coverWeaponClipSetId))
					{
						AI_LOG_WITH_ARGS("[Cover] - Weapon clipset %s isn't loaded for ped %s before transition to aim outro, weapon info %s", coverWeaponClipSetId.GetCStr(), AILogging::GetDynamicEntityNameSafe(pPed), pWeaponInfo->GetName());
					}
				}
#endif // __BANK
				SetState(State_AimOutro);
				return FSM_Continue;
			}
		}

		//Update forcing fire from camera, only force this for 25 degrees to the side of the cover.
		TUNE_GROUP_BOOL(COVER_TUNE, RESTRICT_FORCE_FIRING_FOR_ANGLE, false);
		if(RESTRICT_FORCE_FIRING_FOR_ANGLE && pPed->IsLocalPlayer() && pPed->GetCoverPoint())
		{
			CTaskAimGun* pAimGunTask = static_cast<CTaskAimGun*>(GetSubTask()->GetSubTask());

			if(pAimGunTask && pAimGunTask->GetTaskType() == CTaskTypes::TASK_AIM_GUN_ON_FOOT)
			{
				TUNE_GROUP_FLOAT(COVER_TUNE, HALF_FORCE_FIRE_ANGLE, 25.0f, 0.0f, 180.0f, 0.1f);
				float fHalfForceFireFromCameraAngle = HALF_FORCE_FIRE_ANGLE;
				if(!IsCoverFlagSet(CTaskCover::CF_FacingLeft))
					fHalfForceFireFromCameraAngle = -fHalfForceFireFromCameraAngle;

				Vector3 vCoverDirection = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector());
				vCoverDirection.RotateZ( (fHalfForceFireFromCameraAngle) * DtoR);
				const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
				Vector3 vCamFront = aimCameraFrame.GetFront();
				vCamFront.z = 0.0f;
				vCamFront.Normalize();
				const float fDot = vCoverDirection.Dot( vCamFront );

				if(fDot > 1 - ((Abs(fHalfForceFireFromCameraAngle)/2) * DtoR))
				{
					pAimGunTask->GetGunFireFlags().SetFlag( GFF_ForceFireFromCamera );
				}
				else
				{
					pAimGunTask->GetGunFireFlags().ClearFlag( GFF_ForceFireFromCamera );
				}
			}
		}
	}
	else if(IsCoverFlagSet(CTaskCover::CF_CoverFire))
	{
		//A cover fire request has come in, respond to it.
		SetFlag(aiTaskFlags::RestartCurrentState);
		return FSM_Continue;
	}

	ProcessCoverStep(pMotionAimingTask, pPed);

	ActivateTimeslicing();

#if FPS_MODE_SUPPORTED
	if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_GUN)
		{
			bool bTooHigh = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
			CTaskGun* pGunTask = static_cast<CTaskGun*>(GetSubTask());
			CTaskAimGun* pAimGunTask = (pGunTask->GetSubTask() && pGunTask->GetSubTask()->GetTaskType() == CTaskTypes::TASK_AIM_GUN_ON_FOOT) ? static_cast<CTaskAimGun*>(pGunTask->GetSubTask()) : NULL;
			if (bShouldAimDirectly)
			{
				pGunTask->GetGunFlags().ClearFlag( GF_DisableReload );

				if (pAimGunTask)
				{
					pAimGunTask->GetGunFlags().ClearFlag( GF_DisableReload );
				}

				SetCoverFlag(CTaskCover::CF_AimDirectly);
				m_bStoodUpToFire = false;
			}
			else
			{
				pGunTask->GetGunFlags().SetFlag( GF_DisableReload );

				if (pAimGunTask)
				{
					pAimGunTask->GetGunFlags().SetFlag( GF_DisableReload );
				}

				ClearCoverFlag(CTaskCover::CF_AimDirectly);

				if (!pPed->GetMotionData()->GetIsFPSIdle())
				{
					m_bStoodUpToFire = true;
				}
			}

			if (!bTooHigh && IsCoverFlagSet(CTaskCover::CF_AimDirectly))
			{
				pPed->SetIsCrouching(true, -1, false, true);
			}
			else if (m_bStoodUpToFire)
			{
				pPed->SetIsCrouching(false);
			}
		}
	}
#endif // FPS_MODE_SUPPORTED

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Aim_OnUpdateClone()
{
	CPed* pPed = GetPed();
	pPed->SetIsStrafing(true);
	pPed->SetPedResetFlag(CPED_RESET_FLAG_IsAimingFromCover, true);

	// wait for the queriable state for the gun task before creating it
	if (!GetSubTask() || GetSubTask()->GetTaskType() != CTaskTypes::TASK_GUN)
	{
		if (pPed->GetPedIntelligence()->GetQueriableInterface()->GetTaskInfoForTaskType(CTaskTypes::TASK_GUN, PED_TASK_PRIORITY_MAX, false))
		{
			SetNewTask(CreateFireTask());
		}
	}

	CTaskMotionAiming* pAiming = static_cast<CTaskMotionAiming*>(pPed->GetPedIntelligence()->FindTaskActiveMotionByType(CTaskTypes::TASK_MOTION_AIMING));
	if (pAiming && pAiming->GetState() > CTaskMotionAiming::State_Initial)
	{
		TUNE_FLOAT(CLEAR_COVER_NETWORK_DURATION, REALLY_SLOW_BLEND_DURATION, 0.0f, 2.0f, 0.01f);
		GetPed()->GetMovePed().ClearTaskNetwork(m_TaskCoverMoveNetworkHelper, CLEAR_COVER_NETWORK_DURATION);
	}

	// update target from the gun task
	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_GUN)
	{
		CTaskGun* pGunTask = static_cast<CTaskGun*>(GetSubTask());

		if (pGunTask->GetTarget().GetEntity())
		{
			GetTarget().SetEntity(pGunTask->GetTarget().GetEntity());
		}
		else if (pGunTask->GetTarget().GetIsValid())
		{
			Vector3 targetPos;
			pGunTask->GetTarget().GetPosition(targetPos);
			GetTarget().SetPosition(targetPos);
		}
	}
	if (GetStateFromNetwork() != State_AimIntro && GetStateFromNetwork() != State_Aim)
	{
#if __BANK
		if (pPed->IsAPlayerPed())
		{
			const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfoFromObject() ? pPed->GetWeaponManager()->GetEquippedWeaponInfoFromObject() : pPed->GetWeaponManager()->GetEquippedWeaponInfo();
			const fwMvClipSetId coverWeaponClipSetId = pWeaponInfo ? pWeaponInfo->GetPedCoverWeaponClipSetId(*pPed) : CLIP_SET_ID_INVALID;
			if (!CTaskCover::IsCoverClipSetLoaded(coverWeaponClipSetId))
			{
				AI_LOG_WITH_ARGS("[Cover] - Weapon clipset %s isn't loaded for ped %s before transition to aim outro, weapon info %s", coverWeaponClipSetId.GetCStr(), AILogging::GetDynamicEntityNameSafe(pPed), pWeaponInfo->GetName());
			}
		}
#endif // __BANK
		SetState(State_AimOutro);
	}

	// we can timeslice this ped if the state hasn't changed
	if(GetState() == State_Aim)
	{
		ActivateTimeslicing();
	}

	ProcessCoverStep(pAiming, pPed);

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Aim_OnExit()
{
	m_bForceFireBullet = false;

#if FPS_MODE_SUPPORTED
	const CPed& rPed = *GetPed();
	if (rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		m_WasScopedDuringAim = rPed.GetMotionData()->GetWasFPSScope();
	}
#endif // FPS_MODE_SUPPORTED

	ClearCoverFlag(CTaskCover::CF_ShouldReturnToIdle);

	if (m_TaskCoverMoveNetworkHelper.IsNetworkActive())
	{
		m_TaskCoverMoveNetworkHelper.ReleaseNetworkPlayer();
	}

	if (!GetIsFlagSet(aiTaskFlags::InMakeAbortable))
	{
		TUNE_GROUP_FLOAT(COVER_INTRO_DEBUG, CUSTOM_BLEND_DURATION, 0.1f, 0.0f, 0.5f, 0.01f);
		static_cast<CTaskCover*>(GetParent())->StartCoverNetwork(false, false, true, true, CUSTOM_BLEND_DURATION);
		AI_LOG_WITH_ARGS("[%s][TaskStateChange] - %s Ped %s is starting cover task move network in aim exit\n", GetTaskName(), AILogging::GetDynamicEntityIsCloneStringSafe(GetPed()), AILogging::GetDynamicEntityNameSafe(GetPed()));
	}

	//Clear the time until return to idle from aim.
	m_fTimeUntilReturnToIdleFromAimedAt = -1.0f;

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return  CTaskInCover::AimOutro_OnEnter()
{
	bool bFindCoverEdge = false;

	CPed& ped = *GetPed();

	if (ped.IsNetworkClone() && !m_TaskUseCoverMoveNetworkHelper.IsNetworkActive())
	{
		static_cast<CTaskCover*>(GetParent())->StartCoverNetwork(false, false, true, true);
		AI_LOG_WITH_ARGS("[%s][TaskStateChange] - %s Ped %s is starting cover task move network in aim outro since use cover network not active\n", GetTaskName(), AILogging::GetDynamicEntityIsCloneStringSafe(GetPed()), AILogging::GetDynamicEntityNameSafe(GetPed()));
	}

	if (ped.IsLocalPlayer() && ped.GetPlayerInfo() && ped.GetCoverPoint())
	{
#if FPS_MODE_SUPPORTED
		bool bIsFPSMode = ped.IsFirstPersonShooterModeEnabledForPlayer(false);
		if (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations && bIsFPSMode)
		{
			m_TaskUseCoverMoveNetworkHelper.SetFlag(true, CTaskMotionInCover::ms_IsFirstPersonFlagId);
		}
#endif // FPS_MODE_SUPPORTED

		TUNE_GROUP_BOOL(COVER_AIM_TUNE, RECALCULATE_FACING_DIRECTION, true);
		if (RECALCULATE_FACING_DIRECTION)
		{
			// Compute if we need to change facing direction
			Vector3 vCoverDirection = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector());
			const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
			Vector3 vCamFront = aimCameraFrame.GetFront();
			vCamFront.z = 0.0f;
			vCamFront.Normalize();

			const float fDirDotCam = vCoverDirection.Dot(vCamFront);
			aiDebugf2("Dir Dot Cam: %.4f", fDirDotCam);

			TUNE_GROUP_FLOAT(COVER_AIM_TUNE, COSANGLE_CHANGE_DIR_TOLERANCE, 0.45f, -1.0f, 1.0f, 0.01f);
			float fChangeDirTolerance = COSANGLE_CHANGE_DIR_TOLERANCE;
#if FPS_MODE_SUPPORTED
			TUNE_GROUP_FLOAT(COVER_AIM_TUNE, COSANGLE_CHANGE_DIR_TOLERANCE_LOW_COVER_FIRST_PERSON, 0.99f, -1.0f, 1.0f, 0.01f);
			if (bIsFPSMode && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
			{
				fChangeDirTolerance = COSANGLE_CHANGE_DIR_TOLERANCE_LOW_COVER_FIRST_PERSON;
			}
#endif
			if (fDirDotCam <= fChangeDirTolerance)
			{
				static float fScalar = 1.0f;
				const float fDirCrossCam = fScalar * vCoverDirection.CrossZ(vCamFront);
				aiDebugf2("Dir Cross Cam : %.4f",  fDirCrossCam);
				if (IsFacingLeft() && fDirCrossCam <= 0.0f)
				{
					ClearCoverFlag(CTaskCover::CF_FacingLeft);
				}
				else if (!IsFacingLeft() && fDirCrossCam > 0.0f)
				{
					SetCoverFlag(CTaskCover::CF_FacingLeft);
				}
			}
		}

		if (ped.GetPlayerInfo()->IsCoverGeneratedByDynamicEntity() && ped.GetCoverPoint())
		{
			Vector3 vCoverPosition(Vector3::ZeroType);
			if (ped.GetCoverPoint()->GetCoverPointPosition(vCoverPosition))
			{
				Vector3 vLastKnownCoverPosition = ped.GetPlayerInfo()->GetDynamicCoverPointLastKnownPosition();
				TUNE_GROUP_FLOAT(COVER_AIM_TUNE, MIN_COVER_DIST_CHANGED_TO_FIND_COVER_EDGE, 0.1f, 0.0f, 1.0f, 0.01f);
				if (vLastKnownCoverPosition.Dist2(vCoverPosition) > rage::square(MIN_COVER_DIST_CHANGED_TO_FIND_COVER_EDGE))
				{
					bFindCoverEdge = true;
				}
			}
		}
	}

	if (bFindCoverEdge)
	{
		// Maybe don't need to do this?
		FindCoverEdgeAndUpdateCoverPosition();
	}

	Vector3 vTargetPosition(VEC3_ZERO);

	// the target can sometimes not be valid for clones. This is rare and it happens when we don't get a chance to grab the target in Aim_OnUpdateClone 
	// (ie the information did not arrive in an update)
	if (GetTarget().GetIsValid())
	{
		GetTarget().GetPosition(vTargetPosition);
	}

	// Send the request to transition to the reload state in the main network
	m_TaskUseCoverMoveNetworkHelper.SendRequest(ms_AimOutroRequestId);
	m_TaskUseCoverMoveNetworkHelper.WaitForTargetState(ms_AimOutroOnEnterId);

	u32 iFlags = m_bReactToFire ? CTaskAimGunFromCoverOutro::CAF_ReactToFire : 0;

	const bool bIsHighCover = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
	if (ped.IsAPlayerPed() && (!m_bStoodUpToFire || bIsHighCover))
	{
		if (!m_bStoodUpToFire && !bIsHighCover)
		{
			iFlags |= CTaskAimGunFromCoverOutro::CAF_NoStep;
		}
		else
		{
			aiDebugf1("m_iCurrentCoverStepNodeIndex : %i", m_iCurrentCoverStepNodeIndex); 
			const bool bInHighCoverNotAtEdge = (!IsCoverFlagSet(CTaskCover::CF_AtCorner) && IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint)) || m_bForcedStepBack;
			if (m_iCurrentCoverStepNodeIndex == 2 || (bInHighCoverNotAtEdge && m_iCurrentCoverStepNodeIndex != 0))
			{
				iFlags |= CTaskAimGunFromCoverOutro::CAF_LongStep;
			}
			else if (m_iCurrentCoverStepNodeIndex == 1)
			{
				iFlags |= CTaskAimGunFromCoverOutro::CAF_ShortStep;
			}
			else
			{
				iFlags |= CTaskAimGunFromCoverOutro::CAF_NoStep;
			}
		}
	}
	else
	{
		iFlags |= CTaskAimGunFromCoverOutro::CAF_ShortStep;
	}

	bool bToPeek = false;

#if FPS_MODE_SUPPORTED
	bToPeek = ped.IsFirstPersonShooterModeEnabledForPlayer(false) && CheckForPeeking() && CTaskMotionInCover::ms_Tunables.m_EnableAimOutroToPeekAnims;
	if (bToPeek)
	{
		iFlags |= CTaskAimGunFromCoverOutro::CAF_ToPeek;
	}
#endif // FPS_MODE_SUPPORTED

	m_TaskUseCoverMoveNetworkHelper.SetFloat(ms_AimOutroRateId, CalculateRateForAimOutro(bToPeek));

	SetNewTask(rage_new CTaskAimGunFromCoverOutro(vTargetPosition, iFlags, m_TaskUseCoverMoveNetworkHelper));

	m_bWantsToExit = false;
	m_bReactToFire = false;
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::AimOutro_OnUpdate()
{
	CPed* pPed = GetPed();

	if (pPed->IsLocalPlayer())
	{

#if FPS_MODE_SUPPORTED
		ProcessPelvisOffset();
#endif // FPS_MODE_SUPPORTED

		if (CheckForExit())
		{
			m_bWantsToExit = true;
		}
		else if (CheckForReload(true))
		{
			m_bOutroToReload = true;
		}

		if (m_bOutroToReload && !m_bLetGoOfAimAfterStartingReload)
		{
			m_bLetGoOfAimAfterStartingReload = !pPed->GetPlayerInfo()->IsAiming(false);
		}
	}

	// Block weapon switching when moving back from aiming
	pPed->SetPedResetFlag(CPED_RESET_FLAG_IsDoingCoverAimOutro, true);

	// Make CStaticMovementScanner do some work whenever we are in this state, to
	// replace a check it used to do to see if this task was running.
	pPed->SetPedResetFlag(CPED_RESET_FLAG_ForceMovementScannerCheck, true);

	if (!m_TaskUseCoverMoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	if (pPed->IsLocalPlayer())
	{
		if (m_TaskUseCoverMoveNetworkHelper.GetBoolean(CTaskAimGunFromCoverOutro::ms_OutroAimInterruptId))
		{

			ProcessReloadSecondaryTask();
			ProcessWeaponSwapSecondaryTask();

			if (m_bWantsToExit)
			{
				SetState(State_Finish);
				return FSM_Continue;
			}
		}
	}

	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished) || !GetSubTask())
	{
		m_TaskUseCoverMoveNetworkHelper.SetClipSet(CTaskCover::GetWeaponHoldingClipSetForArmament(pPed));

		NMovingGround::SetPedVelocity(pPed, Vec3V(V_ZERO));

		s32 iNewState;
		if (pPed->IsLocalPlayer() && !m_bOutroToReload && CheckForMovingOutToFire(iNewState) && iNewState == State_AimIntro)
		{
			SetState(State_AimIntro);
			return FSM_Continue;
		}
#if FPS_MODE_SUPPORTED
		else if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && CheckForPeeking() && CTaskMotionInCover::ms_Tunables.m_EnableAimOutroToPeekAnims)
		{
			SetState(State_Peeking);
			return FSM_Continue;
		}
#endif // FPS_MODE_SUPPORTED
		else if (CheckForReload() || CheckForSwitchingWeapon() )
		{
			SetState(State_Idle);	// Need to go back to idle to restart the motion network
			return FSM_Continue;
		}
		else if (!ms_Tunables.m_UseAutoPeekAimFromCoverControls && CheckForPeeking())
		{
			SetState(State_Peeking);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else
		{
			SetState(State_Idle);
			return FSM_Continue;
		}
	}

	ActivateTimeslicing();
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::AimOutro_OnExit()
{
	CPed& ped = *GetPed();

	// No longer crouching, done in exit to prevent strafe clipset from changing underneath us
	ped.SetIsCrouching(false, -1, false);

	CWeapon* pWeapon = ped.GetWeaponManager()->GetEquippedWeapon();
	// Force a weapon switch if out of ammo
	if (!m_bAimWithoutAmmo && pWeapon && !pWeapon->GetWeaponInfo()->GetIsMelee() && !pWeapon->GetWeaponInfo()->GetDontSwapWeaponIfNoAmmo() && pWeapon->GetAmmoTotal() == 0 && pWeapon->GetAmmoInClip() <= 0)
	{
		ped.GetWeaponManager()->EquipBestWeapon();
	}

	m_iCurrentCoverStepNodeIndex = -1;

	// Set the flag back to false since we are leaving the state. It does get
	// reset on each update, but it may be safer to keep it more immediately up
	// to date to preserve existing behavior.
	ped.SetPedResetFlag(CPED_RESET_FLAG_ForceMovementScannerCheck, false);

#if FPS_MODE_SUPPORTED
	if (!CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonLocoAnimations)
	{
		m_TaskUseCoverMoveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_IsFirstPersonFlagId);
	}
#endif // FPS_MODE_SUPPORTED

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ThrowingProjectile_OnEnter()
{
	CPed* pPed = GetPed();

	pPed->GetMovePed().ClearTaskNetwork(m_TaskCoverMoveNetworkHelper, REALLY_SLOW_BLEND_DURATION);

	if(!pPed->IsNetworkClone())
	{
		fwMvClipSetId clipSetId = CLIP_SET_ID_INVALID;
		fwMvClipId introClipId	= CLIP_ID_INVALID;
		fwMvClipId baseClipId	= CLIP_ID_INVALID;
		fwMvClipId throwLongClipId	= CLIP_ID_INVALID;
		fwMvClipId throwLongFaceCoverClipId	= CLIP_ID_INVALID;
		fwMvClipId throwShortClipId	= CLIP_ID_INVALID;
		fwMvClipId throwShortFaceCoverClipId	= CLIP_ID_INVALID;

		if (GetThrownProjectileClipSetAndClipIds(pPed, this, clipSetId, introClipId, baseClipId, throwLongClipId, throwShortClipId, throwLongFaceCoverClipId, throwShortFaceCoverClipId, false))
		{
			if( !pPed->IsLocalPlayer() && m_bSmokeGrenadeThrowRequested )
			{
				// Find parent combat task, if any
				CTaskCombat* pParentCombatTask = static_cast<CTaskCombat*>(pPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_COMBAT));
				if( pParentCombatTask )
				{
					// notify that we are throwing as requested
					pParentCombatTask->ReportSmokeGrenadeThrown();
				}
			}

			ClearCoverFlag(CTaskCover::CF_ReleasedFireToThrow);

			// grenade pin sounds
			if( pPed->GetWeaponManager()->GetEquippedWeaponHash() == WEAPONTYPE_GRENADE )
				pPed->GetPedAudioEntity()->HandleAnimEventFlag("GRENADE_PULL_PIN");

			CTaskThrowProjectile* pTask = rage_new CTaskThrowProjectile(GetTarget(), false, CLIP_SET_ID_INVALID);
			pTask->SetClipSetId(clipSetId);
			pTask->SetClipIds(introClipId, baseClipId, throwLongClipId, throwShortClipId, throwLongFaceCoverClipId, throwShortFaceCoverClipId);
			//load turns
			s32 iFlags = 0;//CTaskCover::AF_FaceLeft;
			iFlags |= CTaskCover::AF_Low;
			const CTaskCover::CoverAnimStateInfo* pAnimStateInfo = CTaskCover::GetAnimStateInfoForState(CTaskMotionInCover::ms_Tunables.GetTurnEnterAnimStateInfoForPed(*pPed), iFlags);			
			const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();
			const fwMvClipSetId coreMotionClipSetId = (pPed->IsPlayer() || !pWeaponInfo || pWeaponInfo->GetIsUnarmed()) ? CTaskMotionInCover::ms_Tunables.GetCoreMotionClipSetIdForPed(*pPed) : CTaskMotionInCover::ms_Tunables.m_CoreAIMotionClipSetId;
			const crClip* pLeftTurnClip = fwClipSetManager::GetClip(coreMotionClipSetId, pAnimStateInfo->m_Clips[0]);
			iFlags |= CTaskCover::AF_FaceLeft;
			pAnimStateInfo = CTaskCover::GetAnimStateInfoForState(CTaskMotionInCover::ms_Tunables.GetTurnEnterAnimStateInfoForPed(*pPed), iFlags);
			const crClip* pRightTurnClip = fwClipSetManager::GetClip(coreMotionClipSetId, pAnimStateInfo->m_Clips[0]);
			pTask->SetTurnClips(pLeftTurnClip, pRightTurnClip);
			
			SetNewTask(pTask);
		}
	}
	else // network clone
	{
		// grenade pin sounds
		if( pPed->GetWeaponManager()->GetEquippedWeaponHash() == WEAPONTYPE_GRENADE )
			pPed->GetPedAudioEntity()->HandleAnimEventFlag("GRENADE_PULL_PIN");

		CTask* pTask = pPed->GetPedIntelligence()->CreateCloneTaskForTaskType(CTaskTypes::TASK_THROW_PROJECTILE);
		if(pTask)
			SetNewTask(pTask);
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::ThrowingProjectile_OnUpdate()
{
	CPed* pPed = GetPed();

	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);	

	// subtask is finished
	if ( !GetSubTask() || GetIsFlagSet(aiTaskFlags::SubTaskFinished) )
	{
		SetState(State_Idle);
		return FSM_Continue;
	}
	else if (pPed->IsLocalPlayer())
	{
		weaponAssert(pPed->GetWeaponManager());
		pPed->SetPedResetFlag( CPED_RESET_FLAG_TemporarilyBlockWeaponSwitching, true );
		CTaskThrowProjectile* pThrowTask = static_cast<CTaskThrowProjectile*>(FindSubTaskOfType(CTaskTypes::TASK_THROW_PROJECTILE));
		if (pThrowTask)
		{
			if (pThrowTask->GetClipHelper())
			{
				if (!pPed->GetPlayerInfo()->IsFiring() || IsCoverFlagSet(CTaskCover::CF_ReleasedFireToThrow))
					SetCoverFlag(CTaskCover::CF_ReleasedFireToThrow);
				else
					ClearCoverFlag(CTaskCover::CF_ReleasedFireToThrow);
			}

#if FPS_MODE_SUPPORTED
			TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MIN_TIME_IN_THROW_STATE_TO_ALLOW_DIRECT_PEEK, 0.275f, 0.0f, 3.0f, 0.01f);
			if (CTaskMotionInCover::ms_Tunables.m_EnableBlindFireToPeek && pThrowTask->GetState() == CTaskThrowProjectile::State_ThrowProjectile 
			&& pThrowTask->GetTimeInState() > MIN_TIME_IN_THROW_STATE_TO_ALLOW_DIRECT_PEEK && pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
			{
				if (CheckForPeeking())
				{
					// To prevent loco from blending in a frame, which triggers the sprint breakout, which pops the camera heading
					pPed->ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);
					SetState(State_Peeking);
					return FSM_Continue;
				}
			}
#endif // FPS_MODE_SUPPORTED
		}
		CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();
		bool bExplodeGrenadeInHand = CThrowProjectileHelper::HasHeldProjectileTooLong(pPed, GetTimeInState()) && !FindSubTaskOfType(CTaskTypes::TASK_SWAP_WEAPON) && !pThrowTask;

		if( bExplodeGrenadeInHand )
		{
			const s32 nBoneIndex = pPed->GetBoneIndexFromBoneTag(BONETAG_R_HAND);

			Matrix34 weaponMat;
			pPed->GetGlobalMtx(nBoneIndex, weaponMat);
			 
			// 'Throw' the projectile
			CWeapon::sFireParams params(pPed, weaponMat, &weaponMat.d, &weaponMat.d);
			params.fOverrideLifeTime = 0.f;
			if(pWeapon->Fire(params))
			{
				pPed->GetWeaponManager()->DestroyEquippedWeaponObject();
			}

			SetState(State_Idle);
			return FSM_Continue;
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::ThrowingProjectile_OnUpdateClone()
{
	//Very important to also check !GetSubTask otherwise can end up in infinitely in this OnUpdateClone - lavalley.
	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished) || !GetSubTask())
	{
		SetNextStateFromNetwork();
	}
	
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ThrowingProjectile_OnExit()
{
	CPed* pPed = GetPed();

	u32 uWeaponHash = pPed->GetWeaponManager()->GetEquippedWeaponHash();
	bool bIsWeaponOutOfAmmo = pPed->GetInventory()->GetIsWeaponOutOfAmmo(uWeaponHash);
	if(!bIsWeaponOutOfAmmo && !pPed->IsLocalPlayer() && m_bSmokeGrenadeThrowRequested)
	{
		// @TODO: Why is smoke grenade not out of ammo?
		bIsWeaponOutOfAmmo = true;
	}
	if ( bIsWeaponOutOfAmmo  )
	{
        const CWeaponInfo* pWeaponInfo = CWeaponInfoManager::GetInfo<CWeaponInfo>(uWeaponHash);
        Assert(pWeaponInfo);

		if (pWeaponInfo->GetIsThrownWeapon())
		{
			pPed->GetInventory()->RemoveWeapon(uWeaponHash);
		}
		pPed->GetWeaponManager()->EquipBestWeapon(true);

		m_bSmokeGrenadeThrowRequested = false;
		m_bSmokeGrenadeThrowInProgress = false;
	}

	if (!pPed->GetUsingRagdoll())
		static_cast<CTaskCover*>(GetParent())->StartCoverNetwork(false);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::Reloading_OnEnter()
{
	s32 iReloadFlags = RELOAD_IDLE | RELOAD_SECONDARY | RELOAD_COVER;
	SetNewTask(rage_new CTaskReloadGun(CWeaponController::WCT_Reload, iReloadFlags));

	m_ShouldReloadWeaponDelay = 0; //ensure this is reset on reload
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Reloading_OnUpdate()
{
	// Need to set this here as the motion in cover subtask gets destroyed
	m_TaskMotionInCoverMoveNetworkHelper.SetFloat(CTaskMotionInCover::ms_HeightId, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) ? 1.0f : 0.0f);

	CPed* pPed = GetPed();
	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished) || IsCoverFlagSet(CTaskCover::CF_AimIntroRequested) || (CTaskMotionInCover::CheckForPinnedAndGetClipSet(*pPed, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint)) != CLIP_SET_ID_INVALID))
	{
		SetState(State_Idle);
		return FSM_Continue;
	}
	
	if (CheckForExit())
	{
		SetState(State_Finish);
	}

	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::Reloading_OnUpdateClone()
{
	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished) || !GetSubTask())
	{
		SetNextStateFromNetwork();
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::Reloading_OnExit()
{
	m_TaskCoverMoveNetworkHelper.SendRequest(CTaskCover::ms_NoTaskRequestId);
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::SwapWeapon_OnEnter()
{
	s32 iFlags = SWAP_HOLSTER|SWAP_ABORT_SET_DRAWN|SWAP_DRAW|SWAP_SECONDARY;

// 	if(NetworkInterface::IsGameInProgress())
// 	{
// 		iFlags = SWAP_INSTANTLY;
// 	}

	// Setup the cover swap weapon subnetwork to be inserted when the main network enters the intro state
	CTaskSwapWeapon* pSwapWeaponTask = rage_new CTaskSwapWeapon(iFlags);
	static_cast<CTaskCover*>(GetParent())->RestartUseCoverNetwork(GetPed());

	// Send the request to transition to the swap weapon state in the main network
	m_TaskUseCoverMoveNetworkHelper.WaitForTargetState(ms_WeaponSwapOnEnterId);
	m_TaskUseCoverMoveNetworkHelper.SendRequest(ms_SwapWeaponRequestId);

	SetNewTask(pSwapWeaponTask);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::SwapWeapon_OnUpdate()
{
	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);	

	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished))
	{
		CheckForBlockedBlindFire();
		SetState(State_Idle);
		return FSM_Continue;
	}

	CPed* pPed = GetPed();

	if (pPed->IsLocalPlayer() && pPed->GetInventory())
		pPed->GetInventory()->Process();


	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::SwapWeapon_OnUpdateClone()
{
	//Very important to also check !GetSubTask otherwise can end up in infinitely in this OnUpdateClone - lavalley.
	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished) || !GetSubTask())
	{
		SetNextStateFromNetwork();
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::SwapWeapon_OnExit()
{
	m_TaskCoverMoveNetworkHelper.SetFloat(CTaskCover::ms_NoTaskBlendDurationId, m_fNoTaskBlendDuration);
	m_TaskCoverMoveNetworkHelper.SendRequest(CTaskCover::ms_NoTaskRequestId);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::UseMobile_OnEnter()
{
	CTaskMotionInCover* pMotionTask = rage_new CTaskMotionInCover(m_TaskCoverMoveNetworkHelper, m_TaskMotionInCoverMoveNetworkHelper);
	SetNewTask(pMotionTask);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskInCover::UseMobile_OnUpdate()
{
	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		// Wait until the movement network has been inserted before allowing transitions
		if (GetSubTask()->GetState() <= CTaskMotionInCover::State_Start)
		{
			return FSM_Continue;
		}
	}

	if (!m_TaskUseCoverMoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	// Check for task state transitions
	if (GetIsFlagSet(aiTaskFlags::SubTaskFinished) || IsCoverFlagSet(CTaskCover::CF_AimIntroRequested))
	{
		GetPed()->GetWeaponManager()->CreateEquippedWeaponObject();
		SetState(State_Idle);
		return FSM_Continue;
	}
	else if (CheckForExit())
	{
		return FSM_Continue;
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::IsInMotionState(s32 iState, bool bReturnTrueIfNoSubtask) const
{
	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		if (GetSubTask()->GetState() == iState)
		{
			return true;
		}
		return false;
	}

	// If no motion in cover task is running assume we're in the correct state
	return bReturnTrueIfNoSubtask;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::WasInMotionState(s32 iState) const
{
	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		if (GetSubTask()->GetPreviousState() == iState)
		{
			return true;
		}
		return false;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::IsInMovingMotionState(bool bReturnTrueIfNoSubtask) const
{
	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		s32 iState = GetSubTask()->GetState();
		if (iState == CTaskMotionInCover::State_Moving || iState == CTaskMotionInCover::State_Stepping || iState == CTaskMotionInCover::State_WalkStart ||
			iState == CTaskMotionInCover::State_Stopping || iState == CTaskMotionInCover::State_StoppingAtEdge || iState == CTaskMotionInCover::State_StoppingAtInsideEdge)
		{
			return true;
		}
		return false;
	}

	// If no motion in cover task is running assume we're in the correct state
	return bReturnTrueIfNoSubtask;
}

bool CTaskInCover::RequestStepping() 
{		
	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		return static_cast<CTaskMotionInCover*>(GetSubTask())->RequestStepping();
	}	
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::IsAtOutsideEdge() const
{
	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		s32 iState = GetSubTask()->GetState();
		if (iState == CTaskMotionInCover::State_AtEdge || iState == CTaskMotionInCover::State_AtEdgeLowCover)
		{
			return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

#if FPS_MODE_SUPPORTED
bool CTaskInCover::ForceAimDueToDirectAimInFPM(bool bAimDirectly) const
{
	if (!bAimDirectly)
		return false;

	const CPed& rPed = *GetPed();
	if (!rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
		return false;
	
	const CControl* pControl = rPed.GetControlFromPlayer();
	const float fWalkUpDownNorm = pControl ? -pControl->GetPedWalkUpDown().GetNorm() : 0.0f;
	if (fWalkUpDownNorm > 0.1f)
		return false;

	return true;
}

void CTaskInCover::ProcessPelvisOffset()
{
	INSTANTIATE_TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MOVER_TO_PELVIS_OFFSET, -2.0f, 2.0f, 0.01f);
	INSTANTIATE_TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, ENABLE_PELVIS_OFFSET_FOR_FPS);
	CPed& rPed = *GetPed();
	if (rPed.IsFirstPersonShooterModeEnabledForPlayer(false) && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		float fDesiredPelvisOffset = 0.0f;
		if (ENABLE_PELVIS_OFFSET_FOR_FPS)
		{
			const CTaskAimAndThrowProjectile* pProjTask = static_cast<const CTaskAimAndThrowProjectile*>(FindSubTaskOfType(CTaskTypes::TASK_AIM_AND_THROW_PROJECTILE));

			// Blend out pelvis offset when quick throwing grenade - B*2001940, and also when aiming directly
			if (!pProjTask && !IsCoverFlagSet(CTaskCover::CF_AimDirectly))
			{
				// Split the range into two so we can apply separate lerp values as we may not want an even split
				float fDesiredPitch = CUpperBodyAimPitchHelper::ComputeDesiredPitchSignal(rPed);	
				if (fDesiredPitch > -1.0f)
				{
					TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MIN_PITCH_LIMIT, 0.1f, 0.0f, 1.0f, 0.01f);
					TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MAX_PITCH_LIMIT, 0.8f, 0.0f, 1.0f, 0.01f);
					fDesiredPitch = Clamp((fDesiredPitch - MIN_PITCH_LIMIT) / (MAX_PITCH_LIMIT - MIN_PITCH_LIMIT), 0.0f, 1.0f);
					TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, AIM_DOWN_PITCH_MIN_OFFSET, 0.5f, -2.0f, 2.0f, 0.01f);
					TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, AIM_UP_PITCH_MAX_OFFSET, -0.25f, -2.0f, 2.0f, 0.01f);
					const float fMinPitchOffset = fDesiredPitch <= 0.5f ? AIM_DOWN_PITCH_MIN_OFFSET : 0.0f;
					const float fMaxPitchOffset = fDesiredPitch <= 0.5f ? 0.0f : AIM_UP_PITCH_MAX_OFFSET;
					const float fEffectivePitch = fDesiredPitch <= 0.5f ? 2.0f * fDesiredPitch : (fDesiredPitch - 0.5f) * 2.0f;
					const float fHeightOffsetForPitch = (1.0f - fEffectivePitch) * fMinPitchOffset + fEffectivePitch * fMaxPitchOffset;
					const float fPeekHeightOffset = rPed.GetLowCoverHeightOffsetFromMover() > -0.5f ? rPed.GetLowCoverHeightOffsetFromMover() : 0.0f;
					fDesiredPelvisOffset = fPeekHeightOffset + MOVER_TO_PELVIS_OFFSET + fHeightOffsetForPitch;

					TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MIN_PELVIS_OFFSET, -0.25f, -1.0f, 1.0f, 0.01f);
					TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MAX_PELVIS_OFFSET, 0.3f, -1.0f, 1.0f, 0.01f);
					fDesiredPelvisOffset = Clamp(fDesiredPelvisOffset, MIN_PELVIS_OFFSET, MAX_PELVIS_OFFSET);
					//aiDisplayf("fMinPitchOffset = %.2f, fMaxPitchOffset = %.2f, fEffectivePitch = %.2f, fHeightOffsetForPitch = %.2f, fDesiredPelvisOffset = %.2f", fMinPitchOffset, fMaxPitchOffset, fEffectivePitch, fHeightOffsetForPitch, fDesiredPelvisOffset);

				}
			}

			bool bShouldUsePitchBasedPelvisOffset = true;

			if (GetState() == State_AimIntro && GetPreviousState() != State_Peeking)
			{
				TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MIN_TIME_IN_AIM_INTRO_STATE_TO_BLEND_IN_PELVIS, 0.0f, 0.0f, 5.0f, 0.01f);
				if (GetTimeInState() < MIN_TIME_IN_AIM_INTRO_STATE_TO_BLEND_IN_PELVIS)
				{
					bShouldUsePitchBasedPelvisOffset = false;
				}
			}
			else if (GetState() == State_AimOutro)
			{
				const CTaskAimGunFromCoverOutro* pAimOutroTask = static_cast<CTaskAimGunFromCoverOutro*>(FindSubTaskOfType(CTaskTypes::TASK_AIM_GUN_FROM_COVER_OUTRO));
				if (pAimOutroTask && !pAimOutroTask->IsOutroFlagSet(CTaskAimGunFromCoverOutro::CAF_ToPeek))
				{
					TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MAX_TIME_IN_AIM_OUTRO_STATE_TO_BLEND_IN_PELVIS, 0.1f, 0.0f, 5.0f, 0.01f);
					if (GetTimeInState() > MAX_TIME_IN_AIM_OUTRO_STATE_TO_BLEND_IN_PELVIS)
					{
						bShouldUsePitchBasedPelvisOffset = false;
					}
				}
			}
			else if (GetState() == State_BlindFiring)
			{
				const CTaskAimGunBlindFire* pBlindFireTask = static_cast<CTaskAimGunBlindFire*>(FindSubTaskOfType(CTaskTypes::TASK_AIM_GUN_BLIND_FIRE));
				if (pBlindFireTask)
				{
					if (pBlindFireTask->GetState() == CTaskAimGunBlindFire::State_OutroNew || pBlindFireTask->GetState() == CTaskAimGunBlindFire::State_CockGun)
					{
						bShouldUsePitchBasedPelvisOffset = false;
					}
					else if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !pBlindFireTask->UsingOverTheTopFiring())
					{
						bShouldUsePitchBasedPelvisOffset = false;
					}
				}
			}

			if (!bShouldUsePitchBasedPelvisOffset)
			{
				fDesiredPelvisOffset = 0.0f;
			}
		}
		rPed.GetIkManager().SetExternallyDrivenPelvisOffset(fDesiredPelvisOffset);
	}
}
#endif // FPS_MODE_SUPPORTED

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ProcessCoverSwitchDirection(const CPed& ped, float fTolerance, bool bCheckAimDirectly, bool bCheckAtCorner)
{
	// Try to switch our facing direction (spin out the other way) if we're aiming over our other shoulder
	// or have a target in that direction
	m_bSwitchedCoverDirection = false;

	if (ped.IsLocalPlayer() && (!IsCoverFlagSet(CTaskCover::CF_AimDirectly) || bCheckAimDirectly) && IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		const bool bInHighCoverNotAtEdge = (!IsCoverFlagSet(CTaskCover::CF_AtCorner) && IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint)) || m_bForcedStepBack || bCheckAtCorner;
		bool bAllowFacingSwitch = bInHighCoverNotAtEdge;

		const bool bFacingLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
		if (!bAllowFacingSwitch && !ped.GetCoverPoint()->IsEdgeCoverPoint(bFacingLeft))
		{
			bAllowFacingSwitch = true;
		}

		if (bAllowFacingSwitch)
		{
			CEntity* pTargetEntity =  ped.GetPlayerInfo()->GetTargeting().GetLockOnTarget() ? ped.GetPlayerInfo()->GetTargeting().GetLockOnTarget() : ped.GetPlayerInfo()->GetTargeting().FindLockOnTarget();				
			Vector3 vCoverDirection = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector());
			Vector3 vTargetDirection;
			if (pTargetEntity)
			{
				aiDisplayf("HAD TARGET");
				vTargetDirection = VEC3V_TO_VECTOR3(pTargetEntity->GetTransform().GetPosition()) - VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
			}
			else
			{
				const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
				vTargetDirection = aimCameraFrame.GetFront();
			}

			vTargetDirection.z = 0.0f;
			vTargetDirection.Normalize();

			const float fDot = vTargetDirection.Dot(vCoverDirection);
			aiDisplayf("fDot = %.2f", fDot);
			TUNE_GROUP_FLOAT(COVER_TUNE, MIN_DOT_TO_SWITCH_FACING_DIRECTION, 0.85f, 0.0f, 1.0f, 0.01f);
			TUNE_GROUP_FLOAT(COVER_TUNE, MIN_DOT_TO_SWITCH_FACING_DIRECTION_TARGET, 0.9f, 0.0f, 1.0f, 0.01f);
			if (fDot < MIN_DOT_TO_SWITCH_FACING_DIRECTION || (pTargetEntity && fDot < MIN_DOT_TO_SWITCH_FACING_DIRECTION_TARGET))
			{
				const float fCross = vCoverDirection.CrossZ(vTargetDirection);
				aiDisplayf("fCross = %.2f", fCross);
				if (!bFacingLeft && fCross >= fTolerance)
				{
					m_bSwitchedCoverDirection = true;
					SetCoverFlag(CTaskCover::CF_FacingLeft);
				}
				else if (bFacingLeft && fCross < fTolerance)
				{
					m_bSwitchedCoverDirection = true;
					ClearCoverFlag(CTaskCover::CF_FacingLeft);
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::UpdateCornerMoveStatus()
{
	// Disable for now
	return;

// 	CPed* pPed = GetPed();
// 
// 	if (pPed->IsLocalPlayer())
// 	{
// 		if ((m_vecStick.x < -ms_Tunables.m_MinStickInputToEnableMoveAroundCorner && IsCoverFlagSet(CF_FacingLeft)) ||
// 			(m_vecStick.x > ms_Tunables.m_MinStickInputToEnableMoveAroundCorner && !IsCoverFlagSet(CF_FacingLeft)))
// 		{
// 			// Cache the offset info if not already done so
// 			Quaternion qEnd, qStart;
// 			Vector3 vXlation;
// 
// 			if (IsCoverFlagSet(CF_FacingLeft))
// 			{
// 				if (pPed->GetCoverPoint()->GetHeight() == CCoverPoint::COVHEIGHT_LOW)
// 				{
// 					// 					if (ms_bHaveCachedCornerMoveOffset[CH_Low][CD_Left])
// 					// 					{
// 					// 						vXlation = ms_vCachedCornerMoveOffsets[CH_Low][CD_Left];
// 					// 					}
// 					// 					else
					// 					{
// 						const crClip* pAnimation = fwAnimManager::GetClipIfExists(GetClipGroupNameForArmament(), "pm0_low_cturn_l_90");
// 						qStart = CClipBlender::GetMoverTrackRotation(0.0f, pAnimation);
// 						qEnd = CClipBlender::GetMoverTrackRotation(1.0f, pAnimation);
// 						vXlation = fwAnimDirector::GetMoverTrackTranslation(1.0f, pAnimation) - fwAnimDirector::GetMoverTrackTranslation(0.0f, pAnimation);
// 						vXlation.z = 0.0f;
// 						//ms_vCachedCornerMoveOffsets[CH_Low][CD_Left] = vXlation;
// 						//ms_bHaveCachedCornerMoveOffset[CH_Low][CD_Left] = true;
// 					}
					// 					}
					// 					else
					// 					{
// 					// 					if (ms_bHaveCachedCornerMoveOffset[CH_High][CD_Left])
// 					// 					{
// 					// 						vXlation = ms_vCachedCornerMoveOffsets[CH_High][CD_Left];
// 					// 					}
// 					// 					else
// 					{
// 						const crClip* pAnimation = fwAnimManager::GetClipIfExists(GetClipGroupNameForArmament(), "pm0_high_cturn_l_90");
// 						qStart = CClipBlender::GetMoverTrackRotation(0.0f, pAnimation);
// 						qEnd = CClipBlender::GetMoverTrackRotation(1.0f, pAnimation);
// 						vXlation = fwAnimDirector::GetMoverTrackTranslation(1.0f, pAnimation) - fwAnimDirector::GetMoverTrackTranslation(0.0f, pAnimation);
// 						vXlation.z = 0.0f;
// 						//ms_vCachedCornerMoveOffsets[CH_High][CD_Left] = vXlation;
// 						//ms_bHaveCachedCornerMoveOffset[CH_High][CD_Left] = true;
// 
// 					}
// 				}
					// 					}
					// 					else
					// 					{
// 				if (pPed->GetCoverPoint()->GetHeight() == CCoverPoint::COVHEIGHT_LOW)
// 				{
// 					// 					if (ms_bHaveCachedCornerMoveOffset[CH_Low][CD_Right])
// 					// 					{
// 					// 						vXlation = ms_vCachedCornerMoveOffsets[CH_Low][CD_Right];
// 					// 					}
// 					// 					else
// 					{
// 						const crClip* pAnimation = fwAnimManager::GetClipIfExists(GetClipGroupNameForArmament(), "pm0_low_cturn_r_90");
// 						qStart = CClipBlender::GetMoverTrackRotation(0.0f, pAnimation);
// 						qEnd = CClipBlender::GetMoverTrackRotation(1.0f, pAnimation);
// 						vXlation = fwAnimDirector::GetMoverTrackTranslation(1.0f, pAnimation) - fwAnimDirector::GetMoverTrackTranslation(0.0f, pAnimation);
// 						vXlation.z = 0.0f;
// 						//ms_vCachedCornerMoveOffsets[CH_Low][CD_Right] = vXlation;
// 						//ms_bHaveCachedCornerMoveOffset[CH_Low][CD_Right] = true;
// 					}
					// 					}
					// 					else
					// 					{
// 					// 					if (ms_bHaveCachedCornerMoveOffset[CH_High][CD_Right])
// 					// 					{
// 					// 						vXlation = ms_vCachedCornerMoveOffsets[CH_High][CD_Right];
// 					// 					}
// 					// 					else
// 					{
// 						const crClip* pAnimation = fwAnimManager::GetClipIfExists(GetClipGroupNameForArmament(), "pm0_high_cturn_r_90");
// 						qStart = CClipBlender::GetMoverTrackRotation(0.0f, pAnimation);
// 						qEnd = CClipBlender::GetMoverTrackRotation(1.0f, pAnimation);
// 						vXlation = fwAnimDirector::GetMoverTrackTranslation(1.0f, pAnimation) - fwAnimDirector::GetMoverTrackTranslation(0.0f, pAnimation);
// 						vXlation.z = 0.0f;
// 						//ms_vCachedCornerMoveOffsets[CH_High][CD_Right] = vXlation;
// 						//ms_bHaveCachedCornerMoveOffset[CH_High][CD_Right] = true;
// 					}
// 				}
// 			}
// 
// 			Vector3 vStartRot, vEndRot;
// 			qStart.ToEulers(vStartRot, "xyz");
// 			qEnd.ToEulers(vEndRot, "xyz");
// 
// 			//Displayf("Start Rotation = %.2f, End Rotation = %.2f", vStartRot.z , vEndRot.z);
// 			vStartRot.z = fwAngle::LimitRadianAngle(vStartRot.z);
// 			vEndRot.z = fwAngle::LimitRadianAngle(vEndRot.z);
// 			//Displayf("(Limited) Start Rotation = %.2f, End Rotation = %.2f", vStartRot.z , vEndRot.z);
// 
// 			float fTotalAnimatedRotZ = vEndRot.z - vStartRot.z;
// 			fTotalAnimatedRotZ = fwAngle::LimitRadianAngle(fTotalAnimatedRotZ);
// 
// 			Vector3 vFacingDir(0.0f, 1.0f, 0.0f);
// 			vFacingDir.RotateZ(pPed->GetCurrentHeading());
// 			vFacingDir.RotateZ(fTotalAnimatedRotZ);
// 			//Displayf("Total Local Rotation = %.2f, Current Heading = %.2f", fTotalAnimatedRotZ, pPed->GetCurrentHeading());
// 
// 			//Displayf("Local Translation = (%.2f,%.2f,%.2f)", vXlation.x, vXlation.y, vXlation.z);
// 
// 			vXlation.RotateZ(pPed->GetCurrentHeading());
// 			vXlation.RotateZ(-fTotalAnimatedRotZ);
// 
// 			//Displayf("World Translation = (%.2f,%.2f,%.2f)", vXlation.x, vXlation.y, vXlation.z);
// 
// 			static bool s_bForceTranslation = false;
// 			if (s_bForceTranslation)
// 			{
// 				vXlation = Vector3(-0.78f,0.81f,0.00f);
// 			}
// 
// 			Vector3 vTestPosition = pPed->GetPosition() + vXlation;
// 
// 			float fOverrideDirection = -999.0f;
// 
// 			fOverrideDirection = fwAngle::LimitRadianAngle(pPed->GetCurrentHeading() + fTotalAnimatedRotZ);
// 			fOverrideDirection += IsCoverFlagSet(CF_FacingLeft) ? -HALF_PI : HALF_PI;	// Want to look for cover perpendicular to facing direction
// 			fOverrideDirection = fwAngle::LimitRadianAngle(fOverrideDirection);
// 
// 			if (CDynamicCoverHelper::TestForDynamicCover(pPed), vTestPosition, false, fOverrideDirection, true, true)
// 			{
// 				BANK_COVER_DEBUG(Displayf("TestForDynamicCover SUCCEEDED in CTaskInCover::UpdateCornerMoveStatus()");)
// 				SetCoverFlag(CF_ReadyForCornerMove);
// #if __BANK
// 				if (CCoverDebug::ms_bRenderCornerMoveTestPos)
// 				{
// 					CCoverDebug::ms_debugDraw.AddSphere(vTestPosition, 0.05f, Color_green, 1000);
// 					CCoverDebug::ms_debugDraw.AddLine(pPed->GetPosition(), vTestPosition, Color_purple, 1000);
// 					CCoverDebug::ms_debugDraw.AddLine(vTestPosition, vTestPosition + vFacingDir, Color_blue, 1000);
// 				}
// #endif 
					// 					}
					// 					else
// 			{
// 				BANK_COVER_DEBUG(Displayf("TestForDynamicCover FAILED in CTaskInCover::UpdateCornerMoveStatus()");)
// #if __BANK
// 					if (CCoverDebug::ms_bRenderCornerMoveTestPos)
// 					{
// 						CCoverDebug::ms_debugDraw.AddSphere(vTestPosition, 0.05f, Color_red, 1000);
// 						CCoverDebug::ms_debugDraw.AddLine(pPed->GetPosition(), vTestPosition, Color_purple, 1000);
// 						CCoverDebug::ms_debugDraw.AddLine(vTestPosition, vTestPosition + vFacingDir, Color_blue, 1000);
// 					}
// #endif 
// 			}
// 		}
// 	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::IsPedsVehicleCoverOnFire(const CPed& rPed) const
{

	CCoverPoint* pCoverPoint = rPed.GetCoverPoint();
	if (pCoverPoint &&
		pCoverPoint->IsDangerous() &&
		pCoverPoint->m_pEntity &&
		pCoverPoint->m_pEntity->GetIsTypeVehicle() )
	{
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

CTaskGun* CTaskInCover::CreateBlindFireGunTask()
{
	CPed* pPed = GetPed();

	CTaskGun* pGunTask = NULL;

	// Create blind fire gun task
	if (pPed->IsLocalPlayer())
	{
		pGunTask = rage_new CTaskGun(CWeaponController::WCT_Player, CTaskTypes::TASK_AIM_GUN_BLIND_FIRE);

		// Don't allow the player to just aim
		pGunTask->GetGunFlags().SetFlag(GF_DisableAiming);
		pGunTask->GetGunFlags().SetFlag(GF_UpdateTarget);
		pGunTask->GetGunFlags().SetFlag(GF_FireAtLeastOnce);
		pGunTask->GetGunFlags().SetFlag(GF_DisableReload);
	}
	else
	{
		float fDuration = pPed->GetPedIntelligence()->GetCombatBehaviour().GetCombatFloat(kAttribFloatBurstDurationInCover);

		pGunTask = rage_new CTaskGun(CWeaponController::WCT_Fire, CTaskTypes::TASK_AIM_GUN_BLIND_FIRE, GetTarget(), fDuration);

		// If blind firing, fire continuously
		pGunTask->SetFiringPatternHash(FIRING_PATTERN_FULL_AUTO);

		// Act as if we haven't fire in ages 
		pPed->SetTimeSinceLastShotFired(10.0f);

		pGunTask->GetGunFlags().SetFlag(GF_DisableReload);
		pGunTask->GetGunFlags().SetFlag(GF_FireBulletsInGunDirection);
		pGunTask->GetGunFlags().ClearFlag(GF_WaitForFacingAngleToFire);

		if (pPed->IsPlayer() && pPed->IsNetworkClone())
		{
			pGunTask->GetGunFlags().SetFlag(GF_UpdateTarget);
		}
	}

	// Configure gun task flags and ik info
	if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		pGunTask->GetGunFlags().SetFlag(GF_LowCover);
	}

	if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		pGunTask->GetGunFlags().SetFlag(GF_LeftCover);
	}

	if (IsCoverFlagSet(CTaskCover::CF_AtCorner))
	{
		pGunTask->GetGunFlags().SetFlag(GF_CornerCover);
	}

#if __ASSERT
	if (pPed->IsNetworkClone())
	{
		const bool bLeftCover = pGunTask->GetGunFlags().IsFlagSet(GF_LeftCover);
		const bool bLowCover = pGunTask->GetGunFlags().IsFlagSet(GF_LowCover);	
		const bool bCornerCover = pGunTask->GetGunFlags().IsFlagSet(GF_CornerCover);
		taskAssertf(bLeftCover || bLowCover || bCornerCover, "Expected at least one flag set for clone, bLeftCover ? %s, bLowCover ? %s, bCornerCover ? %s", bLeftCover ? "TRUE" : "FALSE", bLowCover ? "TRUE" : "FALSE", bCornerCover ? "TRUE" : "FALSE");
	}
#endif // __ASSERT

	taskFatalAssertf(pPed->GetWeaponManager(), "ped doesn't have a weapon manager");
	const CWeaponInfo* pWeaponInfo = CWeaponInfoManager::GetInfo<CWeaponInfo>(pPed->GetWeaponManager()->GetEquippedWeaponHash());
	if (AssertVerify(pWeaponInfo) && !pWeaponInfo->GetAllowEarlyExitFromFireAnimAfterBulletFired()) 
	{
		pGunTask->GetGunFlags().SetFlag(GF_OnlyExitFireLoopAtEnd);
	}

	pGunTask->GetGunFlags().SetFlag(GF_DontUpdateHeading);		
	pGunTask->GetGunFlags().SetFlag(GF_FireAtIkLimitsWhenReached);
	pGunTask->GetGunFlags().SetFlag(GF_DisableBlockingClip);
	pGunTask->GetGunFlags().SetFlag(GF_PreventWeaponSwapping);
	pGunTask->GetGunFlags().SetFlag(GF_BlindFiring);
	pGunTask->GetGunFlags().SetFlag(GF_DisableBulletReactions);
	pGunTask->GetGunFlags().SetFlag(GF_FireAtLeastOnce);

	float torsoOffsetYaw = 0.0f;
	if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		torsoOffsetYaw = (DtoR * 90.0f);
		if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) || (IsCoverFlagSet(CTaskCover::CF_AtCorner) && !IsCoverFlagSet(CTaskCover::CF_UseOverTheTopFiring)))
		{
			pGunTask->GetIkInfo().SetTorsoMinMaxYaw(0.0f, QUARTER_PI);
		}
	}
	else
	{
		torsoOffsetYaw = (DtoR * -90.0f);
		if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) || (IsCoverFlagSet(CTaskCover::CF_AtCorner) && !IsCoverFlagSet(CTaskCover::CF_UseOverTheTopFiring)))
		{
			pGunTask->GetIkInfo().SetTorsoMinMaxYaw(-QUARTER_PI, 0.0f);
		}
	}

	// Set the pitch values to avoid firing through small walls
	if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AtCorner))
	{
		pGunTask->GetIkInfo().SetTorsoMinMaxPitch(BLIND_FIRE_OVER_MIN_PITCH, BLIND_FIRE_OVER_MAX_PITCH);
	}
	else
	{
		pGunTask->GetIkInfo().SetTorsoMinMaxPitch(ms_Tunables.m_BlindFireHighCoverMinPitchLimit, ms_Tunables.m_BlindFireHighCoverMaxPitchLimit);
	}

	pGunTask->GetIkInfo().SetTorsoOffsetYaw(torsoOffsetYaw);

	taskFatalAssertf(pPed->GetWeaponManager()->GetEquippedWeaponInfo(), "NULL equipped weapon info");
	pGunTask->SetOverrideClipSetId(pPed->GetWeaponManager()->GetEquippedWeaponInfo()->GetPedCoverWeaponClipSetId(*pPed));

	return pGunTask;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ProcessMovement()
{
	CPed* pPed = GetPed();

	// The desired speed will be 0.0f when Abs(m_vecStick.x) == m_MinStickInputToMoveInCover and 1.0f when Abs(m_vecStick.x) == 128.0f
	const float fStickRangeModified = 128.0f - ms_Tunables.m_MinStickInputToMoveInCover;
	float fDesiredMBR = Abs(m_vecStick.x) / fStickRangeModified; // Divide by remaining stick range to normalize it between 0 - 1
	fDesiredMBR = rage::Clamp(fDesiredMBR, 0.0f, 1.0f);

	float fCurrentMBR = pPed->GetMotionData()->GetCurrentMbrY();

	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		if (pPed->GetPlayerInfo()->IsRoundCover())
			fDesiredMBR *= 0.5f; 

		if (GetSubTask()->GetState() == CTaskMotionInCover::State_StoppingAtEdge)
		{
			fDesiredMBR = 0.0f;
			// Apply some smoothing
			TUNE_GROUP_FLOAT(COVER_TUNE, fSpeedSmoothingStopping, 0.15f, 0.0f, 1.0f, 0.01f);
			fCurrentMBR = rage::Lerp(fSpeedSmoothingStopping, fCurrentMBR, fDesiredMBR);
		}
	}
	else
	{
		// Apply some smoothing
		TUNE_GROUP_FLOAT(COVER_TUNE, fSpeedSmoothing, 0.15f, 0.0f, 1.0f, 0.01f);
		fCurrentMBR = rage::Lerp(fSpeedSmoothing, fCurrentMBR, fDesiredMBR);
	}

	pPed->GetMotionData()->SetDesiredMoveBlendRatio(fDesiredMBR, 0.0f);
	pPed->GetMotionData()->SetCurrentMoveBlendRatio(fCurrentMBR, 0.0f);

	pPed->SetPedResetFlag( CPED_RESET_FLAG_DontChangeMbrInSimpleMoveDoNothing, true );
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CheckForExit()
{
	CPed* pPed = GetPed();

	if (pPed->IsLocalPlayer())
	{

		// Make sure we don't exit the task immediately due to pressing cover as it might detect the original press as an exit
		if (aiTask::GetTimeRunning() < ms_Tunables.m_MinTimeToSpendInTask)
		{
			return false;
		}

#if FPS_MODE_SUPPORTED
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MIN_TIME_BEFORE_EXIT_WHEN_AIMING, 0.75f, 0.0f, 2.0f, 0.01f);
		if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && pPed->GetPlayerInfo()->IsAiming())
		{
			if (GetTimeRunning() < MIN_TIME_BEFORE_EXIT_WHEN_AIMING)
			{
				return false;
			}
		}
#endif // FPS_MODE_SUPPORTED

		// Don't exit cover if we are using the phone camera
		if (CPhoneMgr::CamGetState())
		{
			return false;
		}

		// Leave cover if:
		// - the cover button is pressed
		// - the player is pressing away from the cover direction whilst not moving and not aiming with a scoped weapon, where movement is blocked
		// - the player presses jump and is not aiming with a scoped weapon, where movement is blocked

		const bool bIsAiming = GetState() == State_Aim;

		const bool bIsScopedWeapon = pPed->GetWeaponManager() && pPed->GetWeaponManager()->GetEquippedWeaponHasFirstPersonScope();
		const bool bIsAimingScopedWeapon = bIsAiming && bIsScopedWeapon;

		TUNE_GROUP_FLOAT(COVER_TUNE, MIN_TIME_RELOADING_WEAPON_TO_ALLOW_EXIT, 0.5f, 0.0f, 2.0f, 0.01f);
		CTask* pReloadTask = pPed->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN);
		if (pReloadTask)
		{
			pPed->SetPedResetFlag(CPED_RESET_FLAG_DisableCameraConstraintFallBackThisFrame, true);

			if (pReloadTask->GetTimeRunning() < MIN_TIME_RELOADING_WEAPON_TO_ALLOW_EXIT)
			{
				return false;
			}
		}

		if (bIsScopedWeapon)
		{
			// Prevent accidental break off when zooming back when coming back to reload on sniper
			if (GetState() == State_AimOutro && m_bOutroToReload)
			{
				return false;
			}

			if (pReloadTask)
			{
				const bool bWantsToAim = pPed->GetPlayerInfo()->IsAiming(false);
				if (bWantsToAim)
				{
					return false;
				}
			}
		}

		CControl* pControl = pPed->GetControlFromPlayer();
		CTask* pTask = pPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_PLAYER_ON_FOOT);
		bool bSprintReleased = pTask && static_cast<CTaskPlayerOnFoot*>(pTask)->GetCoverSprintReleased();

#if FPS_MODE_SUPPORTED
		bool bIsFPSMode = pPed->IsFirstPersonShooterModeEnabledForPlayer(false);
		const float fInputYAxisQuitValue = (bIsFPSMode && IsCoverFlagSet(CTaskCover::CF_AimDirectly)) ? ms_Tunables.m_InputYAxisQuitValueAimDirect : ms_Tunables.m_InputYAxisQuitValue;
#else //FPS_MODE_SUPPORTED
		const float fInputYAxisQuitValue = ms_Tunables.m_InputYAxisQuitValue;
#endif // FPS_MODE_SUPPORTED
		bool bSprintDown = pControl->GetValue(INPUT_SPRINT).IsDown();
		const bool bExitCoverPressed = pControl->GetPedCover().IsPressed() || 
			(bSprintReleased && bSprintDown && (m_vecStick.Mag2() > (fInputYAxisQuitValue*fInputYAxisQuitValue)));
		bool bStickExitPressed = m_vecStick.y < fInputYAxisQuitValue;

		float fMag = 0.0f;
		float fAngle = 0.0f;
		if (m_bCachedStickValid && ComputeStickInputPolarForm(m_vecStick, fMag, fAngle))
		{
			const float fDiff = Abs(fwAngle::LimitRadianAngle(fAngle - m_fCachedStickAngle));
			TUNE_GROUP_FLOAT(COVER_TUNE, MAX_STICK_ANGLE_DIFF, PI, 0.0f, PI, 0.01f);
			TUNE_GROUP_FLOAT(COVER_TUNE, MAX_STICK_X_INPUT_HELD, 30.0f, -128.0f, 128.0f, 1.0f);
			if (fDiff < MAX_STICK_ANGLE_DIFF)
			{
				if (Abs(m_vecStick.x) > MAX_STICK_X_INPUT_HELD)
				{
					bStickExitPressed = false;
					aiDisplayf("Disabling exit cover due to previous stick input");
				}
			}
#if __BANK
			else
			{
				aiDisplayf("fDiff = %.2f", fDiff);
			}
#endif // __BANK
		}

		if (m_bDelayedExit)
		{
			if (IsInMotionState(CTaskMotionInCover::State_TurnEnter, false) || IsInMotionState(CTaskMotionInCover::State_TurnEnd, false)
				FPS_MODE_SUPPORTED_ONLY(|| (bIsFPSMode && (IsInMotionState(CTaskMotionInCover::State_Peeking, false) || IsInMovingMotionState(false)))))
				return false;
			else
			{
				if (bStickExitPressed) 
					SetTerminationReason(CTaskCover::TR_NormalExit);
				SetState(State_Finish);
				return true;
			}
		}

		if (m_bDelayedBlindFireExit)
		{
			if (GetState() == State_BlindFiring)
			{
				const CTaskAimGunBlindFire* pBlindFireTask = static_cast<const CTaskAimGunBlindFire*>(FindSubTaskOfType(CTaskTypes::TASK_AIM_GUN_BLIND_FIRE));
				if (pBlindFireTask && pBlindFireTask->GetState() == CTaskAimGunBlindFire::State_FireNew)
				{
					// Still firing, continue to delay
					return false;
				}
			}
			
			// No longer in State_BlindFiring or CTaskAimGunBlindFire::State_FireNew, time to breakout
			SetState(State_Finish);
			return true;
		}

		if (bExitCoverPressed || 
			(bStickExitPressed && !bIsAimingScopedWeapon  && (!IsInMotionState(CTaskMotionInCover::State_Moving, GetState() != State_StreamAssets) || bIsAiming)))
		{
			if (!IsInMotionState(CTaskMotionInCover::State_EdgeTurn, false) && !IsInMotionState(CTaskMotionInCover::State_CoverToCover, false)
				FPS_MODE_SUPPORTED_ONLY(&& (!bIsFPSMode || (!IsInMotionState(CTaskMotionInCover::State_TurnEnter, false) && !IsInMotionState(CTaskMotionInCover::State_TurnEnd, false)))))
			{			
				// Check if the player is trying to do cover to cover
				const bool bYBlock = fabs(m_vecStick.y) > CTaskMotionInCover::ms_Tunables.m_MinStickInputToEnableCoverToCover;
				const bool bWantsToMoveRight = m_vecStick.x > CTaskMotionInCover::ms_Tunables.m_MinStickInputToEnableCoverToCover && !bYBlock;
				const bool bWantsToMoveLeft = m_vecStick.x < -CTaskMotionInCover::ms_Tunables.m_MinStickInputToEnableCoverToCover && !bYBlock;

				bool bDontExit = false;

				if (IsCoverFlagSet(CTaskCover::CF_AtCorner) &&
					((bWantsToMoveRight && !IsCoverFlagSet(CTaskCover::CF_FacingLeft))
					|| (bWantsToMoveLeft && IsCoverFlagSet(CTaskCover::CF_FacingLeft))))
				{
					if ((CTaskMotionInCover::ms_Tunables.m_UseSprintButtonForCoverToCover || pControl->GetPedCover().IsPressed() || pControl->GetPedSprintIsPressed()))
					{
						if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
						{
							CCoverPoint newCoverPoint;
							if (CTaskMotionInCover::PlayerCheckForCoverToCover(newCoverPoint, *pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), GetStickInput(), !IsCoverPointTooHigh()))
							{
								static_cast<CTaskMotionInCover*>(GetSubTask())->SetCoverToCoverPoint(newCoverPoint);
								bDontExit = true;
								return false;
							}	
						}
					}
				}

				if (!bDontExit)
				{
					bool bIsCornerExit = false;

					if ((bExitCoverPressed || bStickExitPressed) && GetState() != State_Aim)
					{
						if (CTaskMotionInCover::PlayerCheckForCornerExit(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), m_vecStick))
						{
							SetTerminationReason(CTaskCover::TR_CornerExit);
							bIsCornerExit = true;
						}
						else //if (Abs(m_vecStick.x) < ms_Tunables.m_MaxInputForIdleExit && Abs(m_vecStick.y) < ms_Tunables.m_MaxInputForIdleExit)
						{
							if (GetState()==State_AimOutro)
								SetTerminationReason(CTaskCover::TR_IdleExit); //B* 1271032
							else if (bStickExitPressed || bSprintDown) //B* 1119554 B* 1430890 B* 1430909
								SetTerminationReason(CTaskCover::TR_NormalExit);
							else if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && (bWantsToMoveRight || bWantsToMoveLeft))
								SetTerminationReason(CTaskCover::TR_NormalExit); //B* 1430890
							else
								SetTerminationReason(CTaskCover::TR_IdleExit);
							CTask* pMotionInCoverTask = GetSubTask();
							if (pMotionInCoverTask && pMotionInCoverTask->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
							{
								 // Blend straight to loco if not idle, these states don't look good with standard exits
								if (!static_cast<CTaskMotionInCover*>(pMotionInCoverTask)->IsIdle())
								{
									SetTerminationReason(CTaskCover::TR_NormalExit);
									if (pPed->WantsToUseActionMode())
									{
										pPed->ForceMotionStateThisFrame(pControl->GetPedSprintIsDown() ? CPedMotionStates::MotionState_ActionMode_Run : CPedMotionStates::MotionState_ActionMode_Walk);
									}
								}
							}	
						}
					}
				
					// While peeking in first person mode we're able to exit cover while our camera and ped heading are outside of their limits
					// causing the camera heading to get clamped.  By delaying the exit while peeking it should give the ped a chance to complete
					// a turn (if one is necessary) before exiting which should bring the camera and ped headings together
					// Don't do this when doing a corner exit, the motion anims will change underneath causing B*2105721
					if (IsInMotionState(CTaskMotionInCover::State_TurnEnter, false) || IsInMotionState(CTaskMotionInCover::State_TurnEnd, false)
						FPS_MODE_SUPPORTED_ONLY(|| (!bIsCornerExit && bIsFPSMode && (IsInMotionState(CTaskMotionInCover::State_Peeking, false) || IsInMovingMotionState(false)))))
					{
						m_bDelayedExit = true;
						return false;
					}

					// If we're trying to break out of cover mid blind fire with a weapon flagged GetForceFullFireAnimation, delay it until no longer in the fire state
					const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager() ? pPed->GetWeaponManager()->GetEquippedWeaponInfo() : NULL;
					if (GetState() == State_BlindFiring && pWeaponInfo && pWeaponInfo->GetForceFullFireAnimation())
					{
						const CTaskAimGunBlindFire* pBlindFireTask = static_cast<const CTaskAimGunBlindFire*>(FindSubTaskOfType(CTaskTypes::TASK_AIM_GUN_BLIND_FIRE));
						if (pBlindFireTask && pBlindFireTask->GetState() == CTaskAimGunBlindFire::State_FireNew)
						{
							m_bDelayedBlindFireExit = true;
							return false;
						}
					}

					SetState(State_Finish);
					return true;
				}
			}
		}

		const float fPedWalkUpDown = -pControl->GetPedWalkUpDown().GetNorm();
		if (!bIsAiming && pControl->GetPedJump().IsPressed() && !bIsAimingScopedWeapon && fPedWalkUpDown > CTaskMotionInCover::ms_Tunables.m_MinStickInputToMoveAroundCorner 
			&& !(NetworkInterface::IsGameInProgress() && pPed->GetPedResetFlag(CPED_RESET_FLAG_DisablePlayerVaulting)))
		{
			if (CTaskJumpVault::WillVault(pPed, JF_ForceVault|JF_DisableJumpingIfNoClimb))
			{
				pPed->SetPedConfigFlag( CPED_CONFIG_FLAG_VaultFromCover, true );
				SetTerminationReason(CTaskCover::TR_IdleExit);
				SetState(State_Finish);
				return true;
			}
		}

		CTaskCover* pCoverTask = static_cast<CTaskCover*>(GetParent());
		if (pCoverTask->CheckForMovingCover(pPed))
		{
			pPed->SetCoverPoint(NULL);			
			SetState(State_Finish);
			return true;
		}

		if (pPed->GetIsSwimming())
		{
			SetState(State_Finish);
			return true;
		}

		// Periodically check validity of dynamic cover
		static dev_float TIME_BETWEEN_DYNAMIC_COVER_CHECKS = 0.5f;
		const bool bBlindFiring = GetState() == State_BlindFiring;
		if (pPed->GetPlayerInfo()->IsCoverGeneratedByDynamicEntity() && !IsInMotionState(CTaskMotionInCover::State_CoverToCover) && 
			(IsInMotionState(CTaskMotionInCover::State_Idle) || GetState() == State_Peeking || IsInMotionState(CTaskMotionInCover::State_AtEdge) || bBlindFiring))
		{
			if (GetState() != State_AimIntro && GetState() != State_Aim && GetState() != State_AimOutro)
			{
				m_fTimeSinceLastDynamicCoverCheck += GetTimeStep();
				if( m_fTimeSinceLastDynamicCoverCheck > TIME_BETWEEN_DYNAMIC_COVER_CHECKS )
				{
					m_fTimeSinceLastDynamicCoverCheck = 0.0f;

					// If we're on cover against a car door the cover verification can end up changing the cover position
					// and pulls us awkwardly about, assume if we're against a vehicle door our position is valid
					bool bIgnoreCoverVerification = false;
					if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
					{
						bIgnoreCoverVerification = CTaskCover::IsPlayerPedInCoverAgainstVehicleDoor(*pPed, *pPed->GetCoverPoint());

						TUNE_GROUP_BOOL(COVER_TUNE, DO_DISTANCE_VERIFICATION_CHECK, true);
						if (DO_DISTANCE_VERIFICATION_CHECK && !bIgnoreCoverVerification)
						{
							CEntity* pEntity = CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity();
							if (!pEntity)
							{
								pEntity = CTaskCover::GetEntityPlayerIsInCoverAgainst(*pPed, *pPed->GetCoverPoint());
								CPlayerInfo::ms_DynamicCoverHelper.SetCoverEntryEntity(pEntity);
								AI_LOG_WITH_ARGS("[cover] Player %s cover verification entity %s\n", AILogging::GetDynamicEntityNameSafe(pPed), pEntity ? (pEntity->GetModelName() ? pEntity->GetModelName() : "none") : "null");
							}

							if (pEntity)
							{
								const Vector3 vCachedPosition = CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntityCachedPosition();
								const Vector3 vActualPosition = VEC3V_TO_VECTOR3(pEntity->GetTransform().GetPosition());
								TUNE_GROUP_FLOAT(COVER_TUNE, MIN_DIST_MOVED_TO_RETEST_COVER, 0.5f, 0.0f, 2.0f, 0.01f);
								if (!vCachedPosition.IsClose(VEC3_ZERO, SMALL_FLOAT) || vActualPosition.IsClose(VEC3_ZERO, SMALL_FLOAT))
								{
									if (vCachedPosition.Dist2(vActualPosition) < square(MIN_DIST_MOVED_TO_RETEST_COVER))
									{
										bIgnoreCoverVerification = true;
									}
								}
								AI_LOG_WITH_ARGS("[cover] Player %s %s cover verification, vCachedPosition (%.2f,%.2f,%.2f), vActualPosition (%.2f,%.2f,%.2f)\n", AILogging::GetDynamicEntityNameSafe(pPed), bIgnoreCoverVerification ? "ignoring" : "doing", vCachedPosition.x, vCachedPosition.y, vCachedPosition.z, vActualPosition.x, vActualPosition.y, vActualPosition.z);
							}
						}
					}

					// Ensure the dynamic cover point at this position is valid 
					TUNE_GROUP_BOOL(COVER_TUNE, DO_DYNAMIC_EXIT_TESTS, true);
					if (DO_DYNAMIC_EXIT_TESTS && !bIgnoreCoverVerification && !pPed->GetPlayerInfo()->AreControlsDisabled())
					{
						if (bBlindFiring || (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER))
						{
							const bool bIsIdle = bBlindFiring || GetSubTask()->GetState() == CTaskMotionInCover::State_Idle || GetSubTask()->GetState() == CTaskMotionInCover::State_AtEdge || GetSubTask()->GetState() == CTaskMotionInCover::State_Peeking;							
							if (CTaskMotionInCover::FindNewDynamicCoverPoint(pPed, 0.0f, IsCoverFlagSet(CTaskCover::CF_FacingLeft), false, bIsIdle))
							{
								Vector3 vTargetPosition;
								GetTarget().GetPosition(vTargetPosition);

								Vector3 vOutCoverDirection, vOutCoverCoords;

								// Update the blind fire status;
								CalculateCoverPosition();
								CheckForBlockedBlindFire();

								pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
							}
							else
							{
#if __BANK
								aiDisplayf("Frame : %i, pulling ped %s (%p) out of cover because unable to find cover point", fwTimer::GetFrameCount(), AILogging::GetDynamicEntityNameSafe(pPed), pPed);
#endif // __BANK
								pPed->SetCoverPoint(NULL);			
								SetState(State_Finish);
								return true;
							}
						}
					}
				}
			}
		}
	}
	else if (pPed->IsNetworkClone())
	{
		if (IsCoverFlagSet(CTaskCover::CF_AbortTask))
		{
			SetState(State_Finish);

			return true;
		}
	}
	else if (GetTarget().GetIsValid() && static_cast<CTaskCover*>(GetParent())->GetForcedExit() == CTaskCover::FE_None)
	{
		// States should be able to handle aim intro requests
		if(IsCoverFlagSet(CTaskCover::CF_AimIntroRequested))
		{
			return false;
		}

		Vector3 vTargetPos;
		GetTarget().GetPosition(vTargetPos);

		CCoverPoint* pCoverPoint = pPed->GetCoverPoint();
		if (IsPedsVehicleCoverOnFire(*pPed))
		{
			CEventVehicleOnFire fireEvent(static_cast<CVehicle*>(pCoverPoint->m_pEntity.Get()));
			pPed->GetPedIntelligence()->AddEvent(fireEvent);
			return true;
		}

		const CEntity* pTargetEntity = GetTarget().GetEntity();		
		if (pCoverPoint && !CCover::DoesCoverPointProvideCoverFromTargets(pPed, vTargetPos, pCoverPoint, pCoverPoint->GetArcToUse(*pPed, pTargetEntity), pTargetEntity))
		{
			return true;
		}
	}

	return false;
}


////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CheckForPeeking()
{
	CPed* pPed = GetPed();
	bool bIsFPSMode = false;

	if (pPed->IsLocalPlayer())
	{
		if (CTaskPlayerOnFoot::CheckForUseMobilePhone(*pPed))
			return false;

		if (pPed->GetPlayerInfo()->IsRoundCover())
			return false;		

		bool bIsHighCover = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
		if (pPed->GetCoverPoint() && bIsHighCover && !pPed->GetCoverPoint()->IsEdgeCoverPoint(IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
			return false;
	 
		bool edgeCoverOk = !pPed->GetPlayerInfo()->DynamicCoverInsideCorner() && pPed->GetPlayerInfo()->GetDynamicCoverEdgeDistance() >= 0.0f;
#if DISABLE_LOW_COVER_EDGE_PEEK
		if (!bIsHighCover)
		{
			edgeCoverOk = false;
		}
#endif
		static dev_float sf_MinStickAxisInput = 100.0f;

		Vector2 vStickInput = m_vecStick;
#if FPS_MODE_SUPPORTED
		const CControl* pControl = pPed->GetControlFromPlayer();
		bIsFPSMode = pPed->IsFirstPersonShooterModeEnabledForPlayer(false);
		if (bIsFPSMode && CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations)
		{
			// If we're delaying the exit while peeking we need to exit the peek state so that we can attept to turn the ped to face the camera
			if (m_bDelayedExit)
			{
				return false;
			}

			INSTANTIATE_TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, USE_PEEK_TOGGLE);
			if (USE_PEEK_TOGGLE)
			{
				if (GetState() == State_Peeking)
					return m_bPeekToggleEnabled;

				if (m_bPeekToggleEnabled)
					return true;

				if (pControl && (GetPreviousState() != State_Peeking || GetTimeInState() > 0.25f))
					return pControl->GetPedLookBehind().IsPressed();
			}
		}
#endif // FPS_MODE_SUPPORTED
		bool stickOK = false;
		if (!bIsHighCover && vStickInput.y > sf_MinStickAxisInput)
		{
			stickOK = true;
		}
		else if (edgeCoverOk)
		{
			// First check X direction...
			if (IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? vStickInput.x < -sf_MinStickAxisInput : vStickInput.x > sf_MinStickAxisInput)
			{
				stickOK = true;
			}
#if	FPS_MODE_SUPPORTED
			else if (bIsFPSMode)
			{
				// Check Y direction...
				if (vStickInput.y > sf_MinStickAxisInput)
				{
					stickOK = true;
				}
				// Check the diagonal...
				else if (IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? vStickInput.Dot(Vector2(-1.0f, 1.0f)) > sf_MinStickAxisInput : vStickInput.Dot(Vector2(1.0f, 1.0f)) > sf_MinStickAxisInput)
				{
					stickOK = true;
				}
			}
#endif
		}

#if FPS_MODE_SUPPORTED
		TUNE_GROUP_BOOL(FIRST_PERSON_BLINDFIRE_TUNE, DISABLE_LOW_PEEKING_IF_OVERHEAD_BLOCKED, true);
		if (DISABLE_LOW_PEEKING_IF_OVERHEAD_BLOCKED && bIsFPSMode && !bIsHighCover && IsCoverFlagSet(CTaskCover::CF_AtCorner))
		{
			u8 uFudge;
			if (!CTaskInCover::CheckForBlindFireOverheadClearance(pPed, uFudge))
			{
				return false;
			}
		}
#endif // FPS_MODE_SUPPORTED

		if (!stickOK || (!edgeCoverOk && bIsHighCover) )
			return false;
		
	}

	if (IsCoverFlagSet(CTaskCover::CF_RunningPinnedVariation)
		|| (!pPed->IsLocalPlayer() && IsCoverFlagSet(CTaskCover::CF_RunningIdleVariation)))
	{
		return false;
	}

	//not while reloading B* 1008864
	if (pPed->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN))	
	{
		return false;
	}

	if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER)
	{
		CTaskMotionInCover* pMotionTask = static_cast<CTaskMotionInCover*>(GetSubTask());

		if (ms_Tunables.m_UseAutoPeekAimFromCoverControls && 
			(pMotionTask->GetState() == CTaskMotionInCover::State_CoverToCover ||
			pMotionTask->GetState() == CTaskMotionInCover::State_EdgeTurn))
		{
			return false;
		}

		if (pMotionTask->GetState() == CTaskMotionInCover::State_TurnEnter ||
			pMotionTask->GetState() == CTaskMotionInCover::State_TurnEnd ||
			pMotionTask->GetState() == CTaskMotionInCover::State_WalkStart ||
			pMotionTask->GetState() == CTaskMotionInCover::State_Moving)
		{
			return false;
		}

		TUNE_GROUP_FLOAT(COVER_TUNE, MIN_TIME_IN_SETTLE_TO_PEEK, 0.1f, 0.0f, 1.0f, 0.01f);
		if (pMotionTask->GetState() == CTaskMotionInCover::State_Settle && pMotionTask->GetTimeInState() < MIN_TIME_IN_SETTLE_TO_PEEK)
		{
			return false;
		}

		if (((pMotionTask->CheckForTurn() && (ms_Tunables.m_UseAutoPeekAimFromCoverControls && !IsAimButtonHeldDown()))
			|| !ms_Tunables.m_UseAutoPeekAimFromCoverControls))
		{
			return false;
		}
	}

	if (GetState() != State_AimOutro)
	{
		if (pPed->IsLocalPlayer() && !ms_Tunables.m_UseAutoPeekAimFromCoverControls)
		{
			return false;
		}
	}

	if (IsCoverFlagSet(CTaskCover::CF_DisableAimingAndPeeking))
	{
		return false;
	}

	// We need to switch weapons first
	if (pPed->GetWeaponManager()->GetEquippedWeaponObjectHash() != pPed->GetWeaponManager()->GetSelectedWeaponHash() && !pPed->IsLocalPlayer())
	{
		return false;
	}

	// unsupported peeking state (high mid-wall)
	if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AtCorner) && !IsAtOutsideEdge())
		return false;

	if (IsAtOutsideEdge() || IsInMotionState(CTaskMotionInCover::State_Idle) || IsInMotionState(CTaskMotionInCover::State_Peeking) 
		|| IsInMotionState(CTaskMotionInCover::State_PlayingIdleVariation) || IsInMotionState(CTaskMotionInCover::State_Settle))
	{
		// Assume we're in the correct state if we're already peeking
		if (GetState() != State_Peeking)
		{
			if (IsInMotionState(CTaskMotionInCover::State_Idle))
			{
				if (IsCoverPointTooHigh() && !IsCoverFlagSet(CTaskCover::CF_AtCorner))
				{
					return false;
				}
			}
		}

		if (pPed->GetPedResetFlag( CPED_RESET_FLAG_ForcePeekFromCover ))
		{
			return true;
		}
		else if (pPed->IsLocalPlayer())
		{
			if (ms_Tunables.m_UseAutoPeekAimFromCoverControls || IsAimButtonHeldDown())
			{
				if (bIsFPSMode && GetState() != State_Peeking)
				{
					if (IsFPSPeekPositionObstructed(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
					{
						return false;
					}
				}

				const bool bIsPeeking = GetState() == State_Peeking ? true : false;
				if (!bIsPeeking && ms_Tunables.m_UseAutoPeekAimFromCoverControls)
				{
					if (GetSubTask() && GetSubTask()->GetTaskType() == CTaskTypes::TASK_MOTION_IN_COVER && !bIsFPSMode)
					{
						CTaskMotionInCover* pMotionTask = static_cast<CTaskMotionInCover*>(GetSubTask());
						if (pMotionTask->GetState() == CTaskMotionInCover::State_AtEdge && pMotionTask->GetPreviousState() == CTaskMotionInCover::State_StoppingAtEdge)
						{
							if (pMotionTask->GetTimeInState() < ms_Tunables.m_MinTimeBeforeAllowingAutoPeek)
							{
								return false;
							}
						}
						else if (pMotionTask->GetState() == CTaskMotionInCover::State_Settle)
						{
							const Vector2 vStickInput = CTaskCover::ComputeStickInput(*pPed);
							return !CTaskMotionInCover::PlayerCheckForMovingAbout(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), vStickInput);
						}
					}
				}
				return true;
			}
		}
		// AI peek every few seconds
		else if (!pPed->GetPedConfigFlag( CPED_CONFIG_FLAG_BlockPeekingInCover ))
		{
			// If we have a valid target then make sure we're outside of the minimum range
			if(GetTarget().GetIsValid())
			{
				Vector3 vTargetPosition;
				GetTarget().GetPosition(vTargetPosition);

				ScalarV scDistSq = DistSquared(pPed->GetTransform().GetPosition(), VECTOR3_TO_VEC3V(vTargetPosition));
				ScalarV scMinDistSq = ScalarVFromF32(square(ms_Tunables.m_MinDistanceToTargetForPeek));
				if(IsLessThanAll(scDistSq, scMinDistSq))
				{
					return false;
				}
			}

			if( GetState() != State_Peeking && pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForceInitialPeekInCover) )
			{
				return true;
			}

			static dev_float fTimeInStateRequired = 1.0f;

			// Check if we can peek again based on our time between peek attempts behavior variable
			if (GetState() != State_Peeking && GetTimeInState() > fTimeInStateRequired && fwTimer::GetTimeInMilliseconds() > m_iTimeNextPeekAllowed)
				return true;

			// Check if we've been in this state for the time we set that we need to stay in the state for
			if (GetState() == State_Peeking && GetTimeInState() < m_fTimeToSpendInState)
				return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CouldThrowProjectile(bool bIsPlayer)
{
	// cannot throw projectile for certain cover conditions
	if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AtCorner))
	{
		return false;
	}

	const CPed* pPed = GetPed();

	// Cannot throw from cover when in air defence spheres
	if ( pPed && pPed->GetPedResetFlag(CPED_RESET_FLAG_InAirDefenceSphere) )
	{
		return false;
	}

	// AI ped
	if( !bIsPlayer )
	{
		// Cannot throw if not allowed to fire
		if( IsCoverFlagSet(CTaskCover::CF_AimOnly) )
		{
			return false;
		}

		// Cannot throw if cover can't be blindfired from
		if( !IsCoverFlagSet(CTaskCover::CF_CanBlindFire) )
		{
			return false;
		}

		// Cannot throw if coverpoint is a corner left or right, and ped is facing the wrong way
		if( pPed )
		{
			const CCoverPoint* pCoverPoint = pPed->GetCoverPoint();
			if( pCoverPoint )
			{
				// Get the cover usage of the cover point in use
				const CCoverPoint::eCoverUsage coverUsage = pCoverPoint->GetUsage();
				const bool bCoverIsRightCorner = (coverUsage == CCoverPoint::COVUSE_WALLTOLEFT || coverUsage == CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT);
				const bool bCoverIsLeftCorner = (coverUsage == CCoverPoint::COVUSE_WALLTORIGHT || coverUsage == CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT);
				const bool bIsFacingLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
				if( (bCoverIsLeftCorner && !bIsFacingLeft) || (bCoverIsRightCorner && bIsFacingLeft) )
				{
					// ped is facing inside corner, not safe to throw
					return false;
				}
			}
		}
	}

	// All checks passed, could potentially throw projectile
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CheckForThrowingProjectile()
{
	CPed* pPed = GetPed();

	const bool bIsPlayer = pPed->IsLocalPlayer();

	if (!CouldThrowProjectile(bIsPlayer))
	{
		return false;
	}

#if FPS_MODE_SUPPORTED
	if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		const fwMvClipSetId clipsetId = ms_Tunables.GetThrowProjectileClipSetIdForPed(*pPed) ;
		if (clipsetId != CLIP_SET_ID_INVALID && !CTaskCover::RequestCoverClipSetReturnIfLoaded(clipsetId))
		{
			return false;
		}
	}
#endif // FPS_MODE_SUPPORTED

	weaponAssert(pPed->GetWeaponManager());
	const bool bHasProjectile = pPed->GetWeaponManager()->GetEquippedWeapon() && pPed->GetWeaponManager()->GetEquippedWeapon()->GetWeaponInfo()->GetIsThrownWeapon();

	if (bHasProjectile)
	{
		if (bIsPlayer && !pPed->GetWeaponManager()->GetRequiresWeaponSwitch())
		{
			if (!CNewHud::IsWeaponWheelActive() && pPed->GetPlayerInfo()->IsFiring() && IsCoverFlagSet(CTaskCover::CF_CanBlindFire))
			{
				CheckForOverTheTopFiring();
				return true;
			}
		}

		// If AI ped, requested to throw smoke grenade, and we are in idle state
		if( !bIsPlayer && m_bSmokeGrenadeThrowRequested && GetState() == State_Idle )
		{
			return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::SetStateThrowingProjectile(const float fProjectileCookingTime)
{
	m_fProjectileCookingTime = fProjectileCookingTime;
	SetState(State_ThrowingProjectile);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CheckForSwitchingWeapon()
{
	// Wait for the anims to load in
	if (!static_cast<CTaskCover*>(GetParent())->IsWeaponClipSetLoaded())
	{
		return false;
	}

	if (IsInMotionState(CTaskMotionInCover::State_EdgeTurn))
	{
		return false;
	}

	CPed* pPed = GetPed();
	if (pPed->IsPlayer())
	{
		if (pPed->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN))
		{
			return false;
		}
		if (pPed->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_SWAP_WEAPON))
		{
			return false;
		}
	}

	if (CTaskMobilePhone::IsRunningMobilePhoneTask(*pPed))
	{
		if (!CTaskPlayerOnFoot::CheckForUseMobilePhone(*pPed))
		{
			if (!m_RecreateWeaponTimer.IsSet())
			{
				m_RecreateWeaponTimer.Set(fwTimer::GetTimeInMilliseconds(), ms_Tunables.m_RecreateWeaponTime);
			}
			else if (m_RecreateWeaponTimer.IsOutOfTime())
			{
				m_RecreateWeaponTimer.Unset();
			}
		}
		return false;
	}

	if (pPed->IsPlayer() || IsInMotionState(CTaskMotionInCover::State_AtEdge) 
		|| IsInMotionState(CTaskMotionInCover::State_PlayingIdleVariation)
		|| IsInMotionState(CTaskMotionInCover::State_Peeking) 
		|| IsInMotionState(CTaskMotionInCover::State_Idle) || (GetState() == State_Peeking && ms_Tunables.m_UseAutoPeekAimFromCoverControls)) 
	{
		weaponAssert(pPed->GetWeaponManager());
		const bool bDisableWeaponSwithing = !pPed->IsLocalPlayer() && pPed->GetPedsGroup() && pPed->GetPedsGroup()->GetGroupMembership()->GetLeader() != pPed;
		if(!bDisableWeaponSwithing)
		{
			if(pPed->GetWeaponManager()->GetRequiresWeaponSwitch())
			{
				const CWeaponInfo* pInfo = CWeaponInfoManager::GetInfo<CWeaponInfo>(pPed->GetWeaponManager()->GetEquippedWeaponHash());
				if(pInfo)
				{
					// Ensure weapon is streamed in
					if(pPed->GetInventory() && pPed->GetInventory()->GetIsStreamedIn(pInfo->GetHash()))
					{
						if(pInfo->GetIsCarriedInHand() || pPed->GetWeaponManager()->GetEquippedWeaponObject() != NULL)
						{
							return true;
						}
					}
				}
			}
		}
	}

	if( !pPed->IsPlayer() && m_bSmokeGrenadeThrowRequested && !m_bSmokeGrenadeThrowInProgress && GetState() == State_Idle)
	{
		// give the ped a smoke grenade to throw
		if( pPed->GetInventory() )
		{
			if( pPed->GetInventory()->AddWeaponAndAmmo(WEAPONTYPE_SMOKEGRENADE, 1) )
			{
				// equip the smoke grenade
				Assert(pPed->GetWeaponManager());
				const s32 iVehicleIndex = -1; // not a vehicle weapon
				const bool bCreateWeaponWhenLoaded = true;
				pPed->GetWeaponManager()->EquipWeapon(WEAPONTYPE_SMOKEGRENADE, iVehicleIndex, bCreateWeaponWhenLoaded);

				// we are now in progress
				m_bSmokeGrenadeThrowInProgress = true;

				// need a weapon switch
				return true;
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////
// The moving out to fire function now handles both normal and blind firing
bool CTaskInCover::CheckForMovingOutToFire(s32& newState)
{
	CPed* pPed = GetPed();

	// Wait for the anims to load in
	if (!AreWeaponClipsetsLoadedForPed(*pPed))
	{
		AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : Weapon clipsets aren't loaded\n");
		return false;
	}

	if (pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForcedToStayInCover) || pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForcedToStayInCoverDueToPlayerSwitch))
	{
		AI_LOG_WITH_ARGS_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : ForcedToStayInCover %s, ForcedToStayInCoverDueToPlayerSwitch %s\n", AILogging::GetBooleanAsString(pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForcedToStayInCover)), AILogging::GetBooleanAsString(pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForcedToStayInCoverDueToPlayerSwitch)));
		return false;
	}

	if( pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForceInitialPeekInCover) )
	{
		AI_LOG_WITH_ARGS_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : ForceInitialPeekInCover %s\n", AILogging::GetBooleanAsString(pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForceInitialPeekInCover)));
		return false;
	}

	CPedIntelligence* pPedIntelligence = pPed->GetPedIntelligence();
	CTaskReloadGun* pReloadTask = static_cast<CTaskReloadGun*>(pPedIntelligence->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN));
	bool bCanInterruptReload = false;
	if (ms_Tunables.m_EnableReloadingWhilstMovingInCover && pReloadTask)
	{
		CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();
		if (pWeapon && !pWeapon->GetNeedsToReload(true)) 
		{
			if (pPed->IsLocalPlayer() && (!m_bLetGoOfAimAfterStartingReload || pReloadTask->GetCreatedAmmoClip() || pReloadTask->GetCreatedAmmoClipInLeftHand()))
			{
				AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : Reload condition passed\n");
				return false;
			}

#if FPS_MODE_SUPPORTED
			if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && pPed->GetPlayerInfo() && !pPed->GetPlayerInfo()->IsAiming())
			{
				return false;
			}
#endif // FPS_MODE_SUPPORTED

			bCanInterruptReload = true;
		}
		else
		{
			AI_LOG_WITH_ARGS_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : pWeapon %p\n", pWeapon);
			return false;
		}
	}

	if (!CTaskCover::IsCoverClipSetLoaded(CTaskCover::ms_Tunables.GetCoreWeaponAimingClipSetIdForPed(*pPed)))
	{
		AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : core weapon intro clipset isn't loaded\n");
		return false;
	}

	const CWeaponInfo* pWeaponInfo = pPed->GetEquippedWeaponInfo();
	if (pWeaponInfo)
	{
		fwMvClipSetId coverWeaponClipset = pWeaponInfo->GetPedCoverWeaponClipSetId(*pPed);
		if (!CTaskCover::IsCoverClipSetLoaded(coverWeaponClipset))
		{
			AI_LOG_WITH_ARGS_IF_LOCAL_PLAYER(pPed,"[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : cover weapon clipset %s isn't loaded\n", coverWeaponClipset.GetCStr());
			return false;
		}
	}


	if (static_cast<CTaskCover*>(GetParent())->GetForcedExit() == CTaskCover::FE_Aim)
	{
		newState = State_AimIntro;
		return true;
	}

	if (IsCoverFlagSet(CTaskCover::CF_DisableAimingAndPeeking) 
		|| IsCoverFlagSet(CTaskCover::CF_RunningPinnedVariation))
	{
		return false;
	}

	if (!pPed->IsLocalPlayer() && IsCoverFlagSet(CTaskCover::CF_RunningIdleVariation))
	{
		CTaskMotionInCover* pMotionInCoverTask = static_cast<CTaskMotionInCover*>(GetSubTask());
		if (pMotionInCoverTask && !pMotionInCoverTask->CanInterruptIdleVariation())
		{
			return false;
		}
	}

	if (ms_Tunables.m_EnableAimDirectlyIntros)
	{
		if (!IsAtOutsideEdge() && (!IsInMotionState(CTaskMotionInCover::State_Peeking) && !ms_Tunables.m_UseAutoPeekAimFromCoverControls))
		{
			AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : aim directly intro condition passed\n");
			return false;
		}
	}

	// Check if our firing pattern is still sitting on a finished burst
	const bool bLocalPlayerInControl = pPed->IsLocalPlayer() && pPed->GetPlayerInfo() && !pPed->GetPlayerInfo()->AreControlsDisabled() && !pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_WaitingForPlayerControlInterrupt);
	if(!bLocalPlayerInControl && pPedIntelligence->GetFiringPattern().IsBurstFinished())
	{
		return false;
	}

	// Find out what happen we have and how that relates to us being able to fire or blind fire
	CWeapon* pEquippedWeapon = pPed->GetWeaponManager() ? pPed->GetWeaponManager()->GetEquippedWeapon() : NULL;
	if( !pEquippedWeapon )
	{
		AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : no equipped weapon\n");
		return false;
	}
	
	const CWeaponInfo* pEquippedWeaponInfo = pEquippedWeapon->GetWeaponInfo();
	const CWeaponInfo* pObjectWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfoFromObject(); //verify object in hand is in synch (or non-existant)) B* 1500172
	bool bCanWeaponFire = (pEquippedWeaponInfo->GetIsGunOrCanBeFiredLikeGun() || pEquippedWeaponInfo->GetCanBeAimedLikeGunWithoutFiring()) && (!pObjectWeaponInfo || pObjectWeaponInfo == pEquippedWeaponInfo);
	bool bHasSniper = pEquippedWeaponInfo->GetGroup() == WEAPONGROUP_SNIPER;
	bool bCanBeAimedWithoutFiring = pEquippedWeaponInfo->GetCanBeAimedLikeGunWithoutFiring();
	bool bCanWeaponBlindFire = bCanWeaponFire && !bHasSniper && !bCanBeAimedWithoutFiring;
	bool bCanPositionBlindFire = !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) || IsCoverFlagSet(CTaskCover::CF_AtCorner);

	// Block blind fire if local ped is within an air defence zone.
	if (bCanPositionBlindFire && pPed->GetPedResetFlag(CPED_RESET_FLAG_InAirDefenceSphere))
	{
		bCanPositionBlindFire = false;
	}

	if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && IsFPSPeekPositionObstructed(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
	{
		bCanPositionBlindFire = false;
	}

	// Weapon must be ready to fire before moving out
	if (pEquippedWeapon->GetTimeBeforeNextShot() > 0.0f)
	{
		AI_LOG_WITH_ARGS_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : time before next shot %.2f\n", pEquippedWeapon->GetTimeBeforeNextShot());
		return false;
	}

	// We need to switch weapons first
	if (pPed->GetWeaponManager()->GetEquippedWeaponObjectHash() != pPed->GetWeaponManager()->GetSelectedWeaponHash())
	{
		AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : need to switch weapons\n");
		return false;
	}

	//Finish outro so you can reload or switch weapons
	if (GetState()==State_AimOutro && pEquippedWeaponInfo->GetUsesAmmo() && pEquippedWeapon->GetAmmoInClip() <= 0)
	{
		AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : need to finish outro for reload\n");
		return false;
	}

	//Allow the reload of rpg to finish before coming out of cover
	if (pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_IsSwitchingWeapon) && pObjectWeaponInfo->GetIsRpg())
	{
		AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : switching from RPG\n");
		return false;
	}
	
	// Player and AI logic is different
	if (pPed->IsLocalPlayer())
	{
		// Don't let the player move out if the weapon wheel is active
		if (CNewHud::IsShowingHUDMenu())
		{
			AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : showing HUD menu\n");
			return false;
		}

		bool bTryBlindFire = false;
		bool bDisallowTurnUntilInputZeroed = false;
		if (!CTaskMotionInCover::PlayerCheckForTurning(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), IsCoverFlagSet(CTaskCover::CF_AtCorner), false, GetStickInput(), GetCameraHeadingVec(), IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), GetState() == State_Peeking, bDisallowTurnUntilInputZeroed))
		{
			// For normal firing the player has to have a valid weapon and be aiming + firing, or 
			// trying to blind fire but in a position to aim directly
			const bool bWantsToAim = pPed->GetPlayerInfo()->IsAiming(false);
			const bool bWantsToBlindFire = pPed->GetPlayerInfo()->IsFiring() && !bWantsToAim;

			bool bShouldAimDirectly = false;
			bool bShouldComeOutToAimFromBlindFire = false;
			if (bWantsToAim FPS_MODE_SUPPORTED_ONLY(|| pPed->IsFirstPersonShooterModeEnabledForPlayer(false)))
			{
				// If we want to aim then we'll only aim directly if we aren't blocked, otherwise we'll force a stand up
				bShouldAimDirectly = CTaskInCover::ShouldAimDirectly(*pPed, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), m_bForcedBlockAimDirectly, 0.0f, false) && !m_bForcedBlockAimDirectly;
			}
			else if (bWantsToBlindFire)
			{
				// If we want to blindfire then we need to make sure we only blindfire if we don't want to aim directly, or stand up
				bShouldAimDirectly = CTaskInCover::ShouldAimDirectly(*pPed, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), m_bForcedBlockAimDirectly, 0.0f, true) && !m_bForcedBlockAimDirectly;
				bShouldComeOutToAimFromBlindFire = bShouldAimDirectly || m_bForcedBlockAimDirectly;
			}

			bool bShouldComeOutToAim = bWantsToAim || bShouldComeOutToAimFromBlindFire FPS_MODE_SUPPORTED_ONLY(|| ForceAimDueToDirectAimInFPM(bShouldAimDirectly));			

			if (bShouldAimDirectly)
				SetCoverFlag(CTaskCover::CF_AimDirectly);
			else
				ClearCoverFlag(CTaskCover::CF_AimDirectly);

			if (bCanWeaponFire && bShouldComeOutToAim)
			{
				CheckForOverTheTopFiring();

				if (bShouldAimDirectly && !static_cast<CTaskCover*>(GetParent())->IsCoreWeaponClipSetLoaded())
				{
					AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : should aim directly but core weapon clipset not loaded\n");
					return false;
				}

				if ( bCanInterruptReload ) 
					static_cast<CTaskReloadGun*>(pReloadTask)->RequestInterrupt();

				TUNE_GROUP_BOOL(COVER_TUNE, DO_GROUND_TEST_WHEN_MOVING_OUT_TO_FIRE, true);
				if (DO_GROUND_TEST_WHEN_MOVING_OUT_TO_FIRE)
				{
					if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AtCorner))
					{
						Vector3 vIntersectionUnused;
						if (!FindWallIntersection(*pPed, VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()), VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector()), VEC3V_TO_VECTOR3(pPed->GetTransform().GetB()), vIntersectionUnused, eHighCloseToEdgeTest, NULL, false))
						{
							SetCoverFlag(CTaskCover::CF_CloseToPossibleCorner);
						}
						else
						{
							ClearCoverFlag(CTaskCover::CF_CloseToPossibleCorner);
						}
					}

					Vector3 stepOutMoverPosition;
					float dummyHeading;
					bool shouldAimDirectly		= false;
					ComputeCoverAimPositionAndHeading(stepOutMoverPosition, dummyHeading, shouldAimDirectly, true);
					if (!shouldAimDirectly)
					{
						TUNE_GROUP_FLOAT(COVER_TUNE, Z_OFFSET_FOR_GROUND_PROBE_ON_STAIRS, 1.5f, 0.0f, 2.0f, 0.01f);
						TUNE_GROUP_FLOAT(COVER_TUNE, Z_OFFSET_FOR_GROUND_PROBE, 1.25f, 0.0f, 2.0f, 0.01f);
						TUNE_GROUP_FLOAT(COVER_TUNE, Z_OFFSET_FOR_BACKWARDS_GROUND_PROBE, 1.5f, 0.0f, 2.0f, 0.01f);
						const float fZOffsetForGroundProbe = pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_OnStairs) ? Z_OFFSET_FOR_GROUND_PROBE_ON_STAIRS : Z_OFFSET_FOR_GROUND_PROBE;
						Vector3 vStart = stepOutMoverPosition;
						Vector3 vEnd = vStart - Vector3(0.0f, 0.0f, fZOffsetForGroundProbe);
						Vector3 vIntersectionPos;
						const phInst* pHitInst = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPos, NULL, NULL, true);
						if (!pHitInst)
						{
							// If we didn't hit anything on the first test, set m_bForcedStepBack so we alter the position to step back and retest
							m_bForcedStepBack = true;
							shouldAimDirectly = false;
							ComputeCoverAimPositionAndHeading(stepOutMoverPosition, dummyHeading, shouldAimDirectly, true);
							vStart = stepOutMoverPosition;
							vEnd = vStart - Vector3(0.0f, 0.0f, Z_OFFSET_FOR_BACKWARDS_GROUND_PROBE);
							const phInst* pHitInst = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPos, NULL, NULL, true);
							if (!pHitInst)
							{
								// Still didn't hit any ground, reset the forced step back flag and prevent stepping out to fire, we must be on a thin ledge
								m_bForcedStepBack = false;
								bTryBlindFire = true;									
							}
						}
						
					}
				}
				
				if (!bTryBlindFire)
				{
					m_bAimWithoutAmmo = pEquippedWeapon->GetAmmoTotal() <=0;
					newState = State_AimIntro;
					return true;
				}				
			}
			// For blind firing they  need a blind fire weapon and have the can blind fire flag set
			if(bCanWeaponBlindFire && IsCoverFlagSet(CTaskCover::CF_CanBlindFire) && (pReloadTask == NULL))
			{
				// We'll need to either have a heavy weapon and be firing, or simply not aiming and be firing
				if ((!pPed->GetPlayerInfo()->IsAiming() || bTryBlindFire) && pPed->GetPlayerInfo()->IsFiring())
				{
					TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DISABLE_BLIND_FIRE_IN_HIGH_COVER_IF_CANT_FIRE_CORNER, true);
					// if the cover point isn't too high or we're at a corner we can blind fire
					if (bCanPositionBlindFire)
					{
						bool bCanBlindFire = true;
						// Make sure we got ammo
						if (pEquippedWeapon->GetAmmoInClip() <= 0)
						{
							AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : no ammo\n");
							bCanBlindFire =  false;
						}
						else if (pPed->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_SWAP_WEAPON))
						{
							AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : swapping weapon\n");
							bCanBlindFire = false;
						}
						else if (!CheckBlindFireRange(pPed))
						{
							AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : range check failed\n");
							bCanBlindFire = false;
						}
						else if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && (!IsCoverFlagSet(CTaskCover::CF_AtCorner) || !CanBlindFireCorner(pPed)))
						{
							bCanBlindFire = CheckForBlindFireOverheadClearance(pPed, m_uBlindFireBreakGlass);
							AI_LOG_WITH_ARGS_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : overhead clearance = %s\n", AILogging::GetBooleanAsString(bCanBlindFire));
						} 
						else
						{
							// check if at a real edge
							if (pPed->IsLocalPlayer() && !pPed->GetPlayerInfo()->IsRoundCover() && pPed->GetPlayerInfo()->GetDynamicCoverEdgeDistance() < 0.0f)
							{
								AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : not at edge for blind fire\n");
								return false;
							}
						}

						if (bCanBlindFire) 
						{
							newState = State_BlindFiring; 
							m_bBlindFireWithAim = bTryBlindFire;
							return true;
						}
					}
					else
					{
						AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] FAILED : CTaskInCover::CheckForMovingOutToFire : can't blind fire from this position\n");
					}
				}
			}
		}
	}
	else if(GetTarget().GetIsValid())
	{
		// CWR 9/12/12 - Making it so that peds will not fire if they don't have LOS (if the flags line up that way)
		if( pPedIntelligence->GetCombatBehaviour().IsFlagSet(CCombatData::BF_RequiresLosToShoot) ||
			!pPedIntelligence->GetCombatBehaviour().IsFlagSet(CCombatData::BF_CanShootWithoutLOS) )
		{
			CPedTargetting* pPedTargetting = pPedIntelligence->GetTargetting( true );
			const CEntity* pTarget = GetTarget().GetEntity();
			if(pPedTargetting && pTarget && pTarget->GetIsTypePed())
			{
				// Force an immediate update if the ped isn't in combat as the targeting won't be getting updated
				LosStatus targetLos = pPedTargetting->GetLosStatus(pTarget, !pPed->GetPedResetFlag(CPED_RESET_FLAG_IsInCombat));
				if(targetLos == Los_blocked || targetLos == Los_unchecked)
				{
					return false;
				}
			}
		}

		//Check if the ped should fire.
		bool bShouldFire = false;
		
		//Check if cover fire was requested.
		if(IsCoverFlagSet(CTaskCover::CF_CoverFire))
		{	
			//Always respond to requests for cover fire.
			bShouldFire = true;
			
			//Do not blind fire when providing covering fire.
			bCanWeaponBlindFire = false;
		}
		
		//Check if the ped should randomly fire.
		if(!bShouldFire)
		{
			// For the AI they need their time between bursts to expire for normal or blind firing
			CCombatBehaviour& combatBehaviour = pPedIntelligence->GetCombatBehaviour();
			float fTimeBetweenBursts = combatBehaviour.GetCombatFloat(kAttribFloatTimeBetweenBurstsInCover) + m_fTimeBetweenBurstsRandomness;
			
			//Adjust the burst rate based on the combat orders.
			CCombatOrders* pCombatOrders = pPedIntelligence->GetCombatOrders();
			if(pCombatOrders)
			{
				//Get the time between bursts modifier.
				float fModifier = pCombatOrders->GetTimeBetweenBurstsModifier();

				//Apply the burst rate modifier.
				fTimeBetweenBursts *= fModifier;
			}
			
			if (fTimeBetweenBursts >= 0.0f && GetTimeInState() > fTimeBetweenBursts)
			{
				// This was the random % change of "firing"
				float fChanceOfFiring = MAX(0.5f * combatBehaviour.GetShootRateModifier(), 0.25f);
				if(fwRandom::GetRandomNumberInRange(0.0f, 1.0f) < fChanceOfFiring)
				{
					bShouldFire = true;
				}
			}
		}
		
		//Check if the ped should fire.
		if(bShouldFire)
		{
			// Check if we are pinned down
			bool bIsPinnedDown = false;
			if(pPedIntelligence->CanBePinnedDown())
			{
				if( pPedIntelligence->GetAmountPinnedDown() > ms_Tunables.m_PinnedDownTakeCoverAmount ||
					(fwTimer::GetTimeInMilliseconds() - pPedIntelligence->GetLastPinnedDownTime()) < ms_Tunables.m_MinTimeToBePinnedDown )
				{
					bIsPinnedDown = true;
				}
			}

			// AI does blind fire checks first. Regular cops cannot do blind fire and either the blind fire flag has to be set
			// or the random number has to be less than the percentage chance for this AI to blind fire
			if(!pPed->GetPedResetFlag(CPED_RESET_FLAG_BlockWeaponFire) && !IsCoverFlagSet(CTaskCover::CF_AimOnly) && bCanWeaponBlindFire && bCanPositionBlindFire)
			{
				// Force blind fire if the combat flag has been set
				if(pPedIntelligence->GetCombatBehaviour().IsFlagSet(CCombatData::BF_BlindFireWhenInCover))
				{
					if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) || CheckForBlindFireOverheadClearance(pPed, m_uBlindFireBreakGlass))											
					{
						newState = State_BlindFiring;
						return true;
					}
				}
				else 
				{
					// Otherwise make sure we're supposed to even have a chance of blind firing (law defaults to 0% chance)
					float fBlindFireChance = pPedIntelligence->GetCombatBehaviour().GetCombatFloat(kAttribFloatBlindFireChance);

					// We can then blind fire if we're pinned down (and not law enforcement) or our % succeeds
				    if( fBlindFireChance > 0.0f &&
						((bIsPinnedDown && !pPed->IsLawEnforcementPed()) || fwRandom::GetRandomNumberInRange(0.0f, 1.0f) <= fBlindFireChance) )
					{
						if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) || CheckForBlindFireOverheadClearance(pPed, m_uBlindFireBreakGlass))											
						{
							newState = State_BlindFiring;
							return true;
						}
					}
				}
			}
			
			// Otherwise we have to be able to fire our weapon
			if(bCanWeaponFire && !IsCoverFlagSet(CTaskCover::CF_AimOnly))
			{
				const bool bHigh = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
				bool bForcedBlockAimDirectly = false;
				float fOverlapTolerance = 0.0f;
				bool bAimDirectly = ShouldAimDirectly(*pPed, bHigh, bForcedBlockAimDirectly, fOverlapTolerance);

				if (bAimDirectly) 
					SetCoverFlag(CTaskCover::CF_AimDirectly);
				else
					ClearCoverFlag(CTaskCover::CF_AimDirectly);

				newState = State_AimIntro;
				return true;
			}
		}
	}

#if __BANK
	if (pPed->GetPlayerInfo() && (pPed->GetPlayerInfo()->IsAiming() || pPed->GetPlayerInfo()->IsFiring()))
	{
		AI_LOG_IF_LOCAL_PLAYER(pPed, "[Cover] Local player not moving out to aim / fire even though requesting through controls\n");
	}
#endif // __BANK

	return false;
}

//////////////////////////////////////////////////////////////////////////
bool CTaskInCover::CheckForBlindFireOverheadClearance(CPed* pPed, u8& uBlindFireBreakGlass)
{
	//check for overhead clearance
	// Calculate the aim vector (this determines the heading and pitch angles to point the clips in the correct direction)
	Vector3 vStart(Vector3::ZeroType);
	Vector3 vEnd(Vector3::ZeroType);

	CCoverPoint* pCoverPoint = pPed->GetCoverPoint();
	if (pCoverPoint)
	{
		WorldProbe::CShapeTestFixedResults<> capsuleResult;
		s32 iTypeFlags = ArchetypeFlags::GTA_ALL_MAP_TYPES|ArchetypeFlags::GTA_VEHICLE_TYPE|ArchetypeFlags::GTA_OBJECT_TYPE;
		WorldProbe::CShapeTestCapsuleDesc capsuleDesc;
		static dev_float sfBlindFireCapsuleRadius = 0.05f;
		static dev_float sfBlindFireCapsuleHeightOffset = 0.4f;
		vStart = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());

		// If we're stood inside a plane, then we don't want to use the world axes as the basis for our capsule test
		// as if the entity we'll get inconsistent results when the entity's orientation changes B*1001918
		// May want to apply this for any vehicle we can take cover inside in future, or even on sloped ground
		TUNE_GROUP_BOOL(COVER_BLINDFIRE_TUNE, USE_GROUND_ENTITY_BASIS_FOR_OBSTRUCTION_TESTS, true);
		const bool bCoverMayNotBeAlignedWithWorldUp = USE_GROUND_ENTITY_BASIS_FOR_OBSTRUCTION_TESTS && 
			pPed->IsLocalPlayer() && pPed->GetGroundPhysical() && 
			pPed->GetGroundPhysical()->GetIsTypeVehicle() && static_cast<CVehicle*>(pPed->GetGroundPhysical())->InheritsFromPlane();

		Vector3 vUpVec(0.0f, 0.0f, 1.0f);
		if (bCoverMayNotBeAlignedWithWorldUp)
		{
			// Use the thing we're attached to's up vector to shift height-wise
			vUpVec = VEC3V_TO_VECTOR3(pPed->GetGroundPhysical()->GetTransform().GetUp());
		}
		vStart += sfBlindFireCapsuleHeightOffset * vUpVec;
		Vector3 vCoverDir = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector(NULL));
		if (pPed->IsLocalPlayer())
		{
			vCoverDir = CTaskCover::ComputeCameraHeadingVec(*pPed);
		}
		else if (bCoverMayNotBeAlignedWithWorldUp)
		{
			// Make the cover dir in the attach entity's xy plane (Maybe the direction should already be stored in the vehicle space?)
			Vector3 vRightVec = VEC3V_TO_VECTOR3(pPed->GetGroundPhysical()->GetTransform().GetRight());
			Vector3 vFwdVec = VEC3V_TO_VECTOR3(pPed->GetGroundPhysical()->GetTransform().GetForward());
			const float fRightDot = CTaskInCover::GetXYDot(vRightVec, vCoverDir);
			const float fFwdDot = CTaskInCover::GetXYDot(vFwdVec, vCoverDir);
			vCoverDir = fRightDot * vRightVec + fFwdDot * vFwdVec;
			vCoverDir.Normalize();
		}

		vEnd = vStart;  vEnd.AddScaled(vCoverDir, 0.8f);

		TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, APPLY_BLINDFIRE_PEEK_OFFSET, true);
		if (APPLY_BLINDFIRE_PEEK_OFFSET && pPed->GetLowCoverHeightOffsetFromMover() > 0.0f && CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations)
		{
			vStart.z += pPed->GetLowCoverHeightOffsetFromMover();
			vEnd.z += pPed->GetLowCoverHeightOffsetFromMover();
		}

		capsuleDesc.SetResultsStructure(&capsuleResult);
		capsuleDesc.SetCapsule(vStart, vEnd, sfBlindFireCapsuleRadius);
		capsuleDesc.SetIncludeFlags(iTypeFlags);
		capsuleDesc.SetTypeFlags(ArchetypeFlags::GTA_AI_TEST);
		capsuleDesc.SetIsDirected(false);
		capsuleDesc.SetDoInitialSphereCheck(false);
#if DEBUG_DRAW
		CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), sfBlindFireCapsuleRadius, Color_DarkGreen, 1, 0, false);
#endif // DEBUG_DRAW
		if (WorldProbe::GetShapeTestManager()->SubmitTest(capsuleDesc))
		{
			// See if we hit our own window 					
			if (capsuleResult[0].GetHitInst()->GetArchetype()->GetTypeFlag(ArchetypeFlags::GTA_GLASS_TYPE) ==0 )
				return false; 	
			else
				uBlindFireBreakGlass = BF_WINDOWBREAK_SEARCHING;
		}	else
			uBlindFireBreakGlass = BF_WINDOWBREAK_NONE;
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CheckForReload(bool bIgnoreMotionChecks)
{
	// Wait for the anims to load in
	if (!static_cast<CTaskCover*>(GetParent())->IsWeaponClipSetLoaded())
	{
		return false;
	}

	CPed* pPed = GetPed();

	if (pPed->IsNetworkClone() && pPed->IsAPlayerPed())
	{
		if (pPed->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN))
		{
			return false;
		}

		if (pPed->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_SWAP_WEAPON))
		{
			return false;
		}
		return m_bWantsToReload;
	}

	bool bPassedMotionStateChecks = bIgnoreMotionChecks;

	if (!bPassedMotionStateChecks)
	{
		if (pPed->IsLocalPlayer() && ms_Tunables.m_EnableReloadingWhilstMovingInCover)
		{
			bPassedMotionStateChecks =  IsInMotionState(CTaskMotionInCover::State_AtEdge) || 
				IsInMotionState(CTaskMotionInCover::State_Stepping) || 
				IsInMotionState(CTaskMotionInCover::State_Idle) || 
				IsInMotionState(CTaskMotionInCover::State_PlayingIdleVariation) || 
				IsInMotionState(CTaskMotionInCover::State_Moving) || 
				IsInMotionState(CTaskMotionInCover::State_TurnEnter) || 
				IsInMotionState(CTaskMotionInCover::State_TurnEnd) || 
				IsInMotionState(CTaskMotionInCover::State_Settle) || 
				IsInMotionState(CTaskMotionInCover::State_WalkStart) ||
				IsInMotionState(CTaskMotionInCover::State_Stopping) ||
				IsInMotionState(CTaskMotionInCover::State_StoppingAtEdge) ||
				IsInMotionState(CTaskMotionInCover::State_StoppingAtInsideEdge) ||
				IsInMotionState(CTaskMotionInCover::State_Peeking);
		}
		else
		{
			bPassedMotionStateChecks =	IsInMotionState(CTaskMotionInCover::State_AtEdge) || 
				IsInMotionState(CTaskMotionInCover::State_Idle) || 
				IsInMotionState(CTaskMotionInCover::State_Peeking);
		}
	}

	if (bPassedMotionStateChecks)
	{
		weaponAssert(pPed->GetWeaponManager());
		CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();
		if (pWeapon && pWeapon->GetCanReload())
		{
			bool bReload = m_bOutroToReload;

			// Force reload if required
			bool bIgnoreNeedsToReloadCheck = false;
			
			if (NetworkInterface::IsGameInProgress() && pWeapon->GetWeaponInfo() && pWeapon->GetWeaponInfo()->GetIsRpg())
			{
				// Weapon removed from inventory, no need to reload
				const CWeaponItem* pWeaponItem = pPed->GetInventory() ? pPed->GetInventory()->GetWeapon(pWeapon->GetWeaponHash()) : NULL;
				if (!pWeaponItem)
				{
					bIgnoreNeedsToReloadCheck = true;
				}
			}
			
			if (!bIgnoreNeedsToReloadCheck && pWeapon->GetNeedsToReload(true))
			{
				bReload = true;
			}
			else if(pPed->IsLocalPlayer())
			{
				CControl *pControl = pPed->GetControlFromPlayer();
				if ( pControl->GetPedReload().IsPressed() || pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForceReload))
				{
					bReload = true;
				}

				if (static_cast<CTaskCover*>(GetParent())->GetWantedToReloadDuringEntry())
				{
					if (!pPed->GetWeaponManager()->GetRequiresWeaponSwitch())
					{
						bReload = true;
					}
					static_cast<CTaskCover*>(GetParent())->SetWantedToReloadDuringEntry(false);
				}
#if USE_SIXAXIS_GESTURES
				if (CControlMgr::GetPlayerPad() && CPadGestureMgr::GetMotionControlEnabled(CPadGestureMgr::MC_TYPE_RELOAD) && !bReload)
				{
					CPadGesture* gesture = CControlMgr::GetPlayerPad()->GetPadGesture();
					if (gesture && gesture->GetHasReloaded())
					{
						bReload = true;
					}
				}
#endif // USE_SIXAXIS_GESTURES
			}

			return bReload;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CheckForDetonation()
{
	if (IsInMotionState(CTaskMotionInCover::State_AtEdge) || IsInMotionState(CTaskMotionInCover::State_Idle))
	{
		CPed* pPed = GetPed();
		if (pPed->IsLocalPlayer())
		{
			const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager() ? pPed->GetWeaponManager()->GetEquippedWeaponInfo() :NULL;
			if (pWeaponInfo && pWeaponInfo->GetIsDetonator() && pPed->GetPlayerInfo()->IsFiring())
			{
				return true;
			}
		}
	}
	return false;
}

// Check for our desired pinned down state
bool CTaskInCover::CheckDesiredPinnedDownState(s32& newState)
{
	// Check if we can fire otherwise check if we can peek normally
	if(CheckForMovingOutToFire(newState))
	{
#if __ASSERT
		if (newState == State_AimIntro)
		{
			const fwMvClipSetId weaponClipSetId = CTaskCover::GetWeaponClipSetForArmament(GetPed(), !GetPed()->IsAPlayerPed());
			const bool bClipSetLoaded = CTaskCover::IsCoverClipSetLoaded(weaponClipSetId);
			aiDisplayf("3 : Frame : %i, Clipset %s %s for ped %s", fwTimer::GetFrameCount(), weaponClipSetId.GetCStr(), bClipSetLoaded ? "LOADED":"NOT LOADED", GetPed()->GetDebugName());
		}
#endif // __ASSERT

		// Local player should always move out to fire
		if(GetPed()->IsLocalPlayer())
		{
			return true;
		}

		// If we chose normal firing we need to decide between peeking (if allowed) and firing
		bool bCanPeek = CheckForPeeking();
		if(bCanPeek && (newState == State_AimIntro || fwRandom::GetRandomNumberInRange(0.0f, 1.0f) < ms_Tunables.m_PinnedDownPeekChance))
		{
			newState = State_Peeking;
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		}

		return newState != State_AimIntro;
	}
	else if(CheckForPeeking())
	{
		newState = State_Peeking;
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::IsCoverValid() const
{
	const CPed& rPed = *GetPed();

	if(!rPed.GetCoverPoint())
	{
		return false;
	}
	return CTaskCover::IsCoverValid(*(rPed.GetCoverPoint()), rPed);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ProcessReloadSecondaryTask()
{
	CPed& ped = *GetPed();
	if (ped.IsAPlayerPed())
	{
		if (!m_bLetGoOfAimAfterStartingReload)
		{
			m_bLetGoOfAimAfterStartingReload = !ped.GetPlayerInfo()->IsAiming(false) FPS_MODE_SUPPORTED_ONLY(&& !CTaskCover::IsPlayerAimingDirectlyInFirstPerson(ped));
		}

#if FPS_MODE_SUPPORTED
		if (ped.IsFirstPersonShooterModeEnabledForPlayer(false) && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && GetState() == State_BlindFiring)
		{
			const CTaskAimGunBlindFire* pBlindFireTask = static_cast<const CTaskAimGunBlindFire*>(FindSubTaskOfType(CTaskTypes::TASK_AIM_GUN_BLIND_FIRE));
			if (pBlindFireTask && !pBlindFireTask->CanInterruptOutro())
			{
				return;
			}
		}
#endif // FPS_MODE_SUPPORTED

		if (CheckForReload())
		{
			CTask* pTask = ped.GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN);
			if (!pTask)
			{
				m_bLetGoOfAimAfterStartingReload = false;
				m_bOutroToReload = false;
				s32 iReloadFlags = RELOAD_SECONDARY | RELOAD_COVER;
				ped.GetPedIntelligence()->AddTaskSecondary(rage_new CTaskReloadGun(CWeaponController::WCT_Player, iReloadFlags), PED_TASK_SECONDARY_PARTIAL_ANIM);			
			}
			else
				m_bOutroToReload = false;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ProcessWeaponSwapSecondaryTask()
{
	CPed& ped = *GetPed();
	if (ped.IsLocalPlayer() && CheckForSwitchingWeapon() && GetState() != State_AimOutro)
	{
		CTask* pTask = ped.GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_SWAP_WEAPON);
		if (!pTask)
		{
			s32 iFlags = SWAP_HOLSTER|SWAP_ABORT_SET_DRAWN|SWAP_DRAW|SWAP_SECONDARY;
			
// 			TUNE_GROUP_BOOL(COVER_TUNE, FORCE_SWAP_INSTANTLY, false);
// 			if(NetworkInterface::IsGameInProgress() || FORCE_SWAP_INSTANTLY)
// 			{
// 				iFlags |= SWAP_INSTANTLY;
// 			}
			ped.GetPedIntelligence()->AddTaskSecondary(rage_new CTaskSwapWeapon(iFlags), PED_TASK_SECONDARY_PARTIAL_ANIM);			
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ProcessCoverStep(CTaskMotionAiming* pMotionAimingTask, CPed* pPed)
{
#if FPS_MODE_SUPPORTED
	INSTANTIATE_TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DISABLE_AUTO_STEP_AROUND);
	if (DISABLE_AUTO_STEP_AROUND && pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && !pPed->GetPlayerInfo()->IsAiming(false) && !IsCoverFlagSet(CTaskCover::CF_AimDirectly))
	{
		return;
	}
#endif // FPS_MODE_SUPPORTED

	if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		if (pPed->IsNetworkClone())
		{
			if (!pPed->GetPedIntelligence()->GetQueriableInterface()->IsTaskCurrentlyRunning(CTaskTypes::TASK_AIM_GUN_ON_FOOT))
			{
				return;
			}
		}

		if (pMotionAimingTask && pMotionAimingTask->GetState() != CTaskMotionAiming::State_CoverStep)
		{
			const s32 iDesiredArcIndex = ComputeDesiredArc(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), m_iCurrentCoverStepNodeIndex);
			if (m_iCurrentCoverStepNodeIndex != iDesiredArcIndex && m_iCurrentCoverStepNodeIndex != -1)
			{
				// If we're stepping back into cover then check if we should be aiming directly
				if (iDesiredArcIndex == 0)
				{
					s32 newState;
					CheckForMovingOutToFire(newState);
				}
				// Otherwise - if stepping out of cover then always assume we can't aim directly
				else
				{
					ClearCoverFlag(CTaskCover::CF_AimDirectly);
				}

				m_bWantsToTriggerStep = true;

				float fExtraScalar = 0.0f;
				const CTaskAimGunFromCoverIntro::AimStepInfoSet& aimStepInfoSet = CTaskAimGunFromCoverIntro::ms_Tunables.GetAimStepInfoSet(IsCoverFlagSet(CTaskCover::CF_FacingLeft));
				if (DetermineIfDesiredNodeIsNextNode(IsCoverFlagSet(CTaskCover::CF_FacingLeft), m_iCurrentCoverStepNodeIndex, iDesiredArcIndex))
				{
					m_CoverStepClipId = aimStepInfoSet.m_StepInfos[m_iCurrentCoverStepNodeIndex].m_NextTransitionClipId;
					fExtraScalar = aimStepInfoSet.m_StepInfos[m_iCurrentCoverStepNodeIndex].m_NextTransitionExtraScalar;		
				}
				else
				{
					m_CoverStepClipId = aimStepInfoSet.m_StepInfos[m_iCurrentCoverStepNodeIndex].m_PreviousTransitionClipId;
					fExtraScalar = aimStepInfoSet.m_StepInfos[m_iCurrentCoverStepNodeIndex].m_PreviousTransitionExtraScalar;
				}

				m_iPreviousCoverStepNodeIndex = iDesiredArcIndex;
				m_iCurrentCoverStepNodeIndex = iDesiredArcIndex;
				m_vInitialPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());

				fwMvClipSetId clipSetId = ms_Tunables.m_CoverStepClipSetId;
				const crClip* pClip = fwClipSetManager::GetClip(clipSetId, m_CoverStepClipId);		
				if (pClip)
				{
					bool bHigh = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
					bool bInHighCoverNotAtEdge = GetForcedStepBack() || (!IsCoverFlagSet(CTaskCover::CF_AtCorner) && bHigh);
					if (IsCoverFlagSet(CTaskCover::CF_CloseToPossibleCorner))
					{
						bInHighCoverNotAtEdge = false;
					}
					Vector3 vAimPosition = CTaskAimGunFromCoverIntro::ComputeCurrentStepOutPosition(IsCoverFlagSet(CTaskCover::CF_FacingLeft), *pPed, m_iCurrentCoverStepNodeIndex, bInHighCoverNotAtEdge, IsCoverFlagSet(CTaskCover::CF_CloseToPossibleCorner));
					aiDebugf1("STEP : m_iCurrentCoverStepNodeIndex = %i", m_iCurrentCoverStepNodeIndex);
					m_vClipTranslation = fwAnimHelpers::GetMoverTrackTranslationDiff(*pClip, 0.0f, 1.0f);
					const float fDistToTarget = (vAimPosition - m_vInitialPosition).Mag();
					const float fClipDist = m_vClipTranslation.Mag();
					taskAssert(fClipDist > 0.0f);
					m_fExtraTranslation = fDistToTarget < fClipDist ? Abs(fClipDist - fDistToTarget) : 0.0f;
					TUNE_GROUP_FLOAT(COVER_STEP_TUNE, MAX_EXTRA_DISTANCE, 0.0f, 0.0f, 1.0f, 0.01f);
					m_fExtraTranslation = rage::Clamp(m_fExtraTranslation, 0.0f, MAX_EXTRA_DISTANCE);
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::UpdatePlayerInput(CPed *pPlayerPed)
{
	CControl *pControl = pPlayerPed->GetControlFromPlayer();
	Vector2 vecStick(pControl->GetPedWalkLeftRight().GetNorm(), -pControl->GetPedWalkUpDown().GetNorm());

	const float fCamHeading = camInterface::GetGameplayDirector().GetFrame().ComputeHeading();

	// the work involved to convert all occurrences of vecStick (and m_vecStick) to the new -1...+1 range is too high and involves
	// editing metadata so we are just going to continue using old input ranges.
	vecStick *= 128.0f;
	if (m_bStickHeadingLockEnabled)
	{
		if (m_fLockedStickHeading == -1.0f)
			m_fLockedStickHeading = fCamHeading + -rage::Atan2f(-m_vCoverDirection.x, m_vCoverDirection.y);

		vecStick.Rotate(m_fLockedStickHeading);
		if (vecStick.IsClose(Vector2(0,0), 0.01f))
		{
			m_bStickHeadingLockEnabled = false;
			m_fLockedStickHeading = -1.0f;
		}
	} 
	else 
	{
#if FPS_MODE_SUPPORTED
		bool bForcedBlockAimDirectly = false;
		// This needs to work for the unarmed state (and melee weapons) so unfortunately can't check the CF_AimDirectly flag
		if (pPlayerPed->IsFirstPersonShooterModeEnabledForPlayer(false) && !ShouldAimDirectly(*pPlayerPed, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), bForcedBlockAimDirectly))
		{
			// Try to move left/right in first person high cover when pushing forward on the stick
			if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AtCorner) && 
				vecStick.y > CTaskInCover::ms_Tunables.m_MinStickInputToMoveInCover && Abs(vecStick.x) < CTaskInCover::ms_Tunables.m_MinStickInputToMoveInCover)
			{
				vecStick.x = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? -vecStick.y : vecStick.y;
			}
		}
		else
#endif
		{
			vecStick.Rotate(fCamHeading);
			vecStick.Rotate(-rage::Atan2f(-m_vCoverDirection.x, m_vCoverDirection.y));
		}
	}
	m_vecStick = vecStick;

#if __BANK
	if (CCoverDebug::ms_Tunables.m_OutputStickInputToTTY)
	{
		Displayf("Stick input : %.2f, %.2f", m_vecStick.x, m_vecStick.y);
	}
#endif
}


////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::StoreCoverInformation()
{
	CPed* pPed = GetPed();

	if (pPed && pPed->GetCoverPoint() && (pPed->GetCoverPoint()->GetHeight() == CCoverPoint::COVHEIGHT_TOOHIGH))
		SetCoverFlag(CTaskCover::CF_TooHighCoverPoint);
	else
		ClearCoverFlag(CTaskCover::CF_TooHighCoverPoint);

	if (GetCanFireRoundCorner())
		SetCoverFlag(CTaskCover::CF_AtCorner);
	else
		ClearCoverFlag(CTaskCover::CF_AtCorner);

	if (UseOverTheTopFiring())
		SetCoverFlag(CTaskCover::CF_UseOverTheTopFiring);
	else
		ClearCoverFlag(CTaskCover::CF_UseOverTheTopFiring);
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipId CTaskInCover::GetClipIdForIndex(s32 j)
{
	switch (j)
	{
		case 0: return ms_Clip0Id;
		case 1: return ms_Clip1Id;
		case 2: return ms_Clip2Id;
		case 3: return ms_Clip3Id;
		default: break;
	}
	return CLIP_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipId CTaskInCover::GetWeaponClipIdForIndex(s32 j)
{
	switch (j)
	{
		case 0: return ms_WeaponClip0Id;
		case 1: return ms_WeaponClip1Id;
		case 2: return ms_WeaponClip2Id;
		case 3: return ms_WeaponClip3Id;
		case 4: return ms_WeaponClip4Id;
		case 5: return ms_WeaponClip5Id;
		default: break;
	}
	return CLIP_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CheckForAimOutroInterrupt() const
{
	const CPed& rPed = *GetPed();

	// Don't check clone and non local player peds
	if (rPed.IsNetworkClone() || !rPed.IsLocalPlayer())
	{
		return false;
	}

	// Abort early if no coverpoint
	if (!rPed.GetCoverPoint())
	{
		return true;
	}

	const bool bIsBlindFiring = GetState() == State_BlindFiring;
	fwMvBooleanId interruptId = bIsBlindFiring ? CTaskAimGunBlindFire::ms_BlindFireOutroInterruptId : CTaskAimGunFromCoverOutro::ms_OutroAimInterruptId;

	const bool bCanInterruptToAim = m_TaskUseCoverMoveNetworkHelper.GetBoolean(CTaskAimGunFromCoverOutro::ms_OutroToIntroAimInterruptId);
	const bool bWantsToInterruptToAim = rPed.GetPlayerInfo()->IsAiming();

	if (bCanInterruptToAim && bWantsToInterruptToAim)
	{
		return true;
	}

	// Check for anim interrupt event and check interrupt conditions
	if (m_TaskUseCoverMoveNetworkHelper.GetBoolean(interruptId))
	{
		const Vector2 vStickInput = CTaskCover::ComputeStickInput(rPed);
		const Vector3 vCoverDirection = VEC3V_TO_VECTOR3(rPed.GetCoverPoint()->GetCoverDirectionVector());
		Vector3 vCoverPosition;
		if (rPed.GetCoverPoint()->GetCoverPointPosition(vCoverPosition))
		{
			const bool bPedFacingCorrectDirection = CTaskMotionInCover::IsPedsheadingCloseEnoughToFacingDirection(rPed, vCoverDirection, IsCoverFlagSet(CTaskCover::CF_FacingLeft), 0.1f);
			TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, CLOSE_TOLERANCE, 0.02f, 0.0f, 1.0f, 0.01f);
			const bool bPedCloseToCover = CTaskMotionInCover::IsPedCloseEnoughToCover(rPed, vCoverPosition, CLOSE_TOLERANCE);
			bool bDisallowTurnUntilInputZeroed = false;
			if (bPedFacingCorrectDirection && (bIsBlindFiring || bPedCloseToCover) && (CTaskMotionInCover::PlayerCheckForMovingAbout(rPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), vStickInput) ||
				CTaskMotionInCover::PlayerCheckForTurning(rPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), IsCoverFlagSet(CTaskCover::CF_AtCorner), false, vStickInput, CTaskCover::ComputeCameraHeadingVec(rPed), IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), GetState() == State_Peeking, bDisallowTurnUntilInputZeroed) ||
				bWantsToInterruptToAim || rPed.GetPlayerInfo()->IsFiring() || (bIsBlindFiring && m_bOutroToReload)))
			{
				return true;
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::RestartWeaponHolding()
{
	if (m_TaskMotionInCoverMoveNetworkHelper.IsNetworkAttached())
	{
		CPed* pPed = GetPed();

		const bool bIgnoreWeaponObjectCheck = true;
		const fwMvClipSetId desiredWeaponHoldingClipSetId = CTaskCover::GetWeaponHoldingClipSetForArmament(pPed, bIgnoreWeaponObjectCheck);
		const fwMvClipSetId currentWeaponHoldingClipSetId = m_TaskMotionInCoverMoveNetworkHelper.GetClipSetId(CTaskMotionInCover::ms_UpperBodyWeaponMotionClipSetId);
		m_TaskMotionInCoverMoveNetworkHelper.SetClipSet(desiredWeaponHoldingClipSetId, CTaskMotionInCover::ms_UpperBodyWeaponMotionClipSetId);

		const bool bUseWeaponHolding = desiredWeaponHoldingClipSetId != CLIP_SET_ID_INVALID;
		if (bUseWeaponHolding && desiredWeaponHoldingClipSetId != currentWeaponHoldingClipSetId)
		{
			// If we're switching from weapon holding to weapon holding we need to restart the state
			if (bUseWeaponHolding && currentWeaponHoldingClipSetId != desiredWeaponHoldingClipSetId)
			{
				m_TaskMotionInCoverMoveNetworkHelper.SendRequest(CTaskMotionInCover::ms_RestartWeaponHoldingRequestId);
			}

			s32 iFlags = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? CTaskCover::AF_FaceLeft : 0;
			if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
			{
				iFlags |= CTaskCover::AF_Low;
			}

			if (IsCoverFlagSet(CTaskCover::CF_AtCorner))
			{
				iFlags |= CTaskCover::AF_AtEdge;
			}
			
			CTaskMotionInCover* pMotionInCoverTask = static_cast<CTaskMotionInCover*>(pPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_MOTION_IN_COVER));
			if (pMotionInCoverTask)
			{
				const CTaskCover::CoverAnimStateInfo* pAnimStateInfo = pMotionInCoverTask->GetAnimStateInfoForState();
				if (taskVerifyf(pAnimStateInfo, "NULL anim state info"))
				{
					fwMvClipSetId weaponMotionClipSetId = m_TaskMotionInCoverMoveNetworkHelper.GetClipSetId(CTaskMotionInCover::ms_UpperBodyWeaponMotionClipSetId);

					for (s32 i=0; i<pAnimStateInfo->m_Clips.GetCount(); ++i)
					{	
						taskAssert(pAnimStateInfo->m_Clips[i] != CLIP_ID_INVALID);

						const crClip* pWeaponClip = NULL;
						if (weaponMotionClipSetId != CLIP_SET_ID_INVALID)
						{
							pWeaponClip = fwClipSetManager::GetClip(weaponMotionClipSetId, pAnimStateInfo->m_Clips[i]);
						}

						if (pWeaponClip)
						{
							m_TaskMotionInCoverMoveNetworkHelper.SetClip(pWeaponClip, CTaskMotionInCover::GetWeaponClipIdFromIndex(i));
						}
					}
				}
			}
		}

		m_TaskMotionInCoverMoveNetworkHelper.SetFlag(bUseWeaponHolding, CTaskMotionInCover::ms_UseWeaponHoldingId);

		if (!bUseWeaponHolding)
		{			
			CTaskMotionInCover::SetGripClip(pPed, m_TaskMotionInCoverMoveNetworkHelper);			
		}
		else
		{
			// Shouldn't use grip if we're using a weapon holding anim
			m_TaskMotionInCoverMoveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_UseGripClipId);

			const fwMvFilterId weaponHoldingFilterId = CTaskMotionInCover::ms_Tunables.GetWeaponHoldingFilterIdForPed(*GetPed());
			if (weaponHoldingFilterId != FILTER_ID_INVALID)
			{
				crFrameFilter* pWeaponHoldingFrameFilter = g_FrameFilterDictionaryStore.FindFrameFilter(weaponHoldingFilterId);
				m_TaskMotionInCoverMoveNetworkHelper.SetFilter(pWeaponHoldingFrameFilter, CTaskMotionInCover::ms_WeaponHoldingFilterId);		
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::ComputeStickInputPolarForm(const Vector2& vStickInput, float& fMagnitude, float& fAngle)
{
	const float fNormX = Clamp((vStickInput.x / 128.0f), -1.0f, 1.0f);
	const float fNormY = Clamp((vStickInput.y / 128.0f), -1.0f, 1.0f);
	fMagnitude = sqrt(square(fNormX) + square(fNormY));

	if (fMagnitude <= SMALL_FLOAT)
		return false;

	fAngle = Atan2f(fNormX, fNormY);
	return true;
}

void CTaskInCover::CacheStickAngle()
{
	float fMagnitude = 0.0f;
	if (ComputeStickInputPolarForm(m_vecStick, fMagnitude, m_fCachedStickAngle))
	{
		m_bCachedStickValid = true;
	}
	else
	{
		m_bCachedStickValid = false;
	}
}

bool CTaskInCover::GetCanFireRoundCorner(bool bShouldConsiderTurningDirection) const
{
	const CPed* pPed = GetPed();

	bool bFacingLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
	if(bShouldConsiderTurningDirection && IsInMotionState(CTaskMotionInCover::State_Turning, false))
	{
		bFacingLeft = IsCoverFlagSet(CTaskCover::CF_TurningLeft);
	}

	bool bCanFireRoundCorner = CanPedFireRoundCorner(*pPed, bFacingLeft);

	return bCanFireRoundCorner;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CanPedFireRoundCorner(const CPed& ped, bool bFacingLeft)
{
	const CCoverPoint* coverPoint = ped.GetCoverPoint();
	if (!coverPoint)
	{
		return false;
	}

	bool bIsLowCover = (coverPoint->GetHeight() < CCoverPoint::COVHEIGHT_TOOHIGH);
	CCoverPoint::eCoverUsage coverUsage = coverPoint->GetUsage();

	bool bCanPedFireRoundCorner = CanPedFireRoundCorner(ped, bFacingLeft, bIsLowCover, coverUsage);

	return bCanPedFireRoundCorner;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CanPedFireRoundCorner(const CPed& ped, bool bFacingLeft, bool bIsLowCover, CCoverPoint::eCoverUsage coverUsage)
{
	bool bIsPlayer = ped.IsPlayer();
	if (bIsPlayer && ped.GetPlayerInfo()->DynamicCoverInsideCorner())
	{
		return false;
	}

	if (!bIsPlayer && bIsLowCover)
	{
		return false;
	}

	if (( coverUsage == CCoverPoint::COVUSE_WALLTONEITHER ) ||
		( (coverUsage == CCoverPoint::COVUSE_WALLTORIGHT || coverUsage == CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT) && bFacingLeft ) ||
		( (coverUsage == CCoverPoint::COVUSE_WALLTOLEFT || coverUsage == CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT) && !bFacingLeft ))
	{
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::CalculateInitialHeadingDir(bool bAutoFaceCornerDir)
{
	CPed* pPed = GetPed();

	// No cover point? Can't do it!
	if (!pPed->GetCoverPoint())
		return;

	// If we're auto facing a corner, check which corner it is and set the appropriate flag
	if (bAutoFaceCornerDir)
	{
		// Left corner
		if (pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTORIGHT)
		{
			SetCoverFlag(CTaskCover::CF_FacingLeft);
			return;
		}
		// Right corner
		else if (pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTOLEFT)
		{
			ClearCoverFlag(CTaskCover::CF_FacingLeft);
			return;
		}
	}

	// Otherwise calculate the direction based on the target position
	Vector3 vTargetPosition;
	GetTarget().GetPosition(vTargetPosition);

	Vector3 vToTarget = vTargetPosition - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	vToTarget.z = 0.0f;
	vToTarget.Normalize();

	Vector3 vCoverDir = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector(&RCC_VEC3V(vToTarget)));
	Vector3 vCoverRight = vCoverDir;
	vCoverRight.RotateZ(-HALF_PI);

	Vector3 vTestVec = pPed->IsLocalPlayer() ? VEC3V_TO_VECTOR3(pPed->GetTransform().GetB()) : vToTarget;
	if (vCoverRight.Dot(vTestVec) > 0.0f)
	{
		ClearCoverFlag(CTaskCover::CF_FacingLeft);
	}
	else
	{
		SetCoverFlag(CTaskCover::CF_FacingLeft);
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::FacePedInCorrectDirection(float fTimeStep)
{
	if (fTimeStep <= 0.f)
		return;

	taskAssertf(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_COVER, "Expected parent cover task");
	taskAssert(fTimeStep > 0.0f);

	CPed* pPed = GetPed();

	// Face the ped towards the cover direction
	Vector3 vCovDir = m_vCoverDirection;
	if (pPed->IsNetworkClone())
	{
		Vector3 vToTargetUnused;
		CCover::FindCoverDirectionForPed(*pPed, vCovDir, vToTargetUnused);
	}
	float fFacingDirection = rage::Atan2f(-vCovDir.x, vCovDir.y);
	fFacingDirection += IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? HALF_PI : -HALF_PI;
	fFacingDirection = fwAngle::LimitRadianAngle(fFacingDirection);
	float fHeadingDiff = fFacingDirection -pPed->GetCurrentHeading();
	pPed->SetDesiredHeading(fFacingDirection);
	fHeadingDiff = fwAngle::LimitRadianAngle(fHeadingDiff);	

	static dev_float HEADING_DELTA_APPROACH_RATE = 3.0f;
	Approach(m_fLastAngleDelta, fHeadingDiff, HEADING_DELTA_APPROACH_RATE, fTimeStep);
	static dev_float HEADING_CHANGE_RATE_UPPER_LIMIT = 20.0f*DtoR;
	static dev_float HEADING_CHANGE_RATE_MIN = 10.0f;
	static dev_float HEADING_CHANGE_RATE_MAX = 60.0f;
	float fHeadingChangeRate = Lerp(Min(fabs(m_fLastAngleDelta), HEADING_CHANGE_RATE_UPPER_LIMIT)/HEADING_CHANGE_RATE_UPPER_LIMIT, HEADING_CHANGE_RATE_MIN, HEADING_CHANGE_RATE_MAX);
	static dev_float HEADING_APPROACH_RATE = 30.0;
	Approach(m_fLastHeadingChangeRate, fHeadingChangeRate, HEADING_APPROACH_RATE, fTimeStep);
#if __ASSERT
	if (pPed->IsNetworkClone())
	{
		aiDebugf1("Frame : %i, Facing Direction = %s (Desired = %s)", fwTimer::GetFrameCount(), IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? "LEFT" : "RIGHT", IsCoverFlagSet(CTaskCover::CF_DesiredFacingLeft) ? "LEFT" : "RIGHT");
		if (Abs(fHeadingDiff) > QUARTER_PI)
		{
			aiDebugf1("Frame : %i, Angle delta: %f/%f, changeRate = %f/%f, Min (%f, %f)", fwTimer::GetFrameCount(), m_fLastAngleDelta*RtoD,fHeadingDiff*RtoD, m_fLastHeadingChangeRate, fHeadingChangeRate, m_fLastAngleDelta * m_fLastHeadingChangeRate,fHeadingDiff / fTimeStep);	
		}
	}
#endif // __ASSERT

	// Ensure we can't overshoot
	float fNewHeadingChangeRate = Min(Abs(m_fLastAngleDelta * m_fLastHeadingChangeRate),Abs(fHeadingDiff / fTimeStep));
	fNewHeadingChangeRate *= Sign(m_fLastAngleDelta);

	NMovingGround::SetPedDesiredAngularVelocity(pPed, ScalarV(fNewHeadingChangeRate) * pPed->GetTransform().GetC());	
}

////////////////////////////////////////////////////////////////////////////////

const Vector3& CTaskInCover::GetCameraHeadingVec() 
{
	const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
	return aimCameraFrame.GetFront();
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::SlidePedAgainstCover()
{
	CPed* pPed = GetPed();

	Vector3 vCoverPos = m_vCoverCoords;
	if (pPed->IsNetworkClone() && HasNetCoverPoint(*pPed))
	{
		GetNetCoverPointPosition(*pPed, vCoverPos);
	}

	//Set the extracted velocity of the ped to safely get him to the target point.
	Vector3 vDiff;
	vDiff = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition())-vCoverPos;
	vDiff.z=0;
	const float fDist2=vDiff.Mag2();

	//disabling this on slopes
	static dev_float s_fMaxSlopeAngle = 0.95f;
	if (pPed->GetMaxGroundNormal().GetZf() < s_fMaxSlopeAngle || pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_OnStairs)) 
		return;

	// If outside the distance the ped can move in a single update
	if (fDist2 >= rage::square(ms_Tunables.m_DesiredDistanceToCover))
	{
		fwDynamicEntityComponent *pedDynComp = pPed->CreateDynamicComponentIfMissing();

		Vector3 w = m_vCoverCoords-VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		w *= ms_Tunables.m_InCoverMovementSpeed;
		/*const float wy=DotProduct(w,pPed->GetB());*/ // Don't alter forward movement when moving
		const float wx=Dot(VECTOR3_TO_VEC3V(w), pPed->GetTransform().GetA()).Getf();
		Vector3 extractedVelocity(pedDynComp->GetAnimatedVelocity());
		extractedVelocity.x = wx;
		//extractedVelocity.y = wy;
		Vec3V vDesiredVelocity = pPed->GetTransform().Transform3x3(VECTOR3_TO_VEC3V(extractedVelocity));
		vDesiredVelocity.SetZf(pPed->GetDesiredVelocity().z);
		NMovingGround::SetPedDesiredVelocityClamped(pPed, vDesiredVelocity, MAX_SLIDE_ACCEL_LIMIT);
		//Displayf("ExtractedVelocity x: %.2f, y: %.2f", wx, wy);
		return;
	}
	else
	{	
		// Ok we're in cover... ish
		return;
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::CalculateCoverPosition()
{
	CPed* pPed = GetPed();
	if (!GetTarget().GetIsValid())
		return false;
	Vector3 vTargetPosition;	
	GetTarget().GetPosition(vTargetPosition);	
	m_vCoverDirection = vTargetPosition - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	m_vCoverDirection.z = 0.0f;
	m_vCoverDirection.Normalize();

	if (pPed->GetCoverPoint() && !pPed->GetCoverPoint()->IsOccupied())
		Displayf("Need to reserve this cover point before finding coords!");

	if (!pPed->GetCoverPoint() || !CCover::FindCoordinatesCoverPoint(pPed->GetCoverPoint(), pPed, m_vCoverDirection, m_vCoverCoords))
	{
		return false;
	}
	//m_vCoverCoords += m_vCoverOffset;
	const CPlayerInfo* playerInfo = pPed->GetPlayerInfo();
	if (playerInfo && playerInfo->IsRoundCover())
	{
		m_vCoverDirection = CPlayerInfo::ms_DynamicCoverHelper.ProcessRoundCoverDirection(pPed, pPed->GetPlayerInfo()->GetRoundCoverCenter());
	} 
	else
	{
		m_vCoverDirection = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector(&RCC_VEC3V(m_vCoverDirection)));
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::SetCorrectCrouchStatus()
{
	CPed* pPed = GetPed();

	if(pPed->IsNetworkClone())
	{
		return;
	}

	bool bShouldCrouch = false;

	if (pPed->GetCoverPoint() && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		bShouldCrouch = CGameConfig::Get().AllowCrouchedMovement();
	}

	s32 iState = GetState();

	// Crouch state is set to true in the aim intro depending on whether we're aiming directly in low cover
	// We prevent changing it in these states
	if (iState == State_AimIntro || iState == State_Aim)
	{
		return;
	}

	// Don't allow the crouch state to change too often
	dev_float TIME_BETWEEN_CROUCH_CHANGES = 0.25f;
	m_fTimeSinceLastCrouchChange += GetTimeStep();
	bool bCrouchChange = bShouldCrouch != pPed->GetIsCrouching();
	if (bCrouchChange)
	{
		if (m_fTimeSinceLastCrouchChange > TIME_BETWEEN_CROUCH_CHANGES)
		{
			m_fTimeSinceLastCrouchChange = 0.0f;
		}
		else
		{
			return;
		}
	}
	else
	{
		m_fTimeSinceLastCrouchChange = 0.0f;
	}

	// Set the correct crouch status except when blending out to idle
	if (bShouldCrouch && iState != State_Finish)	
		pPed->SetIsCrouching(true);
	else
		pPed->SetIsCrouching(false);
}

////////////////////////////////////////////////////////////////////////////////

s32 CTaskInCover::CalculateDesiredDirection(const Vector3& vTargetPos)
{
	CPed* pPed = GetPed();

	if (pPed->IsPlayer() /*&& !m_bForcePedTowardsCover*/ && pPed->GetCoverPoint() )
	{
		Vector3 vToTarget = vTargetPos - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		vToTarget.z = 0.0f;
		vToTarget.Normalize();
		Vector3 vCoverHeading = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector(&RCC_VEC3V(vToTarget)));
		CControl *pControl = pPed->GetControlFromPlayer();
		Vector2 vecStick(pControl->GetPedWalkLeftRight().GetNorm() * 127.0f, -pControl->GetPedWalkUpDown().GetNorm() * 127.0f);
		vecStick.Rotate(camInterface::GetGameplayDirector().GetFrame().ComputeHeading());
		vecStick.Rotate(-rage::Atan2f(-vCoverHeading.x, vCoverHeading.y));
		if( vecStick.x > MIN_STICK_INPUT_TO_MOVE_IN_COVER )
			return 1;
		else if( vecStick.x < -MIN_STICK_INPUT_TO_MOVE_IN_COVER )
			return -1;
	}
	return 0;
}

////////////////////////////////////////////////////////////////////////////////

aiTask* CTaskInCover::CreateAimTask()
{
	CPed* pPed = GetPed();

	aiTask* pNewTask = NULL;
	if (pPed->IsPlayer())
	{
		weaponAssert(pPed->GetWeaponManager());
		const bool bHasProjectile = pPed->GetWeaponManager()->GetEquippedWeapon() && pPed->GetWeaponManager()->GetEquippedWeapon()->GetWeaponInfo()->GetIsThrownWeapon();
		if (bHasProjectile)
		{
			pNewTask = rage_new CTaskAimAndThrowProjectile();
		}
		else
		{
			CTaskGun * pGunTask = rage_new CTaskGun(CWeaponController::WCT_Player, CTaskTypes::TASK_AIM_GUN_ON_FOOT);
			pGunTask->GetGunFlags().SetFlag( GF_SkipOutro );
			//pGunTask->GetGunFlags().SetFlag( GF_DisableTorsoIk );
			pGunTask->GetGunFlags().SetFlag( GF_UpdateTarget );
			pGunTask->GetGunFlags().SetFlag( GF_DontUpdateHeading );
			pGunTask->GetGunFlags().SetFlag( GF_AlwaysAiming );
			pGunTask->GetGunFlags().SetFlag(GF_DisableBulletReactions);
			pNewTask = pGunTask;
		}
	}
	else
	{
		// aim toward target if the LOS is blocked
		CTaskGun * pGunTask = rage_new CTaskGun(CWeaponController::WCT_Aim, CTaskTypes::TASK_AIM_GUN_ON_FOOT);
		pGunTask->GetGunFlags().SetFlag( GF_SkipIdleTransitions );
		pGunTask->GetGunFlags().SetFlag( GF_InstantBlendToAim );
		pGunTask->GetGunFlags().SetFlag( GF_SkipOutro );
		//pGunTask->GetGunFlags().SetFlag( GF_DisableTorsoIk );
		// If LOS is blocked, limit the aim angle to realistic values
		pGunTask->GetGunFlags().SetFlag( GF_WaitForFacingAngleToFire );
		pGunTask->GetGunFlags().SetFlag(GF_DisableBulletReactions);
		pGunTask->GetGunFlags().SetFlag(GF_DisableReload);

		pNewTask = pGunTask;
	}	
	return pNewTask;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::CheckForBlockedBlindFire()
{
	CPed* pPed = GetPed();

	SetCoverFlag(CTaskCover::CF_CanBlindFire);
	ClearCoverFlag(CTaskCover::CF_UseOverTheTopBlindFiring);

	if( !pPed->IsLocalPlayer() )
		return;

	if( pPed->GetCoverPoint() == NULL )
		return;

	bool bIsDynamicCoverPoint = pPed->GetPlayerInfo()->GetDynamicCoverPoint() == pPed->GetCoverPoint();

	// Check low first if this is a dynamic point
	if( bIsDynamicCoverPoint )
	{
		if( pPed->GetCoverPoint()->GetHeight() != CCoverPoint::COVHEIGHT_TOOHIGH )
			pPed->GetCoverPoint()->SetHeight( CCoverPoint::COVHEIGHT_LOW );
	}	

	if (!IsCoverFlagSet(CTaskCover::CF_CanBlindFire) && pPed->GetCoverPoint()->GetHeight() != CCoverPoint::COVHEIGHT_TOOHIGH )
	{
		SetCoverFlag(CTaskCover::CF_CanBlindFire);
		if (pPed->GetCoverPoint()->GetHeight() != CCoverPoint::COVHEIGHT_TOOHIGH )
			pPed->GetCoverPoint()->SetHeight( CCoverPoint::COVHEIGHT_LOW );		
		if (IsCoverFlagSet(CTaskCover::CF_CanBlindFire) )
			SetCoverFlag(CTaskCover::CF_UseOverTheTopBlindFiring);
	}
	// 	if( !IsCoverFlagSet(CF_CanBlindFire) && bIsDynamicCoverPoint && pPed->GetCoverPoint()->GetHeight() == CCoverPoint::COVHEIGHT_LOW)
	// 	{
	// 		SetCoverFlag(CF_CanBlindFire);
	// 		pPed->GetCoverPoint()->SetHeight( CCoverPoint::COVHEIGHT_HIGH );	
	// 	}
}

////////////////////////////////////////////////////////////////////////////////

aiTask* CTaskInCover::CreateFireTask()
{
	s32 coverState = GetState();

	CPed* pPed = GetPed();
	pPed->SetLocalOffsetToCoverPoint(VEC3_ZERO);
	CTaskGun* pGunTask = NULL;

	if(!pPed->GetWeaponManager())
		return NULL;

	const CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();
	if(!pWeapon)
		return NULL;

	if( pPed->IsPlayer() )
	{
		pGunTask = rage_new CTaskGun(CWeaponController::WCT_Player, CTaskTypes::TASK_AIM_GUN_ON_FOOT);
		pGunTask->GetGunFlags().SetFlag( GF_SkipOutro );
		//pGunTask->GetGunFlags().SetFlag( GF_DisableTorsoIk );

		pGunTask->GetGunFlags().SetFlag( GF_UpdateTarget );
		pGunTask->GetGunFlags().SetFlag( GF_DontUpdateHeading );
		// Don't allow the player to just aim
		if(!ms_Tunables.m_UseAutoPeekAimFromCoverControls)
		{
			pGunTask->GetGunFlags().SetFlag( GF_DisableAiming );

			if(!pWeapon->GetWeaponInfo()->GetUsesAmmo() || pWeapon->GetAmmoTotal() != 0)
				pGunTask->GetGunFlags().SetFlag( GF_FireAtLeastOnce );
		}

		if (m_bForceFireBullet)
		{
			if(!pWeapon->GetWeaponInfo()->GetUsesAmmo() || pWeapon->GetAmmoTotal() != 0)
				pGunTask->GetGunFlags().SetFlag( GF_FireAtLeastOnce );
		}

#if FPS_MODE_SUPPORTED
		if (!pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
#endif // FPS_MODE_SUPPORTED
		{
			pGunTask->GetGunFlags().SetFlag( GF_PreventAutoWeaponSwitching );
			pGunTask->GetGunFlags().SetFlag( GF_PreventWeaponSwapping );
		}

		pGunTask->GetGunFlags().SetFlag( GF_AllowFiringWhileBlending );

		// Make sure the ped doesn't reload whilst firing from cover
		pGunTask->GetGunFlags().SetFlag( GF_DisableReload );
		// Skip the intro section of the fire clip since we've played our own version from the cover clips
		pGunTask->GetGunFlags().SetFlag( GF_SkipIdleTransitions );
		pGunTask->GetGunFlags().SetFlag( GF_InstantBlendToAim );

		TUNE_GROUP_BOOL(COVER_AIM_TUNE, ALLOW_FORCE_FIRE_FROM_CAMERA, true);
		if (ALLOW_FORCE_FIRE_FROM_CAMERA || pPed->GetPlayerInfo()->IsRoundCover())
			pGunTask->GetGunFireFlags().SetFlag( GFF_ForceFireFromCamera );
	}
	else
	{
		CPedTargetting* pPedTargetting = pPed->GetPedIntelligence()->GetTargetting( true );
		bool bLosBlocked = false;
		// If there is a target and no LOS, aim instead of firing
		LosStatus losStatus = Los_clear;
		const CEntity* pTarget = GetTarget().GetEntity();
		
		const CPed* pTargetPed = NULL;

		if (pTarget)
		{
			taskAssertf(pTarget->GetIsTypePed(), "Expected a ped target entity");
			pTargetPed = static_cast<const CPed*>(pTarget);
		}
		
		if (pPedTargetting && pTargetPed)
		{
			losStatus = pPedTargetting->GetLosStatus(pTarget);
			bLosBlocked = ( losStatus == Los_blocked ) && !pPed->GetPedIntelligence()->GetCombatBehaviour().IsFlagSet(CCombatData::BF_CanShootWithoutLOS);
		}

		bool bAimOnlyBecauseLosBlocked = false;

		// If the target is in cover that protects from this direction, don't fire
		CCoverPoint* pTargetCoverPoint = pTargetPed ? pTargetPed->GetCoverPoint() : NULL;
		if (pTargetCoverPoint)
		{
			if( pPed->GetPedIntelligence()->GetCombatBehaviour().IsFlagSet(CCombatData::BF_RequiresLosToShoot) )
			{
				if( CCover::DoesCoverPointProvideCover(pTargetCoverPoint, pTargetCoverPoint->GetArc(), VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()) ) )
				{
					if (pTargetPed->GetPedIntelligence()->GetQueriableInterface()->IsTaskCurrentlyRunning(CTaskTypes::TASK_IN_COVER))
					{
						s32 coverState = pTargetPed->GetPedIntelligence()->GetQueriableInterface()->GetStateForTaskType(CTaskTypes::TASK_IN_COVER);
						if( (coverState != State_AimIntro && coverState != State_Aim && coverState != State_AimOutro) && coverState != State_BlindFiring )
						{
							bAimOnlyBecauseLosBlocked = true;
						}
					}
				}
			}
		}

		// If the AI los is blocked by a friendly ped, just aim
		if (!IsCoverFlagSet(CTaskCover::CF_AimOnly) && losStatus == Los_blockedByFriendly && !pPed->IsAPlayerPed())
		{
			bAimOnlyBecauseLosBlocked = true;
		}
		
		//Check if this is cover fire.
		bool bIsCoverFire = IsCoverFlagSet(CTaskCover::CF_CoverFire);

		if ((bLosBlocked || IsCoverFlagSet(CTaskCover::CF_AimOnly) || bAimOnlyBecauseLosBlocked) && !pPed->GetPedIntelligence()->GetCombatBehaviour().IsFlagSet(CCombatData::BF_BlindFireWhenInCover))
		{
			float fDuration = pPed->GetPedIntelligence()->GetCombatBehaviour().GetCombatFloat(kAttribFloatBurstDurationInCover) * fwRandom::GetRandomNumberInRange(0.9f, 1.1f);

			// aim toward target if the LOS is blocked
			pGunTask = rage_new CTaskGun(CWeaponController::WCT_Aim, CTaskTypes::TASK_AIM_GUN_ON_FOOT, GetTarget(), fDuration);
			pGunTask->GetGunFlags().SetFlag( GF_SkipIdleTransitions );
			pGunTask->GetGunFlags().SetFlag( GF_SkipOutro );
			//pGunTask->GetGunFlags().SetFlag( GF_DisableTorsoIk );
			pGunTask->GetGunFlags().SetFlag( GF_PreventAutoWeaponSwitching );
		
			// If LOS is blocked, limit the aim angle to realistic values
			pGunTask->GetGunFlags().SetFlag( GF_WaitForFacingAngleToFire );
			// Skip the intro section of the fire clip since we've played our own version from the cover clips
			pGunTask->GetGunFlags().SetFlag( GF_SkipIdleTransitions );
			pGunTask->GetGunFlags().SetFlag( GF_AllowFiringWhileBlending );
			pGunTask->GetGunFlags().SetFlag( GF_InstantBlendToAim );

			// Make sure the ped doesn't reload whilst firing from cover
			pGunTask->GetGunFlags().SetFlag( GF_DisableReload );

			static dev_float MAX_TORSO_PITCH = EIGHTH_PI;
			pGunTask->GetIkInfo().SetTorsoMinMaxPitch(-MAX_TORSO_PITCH, MAX_TORSO_PITCH);
		}
		else
		{
			// Select a duration
			u32   uFiringPattern = FIRING_PATTERN_BURST_FIRE_IN_COVER;
			float fDuration = -1.0f;

			// If blind firing, fire continuously
			if( coverState == State_BlindFiring )
			{
				uFiringPattern = 0;
				fDuration = pPed->GetPedIntelligence()->GetCombatBehaviour().GetCombatFloat(kAttribFloatBurstDurationInCover) * fwRandom::GetRandomNumberInRange(0.9f, 1.1f);
			}
			
			//Check if this is cover fire.
			if(bIsCoverFire)
			{
				//Fire continuously.
				uFiringPattern = 0;
				
				//Fire for approximately 5 seconds.  Perhaps add a combat flag for this?
				fDuration = 5.0f * fwRandom::GetRandomNumberInRange(0.9f, 1.1f);
			}

			// Start the gun control task with the required task and time limit
			pGunTask = rage_new CTaskGun(CWeaponController::WCT_Fire, CTaskTypes::TASK_AIM_GUN_ON_FOOT, GetTarget(), fDuration);
			pGunTask->SetFiringPatternHash(uFiringPattern);
			pGunTask->GetGunFlags().SetFlag( GF_SkipIdleTransitions );
			pGunTask->GetGunFlags().SetFlag( GF_SkipOutro );
			//pGunTask->GetGunFlags().SetFlag( GF_DisableTorsoIk );
			pGunTask->GetGunFlags().SetFlag( GF_WaitForFacingAngleToFire );
			pGunTask->GetGunFlags().SetFlag( GF_AllowFiringWhileBlending );
			pGunTask->GetGunFlags().SetFlag( GF_PreventAutoWeaponSwitching );
			pGunTask->GetGunFlags().SetFlag( GF_InstantBlendToAim );
			
			if(!pWeapon->GetWeaponInfo()->GetUsesAmmo() || pWeapon->GetAmmoTotal() != 0)
				pGunTask->GetGunFlags().SetFlag( GF_FireAtLeastOnce );	

			// Make sure the ped doesn't reload whilst firing from cover
			pGunTask->GetGunFlags().SetFlag( GF_DisableReload );

#if 0 // CS - SHOULD BE ABLE TO HANDLE THIS WITH FIRING PATTERNS?
			pGunTask->SetOnAimFinished( CTaskComplexGun::STATE_EXIT );
			pGunTask->SetOnFireFinished( CTaskComplexGun::STATE_EXIT );
#endif // 0

			// Skip the intro section of the fire clip since we've played our own version from the cover clips
			pGunTask->GetGunFlags().SetFlag( GF_SkipIdleTransitions );

			// If blind firing, make sure the bullets fly down the gun barrel
			if( coverState == State_BlindFiring )
			{
				// Act as if we havne't fire in ages 
				pPed->SetTimeSinceLastShotFired(10.0f);
				pGunTask->GetGunFlags().SetFlag( GF_BlindFiring );
				pGunTask->GetGunFlags().SetFlag( GF_FireBulletsInGunDirection );
				pGunTask->GetGunFlags().SetFlag( GF_DontUpdateHeading );
				pGunTask->GetGunFlags().ClearFlag( GF_WaitForFacingAngleToFire );

				float torsoOffsetYaw = 0.0f;
				if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
				{
					torsoOffsetYaw = ( DtoR * 90.0f);
					if( IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) )
					{
						pGunTask->GetIkInfo().SetTorsoMinMaxYaw(0.0f, QUARTER_PI);
					}
				}
				else
				{
					torsoOffsetYaw = ( DtoR * -90.0f);
					if( IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) )
					{
						pGunTask->GetIkInfo().SetTorsoMinMaxYaw(-QUARTER_PI, 0.0f);
					}
				}
				pGunTask->GetIkInfo().SetTorsoOffsetYaw(torsoOffsetYaw);
				// Set the pitch values to avoid firing through small walls
				if( !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AtCorner) )
				{
					pGunTask->GetIkInfo().SetTorsoMinMaxPitch(BLIND_FIRE_OVER_MIN_PITCH, BLIND_FIRE_OVER_MAX_PITCH);
				}
			}
		}
		
		//Check if this is covering fire.
		if(bIsCoverFire)
		{
			//Play the covering fire response sound.
			pPed->NewSay("COVER_YOU");
			
			//Clear the cover fire flag.
			ClearCoverFlag(CTaskCover::CF_CoverFire);
		}
	}

	//Disable bullet reactions.
	pGunTask->GetGunFlags().SetFlag(GF_DisableBulletReactions);

	return pGunTask;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::UpdatePlayerTargetting()
{
	CPed* pPed = GetPed();

	// If the player, update free aiming and targetting
	if (pPed->IsPlayer())
	{
		Vector3 vTargetPosition = (camInterface::GetGameplayDirector().GetFrame().GetFront() * 20.0f) + VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		GetTarget().SetPosition(vTargetPosition);
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::IsValidForFPSIk(const CPed& rPed)
{
	if (rPed.GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN))
		return false;

	if (GetState() == State_BlindFiring)
	{
		const CTaskAimGunBlindFire* pBlindFireTask = static_cast<const CTaskAimGunBlindFire*>(FindSubTaskOfType(CTaskTypes::TASK_AIM_GUN_BLIND_FIRE));
		if (pBlindFireTask)
		{
			return pBlindFireTask->IsValidForFPSIk(!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint));
		}
	}

	if (GetPreviousState() != State_BlindFiring)
		return false;

	if (GetState() != State_Peeking)
		return false;

	// Delay the ik blend out when going directly to peeking, blend out the ik earlier when looking down or reloading
	TUNE_GROUP_FLOAT(FIRST_PERSON_BLINDFIRE, MIN_TIME_IN_PEEKING_AFTER_BLINDFIRE_TO_PROCESS_FPS_IK, 0.05f, 0.0f, 5.0f, 0.01f);
	TUNE_GROUP_FLOAT(FIRST_PERSON_BLINDFIRE, MAX_TIME_IN_PEEKING_AFTER_BLINDFIRE_TO_PROCESS_FPS_IK, 0.25f, 0.0f, 5.0f, 0.01f);
	TUNE_GROUP_FLOAT(FIRST_PERSON_BLINDFIRE, MAX_PITCH_PEEKING_AFTER_BLINDFIRE_TO_PROCESS_FPS_IK, 1.0f, 0.0f, PI, 0.01f);
	const float fPitch = camInterface::GetGameplayDirector().GetFrame().ComputePitch();
	const float fPitchForLerp = fPitch < 0.0f ? Abs(fPitch) : 0.0f;
	const float fNormedPitch = Clamp(fPitchForLerp / MAX_PITCH_PEEKING_AFTER_BLINDFIRE_TO_PROCESS_FPS_IK, 0.0f, 1.0f);
	const float fMaxTimeInState = Lerp(1.0f - fNormedPitch, MIN_TIME_IN_PEEKING_AFTER_BLINDFIRE_TO_PROCESS_FPS_IK, MAX_PITCH_PEEKING_AFTER_BLINDFIRE_TO_PROCESS_FPS_IK);
	return GetTimeInState() < fMaxTimeInState;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::ShouldStepBack(const CObject* pWeaponObject, const CWeapon* pWeapon) const
{
	taskAssert(pWeapon && pWeaponObject);

	const CPed& ped = *GetPed();

	if (ped.IsLocalPlayer())
	{
		// Always step back in high central cover
		if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
		{
			if (!IsCoverFlagSet(CTaskCover::CF_AtCorner))
			{
				return true;
			}
			return false;
		}

		const Matrix34 weaponMatrix = MAT34V_TO_MATRIX34(pWeaponObject->GetMatrix());
		Vector3 vecStart(VEC3_ZERO);
		Vector3 vecEnd(VEC3_ZERO);

		// calculate the firing vector from the weapon camera (be that 1st or 3rd person)
		bool bHaveFiringVector = pWeapon->CalcFireVecFromAimCamera(&ped, weaponMatrix, vecStart, vecEnd);

		if (bHaveFiringVector)
		{
			Vector3 vTestPos = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
			if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
				vTestPos += VEC3V_TO_VECTOR3(ped.GetTransform().GetB()) * ms_Tunables.m_CrouchedLeftFireOffset;
			else
				vTestPos += VEC3V_TO_VECTOR3(ped.GetTransform().GetB()) * ms_Tunables.m_CrouchedRightFireOffset;

			// increase the length and width of the capsule when unblocking weapon
			const float cfProbeLengthMultiplier = 1.25f;
			const float cfCapsuleRadiusMultiplier = 2.25f;

			// Don't pass in the crouch flag as we always stand up when firing
			return CTaskWeaponBlocked::IsWeaponBlocked(&ped, vecEnd, &vTestPos, cfProbeLengthMultiplier, cfCapsuleRadiusMultiplier);
		}
	}
	return false;
}

//////////////////////////////////////////////////////////////////////////
bool CTaskInCover::CheckBlindFireRange(const CPed* pPed)
{
	if (pPed->IsLocalPlayer() && IsCoverFlagSet(CTaskCover::CF_AtCorner) && IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		return CanBlindFireCorner(pPed);
	}
	return true;
}

bool CTaskInCover::CanBlindFireCorner(const CPed* pPed)
{
	Vector3 vCamNormal = GetCameraHeadingVec();
	vCamNormal.z=0; vCamNormal.Normalize();
	Vector3 vPedNormal = VEC3V_TO_VECTOR3(pPed->GetTransform().GetForward());
	vPedNormal.z=0; vPedNormal.Normalize();
	float vDot = vPedNormal.Dot(vCamNormal);
		//Displayf("Dot = %f", vDot);
	static dev_float s_fBlindFireAngleLimit = -0.2f;
	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, BLIND_FIRE_ANGLE_LIMIT, -0.15f, -1.0f, 1.0f, 0.01f);
	float fLimit = s_fBlindFireAngleLimit;
	if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations)
	{
		fLimit = BLIND_FIRE_ANGLE_LIMIT;
	}

	if (vDot < fLimit)
		return false;
	
	return true;
}

void CTaskInCover::ProcessBlindFireBreakGlass(CPed* pPed)
{
	if (pPed->IsLocalPlayer() && m_uBlindFireBreakGlass!=BF_WINDOWBREAK_NONE)
	{
		CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();
		CCoverPoint* pCoverPoint = pPed->GetCoverPoint();		
		if (pWeapon && pCoverPoint)
		{
			Matrix34 mWeapon;
			mWeapon.d.Zero();
			Vector3 vMuzzle;
			pWeapon->GetMuzzlePosition(mWeapon, vMuzzle);

			WorldProbe::CShapeTestProbeDesc probeDesc;
			Vector3 vStart = vMuzzle;			
			Vector3 vCoverDir = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector(NULL));
			Vector3 vEnd = vStart;  
			vStart.AddScaled(vCoverDir, -0.5f);
			vEnd.AddScaled(vCoverDir, 0.8f);
			// Submit our probe
			WorldProbe::CShapeTestFixedResults<> probeResult;
			probeDesc.SetResultsStructure(&probeResult);
			probeDesc.SetStartAndEnd(vStart, vEnd);
			probeDesc.SetIncludeFlags(ArchetypeFlags::GTA_GLASS_TYPE);
			if(WorldProbe::GetShapeTestManager()->SubmitTest(probeDesc))
			{								
				// Get the entity from the phInst of the intersection and make sure it's dynamic and breakable glass
				CEntity* pEntity = CPhysics::GetEntityFromInst(probeResult[0].GetHitInst());
				if(pEntity && pEntity->GetIsDynamic())
				{
					CDynamicEntity *pGlassObj = (CDynamicEntity*)pEntity;
					if(pGlassObj->m_nDEflags.bIsBreakableGlass)
					{							
						// Attempt to break the glass that we found
						if (CPhysics::BreakGlass(pGlassObj, probeResult[0].GetHitPositionV(), 0.75f, VECTOR3_TO_VEC3V(vCoverDir), 2000.0f, 0))
						{
							if (NetworkInterface::IsGameInProgress())
							{
								CEventShockingBrokenGlass event(*pPed, probeResult[0].GetHitPositionV());
								CShockingEventsManager::Add(event);
							}
						}
					}
				}
				m_uBlindFireBreakGlass=BF_WINDOWBREAK_BREAKING;							
			} 
			else if (m_uBlindFireBreakGlass==BF_WINDOWBREAK_BREAKING)
				m_uBlindFireBreakGlass = BF_WINDOWBREAK_NONE;
		}				
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::SetNextStateFromNetwork()
{
	CPed* pPed = GetPed();

	s32 thisState = GetState();
	s32 nextState = GetStateFromNetwork();

	const bool bFacingCorrectDirection = IsCoverFlagSet(CTaskCover::CF_FacingLeft) == IsCoverFlagSet(CTaskCover::CF_DesiredFacingLeft);
	// handle intro/outro states 
	if (nextState == State_AimOutro)
	{
		nextState = State_Idle;
	}
	else if (nextState == State_Aim && bFacingCorrectDirection)
	{
		nextState = State_AimIntro;
	}

	// disable switching weapon for now until the task is refactored
	if (nextState == State_SwapWeapon)
	{
		nextState = State_Idle;
	}

	const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager() ? pPed->GetWeaponManager()->GetEquippedWeaponInfo() : NULL;
	bool pedHasWeapon = pWeaponInfo ? !pWeaponInfo->GetIsUnarmed() : false; 
	bool nextStateRequiresAWeapon = false;
	
	switch (nextState)
	{
	case State_Reloading:
	case State_AimIntro:
	case State_BlindFiring:
	case State_ThrowingProjectile:
		nextStateRequiresAWeapon = true;
		break;
	default:
		break;
	}

	if (pPed->IsPlayer() && (nextState == State_AimIntro || nextState == State_ThrowingProjectile || nextState == State_BlindFiring))
	{
		// we can't enter a state that requires a target if we have not received it yet
		if (!static_cast<CNetObjPlayer*>(pPed->GetNetworkObject())->HasValidTarget())
		{
			return;
		}
	}

	// we can't enter a state that requires a weapon if there is no weapon or anims for the state yet
	if (nextStateRequiresAWeapon)
	{
		if ((!pedHasWeapon || !static_cast<CTaskCover*>(GetParent())->IsWeaponClipSetLoaded()))
		{
			return;
		}

		// Mismatched weapons, need to wait
		if ((nextState == State_AimIntro || nextState == State_BlindFiring))
		{
			if (pPed->GetCurrentWeaponInfoForHeldObject())
			{
				aiDebugf1("Frame : %i, Weapon Object Info %s(%i), expected (%i)", fwTimer::GetFrameCount(), pPed->GetCurrentWeaponInfoForHeldObject()->GetName(), pPed->GetCurrentWeaponInfoForHeldObject()->GetHash(), m_uWeaponHash);
				if (pPed->GetCurrentWeaponInfoForHeldObject()->GetHash() != m_uWeaponHash)
				{
					return;
				}
			}
		}
	}

	// always return to idle before doing anything else
	if (!CheckForExit())
	{
		if (GetIsFlagSet(aiTaskFlags::SubTaskFinished) || thisState != nextState)
		{
			if (thisState == State_Idle)
			{
				// we need to wait for the queriable state updates for certain states before proceeding
				if (nextState == State_BlindFiring)
				{
					if (pPed->GetPedIntelligence()->GetQueriableInterface()->GetTaskInfoForTaskType(CTaskTypes::TASK_GUN, PED_TASK_PRIORITY_MAX, false))
					{
						SetState(nextState);
					}
				}
				else if (nextState == State_ThrowingProjectile)
				{
					if (pPed->GetPedIntelligence()->GetQueriableInterface()->GetTaskInfoForTaskType(CTaskTypes::TASK_THROW_PROJECTILE, PED_TASK_PRIORITY_MAX, false))
					{
						SetState(nextState);
					}
				}
				else if (nextState == State_AimIntro)
				{
					if (bFacingCorrectDirection)
					{
						SetState(nextState);
					}
				}
				else
				{
					SetState(nextState);
				}
			}
			else
			{
				SetState(State_Idle);
			}
		}
	}
}

void CTaskInCover::SetState(s32 iState)
{
	AI_LOG_WITH_ARGS("[%s][TaskStateChange] - %s Ped %s is changing state from %s to %s\n", GetTaskName(), AILogging::GetDynamicEntityIsCloneStringSafe(GetPed()), AILogging::GetDynamicEntityNameSafe(GetPed()), GetStaticStateName(GetState()), GetStaticStateName(iState));
	aiTask::SetState(iState);
}

bool CTaskInCover::IsAimButtonHeldDown()
{
	CPed* pPed = GetPed();

	if (pPed->IsLocalPlayer())
	{
		CControl *pControl = pPed->GetControlFromPlayer();
		if (pControl->GetPedTargetIsDown(ioValue::ANALOG_BUTTON_DOWN_THRESHOLD))
		{
			return true;
		}
	}
	return false;
}
////////////////////////////////////////////////////////////////////////////////

// fwMvClipId CTaskInCover::GetClipIdFromIndex(s32 i)
// {
// 	switch (i)
// 	{
// 		case 0: return ms_Clip0Id;
// 		case 1: return ms_Clip1Id;
// 		case 2: return ms_Clip2Id;
// 		default: break;
// 	}
// 	return CLIP_ID_INVALID;
// }

////////////////////////////////////////////////////////////////////////////////
// 
// void CTaskInCover::SetClipsFromAnimStateInfo()
// {
// 	
// }

////////////////////////////////////////////////////////////////////////////////

// void CTaskInCover::SetClipsFromAnimStateInfo(s32 iState)
// {
// 
// }

////////////////////////////////////////////////////////////////////////////////

// const CTaskInCover::UseCoverAnimStateInfo* CTaskInCover::GetAnimStateInfoForState()
// {
// 
// }

////////////////////////////////////////////////////////////////////////////////

// const CTaskInCover::UseCoverAnimStateInfo* CTaskInCover::GetAnimStateInfoForState(s32 iState, s32 iFlags)
// {
// 
// }

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskInCover::GetClipSetHashForArmament(const CPed* pPed)
{
	weaponAssert(pPed->GetWeaponManager());
	const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();

	if (pWeaponInfo && taskVerifyf(pWeaponInfo->GetCoverMovementClipSetHashForPed(*pPed) != CLIP_SET_ID_INVALID, "Invalid Ped Cover Movement Clipset Hash for weapon %s", pWeaponInfo->GetName()))
	{
		return pWeaponInfo->GetCoverMovementClipSetHashForPed(*pPed);
	}

	return fwMvClipSetId("cover_movement_unarmed",0xC991EFD3);
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::GetCoverOutModifier( const bool bLeft, const Vector3& coverDir, const Vector3& targetDir, float& fDot, bool bClamp, bool bLow, bool bCloseToEdge )
{
	float fModifier = 0.0f;
	Vector3 vCoverRight;
	vCoverRight.Cross(coverDir, Vector3(0.0f, 0.0f, 1.0f));
	fDot = vCoverRight.Dot(targetDir); // = cos(angle between vCoverRight and targetDir)
	if (bLeft)
	{
		fDot *= -1.0f;	// Multiply by -1.0f so its consistent with the facing right part 

		if(bCloseToEdge)
		{
			fModifier = ms_Tunables.m_CoverLeftFireModifierCloseToEdge;
		}
		else
		{
			fModifier = bLow ? ms_Tunables.m_CoverLeftFireModifierLow : ms_Tunables.m_CoverLeftFireModifier;
		}

		// Move further out if the target is out to the right
		if (fDot < 0.0f)
		{
			fModifier *= 1.0f + (ms_Tunables.m_CoverLeftIncreaseModifier * -fDot);
		}
		// Target is to the left
		// Scale the modifier down the further to the side the target is, 
		// so peds step less far out for targets in an open direction
		else
		{
			float fDot2 = coverDir.Dot(targetDir); // = cos(angle between coverDir and targetDir)
			if (fDot2 > 0.0f)
			{
				fDot2 = MIN(0.5f+(fDot2*0.5f),1.0f);
				fModifier *= coverDir.Dot(targetDir);
			}

			// If fDot2 is negative then we'll probably be aiming directly?
		}
	}
	else
	{
		if(bCloseToEdge)
		{
			fModifier = ms_Tunables.m_CoverRightFireModifierCloseToEdge;
		}
		else
		{
			fModifier = bLow? ms_Tunables.m_CoverRightFireModifierLow : ms_Tunables.m_CoverRightFireModifier;
		}

		// Move further out if the target is out to the left
		if (fDot < 0.0f)
		{
			fModifier *= 1.0f + (ms_Tunables.m_CoverRightIncreaseModifier * -fDot);
		}
		// Target is to the right
		// Scale the modifier down the further to the side the target is, 
		// so peds step less far out for targets in an open direction
		else
		{
			float fDot2 = coverDir.Dot(targetDir); // = cos(angle between coverDir and targetDir)
			if (fDot2 > 0.0f)
			{
				fDot2 = MIN(0.5f+(fDot2*0.5f), 1.0f);
				fModifier *= coverDir.Dot(targetDir);
			}
		}
	}

	if (bClamp)
		fModifier = MIN( 1.2f, fModifier );

	return fModifier;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::GetThrownProjectileClipSetAndClipIds(CPed* pPed, CTaskInCover* pInCoverTask, 
														fwMvClipSetId& clipSetId, fwMvClipId& introClipId, 
														fwMvClipId& baseClipId, fwMvClipId& throwLongClipId, 
														fwMvClipId& throwShortClipId, fwMvClipId& throwLongFaceCoverClipId, 
														fwMvClipId& throwShortFaceCoverClipId, bool bForceEdge)
{
	taskAssert(pInCoverTask->GetState() == State_ThrowingProjectile);

	// Work out the cover clip dictionary index for this ped.
	clipSetId = ms_Tunables.GetThrowProjectileClipSetIdForPed(*pPed);
	
	if (!taskVerifyf(clipSetId != CLIP_SET_ID_INVALID, "Clipset Id Is Invalid"))
	{
		return false;
	}

	s32 iCoverProjectileFlags = 0;

	if (pInCoverTask->IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		iCoverProjectileFlags |= CTaskCover::AF_FaceLeft;
	}

	if (!pInCoverTask->IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		iCoverProjectileFlags |= CTaskCover::AF_Low;
	}

	if (bForceEdge || pInCoverTask->IsCoverFlagSet(CTaskCover::CF_AtCorner))
	{
		iCoverProjectileFlags |= CTaskCover::AF_AtEdge;
	}

	for (s32 i=0; i<ms_Tunables.m_ThrowProjectileClips.GetCount(); ++i)
	{
		if (ms_Tunables.m_ThrowProjectileClips[i].m_Flags == iCoverProjectileFlags)
		{
			introClipId = ms_Tunables.m_ThrowProjectileClips[i].m_PullPinClipId;
			const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();
			if (pWeaponInfo)
			{
				const CAmmoProjectileInfo* pAmmoInfo = static_cast<const CAmmoProjectileInfo*>(pWeaponInfo->GetAmmoInfo());
				if(pAmmoInfo)
				{
					if (pAmmoInfo->GetNoPullPin())
					{
						introClipId = ms_Tunables.m_ThrowProjectileClips[i].m_IntroClipId;
					}					
				}
			}
						
			baseClipId = ms_Tunables.m_ThrowProjectileClips[i].m_BaseClipId;
			throwLongClipId = ms_Tunables.m_ThrowProjectileClips[i].m_ThrowLongClipId;
			throwShortClipId = ms_Tunables.m_ThrowProjectileClips[i].m_ThrowShortClipId;
			throwLongFaceCoverClipId = ms_Tunables.m_ThrowProjectileClips[i].m_ThrowLongFaceCoverClipId;
			throwShortFaceCoverClipId = ms_Tunables.m_ThrowProjectileClips[i].m_ThrowShortFaceCoverClipId;
			break;
		}
	}

	// If a valid clip id and clip set have been selected make sure it exists
	if (introClipId != CLIP_ID_INVALID && baseClipId != CLIP_ID_INVALID && throwLongClipId != CLIP_ID_INVALID && throwShortClipId != CLIP_ID_INVALID)
	{
		if (!taskVerifyf(fwAnimManager::GetClipIfExistsBySetId(clipSetId, introClipId), "Couldn't find clip %s in clipset %s", introClipId.GetCStr(), clipSetId.GetCStr()))
			return false;

		if (!taskVerifyf(fwAnimManager::GetClipIfExistsBySetId(clipSetId, baseClipId), "Couldn't find clip %s in clipset %s", baseClipId.GetCStr(), clipSetId.GetCStr()))
			return false;

		if (!taskVerifyf(fwAnimManager::GetClipIfExistsBySetId(clipSetId, throwLongClipId), "Couldn't find clip %s in clipset %s", throwLongClipId.GetCStr(), clipSetId.GetCStr()))
			return false;

		if (!taskVerifyf(fwAnimManager::GetClipIfExistsBySetId(clipSetId, throwShortClipId), "Couldn't find clip %s in clipset %s", throwShortClipId.GetCStr(), clipSetId.GetCStr()))
			return false;

		return true;
	}

	// No clip
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::SetTerminationReason(CTaskCover::eInCoverTerminationReason reason)
{
	taskFatalAssertf(GetParent()->GetTaskType() == CTaskTypes::TASK_COVER, "Invalid parent task");
	static_cast<CTaskCover*>(GetParent())->SetInCoverTerminationReason(reason);
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::CalculateRateForAimIntro() const
{
	//Check if the ped is a player.
	if(GetPed()->IsPlayer())
	{
#if FPS_MODE_SUPPORTED
		if (GetPreviousState() == State_Peeking && GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			return CTaskAimGunFromCoverIntro::ms_Tunables.m_IntroRateToPeekFPS;
		}
		else
#endif // FPS_MODE_SUPPORTED
		if (CAnimSpeedUps::ShouldUseMPAnimRates())
		{
			return CAnimSpeedUps::ms_Tunables.m_MultiplayerCoverIntroRateModifier;
		}
		else			
			return CTaskAimGunFromCoverIntro::ms_Tunables.m_IntroRate;
	}
	else
	{
		return ms_Tunables.m_AimIntroRateForAi;
	}
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::CalculateRateForAimOutro(bool bToPeek) const
{
	//Check if the ped is a player.
#if FPS_MODE_SUPPORTED
	if (bToPeek && GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		return CTaskAimGunFromCoverIntro::ms_Tunables.m_IntroRateToPeekFPS;
	}
	else
#endif // FPS_MODE_SUPPORTED
	if(GetPed()->IsPlayer())
	{
		return CTaskAimGunFromCoverIntro::ms_Tunables.m_OutroRate;
	}
	else
	{
		return m_bReactToFire ? fwRandom::GetRandomNumberInRange(ms_Tunables.m_MinReactToFireRate, ms_Tunables.m_MaxReactToFireRate) : ms_Tunables.m_AimOutroRateForAi;
	}
}

//////////////////////////////////////////////////////////////////////////

u32 CTaskInCover::CalculateTimeNextPeekAllowed() const
{
	bool bHasLosToTarget = true;

	CPedTargetting* pPedTargetting = GetPed()->GetPedIntelligence()->GetTargetting( true );
	const CEntity* pTarget = GetTarget().GetEntity();
	if(pPedTargetting && pTarget && pTarget->GetIsTypePed())
	{
		bHasLosToTarget = pPedTargetting->GetLosStatus(pTarget) != Los_blocked;
	}

	float fTimeTilNextPeek = bHasLosToTarget ? GetPed()->GetPedIntelligence()->GetCombatBehaviour().GetCombatFloat(kAttribFloatTimeBetweenPeeks) : ms_Tunables.m_TimeBetweenPeeksWithoutLOS;
	fTimeTilNextPeek *= fwRandom::GetRandomNumberInRange(.9f, 1.1f);

	return (fwTimer::GetTimeInMilliseconds() + (s32)(fTimeTilNextPeek * 1000.0f));
}

//////////////////////////////////////////////////////////////////////////

void CTaskInCover::ResetTimeBetweenBurstsRandomness()
{
	float fTimeBetweenBursts = GetPed()->GetPedIntelligence()->GetCombatBehaviour().GetCombatFloat(kAttribFloatTimeBetweenBurstsInCover);
	float fRandomPercent = fwRandom::GetRandomNumberInRange(-ms_Tunables.m_TimeBetweenBurstsMaxRandomPercent, ms_Tunables.m_TimeBetweenBurstsMaxRandomPercent);
	m_fTimeBetweenBurstsRandomness = fTimeBetweenBursts * fRandomPercent;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ProcessAudio()
{
	//Ensure the audio should be processed this frame.
	if(!GetPed()->GetPedIntelligence()->GetAudioDistributer().ShouldBeProcessedThisFrame())
	{
		return;
	}

	//Ensure the flag is not set.
	if(GetPed()->GetPedResetFlag(CPED_RESET_FLAG_DisableCoverAudio))
	{
		return;
	}

	//Ensure some time has passed before saying any lines.
	static dev_float s_fMinTime = 2.0f;
	if(GetTimeRunning() < s_fMinTime)
	{
		return;
	}

	if(GetPed()->GetSpeechAudioEntity())
	{
		//These are arranged in prioritized order.
		if(GetPed()->IsRegularCop() && (GetState() == State_Peeking))
		{
			GetPed()->GetSpeechAudioEntity()->SayWhenSafe("COP_PEEK");
		}
		else if(!GetPed()->IsPlayer() && (GetState() == State_Idle))
		{
			GetPed()->GetSpeechAudioEntity()->SayWhenSafe("STAY_DOWN");
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::AreWeaponClipsetsLoadedForPed(const CPed& rPed) const
{
	if (!static_cast<const CTaskCover*>(GetParent())->IsWeaponClipSetLoaded())
	{
		return false;
	}

	if( !rPed.GetWeaponManager() || !rPed.GetWeaponManager()->GetEquippedWeaponObject() )
	{
		return false;
	}

	const CWeaponInfo* pWeaponInfo = rPed.GetEquippedWeaponInfo();
	if (pWeaponInfo)
	{
		fwMvClipSetId clipset = pWeaponInfo->GetPedCoverWeaponClipSetId(rPed);
		if (clipset != CLIP_SET_ID_INVALID)
		{
			return CTaskCover::IsCoverClipSetLoaded(clipset);
		}
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::IsFPSPeekPositionObstructed(const CPed& rPed, bool bFacingLeft) const
{
	Vector3 vIntersectionUnused;
	const Vector3 vStart = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
	const Vector3 vSide = VEC3V_TO_VECTOR3(rPed.GetTransform().GetA());
	const Vector3 vFwd = VEC3V_TO_VECTOR3(rPed.GetTransform().GetB());
	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, LEFT_PEEK_SIDE_OFFSET, -0.25f, -2.0f, 2.0f, 0.01f);
	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, LEFT_PEEK_FWD_OFFSET, 0.7f, -2.0f, 2.0f, 0.01f);
	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, RIGHT_PEEK_SIDE_OFFSET, 0.25f, -2.0f, 2.0f, 0.01f);
	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, RIGHT_PEEK_FWD_OFFSET, 0.7f, -2.0f, 2.0f, 0.01f);
	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, PEEK_Z_OFFSET, 0.75f, -2.0f, 2.0f, 0.01f);
	const float fSideOffset = bFacingLeft ? LEFT_PEEK_SIDE_OFFSET : RIGHT_PEEK_SIDE_OFFSET;
	const float fFwdOffset = bFacingLeft ? LEFT_PEEK_FWD_OFFSET : RIGHT_PEEK_FWD_OFFSET;
	const Vector3 vEnd = vStart + (fSideOffset * vSide) + (fFwdOffset * vFwd) + (PEEK_Z_OFFSET * ZAXIS);
	return CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionUnused, NULL, NULL, true) ? true : false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::FindWallIntersection(const CPed& rPed, const Vector3& vTestPos, const Vector3& vCoverDir, const Vector3& vPedCoverForward, Vector3& vIntersectionPos, eEdgeTestType testType, const CVehicle* pVehicle, bool bLowCover)
{
	// Cache the variables we'll use to setup the capsule test
	float fEdgeStartYOffset	= testType == eLowInitialEdgeTest ? ms_Tunables.m_InitialLowEdgeWallTestYOffset : ms_Tunables.m_WallTestYOffset;
	if (testType == eHighCloseToEdgeTest)
	{
		fEdgeStartYOffset = ms_Tunables.m_HighCloseEdgeWallTestYOffset;
	}
	float fEdgeEndYOffset = testType == eLowInitialEdgeTest ? ms_Tunables.m_InitialLowEdgeWallTestYOffset : ms_Tunables.m_WallTestYOffset;
	if (testType == eHighCloseToEdgeTest)
	{
		fEdgeEndYOffset = ms_Tunables.m_HighCloseEdgeWallTestYOffset;
	}
	const float fEdgeStartXOffset	= ms_Tunables.m_WallTestStartXOffset;
	const float fEdgeEndXOffset		= ms_Tunables.m_WallTestEndXOffset;

	// The X offset is relative to the ped, which faces at 90 degrees to the cover direction
	Vector3 vStart	= vTestPos + (vPedCoverForward*fEdgeStartYOffset) + (vCoverDir*fEdgeStartXOffset);
	Vector3 vEnd	= vTestPos + (vPedCoverForward*fEdgeEndYOffset)	+ (vCoverDir*fEdgeEndXOffset);

	if (!bLowCover)
	{
		vStart.z -= ms_Tunables.m_WallHighTestZOffset;
		vEnd.z -= ms_Tunables.m_WallHighTestZOffset;
	}

	bool bHitDetected = false;
	if (pVehicle && pVehicle->GetVehicleCoverBoundOffsetInfo())
	{
		bHitDetected = CDynamicCoverHelper::DoLineTestAgainstVehicleDummyBounds(rPed, *pVehicle, vStart, vEnd, vIntersectionPos);
	}
	else
	{
		bHitDetected = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPos) ? true : false;
	}

#if DEBUG_DRAW
	CCoverDebug::sDebugLineParams lineParams;
	lineParams.vStart = RCC_VEC3V(vStart);
	lineParams.vEnd = RCC_VEC3V(vEnd);
	lineParams.color = bHitDetected ? Color_red : Color_green;
	lineParams.uContextHash = CCoverDebug::INSIDE_EDGE_TEST;
	CCoverDebug::AddDebugLine(lineParams);
#endif // DEBUG_DRAW

	if (bHitDetected)
	{
#if DEBUG_DRAW
		CCoverDebug::sDebugSphereParams sphereParams;
		sphereParams.vPos = RCC_VEC3V(vIntersectionPos);
		sphereParams.fRadius = 0.025f;
		sphereParams.color = Color_red;
		sphereParams.uContextHash = CCoverDebug::INSIDE_EDGE_TEST;
		CCoverDebug::AddDebugPositionSphere(sphereParams);
		CTask::ms_debugDraw.AddSphere(VECTOR3_TO_VEC3V(vIntersectionPos), 0.025f, Color_red, 2500);
#endif // DEBUG_DRAW	
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::FindInsideEdgeIntersection(const CPed& rPed, const Vector3& vTestPos, const Vector3& vCoverDir, const Vector3& vPedCoverForward, Vector3& vIntersectionPos, eEdgeTestType testType, const CVehicle* pVehicle, bool UNUSED_PARAM(bIsLeft))
{
	// Cache the variables we'll use to setup the capsule test
	const float fEdgeStartYOffset	= GetInsideEdgeYStartOffset(testType);
	const float fEdgeEndYOffset		= GetInsideEdgeYEndOffset(testType);
	const float fEdgeStartXOffset	= GetInsideEdgeXStartOffset(testType);
	const float fEdgeEndXOffset		= GetInsideEdgeXEndOffset(testType);

	// The X offset is relative to the ped, which faces at 90 degrees to the cover direction
	Vector3 vStart	= vTestPos + (vPedCoverForward*fEdgeStartYOffset) + (vCoverDir*fEdgeStartXOffset);
	Vector3 vEnd	= vTestPos + (vPedCoverForward*fEdgeEndYOffset)	+ (vCoverDir*fEdgeEndXOffset);

	bool bHitDetected = false;
	if (pVehicle && pVehicle->GetVehicleCoverBoundOffsetInfo())
	{
		bHitDetected = CDynamicCoverHelper::DoLineTestAgainstVehicleDummyBounds(rPed, *pVehicle, vStart, vEnd, vIntersectionPos);
	}
	else
	{
		bHitDetected = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPos) ? true : false;
	}

#if DEBUG_DRAW
	CCoverDebug::sDebugLineParams lineParams;
	lineParams.vStart = RCC_VEC3V(vStart);
	lineParams.vEnd = RCC_VEC3V(vEnd);
	lineParams.color = bHitDetected ? Color_red : Color_green;
	lineParams.uContextHash = CCoverDebug::INSIDE_EDGE_TEST;
	CCoverDebug::AddDebugLine(lineParams);
#endif // DEBUG_DRAW

	if (bHitDetected)
	{
#if DEBUG_DRAW
		CCoverDebug::sDebugSphereParams sphereParams;
		sphereParams.vPos = RCC_VEC3V(vIntersectionPos);
		sphereParams.fRadius = 0.025f;
		sphereParams.color = Color_red;
		sphereParams.uContextHash = CCoverDebug::INSIDE_EDGE_TEST;
		CCoverDebug::AddDebugPositionSphere(sphereParams);
		CTask::ms_debugDraw.AddSphere(VECTOR3_TO_VEC3V(vIntersectionPos), 0.025f, Color_red, 2500);
#endif // DEBUG_DRAW	
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::FindEdgeIntersection(const CPed& rPed, const Vector3& vTestPos, const Vector3& vCoverDir, const Vector3& vPedCoverForward, Vector3& vIntersectionPos, eEdgeTestType testType, const CVehicle* pVehicle, bool bIsLeft)
{
	if (FindInsideEdgeIntersection(rPed, vTestPos, vCoverDir, vPedCoverForward, vIntersectionPos, testType, pVehicle, bIsLeft))
	{
		// If we find an inside hit, don't update the cover position
		return false;
	}

	// Cache the variables we'll use to setup the capsule test
	const float fEdgeStartYOffset	= GetEdgeYStartOffset(testType);
	const float fEdgeEndYOffset		= GetEdgeYEndOffset(testType);
	const float fEdgeStartXOffset	= GetEdgeXStartOffset(testType);
	const float fEdgeEndXOffset		= GetEdgeXEndOffset(testType);
	const float fEdgeCapsuleRadius	= ms_Tunables.m_EdgeCapsuleRadius;
	bool		bLowCover = rPed.GetCoverPoint() && rPed.GetCoverPoint()->GetHeight() != CCoverPoint::COVHEIGHT_TOOHIGH;

	TUNE_GROUP_BOOL(COVER_TUNE, DO_WALL_TEST, true);	
	if (DO_WALL_TEST && rPed.GetCoverPoint() && bLowCover && FindWallIntersection(rPed, vTestPos, vCoverDir, vPedCoverForward, vIntersectionPos, testType, pVehicle, bLowCover))
	{
		// If we find a wall then don't update the cover position
		return false;
	}

	// The X offset is relative to the ped, which faces at 90 degrees to the cover direction
	Vector3 vStart	= vTestPos + (vPedCoverForward*fEdgeStartYOffset) + (vCoverDir*fEdgeStartXOffset);
	Vector3 vEnd	= vTestPos + (vPedCoverForward*fEdgeEndYOffset)	+ (vCoverDir*fEdgeEndXOffset);

	bool bHitDetected = false;
	if (pVehicle && pVehicle->GetVehicleCoverBoundOffsetInfo())
	{
		bHitDetected = CDynamicCoverHelper::DoLineTestAgainstVehicleDummyBounds(rPed, *pVehicle, vStart, vEnd, vIntersectionPos);
	}
	else
	{
		WorldProbe::CShapeTestFixedResults<> capsuleResult;
		s32 iTypeFlags = ArchetypeFlags::GTA_ALL_MAP_TYPES|ArchetypeFlags::GTA_MAP_TYPE_COVER|ArchetypeFlags::GTA_VEHICLE_TYPE|ArchetypeFlags::GTA_OBJECT_TYPE;

		WorldProbe::CShapeTestCapsuleDesc capsuleDesc;
		capsuleDesc.SetResultsStructure(&capsuleResult);
		capsuleDesc.SetCapsule(vStart, vEnd, fEdgeCapsuleRadius);
		capsuleDesc.SetIncludeFlags(iTypeFlags);
		capsuleDesc.SetTypeFlags(ArchetypeFlags::GTA_AI_TEST);
		capsuleDesc.SetIsDirected(true);
		capsuleDesc.SetDoInitialSphereCheck(true);
		capsuleDesc.SetOptions(WorldProbe::LOS_IGNORE_NOT_COVER);
		WorldProbe::GetShapeTestManager()->SubmitTest(capsuleDesc);

		// Go over all valid hits, accept the first valid hit that isn't a door
		s32 iHitIndex = 0;
		while (iHitIndex < capsuleResult.GetNumHits() && capsuleResult[iHitIndex].GetHitDetected())
		{
			CEntity* pHitEntity = bHitDetected ? capsuleResult[iHitIndex].GetHitEntity() : NULL;
			const bool bUnableToTakeCoverOnDoor = pHitEntity && pHitEntity->GetIsTypeObject() && ((CObject*)pHitEntity)->IsADoor() && !pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED) && !pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED_BY_NETWORK);
			if (bUnableToTakeCoverOnDoor)
			{
				++iHitIndex;
			}
			else
			{
				//Check the normal of the collision for a real edge
				Vector3 vHitNormal = capsuleResult[iHitIndex].GetHitNormal();
				if (fabs(vHitNormal.z) < 0.5f)
				{
					vHitNormal.z=0; vHitNormal.Normalize();
					float dot = vHitNormal.Dot(vPedCoverForward);
					static dev_float sf_MinEdgeDot = 0.2f;
					if (dot > sf_MinEdgeDot)
					{
						bHitDetected = true;
						break;
					}					
				}		
				++iHitIndex;
			}
		}

		if (bHitDetected)
		{
			// Store the intersection position
			vIntersectionPos = capsuleResult[iHitIndex].GetHitPosition();
		}
	}

#if DEBUG_DRAW
	CCoverDebug::sDebugCapsuleParams capsuleParams;
	capsuleParams.vStart = RCC_VEC3V(vStart);
	capsuleParams.vEnd = RCC_VEC3V(vEnd);
	capsuleParams.color = Color_green;
	capsuleParams.fRadius = fEdgeCapsuleRadius;
	capsuleParams.uContextHash = bIsLeft ? CCoverDebug::LEFT_EDGE_TEST : CCoverDebug::RIGHT_EDGE_TEST;
	CCoverDebug::AddDebugCapsule(capsuleParams);
	CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), fEdgeCapsuleRadius, Color_green, 2500, 0, false);
#endif // DEBUG_DRAW

	if (bHitDetected)
	{
		// Discount if it hits in the initial sphere
		TUNE_GROUP_BOOL(COVER_TUNE, FORCE_ALLOW_ALL_HITS, true);
		const bool bValidHit = FORCE_ALLOW_ALL_HITS || vStart.Dist2(vIntersectionPos) > rage::square(fEdgeCapsuleRadius);
#if DEBUG_DRAW
		if (!bValidHit)
		{
			aiDisplayf("Invalid hit, Dist2 (%.2f/%.2f)", vStart.Dist2(vIntersectionPos), rage::square(fEdgeCapsuleRadius));
		}
		CCoverDebug::sDebugSphereParams sphereParams;
		sphereParams.vPos = RCC_VEC3V(vIntersectionPos);
		sphereParams.fRadius = 0.025f;
		sphereParams.color = Color_red;
		sphereParams.uContextHash = bIsLeft ? CCoverDebug::LEFT_EDGE_TEST : CCoverDebug::RIGHT_EDGE_TEST;
		CCoverDebug::AddDebugPositionSphere(sphereParams);
		CTask::ms_debugDraw.AddSphere(VECTOR3_TO_VEC3V(vIntersectionPos), 0.025f, bValidHit ? Color_red : Color_purple, 2500);
#endif // DEBUG_DRAW

		return bValidHit;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::FindCoverEdgeAndUpdateCoverPosition(CPed* pPed, Vector3& vCoverCoords, float& fEdgeDistance,  bool bPedFacingLeft, bool bEdgeOnly, float fDistTol, bool bFromEntry)
{
#if __DEV
	TUNE_GROUP_BOOL(COVER_TUNE, DISABLE_EDGE_TEST, false);
	if (DISABLE_EDGE_TEST)
		return;
#endif // __DEV

	fEdgeDistance = -1.0f; 

	// Clones do not have a cover point
	if (pPed->IsNetworkClone())
		return;

	// If we don't have a valid cover point bail out now
	if (!pPed->GetCoverPoint())
		return;

	//Round no edges
	if (pPed->IsLocalPlayer() && pPed->GetPlayerInfo()->IsRoundCover())
		return;

	CCoverPoint& coverPoint = *pPed->GetCoverPoint();

	Vector3 vCoverPos(Vector3::ZeroType);
	if (!coverPoint.GetCoverPointPosition(vCoverPos))
		return;

	const CCoverPoint::eCoverHeight coverHeight = coverPoint.GetHeight();
	const CCoverPoint::eCoverUsage usage		= coverPoint.GetUsage();
	const bool bDoLowTest						= ShouldDoLowTest(coverHeight, usage) ? true : false;
	const float fOptimumLeftDist				= bDoLowTest ? ms_Tunables.m_OptimumDistToLeftCoverEdgeCrouched : ms_Tunables.m_OptimumDistToLeftCoverEdge;
	const float fOptimumRightDist				= bDoLowTest ? ms_Tunables.m_OptimumDistToRightCoverEdgeCrouched : ms_Tunables.m_OptimumDistToRightCoverEdge;
	const Vector3 vCoverDir						= VEC3V_TO_VECTOR3(coverPoint.GetCoverDirectionVector());

	Vector3 vTestPos = vCoverPos;
	vTestPos.z += 1.0f;
	vTestPos.z = bDoLowTest ? (vTestPos.z + ms_Tunables.m_EdgeLowZOffset) : (vTestPos.z + ms_Tunables.m_EdgeHighZOffset);

	// The cover direction faces into the wall, so rotate 90 degrees left/right to get the direction the ped should be facing
	Vector3 vPedCoverForward = vCoverDir;
	vPedCoverForward.RotateZ(-HALF_PI);
	const Vector3 vRight = vPedCoverForward;
	const Vector3 vLeft = -vPedCoverForward;

	if (bPedFacingLeft)
	{
		vPedCoverForward = vLeft;
	}

	float fRightEdge = fOptimumRightDist;
	float fLeftEdge = fOptimumLeftDist;

	const bool bIsLowCover = coverHeight != CCoverPoint::COVHEIGHT_TOOHIGH;
	const bool bAiFireOverTheTop = !pPed->IsAPlayerPed() && bIsLowCover;
	
	// Only check the right hand side if the ped can fire right
	const bool bCanFireRight = !bAiFireOverTheTop && 
		(usage == CCoverPoint::COVUSE_WALLTOLEFT || 
		usage == CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT ||
		(usage == CCoverPoint::COVUSE_WALLTONEITHER && !bPedFacingLeft));

	eEdgeTestType testType = eIdleEdgeTest;

	bool bUpdateLowCoverEdgeState = pPed->IsLocalPlayer() && bIsLowCover && bFromEntry && coverPoint.GetUsage() == CCoverPoint::COVUSE_WALLTOBOTH;
	if (bUpdateLowCoverEdgeState)
	{
		testType = eLowInitialEdgeTest;
	}
	else
	{
		CTaskInCover* pCoverTask = static_cast<CTaskInCover*>(pPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_IN_COVER));
		if (pCoverTask)
		{
			if (pCoverTask->IsInMotionState(CTaskMotionInCover::State_Moving, false))
			{
				testType = eMovingEdgeTest;
			}
			else if (pCoverTask->IsInMotionState(CTaskMotionInCover::State_CoverToCover, false))
			{
				testType = eCoverToCoverEdgeTest;
			}
			else if (pCoverTask->IsInMotionState(CTaskMotionInCover::State_Stepping, false))
			{
				testType = eSteppingEdgeTest;
			}
		}
	}

	CVehicle* pCoverVehicle = NULL;
	if (pPed->IsLocalPlayer())
	{
		CEntity* pEntity = CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity();
		if (pEntity && pEntity->GetIsTypeVehicle())
		{
			pCoverVehicle = static_cast<CVehicle*>(pEntity);
		}
	}

	Vector3 vFacingIntersectionPos(Vector3::ZeroType);
	// Right edge
	if (bCanFireRight || bUpdateLowCoverEdgeState)
	{
		if (bUpdateLowCoverEdgeState)
		{
			bPedFacingLeft = false;
			vPedCoverForward = vRight;
		}
		Vector3 vIntersectionPos(Vector3::ZeroType);
		if (FindEdgeIntersection(*pPed, vTestPos, vCoverDir, vPedCoverForward, vIntersectionPos, testType, pCoverVehicle, false))
		{
			fRightEdge = GetXYDot(vPedCoverForward, (vIntersectionPos - vCoverPos));
			if (!bPedFacingLeft)
				vFacingIntersectionPos = vIntersectionPos;

			if (bUpdateLowCoverEdgeState)
			{
				coverPoint.SetUsage(CCoverPoint::COVUSE_WALLTOLEFT);
			}

#if DEBUG_DRAW
			Vector3 vDebugDistPos = vIntersectionPos - vPedCoverForward * fRightEdge;

			CCoverDebug::sDebugLineParams lineParams;
			lineParams.vStart = RCC_VEC3V(vIntersectionPos);
			lineParams.vEnd = RCC_VEC3V(vDebugDistPos);
			lineParams.color = Color_red;
			lineParams.uContextHash = CCoverDebug::RIGHT_EDGE_TEST;
			CCoverDebug::AddDebugLine(lineParams);
			CTask::ms_debugDraw.AddLine(VECTOR3_TO_VEC3V(vIntersectionPos), VECTOR3_TO_VEC3V(vDebugDistPos), Color_red, 2500);

			CCoverDebug::sDebugSphereParams sphereParams;
			sphereParams.vPos = RCC_VEC3V(vDebugDistPos);
			sphereParams.fRadius = 0.025f;
			sphereParams.color = Color_purple;
			sphereParams.uContextHash = CCoverDebug::RIGHT_EDGE_TEST;
			CCoverDebug::AddDebugPositionSphere(sphereParams);
			CTask::ms_debugDraw.AddSphere(VECTOR3_TO_VEC3V(vDebugDistPos), 0.025f, Color_purple, 2500);
#endif // DEBUG_DRAW
		}
	}

	// Only check the left hand side if the ped can fire right
	const bool bCanFireLeft = !bAiFireOverTheTop && 
		(usage == CCoverPoint::COVUSE_WALLTORIGHT || 
		usage == CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT ||
		(usage == CCoverPoint::COVUSE_WALLTONEITHER && bPedFacingLeft));

	bUpdateLowCoverEdgeState = pPed->IsLocalPlayer() && bIsLowCover && bFromEntry && coverPoint.GetUsage() == CCoverPoint::COVUSE_WALLTOBOTH;
	if (bCanFireLeft || bUpdateLowCoverEdgeState) 
	{
		if (bUpdateLowCoverEdgeState)
		{
			bPedFacingLeft = true;
			vPedCoverForward = vLeft;
		}
		Vector3 vIntersectionPos(Vector3::ZeroType);
		if (FindEdgeIntersection(*pPed, vTestPos, vCoverDir, vPedCoverForward, vIntersectionPos, testType, pCoverVehicle, true))
		{
			fLeftEdge = GetXYDot(vPedCoverForward, (vIntersectionPos - vCoverPos));
			if (bPedFacingLeft)
				vFacingIntersectionPos = vIntersectionPos;

			if (bUpdateLowCoverEdgeState)
			{
				coverPoint.SetUsage(CCoverPoint::COVUSE_WALLTORIGHT);
			}

#if DEBUG_DRAW
			Vector3 vDebugDistPos = vIntersectionPos - vPedCoverForward * fLeftEdge;

			CCoverDebug::sDebugLineParams lineParams;
			lineParams.vStart = RCC_VEC3V(vIntersectionPos);
			lineParams.vEnd = RCC_VEC3V(vDebugDistPos);
			lineParams.color = Color_red;
			lineParams.uContextHash = CCoverDebug::LEFT_EDGE_TEST;
			CCoverDebug::AddDebugLine(lineParams);
			CTask::ms_debugDraw.AddLine(VECTOR3_TO_VEC3V(vIntersectionPos), VECTOR3_TO_VEC3V(vDebugDistPos), Color_red, 2500);

			CCoverDebug::sDebugSphereParams sphereParams;
			sphereParams.vPos = RCC_VEC3V(vDebugDistPos);
			sphereParams.fRadius = 0.025f;
			sphereParams.color = Color_purple;
			sphereParams.uContextHash = CCoverDebug::LEFT_EDGE_TEST;
			CCoverDebug::AddDebugPositionSphere(sphereParams);
			CTask::ms_debugDraw.AddSphere(VECTOR3_TO_VEC3V(vDebugDistPos), 0.025f, Color_purple, 2500);
#endif // DEBUG_DRAW
		}
	}

#if DEBUG_DRAW
	// Original pos
	const Vector3 vOriginalCoverCoords = vCoverCoords;
	CCoverDebug::sDebugSphereParams sphereParams;
	sphereParams.vPos = RCC_VEC3V(vCoverCoords);
	sphereParams.fRadius = 0.025f;
	sphereParams.color = Color_orange;
	sphereParams.uContextHash = CCoverDebug::EDGE_TEST_RESULTS;
	CCoverDebug::AddDebugPositionSphere(sphereParams);
#endif // DEBUG_DRAW

	// Update the cover position
	Vector3 vCoverOffset(Vector3::ZeroType);

	const float fMaxOffsetDiff = ms_Tunables.m_EdgeMaximumOffsetDiff;
	const float fMinOffsetDiff = ms_Tunables.m_EdgeMinimumOffsetDiff;

	bool bPlayersLocalCoverpoint = pPed->IsLocalPlayer() && pPed->GetPlayerInfo()->GetDynamicCoverPoint() == pPed->GetCoverPoint();
	const float fDifference = bPedFacingLeft ? (fOptimumLeftDist - fLeftEdge) : (fOptimumRightDist - fRightEdge);

	if (fDistTol > 0.0f && Abs(fDifference) > fDistTol)
	{
		return;
	}

	if (vFacingIntersectionPos.IsNonZero()) 
	{
		Vector3 vDist = vFacingIntersectionPos - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());	
		fEdgeDistance = vDist.XYMag();
	}

	if (bEdgeOnly)
		return;

	if (ABS(fDifference) > fMinOffsetDiff && ABS(fDifference) < fMaxOffsetDiff)
	{
		vCoverOffset.Zero();
		Vector3 vNewCoverCoords = vCoverCoords - (vPedCoverForward * fDifference);
		if (pPed->IsLocalPlayer() && pPed->GetPlayerInfo()->DynamicCoverInsideCorner()) //Never move closer to an inside corner
		{	
			float dot = (vNewCoverCoords-vCoverCoords).Dot(vPedCoverForward);
			if (dot < 0)
				vCoverCoords = vNewCoverCoords;
		}
		else
			vCoverCoords = vNewCoverCoords;

		if (bPlayersLocalCoverpoint)
		{
			if (!CTaskCover::IsCoverPositionValid(vCoverCoords, *pPed))
			{
				return;
			}

// #if __ASSERT
// 			u8 prevDir = coverPoint.GetDirection();
			const Vector3 vCoverDir = VEC3V_TO_VECTOR3(coverPoint.GetCoverDirectionVector());
			coverPoint.SetWorldDirection(CCover::FindDirFromVector(vCoverDir));
// 			Assert(prevDir == coverPoint.GetDirection());
// #endif
			coverPoint.SetWorldPosition(vCoverCoords);
			//coverPoint.SetType(CCoverPoint::COVTYPE_POINTONMAP);

			if (pPed->GetPedResetFlag(CPED_RESET_FLAG_IsEnteringCover))
			{
				TUNE_GROUP_FLOAT(COVER_TUNE, HEIGHT_TEST_Z_OFFSET, 1.5f, 0.0f, 2.0f, 0.01f);
				TUNE_GROUP_FLOAT(COVER_TUNE, HEIGHT_TEST_DIR_OFFSET, 0.5f, 0.0f, 2.0f, 0.01f);
				TUNE_GROUP_FLOAT(COVER_TUNE, HEIGHT_TEST_FWD_OFFSET, 0.2f, 0.0f, 2.0f, 0.01f);
				Vector3 vStart = vCoverCoords + Vector3(0.0f,0.0f, HEIGHT_TEST_Z_OFFSET) + vPedCoverForward * HEIGHT_TEST_FWD_OFFSET;
				Vector3 vEnd = vStart + vCoverDir * HEIGHT_TEST_DIR_OFFSET;
				Vector3 vIntersectUnused;

				bool bHitDetected = false;
				if (pCoverVehicle && pCoverVehicle->GetVehicleCoverBoundOffsetInfo())
				{
					bHitDetected = CDynamicCoverHelper::DoLineTestAgainstVehicleDummyBounds(*pPed, *pCoverVehicle, vStart, vEnd, vIntersectUnused);
				}
				else
				{
					bHitDetected = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectUnused) ? true : false;
				}

				if (bHitDetected)
				{
					if (coverPoint.GetHeight() != CCoverPoint::COVHEIGHT_TOOHIGH)
					{
						coverPoint.SetHeight(CCoverPoint::COVHEIGHT_TOOHIGH);
					}
				}
				else
				{
					if (coverPoint.GetHeight() == CCoverPoint::COVHEIGHT_TOOHIGH)
					{
						coverPoint.SetHeight(CCoverPoint::COVHEIGHT_LOW);
					}
				}
			}

#if DEBUG_DRAW
			CCoverDebug::sDebugArrowParams debugArrowParams;
			Vector3 vDirection = vCoverCoords - vOriginalCoverCoords;
			vDirection.Normalize();
			debugArrowParams.vPos = RCC_VEC3V(vOriginalCoverCoords);
			debugArrowParams.vDir = RCC_VEC3V(vDirection);
			debugArrowParams.color = Color_orange;
			debugArrowParams.uContextHash = CCoverDebug::EDGE_TEST_RESULTS;
			CCoverDebug::AddDebugDirectionArrow(debugArrowParams);

			sphereParams.vPos = RCC_VEC3V(vCoverCoords);
			sphereParams.fRadius = 0.025f;
			sphereParams.color = Color_cyan;
			sphereParams.uContextHash = CCoverDebug::EDGE_TEST_RESULTS;
			CCoverDebug::AddDebugPositionSphere(sphereParams);
#endif // DEBUG_DRAW
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::FindCoverEdgeAndUpdateCoverPosition()
{
	CPed* pPed = GetPed();

	// Make sure the cover coords are uptodate
	if (pPed->GetCoverPoint())
	{
		pPed->GetCoverPoint()->GetCoverPointPosition(m_vCoverCoords);

		// Assume generated or script coverpoints are correctly positioned to prevent getting bad capsule results on awkward geometry
		if (!pPed->IsAPlayerPed())
		{
			return;
		}
	}

	float fEdgeDistance = -1.0f;
	FindCoverEdgeAndUpdateCoverPosition(pPed, m_vCoverCoords, fEdgeDistance, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
	if (pPed->IsLocalPlayer())
		pPed->GetPlayerInfo()->SetDynamicCoverEdgeDistance(fEdgeDistance);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::ShouldDoLowTest(CCoverPoint::eCoverHeight coverHeight, CCoverPoint::eCoverUsage coverUsage)
{
	if (coverHeight == CCoverPoint::COVHEIGHT_TOOHIGH ||
		coverUsage == CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT ||
		coverUsage == CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT)
	{
		return false;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::GetEdgeYStartOffset(eEdgeTestType testType)
{
	if (testType == eMovingEdgeTest)
	{
		return ms_Tunables.m_MovingEdgeTestStartYOffset;
	}
	else if (testType == eCoverToCoverEdgeTest)
	{
		return ms_Tunables.m_CoverToCoverEdgeTestStartYOffset;
	}
	else if (testType == eSteppingEdgeTest)
	{
		return ms_Tunables.m_SteppingEdgeTestStartYOffset;
	}
	else if (testType == eLowInitialEdgeTest)
	{
		return ms_Tunables.m_InitialLowEdgeTestStartYOffset;
	}
	return ms_Tunables.m_EdgeStartYOffset;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::GetEdgeYEndOffset(eEdgeTestType testType)
{
	if (testType == eMovingEdgeTest)
	{
		return ms_Tunables.m_MovingEdgeTestEndYOffset;
	}
	else if (testType == eCoverToCoverEdgeTest)
	{
		return ms_Tunables.m_CoverToCoverEdgeTestEndYOffset;
	}
	else if (testType == eSteppingEdgeTest)
	{
		return ms_Tunables.m_SteppingEdgeTestEndYOffset;
	}
	else if (testType == eLowInitialEdgeTest)
	{
		return ms_Tunables.m_InitialLowEdgeTestEndYOffset;
	}
	return ms_Tunables.m_EdgeEndYOffset;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::GetEdgeXStartOffset(eEdgeTestType UNUSED_PARAM(testType))
{
	return ms_Tunables.m_EdgeStartXOffset;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::GetEdgeXEndOffset(eEdgeTestType UNUSED_PARAM(testType))
{
	return ms_Tunables.m_EdgeEndXOffset;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::GetInsideEdgeYStartOffset(eEdgeTestType UNUSED_PARAM(testType))
{
	return ms_Tunables.m_InsideEdgeStartYOffset;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::GetInsideEdgeYEndOffset(eEdgeTestType UNUSED_PARAM(testType))
{
	return ms_Tunables.m_InsideEdgeEndYOffset;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::GetInsideEdgeXStartOffset(eEdgeTestType UNUSED_PARAM(testType))
{
	return ms_Tunables.m_InsideEdgeStartXOffset;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::GetInsideEdgeXEndOffset(eEdgeTestType UNUSED_PARAM(testType))
{
	return ms_Tunables.m_InsideEdgeEndXOffset;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::CheckForOverTheTopFiring()
{
	CPed* pPed = GetPed();

	ClearCoverFlag(CTaskCover::CF_UseOverTheTopBlindFiringDueToAngle);

	if( pPed->GetCoverPoint()->GetHeight() < CCoverPoint::COVHEIGHT_TOOHIGH )
	{
		Vector3 vTargetPos;
		GetTarget().GetPosition(vTargetPos);
		Vector3 vToTarget = vTargetPos - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		if( IsLessThanAll(Dot( pPed->GetTransform().GetB(), RCC_VEC3V(vToTarget)), ScalarV(V_ZERO)) )
		{
			SetCoverFlag(CTaskCover::CF_UseOverTheTopBlindFiringDueToAngle);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

CTaskInfo* CTaskInCover::CreateQueriableState() const
{
	const bool bWantsToReload = GetPed()->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN) ? true : false;
	const u32 uWeaponHash = GetPed()->GetEquippedWeaponInfo() ? GetPed()->GetEquippedWeaponInfo()->GetHash() : 0;
	return rage_new CClonedUseCoverInfo(GetState(), bWantsToReload, uWeaponHash, m_bForcedStepBack);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ReadQueriableState(CClonedFSMTaskInfo* pTaskInfo)
{
	Assert( pTaskInfo->GetTaskInfoType() == CTaskInfo::INFO_TYPE_USE_COVER_CLONED_FSM );
	CClonedUseCoverInfo *pUseCoverInfo = static_cast<CClonedUseCoverInfo*>(pTaskInfo);
	m_bWantsToReload = pUseCoverInfo->GetNeedsToReload();
	m_uWeaponHash = pUseCoverInfo->GetWeaponHashUsed();
	m_bForcedStepBack = pUseCoverInfo->GetForcedStepBack();
	CTaskFSMClone::ReadQueriableState(pTaskInfo);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::OnCloneTaskNoLongerRunningOnOwner()
{
	SetCoverFlag(CTaskCover::CF_AbortTask);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::ControlPassingAllowed(CPed *pPed, const netPlayer& UNUSED_PARAM(player), eMigrationType UNUSED_PARAM(migrationType))
{
	if (pPed && pPed->IsNetworkClone() && !m_cloneTaskInScope)
	{
		return true;
	}

	return (GetState() == State_Idle || GetState() == State_StreamAssets);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::OverridesNetworkBlender(CPed*) 
{ 
	s32 state = GetState();

	if (state == State_AimIntro || state == State_AimOutro)
	{
		return true;
	}

	return false; 
}

////////////////////////////////////////////////////////////////////////////////

CTaskInCover::FSM_Return CTaskInCover::UpdateClonedFSM(const s32 iState, const FSM_Event iEvent)
{
/*#if __BANK
	if (iEvent == State_Start)
	{
		Displayf("%d: CTaskInCover state = %s\n", fwTimer::GetSystemFrameCount(), GetStateName(iState));
	}
#endif*/

	FSM_Begin

	FSM_State(State_Start)
		FSM_OnUpdate
			return Start_OnUpdateClone();	

	FSM_State(State_StreamAssets)
		FSM_OnUpdate
			return StreamAssets_OnUpdateClone();	

	FSM_State(State_Idle)
		FSM_OnEnter
			Idle_OnEnter();
		FSM_OnUpdate
			return Idle_OnUpdateClone();

	FSM_State(State_Peeking)
		FSM_OnEnter
			Peeking_OnEnter();
		FSM_OnUpdate
			return Peeking_OnUpdateClone();

	FSM_State(State_PeekingToReload)
		FSM_OnEnter
			PeekingToReload_OnEnter();
		FSM_OnUpdate
			return PeekingToReload_OnUpdate();

	FSM_State(State_BlindFiring)
		FSM_OnEnter
			BlindFiring_OnEnter();
		FSM_OnUpdate
			return BlindFiring_OnUpdateClone();

	FSM_State(State_AimIntro)
		FSM_OnEnter
			return AimIntro_OnEnter();
		FSM_OnUpdate
			return AimIntro_OnUpdate();
		FSM_OnUpdate
			return AimIntro_OnExit();

	FSM_State(State_Aim)
		FSM_OnUpdate
			return Aim_OnUpdateClone();
		FSM_OnExit
			Aim_OnExit();

	FSM_State(State_AimOutro)
		FSM_OnEnter
			return AimOutro_OnEnter();
		FSM_OnUpdate
			return AimOutro_OnUpdate();
		FSM_OnExit
			return AimOutro_OnExit();

	FSM_State(State_ThrowingProjectile)
		FSM_OnEnter
			ThrowingProjectile_OnEnter();
		FSM_OnUpdate
			return ThrowingProjectile_OnUpdateClone();
		FSM_OnExit
			ThrowingProjectile_OnExit();

	FSM_State(State_Reloading)
		FSM_OnEnter
			Reloading_OnEnter();
		FSM_OnUpdate
			return Reloading_OnUpdateClone();
		FSM_OnExit
			Reloading_OnExit();

	FSM_State(State_SwapWeapon)
		FSM_OnEnter
			SwapWeapon_OnEnter();
		FSM_OnUpdate
			return SwapWeapon_OnUpdateClone();
		FSM_OnExit
			SwapWeapon_OnExit();

	FSM_State(State_Finish)
		FSM_OnUpdate
		{
#if __ASSERT
			if (GetPed() && GetPed()->IsNetworkClone())
			{
				aiDebugf1("Frame : %i, Clone %s quitting out of in cover task, previous state %s, state from network %s", fwTimer::GetFrameCount(), GetPed()->GetDebugName(), GetStateName(GetPreviousState()), GetStateName(GetStateFromNetwork()));
			}
#endif // __ASSERT
			return FSM_Quit;
		}

	FSM_State(State_UseMobile)

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::ProcessPreRender2()
{
	if (ms_Tunables.m_EnableLeftHandIkInCover)
	{
		CPed* pPed = GetPed();

		if (pPed->GetWeaponManager())
		{
			m_bLeftHandIkActive = true;
			bool bAllow2HandedAttachToStockGrip = false;
			float fIkBlendInDuration = -1.0f;
			float fIkBlendOutDuration = -1.0f;

			const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();
			if (pWeaponInfo)
			{
				// Disable the left hand ik in certain blindfire states
				if (GetState() == State_BlindFiring)
				{
					CTaskAimGunBlindFire* pTaskBlindFire = static_cast<CTaskAimGunBlindFire*>(FindSubTaskOfType(CTaskTypes::TASK_AIM_GUN_BLIND_FIRE));

					if (pTaskBlindFire)
					{
						TUNE_GROUP_FLOAT(FIRST_PERSON_BLINDFIRE_TUNE, LEFT_ARM_IK_BLEND_IN_DURATION, 0.125f, 0.0f, 1.0f, 0.01f);
#if FPS_MODE_SUPPORTED
						if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
						{
							fIkBlendInDuration = LEFT_ARM_IK_BLEND_IN_DURATION;
						}
#endif // FPS_MODE_SUPPORTED 

						s32 state = pTaskBlindFire->GetState();
						bool bFiring2Handed = ((state == CTaskAimGunBlindFire::State_FireNew) || (state == CTaskAimGunBlindFire::State_OutroNew)) && pWeaponInfo->GetIsGun2Handed() && !pWeaponInfo->GetIs1HandedInCover();

						if ((state != CTaskAimGunBlindFire::State_CockGun) && !bFiring2Handed)
						{
							m_bLeftHandIkActive = false;
						}

						if (state == CTaskAimGunBlindFire::State_CockGun && pWeaponInfo->GetFlag(CWeaponInfoFlags::UseSingleActionBehaviour))
						{
							m_bLeftHandIkActive = false;
						}

						// Facing left blind fire animations have the left hand on the weapon's stock
						bAllow2HandedAttachToStockGrip = bFiring2Handed && IsCoverFlagSet(CTaskCover::CF_FacingLeft) && !pTaskBlindFire->GetIKLeftHandUseGripBone();
					}
					else
					{
						m_bLeftHandIkActive = false;
					}
				}
				// Always process the on foot aiming ik when moving out to aim on foot
				else if (GetState() != State_AimIntro && GetState() != State_Aim)
				{
#if FPS_MODE_SUPPORTED
					if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && GetState() == State_AimOutro)
					{
						if(pPed->GetPedResetFlag(CPED_RESET_FLAG_DisableLeftArmIKInCoverOutroFPS))
						{
							m_bLeftHandIkActive = false;
						}
						else
						{
							m_bLeftHandIkActive = true;
						}						
					}
					else
#endif // FPS_MODE_SUPPORTED
					{
						TUNE_GROUP_FLOAT(COVER_AIM_TUNE, IK_BLEND_OUT_DURATION, 0.050f, 0.0f, 1.0f, 0.01f);
						fIkBlendOutDuration = IK_BLEND_OUT_DURATION;

						// Motion in cover also disables left hand ik under certain conditions
						if (!pWeaponInfo->GetUseLeftHandIkInCover())
						{
							m_bLeftHandIkActive = false;
						}
						else if (pWeaponInfo->GetIsGun2Handed() && pWeaponInfo->GetIs1HandedInCover() && !pWeaponInfo->ShouldPedUseAlternateCoverClipSet(*pPed))
						{
							m_bLeftHandIkActive = false;
						}
						else if (pWeaponInfo->GetIsGun1Handed() && !pWeaponInfo->ShouldPedUseAlternateCoverClipSet(*pPed))
						{
							m_bLeftHandIkActive = false;
						}
						else if (pPed->GetPedIntelligence()->FindTaskSecondaryByType(CTaskTypes::TASK_SWAP_WEAPON))
						{
							m_bLeftHandIkActive = false;
						}
						else if (pPed->GetPedResetFlag(CPED_RESET_FLAG_IsDoingCoverOutroToPeek))
						{
							m_bLeftHandIkActive = false;
						}
						else if (FPS_MODE_SUPPORTED_ONLY(pPed->IsFirstPersonShooterModeEnabledForPlayer(false) &&) GetPreviousState() == State_BlindFiring && GetState() == State_Peeking && pWeaponInfo->GetIsGun2Handed() && GetTimeInState() < 0.1f)
						{
							bAllow2HandedAttachToStockGrip = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
						}
					}
				}
				else
				{
					// Aiming
					TUNE_GROUP_FLOAT(COVER_AIM_TUNE, AIM_IK_BLEND_IN_DURATION, NORMAL_BLEND_DURATION, 0.0f, 1.0f, 0.01f);
					TUNE_GROUP_FLOAT(COVER_AIM_TUNE, AIM_IK_BLEND_OUT_DURATION, NORMAL_BLEND_DURATION, 0.0f, 1.0f, 0.01f);
					fIkBlendInDuration = AIM_IK_BLEND_IN_DURATION;
					fIkBlendOutDuration = AIM_IK_BLEND_OUT_DURATION;

#if FPS_MODE_SUPPORTED
					bool bUsingMusketAndReloading = pWeaponInfo->GetHash() == ATSTRINGHASH("WEAPON_MUSKET", 0xa89cb99e) && pPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_RELOAD_GUN);
					if(pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && (pPed->GetPedResetFlag(CPED_RESET_FLAG_IsThrowingProjectileWhileAiming) || bUsingMusketAndReloading))
					{
						m_bLeftHandIkActive = false;
					}
#endif
				}

				if (m_bLeftHandIkActive)
				{
					CTaskMotionAiming::ProcessOnFootAimingLeftHandGripIk(*pPed, *pWeaponInfo, bAllow2HandedAttachToStockGrip, fIkBlendInDuration, fIkBlendOutDuration);
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskInCover::IsInDangerousTargetingState() const
{
	switch(GetState())
	{
	case(State_AimIntro):
	case(State_Aim):
		return true;
	default:
		break;
	} 

	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::OnGunAimedAt(const CEventGunAimedAt& rEvent)
{
	//Grab the ped.
	const CPed* pPed = GetPed();

	//Ensure the ped is not a player.
	if(pPed->IsPlayer())
	{
		return;
	}

	//Ensure the source ped is valid.
	const CPed* pSourcePed = rEvent.GetSourcePed();
	if(!pSourcePed)
	{
		return;
	}

	//Ensure the source ped is a player.
	if(!pSourcePed->IsPlayer())
	{
		return;
	}

	//Ensure we are aiming.
	if(GetState() == State_AimIntro)
	{ //aiming into an aimed at situation so no reaction B* 973130
		m_fTimeUntilReturnToIdleFromAimedAt = 0.0f;
	} 
	if(GetState() != State_Aim)
	{
		return;
	}

	//Ensure we have not set a time to return to idle from aim.
	if(m_fTimeUntilReturnToIdleFromAimedAt >= 0.0f)
	{
		return;
	}

	//Set the time.
	float fMinTimeUntilReturnToIdleFromAim = ms_Tunables.m_MinTimeUntilReturnToIdleFromAimAfterAimedAt;
	float fMaxTimeUntilReturnToIdleFromAim = ms_Tunables.m_MaxTimeUntilReturnToIdleFromAimAfterAimedAt;
	m_fTimeUntilReturnToIdleFromAimedAt = fwRandom::GetRandomNumberInRange(fMinTimeUntilReturnToIdleFromAim, fMaxTimeUntilReturnToIdleFromAim);
}

////////////////////////////////////////////////////////////////////////////////

float CTaskInCover::ComputeStepTransitionMinAngle(const CPed& ped, const int index, const bool bFacingLeft,const float fDesiredAngle)
{
	//Late fix for just the RPG. If there are any other weapons then expose this to data.
	//RPG intersects with collision in this instance
	const CWeapon* pWeapon = ped.GetWeaponManager() ? ped.GetWeaponManager()->GetEquippedWeapon() : NULL;
	if(index == 1 && bFacingLeft && pWeapon && pWeapon->GetWeaponInfo() && pWeapon->GetWeaponInfo()->GetIsRpg() FPS_MODE_SUPPORTED_ONLY(&& !CTaskMotionInCover::ShouldUseFirstPersonAimingAnimations(ped)))
	{
		return -1.5f; // -1.7f in data
	}

	return fDesiredAngle;
}

////////////////////////////////////////////////////////////////////////////////

#if !__FINAL
void CTaskInCover::Debug() const
{
#if DEBUG_DRAW
	static Vec2V svStartPos(50.0f,100.0f);
	Vec2V vStartPos = svStartPos;
	static s32 iVerticalSpace = 10;
	
	if (GetPed()->IsLocalPlayer())
	{
		TUNE_GROUP_FLOAT(COVER_TUNE, START_CIRCLE_X_POS, 0.85f, -1.0f, 1.0f, 0.01f);
		TUNE_GROUP_FLOAT(COVER_TUNE, START_CIRCLE_Y_POS, 0.2f, -1.0f, 1.0f, 0.01f);
		TUNE_GROUP_FLOAT(COVER_TUNE, RADIUS, 0.1f, -1.0f, 1.0f, 0.01f);
		TUNE_GROUP_FLOAT(COVER_TUNE, RADIUS_STICK, 0.005f, -1.0f, 1.0f, 0.001f);
		TUNE_GROUP_FLOAT(COVER_TUNE, TEXT_OFFSET, 0.005f, -1.0f, 1.0f, 0.001f);
		Vector2 vStartRenderPos(START_CIRCLE_X_POS, START_CIRCLE_Y_POS);
		grcDebugDraw::Circle(vStartRenderPos, RADIUS, Color_blue, false);

		float fMagnitude = 0.0f;
		float fAngle = 0.0f;
		if (ComputeStickInputPolarForm(m_vecStick, fMagnitude, fAngle))
		{
			char szText[128];
			Vector2 vAngle(0.0f, -RADIUS * fMagnitude);
			vAngle.Rotate(fAngle);
			vAngle.x /= grcDebugDraw::g_aspect2D.y;
			grcDebugDraw::Line(vStartRenderPos, vStartRenderPos + vAngle, Color_green);
			formatf(szText, "%.2f", fAngle);
			grcDebugDraw::Text(vStartRenderPos + vAngle + Vector2(0.0f, TEXT_OFFSET), Color_blue, szText);
			grcDebugDraw::Circle(vStartRenderPos + vAngle, RADIUS_STICK, Color_blue);
		}

		if (m_bCachedStickValid)
		{
			char szText[128];
			Vector2 vCachedAngle(0.0f, -RADIUS);
			vCachedAngle.Rotate(m_fCachedStickAngle);
			vCachedAngle.x /= grcDebugDraw::g_aspect2D.y;
			grcDebugDraw::Line(vStartRenderPos, vStartRenderPos + vCachedAngle, Color_orange);
			formatf(szText, "%.2f", m_fCachedStickAngle);
			grcDebugDraw::Text(vStartRenderPos + vCachedAngle + Vector2(0.0f, TEXT_OFFSET), Color_red, szText);
			grcDebugDraw::Circle(vStartRenderPos + vCachedAngle, RADIUS_STICK, Color_red);
		}
	}

	u32 iNoTexts = 0;

	Vector3 vCoverCoords;
	char szText[256];
	if (!GetPed()->IsNetworkClone())
	{
		vCoverCoords = m_vCoverCoords;
		formatf(szText, "m_vCoverCoords : (%.2f, %.2f, %.2f)", m_vCoverCoords.x, m_vCoverCoords.y, m_vCoverCoords.z);
	}
	else
	{
		const CTaskCover* pParentTask = static_cast<const CTaskCover*>(GetParent());
		if (pParentTask->GetNetCoverPointPosition(*GetPed(), vCoverCoords))
		{
			formatf(szText, "vNetCoverCoords : (%.2f, %.2f, %.2f)", vCoverCoords.x, vCoverCoords.y, vCoverCoords.z);
		}
		else
		{
			formatf(szText, "vNetCoverCoords : INVALID");
		}
	}

	grcDebugDraw::Line(vCoverCoords, VEC3V_TO_VECTOR3(GetPed()->GetTransform().GetPosition()), Color_blue);
	grcDebugDraw::Sphere(vCoverCoords, 0.025f, Color_blue);

	grcDebugDraw::Text(vStartPos, DD_ePCS_Pixels, Color_blue, szText);
	vStartPos.SetYf(svStartPos.GetYf() + ++iNoTexts*iVerticalSpace);

	formatf(szText, "m_iPreviousCoverStepNodeIndex : %i", m_iPreviousCoverStepNodeIndex);
	grcDebugDraw::Text(vStartPos, DD_ePCS_Pixels, Color_blue, szText);
	vStartPos.SetYf(svStartPos.GetYf() + ++iNoTexts*iVerticalSpace);

	formatf(szText, "m_iCurrentCoverStepNodeIndex : %i", m_iCurrentCoverStepNodeIndex);
	grcDebugDraw::Text(vStartPos, DD_ePCS_Pixels, Color_blue, szText);
	vStartPos.SetYf(svStartPos.GetYf() + ++iNoTexts*iVerticalSpace);

	grcDebugDraw::AddDebugOutput(Color_green, "m_iCurrentCoverStepNodeIndex : (%i)", m_iCurrentCoverStepNodeIndex);
	grcDebugDraw::AddDebugOutput(Color_green, "m_vStickInput : (%.2f, %.2f)", m_vecStick.x, m_vecStick.y);
	grcDebugDraw::AddDebugOutput(Color_green, "m_fPeekHeightOffsetFromMover : (%.2f)", GetPed()->GetLowCoverHeightOffsetFromMover());
	if (GetPed()->IsLocalPlayer())
	{
		grcDebugDraw::AddDebugOutput(Color_green, "Externally Driven Pelvis Offset : (%.2f)", GetPed()->GetIkManager().GetExternallyDrivenPelvisOffset());
	}

// 	Vec2V vCentre(ms_Tunables.m_ControlDebugXPos, ms_Tunables.m_ControlDebugYPos);
// 
// 	grcDebugDraw::Circle(vCentre, ms_Tunables.m_ControlDebugRadius, Color_black, false);
// 	const float fAngle = rage::Atan2f(m_vecStick.y, m_vecStick.x);
// 	grcDebugDraw::Arc(vCentre, ms_Tunables.m_ControlDebugRadius, Color_green, ms_Tunables.m_ControlDebugBeginAngle, ms_Tunables.m_ControlDebugEndAngle, true);

	if (GetPed()->IsLocalPlayer())
	{
		const CPed& ped = *GetPed();
		if (ped.GetCoverPoint())
		{
			grcDebugDraw::AddDebugOutput(Color_green, "Usage : %s", CCoverPoint::GetCoverUsageName(ped.GetCoverPoint()->GetUsage()));
			grcDebugDraw::AddDebugOutput(Color_green, "Dynamic Inside Edge : %s", ped.GetPlayerInfo()->DynamicCoverInsideCorner() ? "TRUE" : "FALSE");

			Vector3 stepOutMoverPosition;
			float dummyHeading;
			bool shouldAimDirectly		= false;
			const bool isPositionValid	= ComputeCoverAimPositionAndHeading(stepOutMoverPosition, dummyHeading, shouldAimDirectly, true);
			if (isPositionValid)
			{
				grcDebugDraw::AddDebugOutput(Color_green, shouldAimDirectly ? "Aim Directly TRUE" : "Aim Directly FALSE");
				grcDebugDraw::Sphere(stepOutMoverPosition, 0.025f, Color_yellow);
			}

			Vector3 vPedPosition = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
			Vector3 vCoverDirection = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector());
			Vector3 vCoverPosition(Vector3::ZeroType);
			if (ped.GetCoverPoint()->GetCoverPointPosition(vCoverPosition))
			{
				const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
				Vector3 vCamFront = aimCameraFrame.GetFront();
				vCamFront.z = 0.0f;
				vCamFront.Normalize();

				TUNE_GROUP_BOOL(COVER_TUNE, RENDER_AIMING_DIRECTLY_DEBUG, false);
				if (RENDER_AIMING_DIRECTLY_DEBUG)
				{
					const float fBlindFireLimitAngle = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) ? CTaskAimGunBlindFire::ms_Tunables.m_HighBlindFireAimingDirectlyLimitAngle : CTaskAimGunBlindFire::ms_Tunables.m_LowBlindFireAimingDirectlyLimitAngle;
					Vector3 vLeftLimit = vCoverDirection;
					vLeftLimit.RotateZ(fBlindFireLimitAngle);
					Vector3 vRightLimit = vCoverDirection;
					vRightLimit.RotateZ(-fBlindFireLimitAngle);
					grcDebugDraw::Line(vPedPosition, vPedPosition + vCoverDirection, Color_yellow);
					grcDebugDraw::Line(vPedPosition, vPedPosition + vLeftLimit, Color_orange);
					grcDebugDraw::Line(vPedPosition, vPedPosition + vRightLimit, Color_blue);
					const float fLeftCross = vLeftLimit.CrossZ(vCamFront);
					const float fRightCross = vRightLimit.CrossZ(vCamFront);
					const bool bAimingDirectly = (fLeftCross < 0.0f && fRightCross > 0.0f) ? false : true;
					grcDebugDraw::Line(vPedPosition, vPedPosition + vCamFront, bAimingDirectly ? Color_green : Color_red);
				}

				if (CTaskAimGunFromCoverIntro::ms_Tunables.m_RenderAimArcDebug)
				{
					vCoverPosition.z += 1.0f;
					grcDebugDraw::Sphere(vCoverPosition, 0.05f, Color_red);
					
					if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
					{
						Vector3 vSide = vCoverDirection;
						Vector3 vRight = vSide;
						vRight.RotateZ(-HALF_PI);
						Vector3 vLeft = vSide;
						vLeft.RotateZ(HALF_PI);

						if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
							vSide = vLeft;
						else
							vSide = vRight;

						const CTaskAimGunFromCoverIntro::AimStepInfoSet& aimStepInfoSet = CTaskAimGunFromCoverIntro::ms_Tunables.GetAimStepInfoSet(IsCoverFlagSet(CTaskCover::CF_FacingLeft));

						for (s32 i=0; i<aimStepInfoSet.m_StepInfos.GetCount(); ++i)
						{
							Color32 renderColor = CTaskAimGunFromCoverIntro::GetAimStepColor(i);
							renderColor.SetAlpha(128);
							Vec3V vStepPosition = CTaskAimGunFromCoverIntro::ms_Tunables.m_RenderArcsAtCoverPosition ? VECTOR3_TO_VEC3V(vCoverPosition) : VECTOR3_TO_VEC3V(vCoverPosition + aimStepInfoSet.m_StepInfos[i].m_StepOutX * vSide - aimStepInfoSet.m_StepInfos[i].m_StepOutY * vCoverDirection);
							vStepPosition += Vec3V(0.0f, 0.0f, 0.01f * i);
							Vec3V vYAxis(V_Y_AXIS_WZERO);
							TUNE_GROUP_BOOL(COVER_AIM_TUNE, ZERO_BASE_HEADING, false);
							float fCoverHeading = fwAngle::LimitRadianAngle(rage::Atan2f(-vCoverDirection.x, vCoverDirection.y));
							float fPedCoverHeading = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? fwAngle::LimitRadianAngle(fCoverHeading + HALF_PI) : fwAngle::LimitRadianAngle(fCoverHeading - HALF_PI);
							const float fAngleMin = ComputeStepTransitionMinAngle(ped,i,IsCoverFlagSet(CTaskCover::CF_FacingLeft),fwAngle::LimitRadianAngle(fPedCoverHeading + aimStepInfoSet.m_StepInfos[i].m_StepTransitionMinAngle));
							const float fAngleMax = fwAngle::LimitRadianAngle(fPedCoverHeading + aimStepInfoSet.m_StepInfos[i].m_StepTransitionMaxAngle);
							Vec3V vMinArc =  RotateAboutZAxis(vYAxis, ScalarVFromF32(fwAngle::LimitRadianAngle(fAngleMin)));
							vMinArc *= ScalarVFromF32(CTaskAimGunFromCoverIntro::ms_Tunables.m_ArcRadius);
							Vec3V vMaxArc =  RotateAboutZAxis(vYAxis, ScalarVFromF32(fwAngle::LimitRadianAngle(fAngleMax)));
							vMaxArc *= ScalarVFromF32(CTaskAimGunFromCoverIntro::ms_Tunables.m_ArcRadius);
							Vec3V vXAxis = vMinArc;	
							vXAxis = RotateAboutZAxis(vXAxis, ScalarVFromF32(HALF_PI));
							grcDebugDraw::Arc(vStepPosition, CTaskAimGunFromCoverIntro::ms_Tunables.m_ArcRadius, renderColor, vMinArc, vXAxis, 0.0f, fwAngle::LimitRadianAngle(fAngleMax - fAngleMin), true);		
							renderColor.SetAlpha(255);
							grcDebugDraw::Line(vStepPosition + vMinArc, vStepPosition, renderColor);
							grcDebugDraw::Line(vStepPosition + vMaxArc, vStepPosition, renderColor);
							grcDebugDraw::Sphere(vStepPosition, 0.025f, renderColor);

							Vector3 vMinArc1(0.0f, 1.0f, 0.0f);
							vMinArc1.RotateZ(fAngleMin);
							Vector3 vMaxArc1(0.0f, 1.0f, 0.0f);
							vMaxArc1.RotateZ(fAngleMax);

							const float fMinCrossZCam = vMinArc1.CrossZ(vCamFront);
							const float fMaxCrossZCam = vMaxArc1.CrossZ(vCamFront);

							if (fMinCrossZCam >= 0.0f && fMaxCrossZCam <= 0.0f)
							{
								grcDebugDraw::Arrow(vStepPosition, vStepPosition + RCC_VEC3V(vCamFront), 0.25f, renderColor);
							}
						}
					}
				}
			}
		}

		// Print out the previous frames cover coords
		grcDebugDraw::AddDebugOutput(Color_green, "m_vCoverCoords : (%.2f, %.2f, %.2f)", m_vCoverCoords.x, m_vCoverCoords.y, m_vCoverCoords.z);

		if (GetPed()->GetCoverPoint())
		{
			const Vector3 vCoverDir = VEC3V_TO_VECTOR3(GetPed()->GetCoverPoint()->GetCoverDirectionVector());
			float fCoverDirection = rage::Atan2f(-vCoverDir.x, vCoverDir.y);
			if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
			{
				fCoverDirection += HALF_PI;
			}
			else 
			{
				fCoverDirection -= HALF_PI;
			}
			fCoverDirection = fwAngle::LimitRadianAngle(fCoverDirection);
			Vector3 vFacingDirection(0.0f,1.0f,0.0f);
			vFacingDirection.RotateZ(fCoverDirection);
			vFacingDirection += m_vCoverCoords;
			grcDebugDraw::Arrow(RCC_VEC3V(m_vCoverCoords), RCC_VEC3V(vFacingDirection), 0.025f, Color_green);
		}

		if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint)) grcDebugDraw::AddDebugOutput(Color_green, "CF_TooHighCoverPoint");
		else								   grcDebugDraw::AddDebugOutput(Color_red, "!CF_TooHighCoverPoint");
	}
#endif

	if (GetSubTask())
		GetSubTask()->Debug();
}

////////////////////////////////////////////////////////////////////////////////

void CTaskInCover::DrawDebug() const
{
#if DEBUG_DRAW
	if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		grcDebugDraw::AddDebugOutput(Color_green, "Direction : Left");
	}
	else
	{
		grcDebugDraw::AddDebugOutput(Color_green, "Direction : Right");
	}
	
	char szText[128];
	const CPed* pPed = GetPed();

	// Draw distance from coverpoint
	const Vector3 vPedPosition(VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()));
	Vector3 vPedPosCoverZ(vPedPosition);
	vPedPosCoverZ.z = m_vCoverCoords.z;

	grcDebugDraw::Line(vPedPosCoverZ,m_vCoverCoords,Color_purple,Color_purple);
	grcDebugDraw::Sphere(vPedPosCoverZ,0.025f,Color_purple);

	Vector3 vTargetPos;
	GetTarget().GetPosition(vTargetPos);
	grcDebugDraw::Sphere(vTargetPos,0.025f,Color_green);

	const float fMagDiff = (vPedPosCoverZ - m_vCoverCoords).Mag();
	formatf(szText,"XY Distance from cover : %.2f", fMagDiff);
	grcDebugDraw::Text(vPedPosCoverZ, Color_purple, szText);

	// Draw the facing direction
	float fFacingDirection = rage::Atan2f(-m_vCoverDirection.x, m_vCoverDirection.y);

	Vector3 vOriginalFacing(0.0f,2.0f,0.0f);
	vOriginalFacing.RotateZ(fFacingDirection);
	grcDebugDraw::Line(vPedPosition,vPedPosition+vOriginalFacing,Color_red,Color_yellow);

	fFacingDirection += IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? HALF_PI : -HALF_PI;
	const float THREE_PI = 3.0f * PI;

	if (fFacingDirection < -THREE_PI) fFacingDirection = -THREE_PI + 0.01f;
	if (fFacingDirection > THREE_PI) fFacingDirection = THREE_PI - 0.01f;
	fFacingDirection = fwAngle::LimitRadianAngle(fFacingDirection);

	// Draw an arrow in the direction of the cover
	Vector3 vFacing(0.0f,1.0f,0.0f);
	vFacing.RotateZ(fFacingDirection);

	static float s_fArrowAngle = 3.0f * QUARTER_PI; 

	Vector3 vArrowHeadL(0.0f,0.1f,0.0f);
	vArrowHeadL.RotateZ(fFacingDirection + s_fArrowAngle);

	Vector3 vArrowHeadR(0.0f,0.1f,0.0f);
	vArrowHeadR.RotateZ(fFacingDirection - s_fArrowAngle);

	Vector3 vArrowTipPos = vPedPosition + vFacing;
	grcDebugDraw::Line(vPedPosition,vArrowTipPos,Color_green,Color_green);

	grcDebugDraw::Line(vArrowTipPos,vArrowTipPos + vArrowHeadL ,Color_green,Color_green);
	grcDebugDraw::Line(vArrowTipPos,vArrowTipPos + vArrowHeadR ,Color_green,Color_green);

	formatf(szText,"Heading Error : %.4f", Abs(fFacingDirection - pPed->GetCurrentHeading()));
	grcDebugDraw::Text(vPedPosCoverZ, Color_purple, 0, -10, szText);
#endif
}

#endif // !__FINAL

////////////////////////////////////////////////////////////////////////////////

// Statics
CTaskMotionInCover::Tunables CTaskMotionInCover::ms_Tunables;

IMPLEMENT_COMBAT_TASK_TUNABLES(CTaskMotionInCover, 0xc3133fe6);

////////////////////////////////////////////////////////////////////////////////

#if FPS_MODE_SUPPORTED
bool CTaskMotionInCover::ShouldUseFirstPersonLocoAnimations(const CPed& rPed)
{
	if (!ms_Tunables.m_EnableFirstPersonLocoAnimations)
	{
		return false;
	}

	if (CTaskCover::CanUseThirdPersonCoverInFirstPerson(rPed))
	{
		return false;
	}

	if (rPed.GetPlayerResetFlag(CPlayerResetFlags::PRF_CAMERA_VIEW_MODE_SWITCHED_TO_OR_FROM_FIRST_PERSON))
	{
		return rPed.GetPlayerResetFlag(CPlayerResetFlags::PRF_CAMERA_VIEW_MODE_SWITCHED_TO_FIRST_PERSON);
	}
	return rPed.IsFirstPersonShooterModeEnabledForPlayer(false);
}

bool CTaskMotionInCover::ShouldUseFirstPersonAimingAnimations(const CPed& rPed)
{
	if (!ms_Tunables.m_EnableFirstPersonAimingAnimations)
	{
		return false;
	}

	if (CTaskCover::CanUseThirdPersonCoverInFirstPerson(rPed))
	{
		return false;
	}

	if (rPed.GetPlayerResetFlag(CPlayerResetFlags::PRF_CAMERA_VIEW_MODE_SWITCHED_TO_OR_FROM_FIRST_PERSON))
	{
		return rPed.GetPlayerResetFlag(CPlayerResetFlags::PRF_CAMERA_VIEW_MODE_SWITCHED_TO_FIRST_PERSON);
	}
	return rPed.IsFirstPersonShooterModeEnabledForPlayer(false);
}
#endif // FPS_MODE_SUPPORTED

fwMvClipSetId CTaskMotionInCover::Tunables::GetCoreMotionClipSetIdForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed)) const
{
#if FPS_MODE_SUPPORTED
	return ShouldUseFirstPersonLocoAnimations(rPed) ? m_CoreMotionFPSClipSetId : m_CoreMotionClipSetId;
#else // FPS_MODE_SUPPORTED
	return m_CoreMotionClipSetId;
#endif // FPS_MODE_SUPPORTED
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetIdleAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_IdleAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_IdleAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetAtEdgeAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_AtEdgeAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_AtEdgeAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetPeekingAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_PeekingAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_PeekingAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetStoppingAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_StoppingAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_StoppingAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetMovingAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_MovingAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_MovingAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetEdgeTurnAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_EdgeTurnAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_EdgeTurnAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetCoverToCoverAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_CoverToCoverAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_CoverToCoverAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetSteppingAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_SteppingAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_SteppingAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetWalkStartAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_WalkStartAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_WalkStartAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetSettleAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_SettleAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_SettleAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetTurnEnterAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_TurnEnterAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_TurnEnterAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetTurnEndAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_TurnEndAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_TurnEndAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskMotionInCover::Tunables::GetTurnWalkStartAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_WalkStartAnimStateInfos; )
	return m_ThirdPersonAnimStateInfos.m_WalkStartAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

const fwMvFilterId CTaskMotionInCover::Tunables::GetWeaponHoldingFilterIdForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{ 
	FPS_MODE_SUPPORTED_ONLY( if (ShouldUseFirstPersonLocoAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_WeaponHoldingFilterId; )
	return m_ThirdPersonAnimStateInfos.m_WeaponHoldingFilterId;
}

////////////////////////////////////////////////////////////////////////////////

// OnEnter Signals
const fwMvBooleanId CTaskMotionInCover::ms_IdleOnEnterId("Idle_OnEnter",0xCA902721);
const fwMvBooleanId CTaskMotionInCover::ms_IdleVariationOnEnterId("IdleVariation_OnEnter",0xF21DDE78);
const fwMvBooleanId CTaskMotionInCover::ms_AtEdgeOnEnterId("AtEdge_OnEnter",0x579C9D48);
const fwMvBooleanId CTaskMotionInCover::ms_MovingOnEnterId("Moving_OnEnter",0xA068F4FA);
const fwMvBooleanId CTaskMotionInCover::ms_PeekingOnEnterId("Peeking_OnEnter",0x34A4A7FE);
const fwMvBooleanId CTaskMotionInCover::ms_StoppingOnEnterId("Stop_OnEnter",0x9AF7C8F);
const fwMvBooleanId CTaskMotionInCover::ms_NormalTurnOnEnterId("NormalTurn_OnEnter",0x2377B945);
const fwMvBooleanId CTaskMotionInCover::ms_EdgeTurnOnEnterId("EdgeTurn_OnEnter",0x7AC1CF2A);
const fwMvBooleanId CTaskMotionInCover::ms_CoverToCoverOnEnterId("CoverToCover_OnEnter",0xCEEF1261);
const fwMvBooleanId CTaskMotionInCover::ms_PinnedIntroOnEnterId("PinnedIntro_OnEnter",0xAD4D70DE);
const fwMvBooleanId CTaskMotionInCover::ms_PinnedIdleOnEnterId("PinnedIdle_OnEnter",0xB213A1FD);
const fwMvBooleanId CTaskMotionInCover::ms_PinnedOutroOnEnterId("PinnedOutro_OnEnter",0x79ED2D58);
const fwMvBooleanId	CTaskMotionInCover::ms_SteppingOnEnterId("Stepping_OnEnter",0xFB52B63F);
const fwMvBooleanId	CTaskMotionInCover::ms_WalkStartOnEnterId("WalkStart_OnEnter",0xBE057D1B);
const fwMvBooleanId	CTaskMotionInCover::ms_SettleOnEnterId("Settle_OnEnter",0x3E3E1E30);
const fwMvBooleanId	CTaskMotionInCover::ms_TurnEnterOnEnterId("TurnEnter_OnEnter",0x5F86C2AC);
const fwMvBooleanId	CTaskMotionInCover::ms_TurnEndOnEnterId("TurnEnd_OnEnter",0x33B37DFE);

// Loop Signals
const fwMvBooleanId CTaskMotionInCover::ms_LoopPeekClipId("LoopPeekClip",0xD32B1F7);
const fwMvBooleanId CTaskMotionInCover::ms_LoopPinnedIdleId("LoopPinnedIdle",0x81346F04);

// ClipFinished Signals
const fwMvBooleanId CTaskMotionInCover::ms_StoppingClipFinishedId("StopClipFinished",0xD0527475);
const fwMvBooleanId CTaskMotionInCover::ms_NormalTurnClipFinishedId("NormalTurnClipFinished",0x7FC9E9EE);
const fwMvBooleanId CTaskMotionInCover::ms_EdgeTurnClipFinishedId("EdgeTurnClipFinished",0xA920EC33);
const fwMvBooleanId CTaskMotionInCover::ms_CoverToCoverClipFinishedId("CoverToCoverClipFinished",0x306D6A58);
const fwMvBooleanId CTaskMotionInCover::ms_PeekingClipFinishedId("PeekingClipFinished",0x57B9A9C2);
const fwMvBooleanId CTaskMotionInCover::ms_PinnedIntroClipFinishedId("PinnedIntroClipFinished",0x41C81991);
const fwMvBooleanId CTaskMotionInCover::ms_PinnedOutroClipFinishedId("PinnedOutroClipFinished",0xEEFDA185);
const fwMvBooleanId CTaskMotionInCover::ms_PinnedIdleClipFinishedId("PinnedIdleClipFinished",0x469F79A3);
const fwMvBooleanId CTaskMotionInCover::ms_IdleVariationClipFinishedId("IdleVariationClipFinished",0xBCF6E53D);
const fwMvBooleanId CTaskMotionInCover::ms_StepClipFinishedId("StepClipFinished",0xB999F992);
const fwMvBooleanId CTaskMotionInCover::ms_SettleClipFinishedId("SettleClipFinished",0x72539187);
const fwMvBooleanId CTaskMotionInCover::ms_ToStandLSettleId("ToStandLSettle",0xBAA8487);
const fwMvBooleanId CTaskMotionInCover::ms_ToStandRSettleId("ToStandRSettle",0x76F1E408);
const fwMvBooleanId CTaskMotionInCover::ms_ToStandLId("ToStandL",0xB008A146);
const fwMvBooleanId CTaskMotionInCover::ms_ToStandRId("ToStandR",0x23830839);
const fwMvBooleanId CTaskMotionInCover::ms_ToCrouchLSettleId("ToCrouchLSettle",0x2AEAE3F0);
const fwMvBooleanId CTaskMotionInCover::ms_ToCrouchRSettleId("ToCrouchRSettle",0xE2698313);
const fwMvBooleanId CTaskMotionInCover::ms_ToCrouchLId("ToCrouchL",0xC0D2046B);
const fwMvBooleanId CTaskMotionInCover::ms_ToCrouchRId("ToCrouchR",0x2880D3C7);
const fwMvBooleanId CTaskMotionInCover::ms_ToWalkId("ToWalk",0x5F3191B9);
const fwMvBooleanId CTaskMotionInCover::ms_CanEarlyOutForMovementId("CAN_EARLY_OUT_FOR_MOVEMENT",0x7E1C8464);
const fwMvBooleanId CTaskMotionInCover::ms_ToStepId("ToStep",0x78F58B63);
const fwMvBooleanId CTaskMotionInCover::ms_ToTurnId("ToTurn",0xFC5517C9);
const fwMvBooleanId CTaskMotionInCover::ms_FixupRotationId("FixupRotation",0xC86B83FA);
const fwMvBooleanId CTaskMotionInCover::ms_TurnEnterClipFinishedId("TurnEnterAnimFinished",0x0EC2DBDD);
const fwMvBooleanId CTaskMotionInCover::ms_TurnEndClipFinishedId("TurnEndClipFinished",0x8B80E51C);
const fwMvBooleanId CTaskMotionInCover::ms_WalkStartClipFinishedId("WalkStartClipFinished",0x46EAED76);

// ClipInterrupt Signals
const fwMvBooleanId CTaskMotionInCover::ms_EdgeTurnFixupId("EdgeTurnFixup", 0xbb463643);
const fwMvBooleanId CTaskMotionInCover::ms_EdgeTurnInterruptId("EdgeTurnInterrupt",0xB8BCB241);
const fwMvBooleanId CTaskMotionInCover::ms_TurnInterruptId("TurnInterrupt",0x3E87DE7A);
const fwMvBooleanId CTaskMotionInCover::ms_TurnInterruptToMovingId("TurnInterruptToMoving",0x8E156458);
const fwMvBooleanId CTaskMotionInCover::ms_TurnInterruptToTurnId("TurnInterruptToTurn",0x7979B434);
const fwMvBooleanId CTaskMotionInCover::ms_TurnInterruptToAimId("TurnInterruptToAim",0x919F434E);

// MoveStateRequest Signals
const fwMvRequestId CTaskMotionInCover::ms_StillRequestId("Still",0x48A35826);
const fwMvRequestId CTaskMotionInCover::ms_MovingRequestId("Moving",0xDF719C6C);
const fwMvRequestId CTaskMotionInCover::ms_StoppingRequestId("Stop",0x930CA7F2);
const fwMvRequestId CTaskMotionInCover::ms_RestartNormalTurnRequestId("RestartNormalTurn",0x6327947E);
const fwMvRequestId CTaskMotionInCover::ms_RestartEdgeTurnRequestId("RestartEdgeTurn",0x30033430);
const fwMvRequestId CTaskMotionInCover::ms_TurningRequestId("Turn",0x2325A549);
const fwMvRequestId CTaskMotionInCover::ms_CoverToCoverRequestId("CoverToCover",0x715BC6BE);
const fwMvRequestId CTaskMotionInCover::ms_RestartWeaponHoldingRequestId("RestartWeaponHolding",0x16F3EF2E);
const fwMvRequestId CTaskMotionInCover::ms_PinnedIdleRequestId("PinnedIdle",0xD2666B8A);
const fwMvRequestId CTaskMotionInCover::ms_PinnedOutroRequestId("PinnedOutro",0x620DB877);
const fwMvRequestId CTaskMotionInCover::ms_SteppingRequestId("Stepping",0xD8F9DDEF);
const fwMvRequestId CTaskMotionInCover::ms_WalkStartRequestId("WalkStart",0xFBE90A9E);
const fwMvRequestId CTaskMotionInCover::ms_SettleRequestId("Settle",0x20AA083B);
const fwMvRequestId CTaskMotionInCover::ms_TurnEnterRequestId("TurnEnter",0xECE08BE5);
const fwMvRequestId CTaskMotionInCover::ms_TurnEndRequestId("TurnEnd",0x6CABC743);

// ClipInput Signals
const fwMvClipId CTaskMotionInCover::ms_Clip0Id("Clip0",0xF416C5E4);
const fwMvClipId CTaskMotionInCover::ms_Clip1Id("Clip1",0xD60C89C4);
const fwMvClipId CTaskMotionInCover::ms_Clip2Id("Clip2",0xB58F45C);
const fwMvClipId CTaskMotionInCover::ms_Clip3Id("Clip3",0xB193C0D3);
const fwMvClipId CTaskMotionInCover::ms_Clip4Id("Clip4",0xe6cd2b45);
const fwMvClipId CTaskMotionInCover::ms_Clip5Id("Clip5",0x951e87e9);
const fwMvClipId CTaskMotionInCover::ms_WeaponClip0Id("WeaponClip0",0x7290AD29);
const fwMvClipId CTaskMotionInCover::ms_WeaponClip1Id("WeaponClip1",0x5F6786D7);
const fwMvClipId CTaskMotionInCover::ms_WeaponClip2Id("WeaponClip2",0xCE2DE462);
const fwMvClipId CTaskMotionInCover::ms_WeaponClip3Id("WeaponClip3",0xBCD941B9);

// ClipOutput Signals
const fwMvClipId CTaskMotionInCover::ms_IdleClipId("IdleClip",0x3894F399);
const fwMvClipId CTaskMotionInCover::ms_TurnClipId("TurnClip",0x6FC1A446);
const fwMvClipId CTaskMotionInCover::ms_EdgeClipId("EdgeClip",0x6BBA7C75);
const fwMvClipId CTaskMotionInCover::ms_GripClipId("GripClip",0x9C688F9B);
const fwMvClipId CTaskMotionInCover::ms_CoverToCoverClipId("CoverToCoverClip",0x4C46CFC);

// Rate Signals
const fwMvFloatId CTaskMotionInCover::ms_StepRateId("StepRate", 0x91de6a66);
const fwMvFloatId CTaskMotionInCover::ms_TurnRateId("TurnRate", 0x58af9dcd);
const fwMvFloatId CTaskMotionInCover::ms_TurnStepRateId("TurnStepRate", 0x1c3786b1);
const fwMvFloatId CTaskMotionInCover::ms_WalkStartRateId("WalkStartRate", 0x7a36e869);
const fwMvFloatId CTaskMotionInCover::ms_MovementRateId("MovementRate",0xE654C106);
const fwMvFloatId CTaskMotionInCover::ms_CoverToCoverRateId("CoverToCoverRate",0x8119C0D8);
const fwMvFloatId CTaskMotionInCover::ms_TurnEndToTurnEnterBlendDurationId("TurnEndToTurnEnterBlendDuration",0x8856AA99);

// PhaseOutput Signals
const fwMvFloatId CTaskMotionInCover::ms_TurnClipCurrentPhaseId("TurnClipCurrentPhase",0x8FB4053F);
const fwMvFloatId CTaskMotionInCover::ms_CoverToCoverClipCurrentPhaseId("CoverToCoverClipCurrentPhase",0xE1E00BC9);
const fwMvFloatId CTaskMotionInCover::ms_SteppingClipCurrentPhaseId("SteppingClipCurrentPhaseId",0xC81DD496);
const fwMvFloatId CTaskMotionInCover::ms_IdleVariationCurrentPhaseID("IdleVariationCurrentPhase",0x69C6FAA8);
const fwMvFloatId CTaskMotionInCover::ms_RestartStillBlendDurationId("RestartStillBlendDuration",0x075a05cb);

// Still State Flags
const fwMvFlagId CTaskMotionInCover::ms_IdleFlagId("Idle",0x71C21326);
const fwMvFlagId CTaskMotionInCover::ms_IdleVariationFlagId("IdleVariation",0x11ACAF68);
const fwMvFlagId CTaskMotionInCover::ms_AtEdgeFlagId("AtEdge",0x5981F851);
const fwMvFlagId CTaskMotionInCover::ms_PeekingFlagId("Peeking",0x3E624EC1);
const fwMvFlagId CTaskMotionInCover::ms_EdgeTurnFlagId("EdgeTurn",0x5A42406C);
const fwMvFlagId CTaskMotionInCover::ms_PinnedFlagId("Pinned",0xD6C51D08);
const fwMvFlagId CTaskMotionInCover::ms_UseWeaponHoldingId("UseWeaponHolding",0xA4C5BC51);
const fwMvFlagId CTaskMotionInCover::ms_UseGripClipId("UseGripClip",0x72838804);

// Blend Input Params
const fwMvFloatId CTaskMotionInCover::ms_HeightId("Height",0x52FDF336);
const fwMvFloatId CTaskMotionInCover::ms_SpeedId("Speed",0xF997622B);
const fwMvFloatId CTaskMotionInCover::ms_StepDistanceId("StepDistance",0xA21864A9);
const fwMvFloatId CTaskMotionInCover::ms_MovementClipRateId("MovementClipRate",0xA13D6505);
const fwMvFloatId CTaskMotionInCover::ms_StillToTurnBlendDurationId("StillToTurnBlendDuration",0xC0DDE321);
const fwMvFloatId CTaskMotionInCover::ms_SettleBlendDurationId("SettleBlendDuration",0xC793B2D3);
const fwMvFloatId CTaskMotionInCover::ms_CamHeadingId("CamHeading",0x40b9a168);
const fwMvFloatId CTaskMotionInCover::ms_StoppingToTurnEnterBlendDurationId("StoppingToTurnEnterBlendDuration",0x90052856);

// Variable ClipSetIds
const fwMvClipSetVarId CTaskMotionInCover::ms_CoreMotionClipSetId("CoreMotionClipSet",0x55CDF626);
const fwMvClipSetVarId CTaskMotionInCover::ms_UpperBodyWeaponMotionClipSetId("UpperBodyWeaponMotionClipSet",0xF9908C36);
const fwMvClipSetVarId CTaskMotionInCover::ms_WeaponClipSetId("WeaponClipSet",0xD1026F2C);
const fwMvClipSetVarId CTaskMotionInCover::ms_FPSIntroGripClipSetId("FPSIntroGripClipSet",0x9EEAA117);

// Filters
const fwMvFilterId CTaskMotionInCover::ms_GripFilterId("GripFilter",0x57C40DEC);
const fwMvFilterId CTaskMotionInCover::ms_WeaponHoldingFilterId("WeaponHoldingFilter",0x7de5f3b1);

#if FPS_MODE_SUPPORTED
const fwMvFlagId CTaskMotionInCover::ms_IsFirstPersonFlagId("IsFirstPerson",0x69e1dd72);
#endif // FPS_MODE_SUPPORTED

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::StartMotionInCoverNetwork(CMoveNetworkHelper& taskCoverMoveNetworkHelper, CMoveNetworkHelper& moveNetworkHelper, CPed* pPed)
{
	if (!moveNetworkHelper.IsNetworkActive())
	{
		fwMvClipSetId movementClipSet = CTaskCover::GetWeaponHoldingClipSetForArmament(pPed);
		fwClipSet* pClipSet = fwClipSetManager::GetClipSet(movementClipSet);
#if __ASSERT
		if (!taskVerifyf(pClipSet, "Couldn't find cover movement clipset"))
		{
			return false;
		}
#endif // __ASSERT

		if (!taskVerifyf(pClipSet->IsStreamedIn_DEPRECATED(), "ClipSet %s wasn't streamed in", pClipSet->GetClipDictionaryName().GetCStr()))
		{
			return false;
		}

		moveNetworkHelper.CreateNetworkPlayer(pPed, CClipNetworkMoveInfo::ms_NetworkTaskMotionInCover);
		moveNetworkHelper.SetClipSet(movementClipSet);
	}

	if (!moveNetworkHelper.IsNetworkAttached())
	{
		taskCoverMoveNetworkHelper.SetSubNetwork(moveNetworkHelper.GetNetworkPlayer(), CTaskCover::ms_MotionTaskNetworkId);
		return false;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::PlayerCheckForMovingAbout(const CPed& ped, bool bFacingLeft, const Vector2& vStickIn, u32 m_uTimeOfLastRoundCornerMove)
{
	taskAssert(ped.IsLocalPlayer());

	bool bPlayersLocalCoverpoint = ped.GetPlayerInfo()->GetDynamicCoverPoint() == ped.GetCoverPoint();

	bool bWantsToMoveRight = vStickIn.x > CTaskInCover::ms_Tunables.m_MinStickInputToMoveInCover;
	bool bWantsToMoveLeft = vStickIn.x < -CTaskInCover::ms_Tunables.m_MinStickInputToMoveInCover;

	const bool bHitPed = ped.GetPlayerInfo()->DynamicCoverHitPed();
	if (bHitPed)
	{
		FindNewDynamicCoverPoint(const_cast<CPed*>(&ped), 0.0f, bFacingLeft, false, true);
	}

	static dev_u32 s_uMinIntervalBetweenRoundCoverMoveInputs = 1000;
	bool bIsRoundCover = ped.GetPlayerInfo()->IsRoundCover();
	bool bRoundCoverMoveOk = bIsRoundCover && ped.GetControlFromPlayer()->GetPedJump().IsDown() 
		&& (fwTimer::GetTimeInMilliseconds() - m_uTimeOfLastRoundCornerMove) > s_uMinIntervalBetweenRoundCoverMoveInputs;
	const bool bCanMoveRight = bRoundCoverMoveOk || (!bIsRoundCover && ped.GetPlayerInfo()->DynamicCoverCanMoveRight() && ped.GetCoverPoint()->GetUsage() != CCoverPoint::COVUSE_WALLTOLEFT);
	const bool bCanMoveLeft = bRoundCoverMoveOk || (!bIsRoundCover && ped.GetPlayerInfo()->DynamicCoverCanMoveLeft() && ped.GetCoverPoint()->GetUsage() != CCoverPoint::COVUSE_WALLTORIGHT);
	const bool bCanMoveAboutDynamicCover = bPlayersLocalCoverpoint && ( (bWantsToMoveRight && bCanMoveRight) || (bWantsToMoveLeft && bCanMoveLeft ) );

	if (bCanMoveAboutDynamicCover || (!bPlayersLocalCoverpoint && (bWantsToMoveRight || bWantsToMoveLeft)))
	{
		//m_fTimeSinceLastDynamicCoverCheck = 0.0f;
		//Vector3 vTestPos = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());

		// Don't allow ped to move in the opposite direction they're facing
		if (bWantsToMoveLeft && !bFacingLeft)
		{
			//BANK_ONLY(if (CCoverDebug::ms_bEnableTaskDebugSpew) Displayf("CheckForMovingAbout FAILED in state %s",GetStateName(GetState()));)
			return false;
		}
		else if (bWantsToMoveRight && bFacingLeft)
		{
			//BANK_ONLY(if (CCoverDebug::ms_bEnableTaskDebugSpew) Displayf("CheckForMovingAbout FAILED in state %s",GetStateName(GetState()));)
			return false;
		} 

		TUNE_GROUP_FLOAT(COVER_TUNE, PED_CHECK_OFFSET, 0.5f, 0.0f, 1.0f, 0.01f);
		Vector3 vInFrontOfPed = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition()) + VEC3V_TO_VECTOR3(ped.GetTransform().GetB()) * PED_CHECK_OFFSET;
		if (!CTaskCover::IsCoverPositionValid(vInFrontOfPed, ped))
		{
			return false;
		}

		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::PlayerCheckForTurning(const CPed& FPS_MODE_SUPPORTED_ONLY(ped), bool bFacingLeft, bool UNUSED_PARAM(bAtEdge), bool FPS_MODE_SUPPORTED_ONLY(bFromTurn), const Vector2& vStickInput, const Vector3& UNUSED_PARAM(vCamHeading), bool FPS_MODE_SUPPORTED_ONLY(bIsHighCover), bool FPS_MODE_SUPPORTED_ONLY(bPeeking),
											   bool& FPS_MODE_SUPPORTED_ONLY(bDisallowTurnUntilInputZeroed))
{
	bool bWantsToTurnLeft = vStickInput.x < -CTaskInCover::ms_Tunables.m_MinStickInputXAxisToTurnInCover && !bFacingLeft;
	bool bWantsToTurnRight = vStickInput.x > CTaskInCover::ms_Tunables.m_MinStickInputXAxisToTurnInCover && bFacingLeft;

#if FPS_MODE_SUPPORTED
	if (ped.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		if (bDisallowTurnUntilInputZeroed)
		{
			if (bWantsToTurnLeft)
			{
				bWantsToTurnLeft = false;
			}
			else if (bWantsToTurnRight)
			{
				bWantsToTurnRight = false;
			}
			else
			{
				bDisallowTurnUntilInputZeroed = false;
			}
		}

		// If we are at the lowest cover height then don't allow a turn into a corner since we won't be able to move and the
		// camera won't adjust the ped will just end up turning back
		camFirstPersonShooterCamera* pFPSCamera = camInterface::GetGameplayDirector().GetFirstPersonShooterCamera(&ped);
		if (!bIsHighCover && pFPSCamera && pFPSCamera->GetLowCoverHeightTValue(ped) <= 0.0f)
		{
			if (bWantsToTurnLeft && CTaskInCover::CanPedFireRoundCorner(ped, true))
			{
				bWantsToTurnLeft = false;
			}
			else if (bWantsToTurnRight && CTaskInCover::CanPedFireRoundCorner(ped, false))
			{
				bWantsToTurnRight = false;
			}
		}

		if (!bFromTurn)
		{
			if (!bIsHighCover && bPeeking)
			{
				return false;
			}

			Vector3 vTargetDirUnused;
			Vector3 vCoverDirection(Vector3::ZeroType);
			if (CCover::FindCoverDirectionForPed(ped, vCoverDirection, vTargetDirUnused))
			{
				Vector3 vCamFwd = camInterface::GetGameplayDirector().GetFrame().GetFront();
				vCamFwd.z = 0.0f;
				vCamFwd.Normalize();
				vCoverDirection.z = 0.0f;
				vCoverDirection.Normalize();
				const float fCovCamDot = vCoverDirection.Dot(vCamFwd);
				TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, TURN_DOT_TOLERANCE_FOR_TURN_COV, 0.5f, 0.0f, 1.0f, 0.01f);
				if (fCovCamDot > TURN_DOT_TOLERANCE_FOR_TURN_COV)
				{
					if (bWantsToTurnLeft || bWantsToTurnRight)
					{
						return true;
					}
				}
				
				TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, ALLOW_AUTO_TURN, true);
				TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, AUTO_TURN_DOT_TOLERANCE_FOR_TURN, 0.6f, 0.0f, 1.0f, 0.01f);
				Vector3 vPedFwd = VEC3V_TO_VECTOR3(ped.GetTransform().GetB());
				const float fPedCamDot = vPedFwd.Dot(vCamFwd);
				if (fPedCamDot > 0.0f)
				{
					return bWantsToTurnLeft || bWantsToTurnRight;
				}
				else if ((ALLOW_AUTO_TURN && ms_Tunables.m_EnableFirstPersonLocoAnimations) && Abs(fPedCamDot) > AUTO_TURN_DOT_TOLERANCE_FOR_TURN)
				{		
					return true;
				}
			}
		}
	}
#endif // FPS_MODE_SUPPORTED

	if (bWantsToTurnLeft || bWantsToTurnRight)
	{
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::PlayerCheckForCoverToCover(CCoverPoint& newCoverPoint, CPed& ped, bool bFacingLeft, const Vector2& vStickInput, bool bLowCover)
{
	taskAssert(ped.IsLocalPlayer());

	const CControl* pControl = ped.GetControlFromPlayer();

	const bool bYBlock = fabs(vStickInput.y) > CTaskMotionInCover::ms_Tunables.m_MinStickInputToEnableCoverToCover;
	const bool bWantsToMoveRight = vStickInput.x > ms_Tunables.m_MinStickInputToEnableCoverToCover && !bYBlock;
	const bool bWantsToMoveLeft = vStickInput.x < -ms_Tunables.m_MinStickInputToEnableCoverToCover && !bYBlock;

	if (((bWantsToMoveRight && !bFacingLeft)
		|| (bWantsToMoveLeft && bFacingLeft)))
	{
		if ((ms_Tunables.m_UseSprintButtonForCoverToCover && pControl->GetPedSprintIsPressed()) ||
			(!ms_Tunables.m_UseSprintButtonForCoverToCover && pControl->GetPedCover().IsPressed()))
		{
			const bool bCanMoveLeft = ped.GetPlayerInfo()->DynamicCoverCanMoveLeft();
			const bool bCanMoveRight = ped.GetPlayerInfo()->DynamicCoverCanMoveRight();
			const bool bFoundNewCover = CPlayerInfo::ms_DynamicCoverHelper.FindNewCoverToCoverPoint(&newCoverPoint, &ped, bFacingLeft, bLowCover);
			if (bFoundNewCover && ms_Tunables.m_EnableCoverToCover)
			{
				return true;
			}			
			else
			{
				ped.GetPlayerInfo()->SetDynamicCoverCanMoveLeft(bCanMoveLeft);
				ped.GetPlayerInfo()->SetDynamicCoverCanMoveRight(bCanMoveRight);
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::PlayerCheckForMoveAroundCorner(CPed& ped, bool bFacingLeft, const Vector2& UNUSED_PARAM(vStickInput), bool bLowCover, u32 uTimeJumpLastPressed)
{
	taskAssert(ped.IsLocalPlayer());

	CControl* pControl = ped.GetControlFromPlayer();
	if (ms_Tunables.m_UseButtonToMoveAroundCorner) 
	{
		TUNE_GROUP_INT(COVER_TUNE, TIME_SINCE_JUMP_PRESSED_TO_ALLOW_CORNER_MOVE, 350, 0, 1000, 10);
		const float fPedWalkLeftRight = pControl->GetPedWalkLeftRight().GetNorm();
		if (((bFacingLeft && fPedWalkLeftRight < -ms_Tunables.m_MinStickInputToMoveAroundCorner) || 
			(!bFacingLeft && fPedWalkLeftRight > ms_Tunables.m_MinStickInputToMoveAroundCorner))
			&& (fwTimer::GetTimeInMilliseconds() - uTimeJumpLastPressed) < TIME_SINCE_JUMP_PRESSED_TO_ALLOW_CORNER_MOVE)
		{
			CCoverPoint newCoverPoint;
			const bool bFoundNewCover = CPlayerInfo::ms_DynamicCoverHelper.FindNewCoverPointAroundCorner(&newCoverPoint, &ped, bFacingLeft, bLowCover);
			if (bFoundNewCover)
			{
				ped.GetPlayerInfo()->GetDynamicCoverPoint()->Copy(newCoverPoint);
				ped.SetCoverPoint(ped.GetPlayerInfo()->GetDynamicCoverPoint());
				ped.GetCoverPoint()->ReserveCoverPointForPed(&ped);
				return true;
			}			
		}
	} 
	else
	{
		if (pControl->GetPedWalkUpDown().HistoryHeldDown(ms_Tunables.m_MinTimeForCornerMove, -1.0f, -ms_Tunables.m_MinStickInputToMoveAroundCorner))
		{
			CCoverPoint newCoverPoint;
			const bool bFoundNewCover = CPlayerInfo::ms_DynamicCoverHelper.FindNewCoverPointAroundCorner(&newCoverPoint, &ped,  bFacingLeft, bLowCover);
			if (bFoundNewCover)
			{
				ped.GetPlayerInfo()->GetDynamicCoverPoint()->Copy(newCoverPoint);
				ped.SetCoverPoint(ped.GetPlayerInfo()->GetDynamicCoverPoint());
				ped.GetCoverPoint()->ReserveCoverPointForPed(&ped);
				return true;
			}			
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::PlayerCheckForCornerExit(const CPed& ped, bool bFacingLeft, const Vector2& vStickInput)
{
	if (ped.IsLocalPlayer())
	{
		if (vStickInput.y > CTaskInCover::ms_Tunables.m_InputYAxisCornerExitValue && CTaskExitCover::CanPedUseCornerExit(ped, bFacingLeft))
		{
			return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

CTaskMotionInCover::CTaskMotionInCover(CMoveNetworkHelper& taskCoverMoveNetworkHelper, CMoveNetworkHelper& moveNetworkHelper)
: m_TaskCoverMoveNetworkHelper(taskCoverMoveNetworkHelper)
, m_MoveNetworkHelper(moveNetworkHelper)
, m_fTurnInterruptPhase(-1.0f)
, m_bCalculatedTurnInterruptPhase(false)
, m_vInitialPedStoppingPosition(Vector3::ZeroType)
, m_fInitialAnimatedSpeed(-1.0f)
, m_fProbeOffset(-1.0f)
, m_fHeight(0.0f)
, m_bCoverToCoverHeadingReached(false)
, m_bTurnHeadingReached(false)
, m_fCoverToCoverDist(0.0f)
, m_fStandUpTimer(ms_Tunables.m_MinTimeToStandUp)
, m_vInitialPedCoverToCoverPosition(Vector3::ZeroType)
, m_fInitialPedCoverToCoverHeading(-1.0f)
, m_fSideStartFixupPhase(-1.0f)
, m_fSideEndFixupPhase(-1.0f)
, m_bEnteredPeekState(false)
, m_bUsingWalkStop(false)
, m_bIgnoreStillRequest(false)
, m_bFire(false)
, m_bStoppedScalingCTCTrans(false)
, m_bPeekVariationStarted(false)
, m_bUseHighCoverAnims(false)
, m_bPeekVariationFinished(false)
, m_uRoundCoverProcessed(0)
, m_uVerifyCoverTimer(0)
, m_StayPinnedTimer(ms_Tunables.m_MinTimeStayPinned, ms_Tunables.m_MaxTimeStayPinned)
, m_PinnedClipSetId(CLIP_SET_ID_INVALID)
, m_IdleVarationClipSetId(CLIP_SET_ID_INVALID)
, m_fStepDistance(0.0f)
, m_bTurningLeft(false)
, m_fTurnEndToTurnEnterBlendDuration(0.05f)
, m_bCoverToCoverPointValid(false)
, m_bPlayerPeekReset(false)
, m_bIsInLowCover(false)
, m_bMovedSinceTurning(false)
, m_bTurningIntoEdge(false)
, m_bDontChangeCoverPositionWhenTurning(false)
, m_bTurnedFromLowCover(false)
, m_bAbortCoverRequest(false)
, m_bRoundCornering(false)
, m_bDoCloneTurn(false)
, m_bMasterTurning(false)
, m_bSteppingRequest(false)
, m_bSteppingRequestComplete(false)
, m_bWasUsingFirstPersonAnims(false)
, m_bRestartNextFrame(false)
#if FPS_MODE_SUPPORTED
, m_bDisallowTurnUntilInputZeroed(false)
, m_bLeftStickTriggeredTurn(false)
#endif
, m_uTimeJumpLastPressed(0)
, m_uTimeOfLastRoundCornerMove(0)
{
	SetInternalTaskType(CTaskTypes::TASK_MOTION_IN_COVER);
}

////////////////////////////////////////////////////////////////////////////////

CTaskMotionInCover::~CTaskMotionInCover()
{
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::CleanUp()
{
	CPed* pPed = GetPed();

	pPed->SetTaskCapsuleRadius(0.0f);
	if(IsIdle())
	{
		// Ensure we are not classed as moving
		pPed->GetMotionData()->SetCurrentMoveBlendRatio(0.0f);
	}

	if (pPed && pPed->GetNetworkObject())
	{
		netBlenderLinInterp *blender = SafeCast(netBlenderLinInterp, pPed->GetNetworkObject()->GetNetBlender());

		if(blender)
		{
			blender->SetUseLogarithmicBlending(false);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::ProcessPreFSM()
{
	CPed* pPed = GetPed();

	pPed->SetPedResetFlag(CPED_RESET_FLAG_ProcessPostPreRender, true);

	if (m_MoveNetworkHelper.IsNetworkAttached())
	{
		pPed->ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);
		if (pPed->IsPlayer())
		{
			CTaskMotionBase* pPrimaryTask = pPed->GetPrimaryMotionTask();
			if( pPrimaryTask && pPrimaryTask->GetTaskType() == CTaskTypes::TASK_MOTION_PED )
			{
				CTaskMotionPed* pTask = static_cast<CTaskMotionPed*>(pPrimaryTask);
				Assert( pTask );
				pTask->SetTaskFlag( CTaskMotionPed::PMF_UseMotionBaseCalcDesiredVelocity );
			}
		}		
	}
	CTaskMotionBasicLocomotion::ProcessMovement(pPed, GetTimeStep());

	// Prevent peds from being easily pushed around in cover when idle
	bool bUseKinematicPhysics = IsIdle();

	if (bUseKinematicPhysics && pPed->IsNetworkClone())
	{
		Vector3 pedVel = pPed->GetVelocity();

		// clone peds can still be moving when idle due to the network blender moving them into the correct position
		if (pedVel.GetHorizontalMag2() > 0.1f)
		{
			bUseKinematicPhysics = false;
		}
	}

	if (bUseKinematicPhysics)
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_TaskUseKinematicPhysics, true);
	}

	if (pPed->IsAPlayerPed())
	{
		m_CoreStreamedClipsetRequestHelper.Request(CTaskCover::ms_Tunables.GetStreamedUnarmedCoverMovementClipSetIdForPed(*pPed));
	}
	if (pPed->IsLocalPlayer())
	{
		if (pPed->GetControlFromPlayer()->GetPedJump().IsPressed())
		{
			m_uTimeJumpLastPressed = fwTimer::GetTimeInMilliseconds();
		}		

		if (m_bRoundCornering)
		{
			if (pPed->GetControlFromPlayer()->GetPedJump().IsUp() || fabs(pPed->GetControlFromPlayer()->GetPedWalkLeftRight().GetNorm())<0.1f)
			{
				m_bRoundCornering = false;		
			}
		}

		//update round cover processing
		if (m_uRoundCoverProcessed == 0)
		{
			if (CPlayerInfo::ms_DynamicCoverHelper.ProcessRoundCover(pPed))
			{
				static dev_u8 s_uProcessRoundCoverInterval = 15;
				m_uRoundCoverProcessed = s_uProcessRoundCoverInterval;
			}
		} 
		else
		{
			m_uRoundCoverProcessed--;
		}
#if __BANK
		if (pPed->GetPlayerInfo()->IsRoundCover())
			ms_debugDraw.AddText(pPed->GetTransform().GetPosition(), 0, 0, "Round Cover", Color_yellow, 1);
#endif
		static dev_float s_fPlayerPeekResetDelay = 0.25f;
#if FPS_MODE_SUPPORTED
		// Settling into the edge seems to take a little bit longer in first person...
		static dev_float s_fPlayerPeekResetDelayFPS = 0.3f;
#endif
		if (!m_bPlayerPeekReset && GetState() != State_TurnEnd) 
		{
			float fPlayerPeekResetDelay = s_fPlayerPeekResetDelay;
#if FPS_MODE_SUPPORTED
			if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
			{
				fPlayerPeekResetDelay = s_fPlayerPeekResetDelayFPS;
			}
#endif
			if (fabs(pPed->GetControlFromPlayer()->GetPedWalkLeftRight().GetNorm())<0.4f || GetTimeInState() >= fPlayerPeekResetDelay)
				m_bPlayerPeekReset = true;
		}

		// If we're on cover against a car door the cover verification can end up changing the cover position
		// and pulls us awkwardly about, assume if we're against a vehicle door our position is valid
		bool bIgnoreCoverVerification = false;
		if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
		{
			// Don't do verification against map / building or fixed cover
			if (!CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity() || CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity()->GetIsTypeBuilding() || CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity()->GetIsAnyFixedFlagSet())
			{
				bIgnoreCoverVerification = true;
			}
			else
			{
				bIgnoreCoverVerification = CTaskCover::IsPlayerPedInCoverAgainstVehicleDoor(*pPed, *pPed->GetCoverPoint());
			}
		}

		if (!bIgnoreCoverVerification && (GetState() == State_Idle || GetState() == State_PlayingIdleVariation || GetState() == State_AtEdge || GetState() == State_Settle))
		{
			if (m_uVerifyCoverTimer == 0)
			{								
				m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
				Vector3 vTestPos = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());				
				if (pPed->GetCurrentPhysicsInst())
					vTestPos.z = pPed->GetCurrentPhysicsInst()->GetMatrix().GetM23f(); 
#if __DEV
				static dev_bool sbSlideTest = false;
				if (sbSlideTest)
				{
					static dev_float sf_RandRange = 0.5f;
					float fOffset = fwRandom::GetRandomNumberInRange(-sf_RandRange, sf_RandRange);
					vTestPos += VEC3V_TO_VECTOR3(pPed->GetTransform().GetForward())*fOffset;
				}
#endif
			
				CCoverPoint newCoverPoint;
				const bool bFoundCover = CPlayerInfo::ms_DynamicCoverHelper.UpdateCoverPoint(pPed->GetCoverPoint(), &newCoverPoint, pPed, vTestPos, true, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
				if (!bFoundCover)
				{
					m_bAbortCoverRequest = true;
				}
#if __DEV
				else if (sbSlideTest)
				{
					pPed->GetPlayerInfo()->GetDynamicCoverPoint()->Copy(newCoverPoint);
					pPed->SetCoverPoint(pPed->GetPlayerInfo()->GetDynamicCoverPoint());
					pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
				}
#endif
			}
			else
			{
				m_uVerifyCoverTimer--;
			}
		}
		else
		{
			m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
		}
	}

	// Make sure the clone ped turns if they're not facing the desired direction (or doesn't turn if they are!)
	if (pPed->IsNetworkClone())
	{
		if (IsCoverFlagSet(CTaskCover::CF_DesiredFacingLeft) && !IsCoverFlagSet(CTaskCover::CF_FacingLeft))
		{
			if (!m_bDoCloneTurn)
			{
				DoCloneTurn();
			}
		}
		else if (!m_bDoCloneTurn && !IsCoverFlagSet(CTaskCover::CF_DesiredFacingLeft) && IsCoverFlagSet(CTaskCover::CF_FacingLeft))
		{
			if (!m_bDoCloneTurn)
			{
				DoCloneTurn();
			}
		}
		else
		{
			m_bDoCloneTurn = false;
		}
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::UpdateFSM(const s32 iState, const FSM_Event iEvent)
{
	FSM_Begin

		FSM_State(State_Start)
			FSM_OnUpdate
				return Start_OnUpdate();	

		FSM_State(State_StreamAssets)
			FSM_OnUpdate
				return StreamAssets_OnUpdate();

		FSM_State(State_Idle)
			FSM_OnEnter
				return Idle_OnEnter();
			FSM_OnUpdate
				return Idle_OnUpdate();
			FSM_OnExit
				return Idle_OnExit();

		FSM_State(State_Stepping)
			FSM_OnEnter
				return Stepping_OnEnter();
			FSM_OnUpdate
				return Stepping_OnUpdate();

		FSM_State(State_WalkStart)
			FSM_OnEnter
				return WalkStart_OnEnter();
			FSM_OnUpdate
				return WalkStart_OnUpdate();

		FSM_State(State_Settle)
			FSM_OnEnter
				return Settle_OnEnter();
			FSM_OnUpdate
				return Settle_OnUpdate();

		FSM_State(State_PlayingIdleVariation)
			FSM_OnEnter
				return PlayingIdleVariation_OnEnter();
			FSM_OnUpdate
				return PlayingIdleVariation_OnUpdate();
			FSM_OnExit
				return PlayingIdleVariation_OnExit();

		FSM_State(State_Stopping)
			FSM_OnEnter
				return Stopping_OnEnter();
			FSM_OnUpdate
				return Stopping_OnUpdate();
		
		FSM_State(State_StoppingAtEdge)
			FSM_OnEnter
				return StoppingAtEdge_OnEnter();
			FSM_OnUpdate
				return StoppingAtEdge_OnUpdate();

		FSM_State(State_AtEdge)
			FSM_OnEnter
				return AtEdge_OnEnter();
			FSM_OnUpdate
				return AtEdge_OnUpdate();
			FSM_OnExit
				return AtEdge_OnExit();

		FSM_State(State_Moving)
			FSM_OnEnter
				return Moving_OnEnter();
			FSM_OnUpdate
				return Moving_OnUpdate();
			FSM_OnExit
				return Moving_OnExit();

		FSM_State(State_StoppingAtInsideEdge)
			FSM_OnEnter
				return StoppingAtInsideEdge_OnEnter();
			FSM_OnUpdate
				return StoppingAtInsideEdge_OnUpdate();

		FSM_State(State_TurnEnter)
			FSM_OnEnter
				return TurnEnter_OnEnter();
			FSM_OnUpdate
				return TurnEnter_OnUpdate();
			FSM_OnExit
				return TurnEnter_OnExit();

		FSM_State(State_TurnEnd)
			FSM_OnEnter
				return TurnEnd_OnEnter();
			FSM_OnUpdate
				return TurnEnd_OnUpdate();
			FSM_OnExit
				return TurnEnd_OnExit();	

		FSM_State(State_EdgeTurn)
			FSM_OnEnter
				return EdgeTurn_OnEnter();
			FSM_OnUpdate
				return EdgeTurn_OnUpdate();
			FSM_OnExit
				return EdgeTurn_OnExit();

		FSM_State(State_InsideCornerTransition)
			FSM_OnEnter
				return InsideCornerTransition_OnEnter();
			FSM_OnUpdate
				return InsideCornerTransition_OnUpdate();
			FSM_OnExit
				return InsideCornerTransition_OnExit();
			
		FSM_State(State_CoverToCover)
			FSM_OnEnter
				return CoverToCover_OnEnter();
			FSM_OnUpdate
				return CoverToCover_OnUpdate();
			FSM_OnExit
				return CoverToCover_OnExit();

		FSM_State(State_AtEdgeLowCover)
			FSM_OnEnter
				return AtEdgeLowCover_OnEnter();
			FSM_OnUpdate
				return AtEdgeLowCover_OnUpdate();

		FSM_State(State_Peeking)
			FSM_OnEnter
				return Peeking_OnEnter();
			FSM_OnUpdate
				return Peeking_OnUpdate();
			FSM_OnExit
				return Peeking_OnExit();

		FSM_State(State_PinnedIntro)
			FSM_OnEnter
				return PinnedIntro_OnEnter();
			FSM_OnUpdate
				return PinnedIntro_OnUpdate();

		FSM_State(State_Pinned)
			FSM_OnEnter
				return Pinned_OnEnter();
			FSM_OnUpdate
				return Pinned_OnUpdate();

		FSM_State(State_PinnedOutro)
			FSM_OnEnter
				return PinnedOutro_OnEnter();
			FSM_OnUpdate
				return PinnedOutro_OnUpdate();

		FSM_State(State_Finish)
			FSM_OnUpdate
				return FSM_Quit;

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::ProcessPostFSM()
{
	SendCommonMoveSignals();

#if FPS_MODE_SUPPORTED
	CPed* pPed = GetPed();
	if (pPed && pPed->IsAPlayerPed() && GetState() != State_Idle && GetState() != State_PlayingIdleVariation && GetState() != State_AtEdge && GetState() != State_AtEdgeLowCover && GetState() != State_Settle)
	{
		pPed->SetPlayerResetFlag(CPlayerResetFlags::PRF_DISABLE_CAMERA_VIEW_MODE_CYCLE);
	}
#endif // FPS_MODE_SUPPORTED
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTaskInfo* CTaskMotionInCover::CreateQueriableState() const
{
	return rage_new CClonedMotionInCoverInfo(GetState(), m_fStepDistance);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::ReadQueriableState(CClonedFSMTaskInfo* pTaskInfo)
{
	Assert( pTaskInfo->GetTaskInfoType() == CTaskInfo::INFO_TYPE_MOTION_IN_COVER_CLONED_FSM );
	CTaskFSMClone::ReadQueriableState(pTaskInfo);

	CClonedMotionInCoverInfo* pMotionInfo = SafeCast(CClonedMotionInCoverInfo, pTaskInfo);

	m_fStepDistance = pMotionInfo->GetStepDistance();

	bool bTurningLeft = false;
	bool bTurningRight = false;

	m_bMasterTurning = false;

	if (pTaskInfo->GetState() == State_Turning || pTaskInfo->GetState() == State_TurnEnter)
	{
		m_bMasterTurning = true;

		if (IsCoverFlagSet(CTaskCover::CF_DesiredFacingLeft))
		{
			bTurningRight = true;
		}
		else
		{
			bTurningLeft = true;
		}
	}
	else if (pTaskInfo->GetState() == State_TurnEnd)
	{
		m_bMasterTurning = true;

		if (IsCoverFlagSet(CTaskCover::CF_DesiredFacingLeft))
		{
			bTurningLeft = true;
		}
		else
		{
			bTurningRight = true;
		}
	}

	if ((bTurningLeft && !IsCoverFlagSet(CTaskCover::CF_FacingLeft)) || 
		(bTurningRight && IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
	{
		DoCloneTurn();
	}
}

////////////////////////////////////////////////////////////////////////////////

CTaskMotionInCover::FSM_Return CTaskMotionInCover::UpdateClonedFSM(const s32 iState, const FSM_Event iEvent)
{
	CPed* pPed = GetPed();

	// find and read the queriable state for this task (it will have a different sequence id so will be ignored by the clone task manager)
	CTaskInfo *taskInfo = pPed->GetPedIntelligence()->GetQueriableInterface()->GetTaskInfoForTaskType(CTaskTypes::TASK_MOTION_IN_COVER, PED_TASK_PRIORITY_MAX, false);

	if(taskInfo)
	{
		ReadQueriableState(static_cast<CClonedFSMTaskInfo *>(taskInfo));
	}

	return UpdateFSM(iState, iEvent);
}

bool CTaskMotionInCover::OverridesNetworkBlender(CPed* pPed)
{
	bool bOverride = false;

	if (!pPed->IsBaseFlagSet(fwEntity::IS_FIXED))
	{
		switch (GetState())
		{
		case State_Idle:
		case State_Peeking:
		case State_AtEdge:
			// don't override if the ped is standing on a vehicle
			if (!(pPed && pPed->GetAttachState() != ATTACH_STATE_PED_ON_GROUND && pPed->GetGroundPhysical() && pPed->GetGroundPhysical()->GetIsTypeVehicle()))
			{
				bOverride = true;
			}
			break;
		case State_StoppingAtInsideEdge:
		case State_StoppingAtEdge:
			bOverride = true;
		}

		if (bOverride)
		{
			Vector3     pedPosition    = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
			Vector3     targetPosition = NetworkInterface::GetLastPosReceivedOverNetwork(pPed);

			static const float INTERSECTING_OBJECT_THRESHOLD = 1.0f;

			// stop overriding if the z value differs too much
			if(Abs(targetPosition.z - pedPosition.z) > INTERSECTING_OBJECT_THRESHOLD)
			{
				bOverride = false;
			}
		}
	}

	return bOverride;
}

bool CTaskMotionInCover::OverridesNetworkHeadingBlender(CPed*)
{
	// ignore heading changes when the master ped is turning, the clone will turn later to face in the right direction
	if (IsCoverFlagSet(CTaskCover::CF_FacingLeft) != IsCoverFlagSet(CTaskCover::CF_DesiredFacingLeft))
	{
		return true;
	}

	if (m_bMasterTurning)
	{
		return true;
	}

	return (GetState() == State_EdgeTurn || GetState() == State_TurnEnter || GetState() == State_TurnEnd || GetState() == State_Moving || GetState() == State_Idle || GetState() == State_AtEdge || GetState() == State_Stepping);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::ProcessPhysics(float fTimeStep, int UNUSED_PARAM(nTimeSlice))
{
 	CPed *pPed = GetPed(); 

	if (pPed->IsAPlayerPed())
	{
		if (GetState() == State_CoverToCover)
		{
			return ProcessCoverToCoverPhysics(fTimeStep);
		}
		else if (GetPreviousState() != State_CoverToCover && (GetState() == State_StoppingAtEdge || GetState() == State_StoppingAtInsideEdge))
		{
			return ProcessStoppingPhysics(fTimeStep);	
		}
		else if (GetState() == State_Stepping || GetState() == State_TurnEnd || GetState() == State_Stopping)
		{
			if (GetState() == State_TurnEnd)
			{
				ProcessTurningPhysics(fTimeStep);
			}
			return ProcessStoppingPhysics(fTimeStep);	
		}
		else if (GetState() == State_Idle)
		{
			if (pPed->GetAttachState() == ATTACH_STATE_PED_ON_GROUND)
			{
				// Need to null out animated velocity to prevent ped's physics from activating whilst idle
				pPed->SetAnimatedVelocity(VEC3_ZERO);
				return false;
			}

#if FPS_MODE_SUPPORTED
			const bool bAllowSlide = pPed->IsFirstPersonShooterModeEnabledForPlayer(false);
#endif // FPS_MODE_SUPPPORTED

			TUNE_GROUP_BOOL(COVER_TUNE, NULL_VELOCITY_WHEN_IDLE, true);
			if (NULL_VELOCITY_WHEN_IDLE FPS_MODE_SUPPORTED_ONLY(&& bAllowSlide))
			{
				NMovingGround::SetPedVelocity(pPed, Vec3V(V_ZERO));
				pPed->SetAnimatedVelocity(VEC3_ZERO);
			}
		}
	}

	return false;
}

bool CTaskMotionInCover::ProcessPostPreRender()
{
	if (GetState() == State_CoverToCover &&  m_bFire)
	{
		CPed* pPed = GetPed();
		// Ignore fire events if we're not holding a gun weapon
		weaponAssert(pPed->GetWeaponManager());
		CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();
		if (pWeapon && !pWeapon->GetWeaponInfo()->GetIsThrownWeapon())
		{			
			const CObject* pWeaponObject = pPed->GetWeaponManager()->GetEquippedWeaponObject();
			if (pWeaponObject) 
			{
				const Matrix34& mWeapon = RCC_MATRIX34(pWeaponObject->GetMatrixRef());
				CWeapon::sFireParams params(pPed, mWeapon);
				pWeapon->Fire(params);	
			}						
			m_bFire = false;
			return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::ProcessMoveSignals()
{
	if(!CPedAILodManager::ShouldDoFullUpdate(*GetPed()))
	{
		SendCommonMoveSignals();
	}

	const int state = GetState();
	switch(state)
	{
		case State_Idle:
			Idle_OnProcessMoveSignals();
			return true;
		case State_Settle:
			Settle_OnProcessMoveSignals();
			return true;
		case State_AtEdge:
			AtEdge_OnProcessMoveSignals();
			return true;
		case State_TurnEnter:
			TurnEnter_OnProcessMoveSignals();
			return true;
		case State_TurnEnd:
			TurnEnd_OnProcessMoveSignals();
			return true;
		case State_Peeking:
			Peeking_OnProcessMoveSignals();
			return true;
		case State_PinnedIntro:
			PinnedIntro_OnProcessMoveSignals();
			return true;
		case State_Pinned:
			Pinned_OnProcessMoveSignals();
			return true;
		case State_PinnedOutro:
			PinnedOutro_OnProcessMoveSignals();
			return true;
		case State_PlayingIdleVariation:
			PlayingIdleVariation_OnProcessMoveSignals();
			return true;
		case State_EdgeTurn:
			EdgeTurn_OnProcessMoveSignals();
			return true;
		default:
			break;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::SendCommonMoveSignals()
{
	if (m_MoveNetworkHelper.IsNetworkActive())
	{
		m_MoveNetworkHelper.SetFloat(ms_MovementRateId, CTaskInCover::ms_Tunables.m_MovementClipRate);
		SendHeightSignal();
		SendSpeedSignal();
		m_MoveNetworkHelper.SetFloat(ms_CoverToCoverRateId, ms_Tunables.m_CoverToCoverClipRate);

		if (GetPed()->IsLocalPlayer())
		{
			float fMvCamHeading = ComputeMvCamHeading();
			m_MoveNetworkHelper.SetFloat(ms_CamHeadingId, fMvCamHeading);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Start_OnUpdate()
{
	CPed* pPed = GetPed();

	if (pPed->IsNetworkClone() && (IsCoverFlagSet(CTaskCover::CF_DesiredFacingLeft) != IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
	{
		DoCloneTurn();
	}

	if (pPed->IsLocalPlayer())
	{
		m_IdleVariationTimer.Reset(ms_Tunables.m_MinTimeBetweenPlayerIdleVariations, ms_Tunables.m_MaxTimeBetweenPlayerIdleVariations);		
	}
	else
	{
		m_IdleVariationTimer.Reset(ms_Tunables.m_MinTimeBetweenIdleVariations, ms_Tunables.m_MaxTimeBetweenIdleVariations);
	}

	SetState(State_StreamAssets);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::StreamAssets_OnUpdate()
{
	CPed* pPed = GetPed();

	fwMvClipSetId weaponHoldingClipsetId = CTaskCover::GetWeaponHoldingClipSetForArmament(pPed);
	if (weaponHoldingClipsetId == CLIP_SET_ID_INVALID || CTaskCover::IsCoverClipSetLoaded(weaponHoldingClipsetId))
	{
		if (!pPed->IsNetworkClone() && pPed->GetCoverPoint())
		{
			if (pPed->GetCoverPoint()->GetHeight() != CCoverPoint::COVHEIGHT_TOOHIGH)
			{
				m_fHeight = 0.0f;
				m_bUseHighCoverAnims = false;
			}
			else
			{
				m_fHeight = 1.0f;
				m_bUseHighCoverAnims = true;
			}
		}
		else
		{
			if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
			{
				m_fHeight = 0.0f;
				m_bUseHighCoverAnims = false;
			}
			else
			{
				m_fHeight = 1.0f;
				m_bUseHighCoverAnims = true;
			}
		}

		taskAssert(GetParent());
		taskAssert(GetParent()->GetParent());
		const bool bHasJustEnteredCover = HasJustEnteredCover();
		const bool bIgnoreMoverBlend = static_cast<CTaskInCover*>(GetParent())->GetPreviousState() == CTaskInCover::State_AimOutro || static_cast<CTaskInCover*>(GetParent())->GetPreviousState() == CTaskInCover::State_BlindFiring || bHasJustEnteredCover;
		m_TaskCoverMoveNetworkHelper.SendRequest(bIgnoreMoverBlend ? CTaskCover::ms_NoTaskIgnoreMoverBlendRequestId : CTaskCover::ms_NoTaskRequestId);
		if (!m_MoveNetworkHelper.IsNetworkAttached() || !m_MoveNetworkHelper.GetNetworkPlayer())
		{
			static_cast<CTaskCover*>(GetParent()->GetParent())->RestartMotionInCoverNetwork(pPed, bIgnoreMoverBlend);
		}

		TUNE_GROUP_BOOL(COVER_PINNED_BUG, RESET_PINNED_FLAG, true);
		if (RESET_PINNED_FLAG && m_MoveNetworkHelper.IsNetworkActive())
		{
			m_MoveNetworkHelper.SetFlag(false, ms_PinnedFlagId);
		}

		if (!bHasJustEnteredCover)
		{
			bool bIgnoreCollisionTest = false;
			if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
			{
				bIgnoreCollisionTest = CTaskCover::IsPlayerPedInCoverAgainstVehicleDoor(*pPed, *pPed->GetCoverPoint());
			}

			//Before deciding if this is an edge, run a cover point test at this location:
			if (pPed->IsLocalPlayer() && pPed->GetPlayerInfo()->IsCoverGeneratedByDynamicEntity() && !bIgnoreCollisionTest)
			{									
				m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
				bool bCoverFound = FindNewDynamicCoverPoint(pPed, 0.0f, IsCoverFlagSet(CTaskCover::CF_FacingLeft), false, true);
				if (!bCoverFound)
				{
					//Cover has gone away :(
					SetState(State_Finish);
					return FSM_Continue;
				}
			}
		}

#if FPS_MODE_SUPPORTED
		if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && CheckForPeeking())
		{
			SetState(State_Peeking);
			return FSM_Continue;
		}
		else 
#endif // FPS_MODE_SUPPORTED
		if (CheckForAtEdge())
		{
			if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
			{
				Vector3 vCurrentCoverPosition(Vector3::ZeroType);
				float fEdgeDistance = -1.0f;
				pPed->GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition);
				CTaskInCover::FindCoverEdgeAndUpdateCoverPosition(pPed, vCurrentCoverPosition, fEdgeDistance, IsCoverFlagSet(CTaskCover::CF_FacingLeft), true);
				pPed->GetPlayerInfo()->SetDynamicCoverEdgeDistance(fEdgeDistance);
			}
			SetState(State_AtEdge);
			return FSM_Continue;
		}
		else
		{
			SetState(State_Idle);
			return FSM_Continue;
		}
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Idle_OnEnter()
{
	static_cast<CTaskInCover*>(GetParent())->CheckForBlockedAim();
	m_bIsInLowCover = !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
	m_bWasUsingFirstPersonAnims = ShouldUseFirstPersonLocoAnimations(*GetPed());

	// Try to update the cover
	// Scale the cover probe position based on our speed (will change depending on how blended the idle clip is)
	CPed* pPed = GetPed();
	if (pPed->IsLocalPlayer() && !pPed->GetPlayerInfo()->DynamicCoverInsideCorner() && GetPreviousState() != State_TurnEnd && GetPreviousState() != State_Settle)
	{
		bool bIgnoreCollisionTest = false;
		if (pPed->GetCoverPoint())
		{
			bIgnoreCollisionTest = CTaskCover::IsPlayerPedInCoverAgainstVehicleDoor(*pPed, *pPed->GetCoverPoint());
		}

		if (!bIgnoreCollisionTest)
		{
			static dev_float s_fMaxMoveSpeedInCover = 1.0f / 2.4f;
			TUNE_GROUP_FLOAT(COVER_TUNE, PROBE_OFFSET_WHEN_IDLING, 0.025f, 0.0f, 1.0f, 0.01f);
			float fOffset = Mag(NMovingGround::GetPedVelocity(pPed)).Getf() * s_fMaxMoveSpeedInCover * PROBE_OFFSET_WHEN_IDLING;
			m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
			FindNewDynamicCoverPoint(pPed, fOffset, IsCoverFlagSet(CTaskCover::CF_FacingLeft), false, true);
		}
	}

	//B*2752343: Safety check to see if we're not floating in the air (there's some problems with State_Stepping not detecting the ground properly)
	if (NetworkInterface::IsGameInProgress() && pPed->IsLocalPlayer())
	{
		Vector3 vStart = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		Vector3 vEnd = vStart + Vector3(0.0f, 0.0f, -2.0f); 
		Vector3 vUnused;	
		if (!CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vUnused, NULL, NULL, true))
		{
			m_bAbortCoverRequest = true;
		}
	}

	bool bShouldSendAIdleRequest = !pPed->IsAPlayerPed() || GetPreviousState() != State_Peeking; 

	m_MoveNetworkHelper.SetFlag(false, ms_AtEdgeFlagId);
	m_MoveNetworkHelper.SetFlag(true, ms_IdleFlagId);
	m_MoveNetworkHelper.SetFlag(false, ms_PeekingFlagId);

	SetClipsFromAnimStateInfo();

	if (bShouldSendAIdleRequest)
	{
		m_MoveNetworkHelper.WaitForTargetState(ms_IdleOnEnterId);
		m_MoveNetworkHelper.SendRequest(ms_StillRequestId);
	}
	
	m_bPlayerPeekReset = false;

	RequestProcessMoveSignalCalls();
	m_MoveInTargetState = false;

	// Turn on ambient lookAts for player.
	if(pPed->IsAPlayerPed())
	{
		// Passing in 0 flags, so no idle anims will be played from the ambient clips.
		atHashWithStringNotFinal ambientContext("EMPTY",0xBBD57BED);
		CTaskAmbientClips* pAmbientTask	= rage_new CTaskAmbientClips(0, CONDITIONALANIMSMGR.GetConditionalAnimsGroup(ambientContext.GetHash()));
		SetNewTask( pAmbientTask );
	}

#if FPS_MODE_SUPPORTED
	// Fix camera pop when returning to cover, the object matrix from the head differed due to the instant anim update
	// when the motion ped task starts
	if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		pPed->SetPedResetFlag(CPED_RESET_FLAG_ForcePreCameraAiAnimUpdateIfFirstPerson, true);
		pPed->SetPedResetFlag(CPED_RESET_FLAG_ePostCameraAnimUpdateUseZeroTimestep, true);
	}
#endif

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Idle_OnUpdate()
{
	m_IdleVariationTimer.Tick(GetTimeStep());

	// Quit if we have no cover point or are using the phone in cover and the use phone task has finished
	if (m_bAbortCoverRequest)
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	CPed& ped = *GetPed();
	if (!ped.IsNetworkClone() && !ped.GetCoverPoint())
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	ProcessUseMobilePhone();
	ProcessLookIK(&ped);

	// Turn Physics Processing On To Keep The Ped In Cover
	// If we're on cover against a car door the cover verification can end up changing the cover position
	// and pulls us awkwardly about, assume if we're against a vehicle door our position is valid
	bool bIgnoreSlideIntoCover = false;
	if (ped.IsLocalPlayer() && ped.GetCoverPoint())
	{
		bIgnoreSlideIntoCover = CTaskCover::IsPlayerPedInCoverAgainstVehicleDoor(ped, *ped.GetCoverPoint());
	}

	if (!bIgnoreSlideIntoCover)
	{
		SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);
	}

	if (!m_MoveInTargetState)
		return FSM_Continue;

	Vector3 vCoverDirection = static_cast<CTaskInCover*>(GetParent())->GetCoverDirection();
	if (ped.IsNetworkClone())
	{
		Vector3 vTargetDirUnused;
		CCover::FindCoverDirectionForPed(ped, vCoverDirection, vTargetDirUnused);
	}

	bool bIsCloseEnough = CTaskMotionInCover::IsPedsheadingCloseEnoughToFacingDirection(ped, vCoverDirection, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
	if (!bIsCloseEnough)
	{
		SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);
	}

	const bool bSwitchedBetweenFirstAndThirdPersonCam = ShouldRestartStateDueToCameraSwitch(m_MoveNetworkHelper);
	const bool bShouldBeInLowCover = !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
	if ((m_bIsInLowCover && !bShouldBeInLowCover) || (!m_bIsInLowCover && bShouldBeInLowCover) || bSwitchedBetweenFirstAndThirdPersonCam)
	{
		SetFlag(aiTaskFlags::RestartCurrentState);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}

	// No transitions until we've restarted
	if (m_bRestartNextFrame)
		return FSM_Continue;

	if (CheckForAtEdge())
	{
		float fEdgeDistance = -1.0f;		
		if (ped.IsLocalPlayer() && ped.GetCoverPoint())
		{
			Vector3 vCurrentCoverPosition(Vector3::ZeroType);
			ped.GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition);
			CTaskInCover::FindCoverEdgeAndUpdateCoverPosition(&ped, vCurrentCoverPosition, fEdgeDistance, IsCoverFlagSet(CTaskCover::CF_FacingLeft), true);
			ped.GetPlayerInfo()->SetDynamicCoverEdgeDistance(fEdgeDistance);
		}
		SetState(State_AtEdge);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForInsideCornerTransition())
	{
		SetState(State_InsideCornerTransition);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForPinned(ped))
	{
		SetState(State_PinnedIntro);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForPeeking())
	{
		SetState(State_Peeking);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForIdleVariation(ped))
	{
		SetState(State_PlayingIdleVariation);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForTurn() && bIsCloseEnough)
	{
		SetState(State_TurnEnter);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForStepping())
	{
		SetState(State_Stepping);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForMovingAbout())
	{
		SetState(State_Moving);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (ped.IsNetworkClone())
	{
		if (GetStateFromNetwork() == State_EdgeTurn)
		{
			SetState(State_EdgeTurn);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		} 
		else if (CheckForCoverToCover())
		{
			SetState(State_CoverToCover);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
	}


	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::Idle_OnProcessMoveSignals()
{
	m_MoveInTargetState = m_MoveNetworkHelper.IsInTargetState();
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Idle_OnExit()
{
	m_MoveNetworkHelper.SetFlag(false, ms_IdleFlagId);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Stepping_OnEnter()
{
	// Try to update the cover
	// Scale the cover probe position based on our speed (will change depending on how blended the idle clip is)
	CPed* pPed = GetPed();
	if (pPed->IsLocalPlayer() && (!pPed->GetPlayerInfo()->DynamicCoverInsideCorner() || GetPreviousState() == State_Turning))
	{
		TUNE_GROUP_FLOAT(COVER_TUNE, PROBE_OFFSET_WHEN_STEPPING, 0.33f, 0.0f, 1.0f, 0.01f);
		float fOffset = PROBE_OFFSET_WHEN_STEPPING;
		m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
		FindNewDynamicCoverPoint(pPed, fOffset, IsCoverFlagSet(CTaskCover::CF_FacingLeft), false, true);
	}

	if (!pPed->IsNetworkClone())
	{
		if (pPed->IsLocalPlayer())
		{
			Vector3 vCurrentCoverPosition(Vector3::ZeroType);
			if (pPed->GetCoverPoint())
			{
				pPed->GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition);
#if DEBUG_DRAW
			CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vCurrentCoverPosition), 0.025f, Color_red, 2000);
#endif // DEBUGDRAW
			}
			
			float fEdgeDistance = -1.0f;
			CTaskInCover::FindCoverEdgeAndUpdateCoverPosition(pPed, vCurrentCoverPosition, fEdgeDistance, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
			pPed->GetPlayerInfo()->SetDynamicCoverEdgeDistance(fEdgeDistance);

			if (pPed->GetCoverPoint() && pPed->GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition))
			{
				TUNE_GROUP_FLOAT(COVER_TUNE, STEPPING_DISTANCE_SCALE, 2.0f, 0.0f, 10.0f, 0.01f);
				m_fStepDistance = (vCurrentCoverPosition - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition())).XYMag()*STEPPING_DISTANCE_SCALE;
				//Displayf("Dist %.4f", m_fStepDistance);
#if DEBUG_DRAW
			CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vCurrentCoverPosition), 0.025f, Color_blue, 2000);
#endif // DEBUGDRAW
			}
		}
		else
		{
			m_fStepDistance = 0.5f;
		}

		// B* 1376288, if we don't get at least >=50% blend on the step, move misses the MOVE events preventing say a step->walk transition triggering a step->settle->step loop.  [6/14/2013 musson]
		static dev_float sf_MinStepDistance = 0.25f;
		m_fStepDistance = Max(m_fStepDistance, sf_MinStepDistance) ; 
	}

	SetClipsFromAnimStateInfo();
	m_MoveNetworkHelper.WaitForTargetState(ms_SteppingOnEnterId);
	m_MoveNetworkHelper.SendRequest(ms_SteppingRequestId);

	float fStepRate = 1.3f;
#if FPS_MODE_SUPPORTED
	if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, STEP_CLIP_RATE, 1.3f, 0.0f, 2.0f, 0.01f);
		fStepRate = STEP_CLIP_RATE;
	}
#endif // FPS_MODE_SUPPORTED

	m_MoveNetworkHelper.SetFloat(ms_StepRateId, fStepRate);
	m_bMovedSinceTurning = true;
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Stepping_OnUpdate()
{
	CPed* pPed = GetPed();

	if (!m_MoveNetworkHelper.IsInTargetState() || !pPed->IsNetworkClone())
	{
		static dev_float STUCK_TIME = 2.5f;
		if (!taskVerifyf(GetTimeInState() < STUCK_TIME, "Stuck in stepping state for more than %.2f seconds, in target state ? %s", STUCK_TIME, m_MoveNetworkHelper.IsInTargetState() ? "TRUE" : "FALSE"))
		{
			m_MoveNetworkHelper.ReleaseNetworkPlayer();
			SetState(State_Start);
			return FSM_Continue;
		}
	}

	m_MoveNetworkHelper.SetFloat(ms_StepDistanceId, m_fStepDistance);

	// we must make the clone wait in this state until it knows what to do next, otherwise it will flip between stepping and settling
	if (pPed->IsNetworkClone() && GetStateFromNetwork() == State_Stepping)
	{
		return FSM_Continue;
	}

	// Turn Physics Processing On To Keep The Ped Against Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedAgainstCover);

	if (!m_MoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	CTaskCover* pCoverTask = static_cast<CTaskCover*>(GetParent()->GetParent());
	if (pCoverTask->CheckForMovingCover(pPed))
	{
		SetState(State_Finish);
		return FSM_Continue;
	}
	else if (CheckForWalkStart())
	{

		if (pPed->GetPlayerInfo() && pPed->GetPlayerInfo()->IsRoundCover()) //no walk starts for round cover
		{
			SetState(State_Moving);
		}
		else
		{
			SetState(State_WalkStart);
		}
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForTurn())
	{
		SetState(State_TurnEnter);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForSettle() || GetIsHeightTransitioning() || m_MoveNetworkHelper.GetBoolean(ms_StepClipFinishedId) || pPed->IsNetworkClone() || !GetPed()->IsOnGround())
	{
		SetState(State_Settle);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::WalkStart_OnEnter()
{
	SetClipsFromAnimStateInfo();
	m_MoveNetworkHelper.WaitForTargetState(ms_WalkStartOnEnterId);
	m_MoveNetworkHelper.SendRequest(ms_WalkStartRequestId);
	m_bMovedSinceTurning = true;

	float fWalkStartRate = 1.3f;
#if FPS_MODE_SUPPORTED
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, WALKSTART_CLIP_RATE, 1.3f, 0.0f, 2.0f, 0.01f);
		fWalkStartRate = WALKSTART_CLIP_RATE;
	}
#endif // FPS_MODE_SUPPORTED

	m_MoveNetworkHelper.SetFloat(ms_WalkStartRateId, fWalkStartRate);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::WalkStart_OnUpdate()
{
	// Turn Physics Processing On To Keep The Ped Against Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedAgainstCover);

	if (!m_MoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	CPed* pPed = GetPed();
	if (pPed->IsLocalPlayer())
	{
		// Scale the cover probe position based on our speed (will change depending on how blended the idle clip is)
		static dev_float s_fMaxMoveSpeedInCover = 1.0f / 2.4f;

		//float fOffset = Mag(NMovingGround::GetPedVelocity(pPed)).Getf() * s_fMaxMoveSpeedInCover * CTaskInCover::ms_Tunables.m_DefaultProbeOffset;
		float fOffset = pPed->GetMotionData()->GetDesiredMbrY() * s_fMaxMoveSpeedInCover * CTaskInCover::ms_Tunables.m_DefaultProbeOffset;

		//Displayf("Frame Count : %u", fwTimer::GetFrameCount());

		m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
		if (!FindNewDynamicCoverPoint(pPed, fOffset, IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
		{
			BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("Cover point not found in state %s",GetStateName(GetState()));)
				SetState(State_Finish);
			return FSM_Continue;
		}

		pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
	}

	bool bDisallowCameraTurn = false;
#if FPS_MODE_SUPPORTED
	// In low cover the player has much more control over the camera and can get it facing in the opposite direction
	// they are moving.  To allow for that - without forcing the ped to turn back to face the camera - we don't check for
	// turns based on the camera vs. ped heading when moving in low cover in first-person
	if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsDelayedExit())
	{
		bDisallowCameraTurn = true;
	}
#endif

	if (CheckForTurn(bDisallowCameraTurn))
	{
		SetState(State_TurnEnter);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForAtEdge())
	{
		float fEdgeDistance = -1.0f;		
		if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
		{
			Vector3 vCurrentCoverPosition(Vector3::ZeroType);
			pPed->GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition);
			CTaskInCover::FindCoverEdgeAndUpdateCoverPosition(pPed, vCurrentCoverPosition, fEdgeDistance, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
			pPed->GetPlayerInfo()->SetDynamicCoverEdgeDistance(fEdgeDistance);
		}

		if (fEdgeDistance > ms_Tunables.m_MinEdgeDistanceForStoppingAnim)
		{
			SetState(State_StoppingAtEdge);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else
		{
			SetState(State_AtEdge);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
	}
	else if (CheckForIdle())
	{
		if (pPed->GetPlayerInfo()->DynamicCoverInsideCorner())
		{
			SetState(State_StoppingAtInsideEdge);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else
		{
			if (ms_Tunables.m_EnableWalkStops && CanUseTaskState(State_Stopping))
			{
				if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
				{
					const float fOffsetScale = Mag(NMovingGround::GetPedVelocity(pPed)).Getf() / ms_Tunables.m_MaxMoveSpeedInCover;
					const float fProbeLength = Max(CTaskInCover::ms_Tunables.m_MinStoppingEdgeCheckProbeOffset, fOffsetScale * CTaskInCover::ms_Tunables.m_MaxStoppingEdgeCheckProbeOffset);
					const float fOffset = fOffsetScale * fProbeLength;
					m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
					FindNewDynamicCoverPoint(pPed, fOffset, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
					if (CheckForAtEdge())
					{
						SetState(State_StoppingAtEdge);
						SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
						return FSM_Continue;
					}
				}
				SetState(State_Stopping);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				return FSM_Continue;
			}
			else
			{
				SetState(State_Idle);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				return FSM_Continue;
			}
		}
	}

	const bool bWalkStartFinished = m_MoveNetworkHelper.GetBoolean(ms_WalkStartClipFinishedId);
	if (m_MoveNetworkHelper.GetBoolean(ms_CanEarlyOutForMovementId) || bWalkStartFinished)
	{
		if (CheckForMovingAbout())
		{
			SetState(State_Moving);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (bWalkStartFinished)
		{
			SetState(State_Stopping);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Settle_OnEnter()
{
	SetClipsFromAnimStateInfo();
	m_MoveNetworkHelper.WaitForTargetState(ms_SettleOnEnterId);
	m_MoveNetworkHelper.SendRequest(ms_SettleRequestId);

	const bool bInLowCover = !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
	const bool bChangedCoverHeight = (m_bTurnedFromLowCover && !bInLowCover) || (!m_bTurnedFromLowCover && bInLowCover);
	float fBlendDuration = GetPreviousState() == State_Stepping ? 0.1f : ms_Tunables.m_DefaultSettleBlendDuration;
	m_MoveNetworkHelper.SetFloat(ms_SettleBlendDurationId, bChangedCoverHeight ? ms_Tunables.m_HeightChangeSettleBlendDuration : fBlendDuration);
	RequestProcessMoveSignalCalls();
	m_MoveInTargetState = false;
	m_MoveCanTransitionToIdle = false;

	CPed& rPed = *GetPed();
	if (rPed.IsLocalPlayer())
	{
		if (rPed.GetCoverPoint() && rPed.GetCoverPoint()->IsEdgeOrDoubleEdgeCoverPoint())
		{
			Vector3 vCurrentCoverPosition(Vector3::ZeroType);
			float fEdgeDistance = -1.0f;
			rPed.GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition);
			CTaskInCover::FindCoverEdgeAndUpdateCoverPosition(&rPed, vCurrentCoverPosition, fEdgeDistance, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
			rPed.GetPlayerInfo()->SetDynamicCoverEdgeDistance(fEdgeDistance);
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Settle_OnUpdate()
{
	// Turn Physics Processing On To Keep The Ped Into Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);
	SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);

	if (!m_MoveInTargetState)
		return FSM_Continue;

	if (ShouldRestartStateDueToCameraSwitch(m_MoveNetworkHelper))
	{
		SetFlag(aiTaskFlags::RestartCurrentState);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForCoverToCover())
	{
		SetState(State_CoverToCover);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForMovingAroundCorner())
	{
		SetState(State_EdgeTurn);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForInsideCornerTransition())
	{
		SetState(State_InsideCornerTransition);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForTurn())
	{
		SetState(State_TurnEnter);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForStepping())
	{
		SetState(State_Stepping);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (GetPed()->IsLocalPlayer() && CheckForPeeking()) //NPCs too?
	{
		SetState(State_Peeking);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (GetPed()->IsNetworkClone())
	{
		if (GetStateFromNetwork() == State_Moving)
		{
			SetState(State_Moving);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (GetStateFromNetwork() == State_WalkStart)
		{
			SetState(State_Moving);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (GetStateFromNetwork() == State_Stopping)
		{
			SetState(State_Stopping);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
	}

	if(m_MoveCanTransitionToIdle || !GetPed()->IsOnGround() || GetIsHeightTransitioning())
	{
		SetState(State_Idle);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::Settle_OnProcessMoveSignals()
{
	m_MoveInTargetState = m_MoveNetworkHelper.IsInTargetState();

	if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		if ((IsCoverFlagSet(CTaskCover::CF_FacingLeft) && m_MoveNetworkHelper.GetBoolean(ms_ToStandLId)) ||
			(!IsCoverFlagSet(CTaskCover::CF_FacingLeft) && m_MoveNetworkHelper.GetBoolean(ms_ToStandRId)))
		{
			m_MoveCanTransitionToIdle = true;
		}
	}
	else
	{
		if ((IsCoverFlagSet(CTaskCover::CF_FacingLeft) && m_MoveNetworkHelper.GetBoolean(ms_ToCrouchLId)) ||
			(!IsCoverFlagSet(CTaskCover::CF_FacingLeft) && m_MoveNetworkHelper.GetBoolean(ms_ToCrouchRId)))
		{
			m_MoveCanTransitionToIdle = true;
		}
	}

	if (m_MoveNetworkHelper.GetBoolean(ms_SettleClipFinishedId))
	{
		m_MoveCanTransitionToIdle = true;
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::PlayingIdleVariation_OnEnter()
{
	SetVariationClip(m_IdleVarationClipSetId, ms_Tunables.m_IdleVariationAnimStateInfos);
	m_MoveNetworkHelper.SetFlag(false, ms_IdleFlagId);
	m_MoveNetworkHelper.SetFlag(false, ms_PeekingFlagId);
	m_MoveNetworkHelper.SetFlag(false, ms_AtEdgeFlagId);
	m_MoveNetworkHelper.SetFlag(true, ms_IdleVariationFlagId);
	m_MoveNetworkHelper.WaitForTargetState(ms_IdleVariationOnEnterId);
	SetCoverFlag(CTaskCover::CF_RunningIdleVariation);

	RequestProcessMoveSignalCalls();
	m_MoveClipFinished = false;

	CPed& rPed = *GetPed();
	const bool bIgnoreWeaponObjectCheck = true;
	const fwMvClipSetId desiredWeaponHoldingClipSetId = CTaskCover::GetWeaponHoldingClipSetForArmament(&rPed, bIgnoreWeaponObjectCheck);
	const bool bUseWeaponHolding = desiredWeaponHoldingClipSetId != CLIP_SET_ID_INVALID;
	if (!bUseWeaponHolding)
	{
		SetGripClip(&rPed, m_MoveNetworkHelper);
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::PlayingIdleVariation_OnUpdate()
{
	// Quit if we have no cover point or are using the phone in cover and the use phone task has finished
	if (m_bAbortCoverRequest)
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	CPed* pPed = GetPed();
	if (!pPed->IsNetworkClone() && !pPed->GetCoverPoint())
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	ProcessUseMobilePhone();

	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);
	if (NeedsToFacePedInCorrectDirection())
		SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);

	if (!m_MoveInTargetState)
		return FSM_Continue;

	const bool bSwitchedBetweenFirstAndThirdPersonCam = ShouldRestartStateDueToCameraSwitch(m_MoveNetworkHelper);
	if (bSwitchedBetweenFirstAndThirdPersonCam)
	{
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		if (CheckForAtEdge())
		{
			SetState(State_AtEdge);
			return FSM_Continue;
		}
		else
		{
			SetState(GetPreviousState());
			return FSM_Continue;
		}
	}

	if (CheckForCoverToCover())
	{
		SetState(State_CoverToCover);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForPinned(*pPed))
	{
		SetState(State_PinnedIntro);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForTurn())
	{
		SetState(State_TurnEnter);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForMovingAbout())
	{
		SetState(State_Moving);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForMovingAroundCorner())
	{
		SetState(State_EdgeTurn);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForInsideCornerTransition())
	{
		SetState(State_InsideCornerTransition);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (GetPed()->IsLocalPlayer() && CheckForPeeking()) //NPCs too?
	{
		SetState(State_Peeking);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if ( m_MoveClipFinished ||
			  pPed->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_SWAP_WEAPON) || 
			  (pPed->IsLocalPlayer() && CPhoneMgr::IsDisplayed()))
	{
		if (CheckForAtEdge())
		{
			SetState(State_AtEdge);
			return FSM_Continue;
		}
		else
		{
			SetState(GetPreviousState());
			return FSM_Continue;
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::PlayingIdleVariation_OnExit()
{
	m_MoveNetworkHelper.SetFlag(false, ms_IdleVariationFlagId);
	ClearCoverFlag(CTaskCover::CF_RunningIdleVariation);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::PlayingIdleVariation_OnProcessMoveSignals()
{
	m_MoveInTargetState = m_MoveNetworkHelper.IsInTargetState();
	if (m_MoveNetworkHelper.GetBoolean(ms_IdleVariationClipFinishedId))
	{
		m_MoveClipFinished = true;
	} 
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Stopping_OnEnter()
{
	SetClipsFromAnimStateInfo();
	m_MoveNetworkHelper.WaitForTargetState(ms_StoppingOnEnterId);
	m_MoveNetworkHelper.SendRequest(ms_StoppingRequestId);

	CPed* pPed = GetPed();
	if (pPed->IsLocalPlayer())
	{
		if (pPed->GetCoverPoint())
		{
			// Scale the cover probe position based on our speed
			const float fOffsetScale = Mag(NMovingGround::GetPedVelocity(pPed)).Getf() / ms_Tunables.m_MaxMoveSpeedInCover;
			const float fOffset = Max(CTaskInCover::ms_Tunables.m_MinStoppingProbeOffset, fOffsetScale * CTaskInCover::ms_Tunables.m_MaxStoppingProbeOffset);
			m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
			FindNewDynamicCoverPoint(pPed, fOffset, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
			pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Stopping_OnUpdate()
{
	ProcessUseMobilePhone();

	// Turn Physics Processing On To Keep The Ped In Cover
	TUNE_BOOL(PROCESS_COVER_PHYSICS, true);
	if (PROCESS_COVER_PHYSICS)
	{
		SetCoverFlag(CTaskCover::CF_ShouldSlidePedAgainstCover);
		SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);
	}

	if (!m_MoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_TIME_IN_STOPPING_STATE, 0.1f, 0.0f, 1.0f, 0.01f);

	bool bDisallowCameraTurn = false;
#if FPS_MODE_SUPPORTED
	// In low cover the player has much more control over the camera and can get it facing in the opposite direction
	// they are moving.  To allow for that - without forcing the ped to turn back to face the camera - we don't check for
	// turns based on the camera vs. ped heading when moving in low cover in first-person
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false) && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsDelayedExit())
	{
		bDisallowCameraTurn = true;
	}
#endif

	if (CheckForTurn(bDisallowCameraTurn))
	{
		SetState(State_TurnEnter);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForMovingAbout() && GetTimeInState() >= MIN_TIME_IN_STOPPING_STATE)
	{
		if (m_MoveNetworkHelper.GetBoolean(ms_ToStepId))
		{
			SetState(State_Stepping);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else
		{
			TUNE_GROUP_BOOL(COVER_TUNE, USE_WALK_START_FROM_STOP, true);
			SetState(USE_WALK_START_FROM_STOP ? State_WalkStart : State_Moving);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
	}
	else if (CheckForAtEdge())
	{
		CPed* pPed = GetPed();
		if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
		{
			Vector3 vCoverPosition;
			pPed->GetCoverPoint()->GetCoverPointPosition(vCoverPosition);
			if (!IsPedCloseEnoughToCover(*pPed, vCoverPosition))
			{
				// Wait until we're close enough
				return FSM_Continue;
			}
		}
		SetState(State_AtEdge);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (m_MoveNetworkHelper.GetBoolean(ms_StoppingClipFinishedId) || !GetPed()->IsOnGround() || GetIsHeightTransitioning())
	{
		SetState(State_Idle);
		return FSM_Continue;
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::StoppingAtEdge_OnEnter()
{
	const CPed* pPed = GetPed();
	m_vInitialPedStoppingPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	m_vInitialPedStoppingPosition.z = 0.0f;
	m_fInitialAnimatedSpeed = -1.0f;	

	if (pPed->IsAPlayerPed() && ms_Tunables.m_EnableWalkStops && (GetPreviousState() == State_Moving || GetPreviousState() == State_WalkStart) && CanUseTaskState(State_StoppingAtEdge))
	{
		SetClipsFromAnimStateInfo();
		m_MoveNetworkHelper.WaitForTargetState(ms_StoppingOnEnterId);
		m_MoveNetworkHelper.SendRequest(ms_StoppingRequestId);
	}
	else
	{
		m_bIgnoreStillRequest = true;
		SetClipsFromAnimStateInfo();
		m_MoveNetworkHelper.SetFlag(true, ms_AtEdgeFlagId);
		m_MoveNetworkHelper.SetFlag(false, ms_IdleFlagId);
		m_MoveNetworkHelper.SetFlag(false, ms_PeekingFlagId);

		m_MoveNetworkHelper.WaitForTargetState(ms_AtEdgeOnEnterId);
		m_MoveNetworkHelper.SendRequest(ms_StillRequestId);
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::StoppingAtEdge_OnUpdate()
{
	ProcessUseMobilePhone();

	if (!m_MoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	bool bDisallowCameraTurn = false;
#if FPS_MODE_SUPPORTED
	// In low cover the player has much more control over the camera and can get it facing in the opposite direction
	// they are moving.  To allow for that - without forcing the ped to turn back to face the camera - we don't check for
	// turns based on the camera vs. ped heading when moving in low cover in first-person
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false) && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsDelayedExit())
	{
		bDisallowCameraTurn = true;
	}
#endif

	if (CheckForCoverToCover())
	{
		SetState(State_CoverToCover);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForTurn(bDisallowCameraTurn))
	{
		SetState(State_TurnEnter);
		return FSM_Continue;
	}

	const CPed* pPed = GetPed();
	if (pPed->IsNetworkClone())
	{
		if (GetStateFromNetwork() != State_StoppingAtEdge && GetStateFromNetwork() != State_AtEdge)
		{
			// transition back to idle first so that we avoid the ped getting stuck trying an invalid move transition
			SetState(State_Idle);
			return FSM_Continue;
		}
	}

	bool bAtEdgeLowCoverOnly = false;
	ProcessStopping(bAtEdgeLowCoverOnly ? State_AtEdgeLowCover : State_AtEdge);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::AtEdge_OnEnter()
{
	static_cast<CTaskInCover*>(GetParent())->CheckForBlockedAim();
	m_bWasUsingFirstPersonAnims = ShouldUseFirstPersonLocoAnimations(*GetPed());

	m_MoveNetworkHelper.SetFlag(true, ms_AtEdgeFlagId);
	m_MoveNetworkHelper.SetFlag(false, ms_IdleFlagId);
	m_MoveNetworkHelper.SetFlag(false, ms_PeekingFlagId);

	SetClipsFromAnimStateInfo();

	if (!m_bIgnoreStillRequest)
	{
		if (GetPed()->IsLocalPlayer() && GetPreviousState() == State_Peeking)
		{
			m_bIgnoreStillRequest = true;
		}
	}
	
	if (!m_bIgnoreStillRequest )
	{
		m_MoveNetworkHelper.WaitForTargetState(ms_AtEdgeOnEnterId);
		m_MoveNetworkHelper.SendRequest(ms_StillRequestId);
	}

	m_bIgnoreStillRequest = false;
	m_bUsingWalkStop = false;	

	// Allow peeking immediately after coming back from firing etc
	static dev_float MAX_TASK_TIME_TO_IGNORE_PEEK_RESET = 0.1f;
	if (GetTimeRunning() > MAX_TASK_TIME_TO_IGNORE_PEEK_RESET)
	{
		m_bPlayerPeekReset = false;
	}
	else
	{
		m_bPlayerPeekReset = true;
	}

	RequestProcessMoveSignalCalls();
	m_MoveInTargetState = false;
	m_bIsInLowCover = !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);

	// Turn on ambient lookAts for player.
	if(GetPed()->IsAPlayerPed())
	{
		// Passing in 0 flags, so no idle anims will be played from the ambient clips.
		atHashWithStringNotFinal ambientContext("EMPTY",0xBBD57BED);
		CTaskAmbientClips* pAmbientTask	= rage_new CTaskAmbientClips(0, CONDITIONALANIMSMGR.GetConditionalAnimsGroup(ambientContext.GetHash()));
		SetNewTask( pAmbientTask );
	}

	// Fix camera pop when returning to cover, the object matrix from the head differed due to the instant anim update
	// when the motion ped task starts
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		GetPed()->SetPedResetFlag(CPED_RESET_FLAG_ForcePreCameraAiAnimUpdateIfFirstPerson, true);
		GetPed()->SetPedResetFlag(CPED_RESET_FLAG_ePostCameraAnimUpdateUseZeroTimestep, true);
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::AtEdge_OnUpdate()
{
	m_IdleVariationTimer.Tick(GetTimeStep());

	CPed& ped = *GetPed();
	ProcessUseMobilePhone();
	ProcessLookIK(&ped);

	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);	
	if (NeedsToFacePedInCorrectDirection())
		SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);

	if (!m_MoveInTargetState)
		return FSM_Continue;	

	const bool bSwitchedBetweenFirstAndThirdPersonCam = ShouldRestartStateDueToCameraSwitch(m_MoveNetworkHelper);	
	const bool bShouldBeInLowCover = !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
	if ((m_bIsInLowCover && !bShouldBeInLowCover) || (!m_bIsInLowCover && bShouldBeInLowCover) || bSwitchedBetweenFirstAndThirdPersonCam)
	{
		SetFlag(aiTaskFlags::RestartCurrentState);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}

	// No transitions until we've restarted
	if (m_bRestartNextFrame)
		return FSM_Continue;

	if (CheckForCoverToCover())
	{
		SetState(State_CoverToCover);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForPeeking())
	{
		SetState(State_Peeking);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForPinned(ped))
	{
		SetState(State_PinnedIntro);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForIdleVariation(ped))
	{
		SetState(State_PlayingIdleVariation);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForTurn())
	{
		SetState(State_TurnEnter);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	if (m_bSteppingRequest && CheckForStepping() FPS_MODE_SUPPORTED_ONLY(&& !ped.IsFirstPersonShooterModeEnabledForPlayer(false)))
	{
		SetState(State_Stepping);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForMovingAbout())
	{
		bool bBlockOnEdgeLowCover = false;
		bool bInVehicleCover = ped.IsLocalPlayer() && CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity() && CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity()->GetIsTypeVehicle();
		if (!bInVehicleCover && ped.GetCoverPoint())
		{
			taskAssert(!ped.IsNetworkClone());
			CCoverPoint::eCoverUsage usage = ped.GetCoverPoint()->GetUsage();
			if (usage == CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT || usage == CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT)
			{
				if (GetTimeInState() < ms_Tunables.m_EdgeLowCoverMoveTime)
					bBlockOnEdgeLowCover = true;
			}
		}

		if (!bBlockOnEdgeLowCover)
		{
			SetState(State_Moving);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}		
	}
	else if (CheckForMovingAroundCorner())
	{
		SetState(State_EdgeTurn);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	// We used to do this, but I don't think it's needed - we just did it above.
	//	else if (CheckForPeeking())
	//	{
	//		SetState(State_Peeking);
	//		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
	//		return FSM_Continue;
	//	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::AtEdge_OnProcessMoveSignals()
{
	m_MoveInTargetState = m_MoveNetworkHelper.IsInTargetState();
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::AtEdge_OnExit()
{
	m_MoveNetworkHelper.SetFlag(false, ms_AtEdgeFlagId);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Moving_OnEnter()
{
	SetClipsFromAnimStateInfo();

	m_MoveNetworkHelper.WaitForTargetState(ms_MovingOnEnterId);
	m_MoveNetworkHelper.SendRequest(ms_MovingRequestId);
	m_bMovedSinceTurning = true;
	m_bRoundCornering = false;
	m_bSteppingRequestComplete = false;
	taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
	if (GetPed()->GetPlayerInfo() && GetPed()->GetPlayerInfo()->IsRoundCover())
	{
		static_cast<CTaskInCover*>(GetParent())->SetStickHeadingLock(true);	
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Moving_OnUpdate()
{
	ProcessUseMobilePhone();

	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedAgainstCover);
	SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);

	if (!m_MoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	CPed* pPed = GetPed();
	if (pPed->IsLocalPlayer())
	{
		// Scale the cover probe position based on our speed (will change depending on how blended the idle clip is)
		const float fOffsetScale = Mag(NMovingGround::GetPedVelocity(pPed)).Getf() / ms_Tunables.m_MaxMoveSpeedInCover;
		const float fProbeLength = Max(CTaskInCover::ms_Tunables.m_MinMovingProbeOffset, fOffsetScale * CTaskInCover::ms_Tunables.m_MaxMovingProbeOffset);
		float fOffset = pPed->GetMotionData()->GetDesiredMbrY() * fProbeLength;
		
		// Because we're pushing the probes further ahead when moving we may end up not detecting valid cover
		// depending on where the probes land. If so, retry closer into the player
		m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
		if (!FindNewDynamicCoverPoint(pPed, fOffset, IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
		{
			bool bShouldQuit = true;
			aiDisplayf("Frame : %i, Cover point not found in state %s, fOffset %.2f",fwTimer::GetFrameCount(),GetStateName(GetState()), fOffset);
			// Retry if the offset used was quite large
			TUNE_GROUP_FLOAT(COVER_TUNE, RETRY_OFFSET_LIMIT, 0.15f, 0.0f, 1.0f, 0.01f);
			if (fOffset > RETRY_OFFSET_LIMIT)
			{
				TUNE_GROUP_FLOAT(COVER_TUNE, RETRY_OFFSET_SCALE, 0.1f, 0.0f, 1.0f, 0.01f);
				fOffset *= RETRY_OFFSET_SCALE;
				if (FindNewDynamicCoverPoint(pPed, fOffset, IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
				{
					aiDisplayf("Frame : %i, Cover point found after retry in state %s, fOffset %.2f",fwTimer::GetFrameCount(),GetStateName(GetState()), fOffset);
					bShouldQuit = false;
				}
				else
				{
					aiDisplayf("Frame : %i, Cover point not found after retry in state %s, fOffset %.2f",fwTimer::GetFrameCount(),GetStateName(GetState()), fOffset);
					TUNE_GROUP_BOOL(COVER_TUNE, DONT_LEAVE_COVER_FOR_WOOD_BOX, true);	
					if (pPed->GetCoverPoint() && DONT_LEAVE_COVER_FOR_WOOD_BOX && CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity() && CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity()->GetArchetype() && CPlayerInfo::ms_DynamicCoverHelper.GetCoverEntryEntity()->GetModelIndex() == MI_PROP_BOX_WOOD04A)
					{
						bShouldQuit = false;
					}
				}
			}
			else
			{
				aiDisplayf("Frame : %i, Not retrying due to offset - %.2f", fwTimer::GetFrameCount(), fOffset);
			}

			if (bShouldQuit)
			{
				SetState(State_Finish);
				return FSM_Continue;
			}
		}

		taskAssert(pPed->GetCoverPoint());
		pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
	}

	//bool bSearchForNewCover = GetTimeInState() > CTaskInCover::ms_Tunables.m_StartExtendedProbeTime ? true : false;

	static dev_float sf_MaxRoundCornerNavTime = 0.5f;
	bool bRoundCoverTimeOut = false;
	if (pPed->IsLocalPlayer() && pPed->GetPlayerInfo()->IsRoundCover() && GetTimeInState() > sf_MaxRoundCornerNavTime)
	{
		m_bRoundCornering = true;
		bRoundCoverTimeOut = true;
		m_uTimeOfLastRoundCornerMove = fwTimer::GetTimeInMilliseconds();
	}

	bool bDisallowCameraTurn = false;
#if FPS_MODE_SUPPORTED
	TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, ALLOW_TURN_FROM_MOVING, true);
	bool bIsFPSMode = pPed->IsFirstPersonShooterModeEnabledForPlayer(false);
	// In low cover the player has much more control over the camera and can get it facing in the opposite direction
	// they are moving.  To allow for that - without forcing the ped to turn back to face the camera - we don't check for
	// turns based on the camera vs. ped heading when moving in low cover in first-person
	if (bIsFPSMode && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsDelayedExit())
	{
		bDisallowCameraTurn = true;
	}
#endif
	if ((pPed->IsNetworkClone() FPS_MODE_SUPPORTED_ONLY(|| (ALLOW_TURN_FROM_MOVING && bIsFPSMode))) && CheckForTurn(bDisallowCameraTurn))
	{
		SetState(State_TurnEnter);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	
	if (CheckForAtEdge())
	{
		float fEdgeDistance = -1.0f;
		static dev_float sf_MinEdgeDistanceForStopping = 0.75f;
		if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
		{
			Vector3 vCurrentCoverPosition(Vector3::ZeroType);
			pPed->GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition);
			CTaskInCover::FindCoverEdgeAndUpdateCoverPosition(pPed, vCurrentCoverPosition, fEdgeDistance, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
			pPed->GetPlayerInfo()->SetDynamicCoverEdgeDistance(fEdgeDistance);
		}

		if (ms_Tunables.m_EnableWalkStops && GetTimeInState() > ms_Tunables.m_BlendToIdleTime)
		{
			
			if (fEdgeDistance > ms_Tunables.m_MinEdgeDistanceForStoppingAnim)
			{
				SetState(State_StoppingAtEdge);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				// force a network update so the other machines know the ped is stopping a.s.a.p
				ForceResendOfSyncData(*pPed);
				return FSM_Continue;
			}			
		}

		if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
		{
			Vector3 vCoverPosition;
			pPed->GetCoverPoint()->GetCoverPointPosition(vCoverPosition);
			if (fEdgeDistance > sf_MinEdgeDistanceForStopping && !IsPedCloseEnoughToCover(*pPed, vCoverPosition))
			{
				// Wait until we're close enough
				return FSM_Continue;
			}
		}

		bool bSetEdgeState = true;
		if (pPed->IsNetworkClone())
		{
			Vector3 coverPointPosition;
			if (GetNetCoverPointPosition(*pPed, coverPointPosition) && !pPed->GetUsingRagdoll())
			{
				coverPointPosition.z += pPed->GetCapsuleInfo()->GetGroundToRootOffset();
				Vector3 pedPos = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
				Vector3 diff = pedPos - coverPointPosition;
				const float fDiffMagSqd = diff.Mag2();
				TUNE_GROUP_FLOAT(COVER_TUNE, MAX_DIST_TOGO_DIRECLTY_TO_EDGE, 0.25f, 0.0f, 1.0f, 0.01f);
				if (fDiffMagSqd > square(MAX_DIST_TOGO_DIRECLTY_TO_EDGE))
				{
					SetState(State_StoppingAtEdge);
					bSetEdgeState = false;
				}
			}
		}

		if (bSetEdgeState)
		{
			SetState(State_AtEdge);
		}
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		// force a network update so the other machines know the ped is stopping a.s.a.p
		ForceResendOfSyncData(*pPed);
		return FSM_Continue;
	}
	else if (CheckForIdle() || bRoundCoverTimeOut)
	{		
		if (pPed->GetNetworkObject() && !pPed->IsNetworkClone())
		{
			// force a network update so the other machines know the ped is stopping a.s.a.p
			SafeCast(CNetObjPed, pPed->GetNetworkObject())->ForceResendAllData();
		}

		if (pPed->GetPlayerInfo() && pPed->GetPlayerInfo()->DynamicCoverInsideCorner() && pPed->GetPlayerInfo()->GetInsideCornerDistance() <= ms_Tunables.m_InsideCornerStopDistance)
		{
			if (ms_Tunables.m_EnableWalkStops && GetTimeInState() > ms_Tunables.m_BlendToIdleTime && CanUseTaskState(State_Stopping))
			{
				SetState(State_StoppingAtInsideEdge);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				// force a network update so the other machines know the ped is stopping a.s.a.p
				ForceResendOfSyncData(*pPed);
				return FSM_Continue;
			}
			else
			{
				SetState(State_Idle);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				// force a network update so the other machines know the ped is stopping a.s.a.p
				ForceResendOfSyncData(*pPed);
				return FSM_Continue;
			}
		}
		else
		{
			if (ms_Tunables.m_EnableWalkStops && GetTimeInState() > ms_Tunables.m_BlendToIdleTime && CanUseTaskState(State_Stopping))
			{
				if (pPed->IsLocalPlayer() && pPed->GetCoverPoint())
				{
					const float fOffsetScale = Mag(NMovingGround::GetPedVelocity(pPed)).Getf() / ms_Tunables.m_MaxMoveSpeedInCover;
					const float fProbeLength = Max(CTaskInCover::ms_Tunables.m_MinStoppingEdgeCheckProbeOffset, fOffsetScale * CTaskInCover::ms_Tunables.m_MaxStoppingEdgeCheckProbeOffset);
					const float fOffset = fOffsetScale * fProbeLength;
					m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
					FindNewDynamicCoverPoint(pPed, fOffset, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
					if (CheckForAtEdge())
					{
						SetState(State_StoppingAtEdge);
						SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
						// force a network update so the other machines know the ped is stopping a.s.a.p
						ForceResendOfSyncData(*pPed);
						return FSM_Continue;
					}
				}
				SetState(State_Stopping);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				// force a network update so the other machines know the ped is stopping a.s.a.p
				ForceResendOfSyncData(*pPed);
				return FSM_Continue;
			}
			else
			{
				SetState(State_Idle);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				// force a network update so the other machines know the ped is stopping a.s.a.p
				ForceResendOfSyncData(*pPed);
				return FSM_Continue;
			}
		}
	}

	return FSM_Continue;
}

CTask::FSM_Return CTaskMotionInCover::Moving_OnExit()
{
	if (GetPed()->IsLocalPlayer() && GetParent())
	{
		static_cast<CTaskInCover*>(GetParent())->CacheStickAngle();
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::StoppingAtInsideEdge_OnEnter()
{
	const CPed* pPed = GetPed();
	m_vInitialPedStoppingPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	m_vInitialPedStoppingPosition.z = 0.0f;
	m_fInitialAnimatedSpeed = -1.0f;

	if (pPed->IsAPlayerPed() && ms_Tunables.m_EnableWalkStops && GetPreviousState() != State_CoverToCover)
	{
		SetClipsFromAnimStateInfo();
		m_MoveNetworkHelper.WaitForTargetState(ms_StoppingOnEnterId);
		m_MoveNetworkHelper.SendRequest(ms_StoppingRequestId);
	}
	else
	{
		SetClipsFromAnimStateInfo();
		m_MoveNetworkHelper.SetFlag(true, ms_AtEdgeFlagId);
		m_MoveNetworkHelper.SetFlag(false, ms_IdleFlagId);
		m_MoveNetworkHelper.SetFlag(false, ms_PeekingFlagId);

		m_MoveNetworkHelper.WaitForTargetState(ms_AtEdgeOnEnterId);
		m_MoveNetworkHelper.SendRequest(ms_StillRequestId);
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::StoppingAtInsideEdge_OnUpdate()
{
	ProcessUseMobilePhone();

	const CPed* pPed = GetPed();
	if (pPed->IsNetworkClone())
	{
		if (GetStateFromNetwork() != State_StoppingAtInsideEdge && GetStateFromNetwork() != State_AtEdge)
		{
			// transition back to idle first so that we avoid the ped getting stuck trying an invalid move transition
			SetState(State_Idle);
		}
	}
	else
	{
		ProcessStopping(State_Idle);
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Turning_OnExit()
{
	ClearCoverFlag(CTaskCover::CF_TurningLeft);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::TurnEnter_OnEnter()
{
	BANK_ONLY(aiDebugf1("Frame %i: Ped %s(%p) Entering TurnEnter_OnEnter", fwTimer::GetFrameCount(), GetPed()->GetDebugName(),GetPed()));
	SetClipsFromAnimStateInfo();
	m_MoveNetworkHelper.WaitForTargetState(ms_TurnEnterOnEnterId);
	m_MoveNetworkHelper.SendRequest(ms_TurningRequestId);
	m_MoveNetworkHelper.SendRequest(ms_TurnEnterRequestId);
	m_bTurningLeft = !IsCoverFlagSet(CTaskCover::CF_FacingLeft);
	m_bTurnedFromLowCover = !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
	m_bIgnoreStillRequest = false;

	CPed& rPed = *GetPed();
	if (GetPreviousState() == State_Turning)
	{
		m_MoveNetworkHelper.SetFloat(ms_TurnEndToTurnEnterBlendDurationId, m_fTurnEndToTurnEnterBlendDuration);
	}
#if FPS_MODE_SUPPORTED
	else if (GetPreviousState() == State_Stopping || GetPreviousState() == State_StoppingAtEdge || GetPreviousState() == State_StoppingAtInsideEdge)
	{
		if (rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, STOPPING_TO_TURN_ENTER_BLEND_DURATION, 0.1f, 0.0f, 1.0f, 0.01f);
			m_MoveNetworkHelper.SetFloat(ms_StoppingToTurnEnterBlendDurationId, STOPPING_TO_TURN_ENTER_BLEND_DURATION);
		}
	}
	// If we've just gone from peeking to turning then likely the player is still holding the stick to be peeking so we don't want to
	// trigger a turn back the other way until the left stick input has been zeroed
	else if (GetPreviousState() == State_Peeking)
	{
		m_bDisallowTurnUntilInputZeroed = true;
	}
#endif

	RequestProcessMoveSignalCalls();
	m_MoveClipFinished = false;
	m_MoveInTargetState = false;
	m_bTurningIntoEdge = false;
	m_bSteppingRequestComplete = false;
	m_bDontChangeCoverPositionWhenTurning = false;

	if (rPed.IsLocalPlayer() && rPed.GetCoverPoint())
	{
		if (rPed.GetPlayerInfo()->IsRoundCover())
		{
			m_bDontChangeCoverPositionWhenTurning = true;
		}
		else if (rPed.GetCoverPoint()->IsEdgeCoverPoint())
		{	
			
			if (TestForObstructionsBehindPlayer(rPed))
			{
				m_bDontChangeCoverPositionWhenTurning = true;
			}
			else if (!rPed.GetCoverPoint()->IsEdgeCoverPoint(IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
			{
				m_bTurningIntoEdge = true;
			}
		}

		TUNE_GROUP_BOOL(COVER_TUNE, DISABLE_MOVED_SINCE_TURNING, true);
		if (!DISABLE_MOVED_SINCE_TURNING && !m_bMovedSinceTurning && (GetPreviousState() == State_TurnEnd || GetPreviousState() == State_Idle || GetPreviousState() == State_AtEdge || GetPreviousState() == State_Settle))
		{
			m_bDontChangeCoverPositionWhenTurning = true;
		}
	}

	float fTurnEnterRate = 1.3f;
#if FPS_MODE_SUPPORTED
	if (rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, TURN_ENTER_CLIP_RATE, 1.3f, 0.0f, 2.0f, 0.01f);
		fTurnEnterRate = TURN_ENTER_CLIP_RATE;

		m_bLeftStickTriggeredTurn = CheckForTurn(true, true, false);
	}
#endif // FPS_MODE_SUPPORTED

	m_MoveNetworkHelper.SetFloat(ms_TurnRateId, fTurnEnterRate);

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::TurnEnter_OnUpdate()
{
	// Turn Physics Processing On To Keep The Ped Against Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedAgainstCover);

	CPed& ped = *GetPed();

	// We need to process the turn each frame
	ped.GetPedAiLod().SetForceNoTimesliceIntelligenceUpdate(true);

#if FPS_MODE_SUPPORTED
	// Don't allow locking on during a turn
	if (ped.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		ped.SetPedResetFlag(CPED_RESET_FLAG_DisablePlayerLockon, true);
		ped.SetPedResetFlag(CPED_RESET_FLAG_ClearLockonTarget, true);
	}
#endif

	if (!m_MoveInTargetState)
		return FSM_Continue;

	if (m_MoveClipFinished)
	{
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		SetState(State_TurnEnd);
		return FSM_Continue;
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::TurnEnter_OnProcessMoveSignals()
{
	bool inTargetState = m_MoveNetworkHelper.IsInTargetState();
	m_MoveInTargetState = inTargetState;
	if(inTargetState && (m_MoveNetworkHelper.GetBoolean(ms_ToStepId) || m_MoveNetworkHelper.GetBoolean(ms_TurnEnterClipFinishedId)))
	{
		m_MoveClipFinished = true;
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::TurnEnter_OnExit()
{
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::TurnEnd_OnEnter()
{
	BANK_ONLY(aiDebugf1("Frame %i: Ped %s(%p) Entering TurnEnd_OnEnter", fwTimer::GetFrameCount(), GetPed()->GetDebugName(),GetPed()));
	if (m_bTurningLeft)
	{
		ClearCoverFlag(CTaskCover::CF_FacingLeft);
	}
	else
	{
		SetCoverFlag(CTaskCover::CF_FacingLeft);
	}

	SetClipsFromAnimStateInfo();
	m_MoveNetworkHelper.WaitForTargetState(ms_TurnEndOnEnterId);
	m_MoveNetworkHelper.SendRequest(ms_TurnEndRequestId);

	if (!IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		SetCoverFlag(CTaskCover::CF_FacingLeft);
	}
	else
	{
		ClearCoverFlag(CTaskCover::CF_FacingLeft);
	}

	CPed& rPed = *GetPed();
	rPed.SetPedResetFlag(CPED_RESET_FLAG_InCoverFacingLeft, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
	//Reload anim swap
	CTask* pTask = rPed.GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN);
	if (pTask)	
	{
		static_cast<CTaskReloadGun*>(pTask)->RequestAnimSwap();
	}

	RequestProcessMoveSignalCalls();
	m_MoveClipFinished = false;
	m_MoveInTargetState = false;
	m_MoveSignalToTurn = false;
	m_vInitialPedStoppingPosition = VEC3V_TO_VECTOR3(GetPed()->GetTransform().GetPosition());

	m_bDoCloneTurn = false;

	TUNE_GROUP_FLOAT(COVER_TUNE, STOP_STEP_DIST, 0.05f, 0.0f, 0.5f, 0.01f);
	bool bWantsToTurnOrStop = m_bDontChangeCoverPositionWhenTurning || CheckForTurn(true) || CheckForIdle(false);

	float fDesiredStepDist = bWantsToTurnOrStop ? 0.0f : 0.5f;
	// Don't update the cover position if we detected an obstruction
	if (rPed.IsLocalPlayer() && rPed.GetCoverPoint() && !m_bDontChangeCoverPositionWhenTurning)
	{
		// Max step distance is 0.5m
		if (!m_bTurningIntoEdge)
		{
			const float fOffsetScale = fDesiredStepDist * 2.0f;
			const float fOffset = Max(CTaskInCover::ms_Tunables.m_MinTurnProbeOffset, fOffsetScale * CTaskInCover::ms_Tunables.m_MaxTurnProbeOffset);
			m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
			FindNewDynamicCoverPoint(&rPed, fOffset, IsCoverFlagSet(CTaskCover::CF_FacingLeft), false, true, true);
			m_bMovedSinceTurning = true;
		}

		Vector3 vCurrentCoverPosition;
		rPed.GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition);
#if DEBUG_DRAW
		CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vCurrentCoverPosition), 0.025f, Color_red, 2000);
#endif // DEBUG_DRAW

		float fEdgeDistance = -1.0f;
		CTaskInCover::FindCoverEdgeAndUpdateCoverPosition(&rPed, vCurrentCoverPosition, fEdgeDistance, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
		rPed.GetPlayerInfo()->SetDynamicCoverEdgeDistance(fEdgeDistance);

		if (rPed.GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition))
		{
			const Vector3 vPedPos = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
			fDesiredStepDist = (vCurrentCoverPosition - vPedPos).XYMag();
#if DEBUG_DRAW
			CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vCurrentCoverPosition), 0.025f, Color_blue, 2000);
#endif // DEBUG_DRAW
		}
	}

	if (!rPed.IsNetworkClone())
	{
		m_fStepDistance = fDesiredStepDist;
		aiDebugf2("Dist %.4f", m_fStepDistance);
	}

	float fTurnExitRate = 1.3f;
	float fTurnStepRate = 1.5f;
#if FPS_MODE_SUPPORTED
	if (rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, TURN_EXIT_CLIP_RATE, 1.3f, 0.0f, 2.0f, 0.01f);
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, TURN_STEP_CLIP_RATE, 1.5f, 0.0f, 2.0f, 0.01f);
		fTurnExitRate = TURN_EXIT_CLIP_RATE;
		fTurnStepRate = TURN_STEP_CLIP_RATE;
	}
#endif // FPS_MODE_SUPPORTED

	m_MoveNetworkHelper.SetFloat(ms_TurnRateId, fTurnExitRate);
	m_MoveNetworkHelper.SetFloat(ms_TurnStepRateId, fTurnStepRate);

	m_MoveNetworkHelper.SetFloat(ms_StepDistanceId, m_fStepDistance);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::TurnEnd_OnUpdate()
{
	CPed& ped = *GetPed();

	// We need to process the turn each frame
	ped.GetPedAiLod().SetForceNoTimesliceIntelligenceUpdate(true);

	bool bRightEdge = false;
	bool bLeftEdge = false;
	bool bWantsToTurnOrStop = false;
	if (ped.IsLocalPlayer() && ped.GetCoverPoint())
	{
		bRightEdge = ped.GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTOLEFT || ped.GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTONEITHER;
		bLeftEdge = ped.GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTORIGHT || ped.GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTONEITHER;
		if ((!IsCoverFlagSet(CTaskCover::CF_FacingLeft) && bRightEdge) || (IsCoverFlagSet(CTaskCover::CF_FacingLeft) && bLeftEdge))
		{
			bWantsToTurnOrStop = true;
		}
	}

	// Turn Physics Processing On To Keep The Ped Against Cover
	if (bRightEdge || bLeftEdge)
	{		
		//SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover); // Removing per B* 1317820, it doesn't seem necessary anymore, and wipes out animated mover translation. [4/25/2013 musson]
	}
	else
	{
		// Turn Physics Processing On To Keep The Ped Against Cover
		SetCoverFlag(CTaskCover::CF_ShouldSlidePedAgainstCover);
	}

	if (m_MoveNetworkHelper.GetBoolean(ms_FixupRotationId))
	{
		SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);
	}

#if FPS_MODE_SUPPORTED
	// Don't allow locking on during a turn
	if (ped.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		ped.SetPedResetFlag(CPED_RESET_FLAG_DisablePlayerLockon, true);
		ped.SetPedResetFlag(CPED_RESET_FLAG_ClearLockonTarget, true);
	}
#endif

	if (!m_MoveInTargetState)
		return FSM_Continue;

	bool bCanChangeState = m_MoveClipFinished;
	bool bDelayedExit = IsDelayedExit();
	
	Vector3 vTargetDirUnused;
	Vector3 vCoverDirection(Vector3::ZeroType);
	if (CCover::FindCoverDirectionForPed(ped, vCoverDirection, vTargetDirUnused))
	{
		if (!bCanChangeState && IsPedsheadingCloseEnoughToFacingDirection(ped, vCoverDirection, IsCoverFlagSet(CTaskCover::CF_FacingLeft), bDelayedExit ? HALF_PI : ms_Tunables.m_CoverHeadingCloseEnoughTurn))
		{
			bCanChangeState = true;
		}
	}

	if (bCanChangeState)
	{
		// Don't update the cover position if we detected an obstruction... but do need to know if now facing an edge.
		if (ped.IsLocalPlayer() && ped.GetCoverPoint())
		{
			//Need a new check to look for obstacles, if this is a problem will need a different solution for turning at corners triggering false "at edge" states
			//this being a 0.0f offset should not affect the TurningIntoEdge.
			//if (!m_bTurningIntoEdge) 			
			if (ped.GetPlayerInfo()->GetDynamicCoverEdgeDistance() < 0.0f) //otherwise already found edge, only find new cover point once, B* 1547907
			{				
				m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
				FindNewDynamicCoverPoint(&ped, 0.0f, IsCoverFlagSet(CTaskCover::CF_FacingLeft), false, true, true);
				m_bMovedSinceTurning = true;
			}
			else
			{
				// The call to FindNewDynamicCoverPoint was responsible for resetting these flags so we need to manually do it here...
				ped.GetPlayerInfo()->SetDynamicCoverInsideCorner(false);
				ped.GetPlayerInfo()->SetDynamicCoverHitPed(false);
			}

			Vector3 vCurrentCoverPosition;
			ped.GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition);
#if DEBUG_DRAW
			CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vCurrentCoverPosition), 0.025f, Color_red, 2000);
#endif // DEBUG_DRAW

			float fEdgeDistance = -1.0f;
			CTaskInCover::FindCoverEdgeAndUpdateCoverPosition(&ped, vCurrentCoverPosition, fEdgeDistance, IsCoverFlagSet(CTaskCover::CF_FacingLeft));
			ped.GetPlayerInfo()->SetDynamicCoverEdgeDistance(fEdgeDistance);

			if (ped.GetCoverPoint()->GetCoverPointPosition(vCurrentCoverPosition))
			{				
#if DEBUG_DRAW
				CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vCurrentCoverPosition), 0.025f, Color_blue, 2000);
#endif // DEBUG_DRAW
			}
		}

		if (ped.GetCoverPoint())
		{
			bool bDisallowCameraTurn = false;
#if FPS_MODE_SUPPORTED
			bool bIsFPSMode = ped.IsFirstPersonShooterModeEnabledForPlayer(false);
			// In low cover the player has much more control over the camera and can get it facing in the opposite direction
			// they are moving.  To allow for that - without forcing the ped to turn back to face the camera - we don't check for
			// turns based on the camera vs. ped heading when moving in low cover in first-person
			if (bIsFPSMode && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
			{
				bDisallowCameraTurn = true;
			}
#endif
			if ((m_MoveSignalToTurn FPS_MODE_SUPPORTED_ONLY(|| (ms_Tunables.m_EnableFirstPersonLocoAnimations && bIsFPSMode))) && CheckForTurn(bDisallowCameraTurn, m_MoveSignalToTurn))
			{
				if (!m_bDontChangeCoverPositionWhenTurning)
				{
					// Try to update the cover
					// Scale the cover probe position based on our speed (will change depending on how blended the idle clip is)
					CPed* pPed = GetPed();
					if (pPed->IsLocalPlayer() && (!pPed->GetPlayerInfo()->DynamicCoverInsideCorner() || GetPreviousState() == State_Turning))
					{
						m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
						FindNewDynamicCoverPoint(pPed, 0.0f, IsCoverFlagSet(CTaskCover::CF_FacingLeft), false, true, true, bWantsToTurnOrStop);
					}
				}
				m_fTurnEndToTurnEnterBlendDuration = rage::Max(0.05f, m_fStepDistance);
				SetState(State_TurnEnter);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				return FSM_Continue;
			}
			m_MoveSignalToTurn = false;
		}

		bool bCloseToCoverConditionPassed = true;

		if (ped.IsLocalPlayer() && ped.GetCoverPoint())
		{
			Vector3 vCoverPosition(Vector3::ZeroType);
			ped.GetCoverPoint()->GetCoverPointPosition(vCoverPosition);
			bCloseToCoverConditionPassed = IsPedCloseEnoughToCover(ped, vCoverPosition);
		}

		if (CheckForCoverToCover())
		{
			SetState(State_CoverToCover);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (ped.IsLocalPlayer() && ped.GetPlayerInfo()->IsRoundCover() && CheckForMovingAbout())
		{
			SetState(State_Moving);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (CheckForWalkStart())
		{

			TUNE_GROUP_BOOL(COVER_TUNE, ENABLE_TURN_WALK_START, true);	
			SetState(ENABLE_TURN_WALK_START ? State_WalkStart : State_Moving);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (!bWantsToTurnOrStop && CheckForStepping())
		{
			TUNE_GROUP_FLOAT(COVER_TUNE, MIN_DIST_TO_STEP, 0.1f, 0.0f, 0.5f, 0.01f);	
			const bool bShouldStep = ped.IsNetworkClone() || (m_fStepDistance < MIN_DIST_TO_STEP ? true : false);		
			SetState(bShouldStep ? State_Stepping : State_Moving);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (ped.IsNetworkClone() && GetStateFromNetwork() == State_Moving)
		{
			SetState(State_Moving);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (m_MoveClipFinished || ((bDelayedExit || CheckForSettle()) && bCloseToCoverConditionPassed))
		{
			// Try to update the cover
			// Scale the cover probe position based on our speed (will change depending on how blended the idle clip is)
			if (ped.GetCoverPoint() && !m_bDontChangeCoverPositionWhenTurning)
			{
				const bool bRightEdge = ped.GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTOLEFT || ped.GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTONEITHER;
				const bool bLeftEdge = ped.GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTORIGHT || ped.GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTONEITHER;
				if ((IsCoverFlagSet(CTaskCover::CF_FacingLeft) && !bRightEdge) || (!IsCoverFlagSet(CTaskCover::CF_FacingLeft) && !bLeftEdge))
				{
					if (ped.IsLocalPlayer() && (!ped.GetPlayerInfo()->DynamicCoverInsideCorner() || GetPreviousState() == State_Turning))
					{
						m_uVerifyCoverTimer = ms_Tunables.m_VerifyCoverInterval;
						FindNewDynamicCoverPoint(&ped, 0.0f, IsCoverFlagSet(CTaskCover::CF_FacingLeft), false, true, true, bWantsToTurnOrStop);
					}
				}
			}
			SetState(State_Settle);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (GetPed()->IsNetworkClone() && GetStateFromNetwork() == State_Stopping)
		{
			SetState(State_Stopping);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::TurnEnd_OnProcessMoveSignals()
{
	m_MoveNetworkHelper.SetFloat(ms_StepDistanceId, m_fStepDistance);
	bool inTargetState = m_MoveNetworkHelper.IsInTargetState();
	m_MoveInTargetState = inTargetState;

	if(m_MoveNetworkHelper.GetBoolean(ms_ToTurnId))
	{
		// Not sure, but currently we set this back to false during the state update.
		m_MoveSignalToTurn = true;
	}

	if(m_MoveNetworkHelper.GetBoolean(ms_TurnEndClipFinishedId))
	{
		m_MoveClipFinished = true;
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::TurnEnd_OnExit()
{
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::EdgeTurn_OnEnter()
{
	SetClipsFromAnimStateInfo();

	m_MoveNetworkHelper.SetFlag(false, ms_AtEdgeFlagId);
	m_MoveNetworkHelper.SetFlag(false, ms_IdleFlagId);
	m_MoveNetworkHelper.SetFlag(false, ms_PeekingFlagId);
	m_MoveNetworkHelper.SetFlag(true, ms_EdgeTurnFlagId);

	m_bSteppingRequestComplete = false;
	m_MoveClipFinished = false;

	if (GetPreviousState() == State_EdgeTurn)
		m_MoveNetworkHelper.SendRequest(ms_RestartEdgeTurnRequestId);
	else
		m_MoveNetworkHelper.SendRequest(ms_TurningRequestId);

	if (GetPreviousState() == State_Peeking)
	{
		m_MoveNetworkHelper.SetFloat(ms_StillToTurnBlendDurationId, ms_Tunables.m_PeekToEdgeTurnBlendDuration);
	}
	else
	{
		m_MoveNetworkHelper.SetFloat(ms_StillToTurnBlendDurationId, ms_Tunables.m_DefaultEdgeTurnBlendDuration);
	}
	m_MoveNetworkHelper.WaitForTargetState(ms_EdgeTurnOnEnterId);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::EdgeTurn_OnUpdate()
{
	if (!m_MoveInTargetState)
		return FSM_Continue;

	if (m_MoveNetworkHelper.GetBoolean(ms_EdgeTurnFixupId))
	{
		SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);
	}

	if (m_MoveNetworkHelper.GetBoolean(ms_EdgeTurnInterruptId))
	{
		if (CheckForTurn())
		{
			SetState(State_Idle); //sending to Idle 1st to fix up the cover point B* 1489300
			//SetState(State_TurnEnter);
			return FSM_Continue;
		}
		else if (CheckForMovingAbout())
		{
			SetState(State_Moving);
			return FSM_Continue;
		}
	}

	if (m_MoveClipFinished)
	{
		if (CheckForTurn())
		{
			SetState(State_TurnEnter);
			return FSM_Continue;
		}
		else if (CheckForMovingAbout())
		{
			SetState(State_Moving);
			return FSM_Continue;
		}
		else
		{
			SetState(State_Idle);
			return FSM_Continue;
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::EdgeTurn_OnExit()
{
	m_MoveNetworkHelper.SetFlag(false, ms_EdgeTurnFlagId);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::EdgeTurn_OnProcessMoveSignals()
{
	m_MoveInTargetState = m_MoveNetworkHelper.IsInTargetState();

	if (m_MoveNetworkHelper.GetBoolean(ms_EdgeTurnClipFinishedId))
	{
		m_MoveClipFinished = true;
	} 
}

//////////////////////////////////////////////////////////////////////////
CTask::FSM_Return CTaskMotionInCover::InsideCornerTransition_OnEnter()
{
	SetClipsFromAnimStateInfo();
	m_MoveNetworkHelper.WaitForTargetState(ms_SteppingOnEnterId);
	m_MoveNetworkHelper.SendRequest(ms_SteppingRequestId);
	m_fInitialPedCoverToCoverHeading = GetPed()->GetCurrentHeading();
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::InsideCornerTransition_OnUpdate()
{
	static dev_float sf_InsideCornerStepDistance = 0.5f; 
	m_fStepDistance = sf_InsideCornerStepDistance;
	m_MoveNetworkHelper.SetFloat(ms_StepDistanceId, m_fStepDistance);

	// Turn Physics Processing On To Keep The Ped Against Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedAgainstCover);

	if (!m_MoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	CPed* pPed = GetPed();

	if (!pPed->IsNetworkClone())
	{
		float fClipPhase = m_MoveNetworkHelper.GetFloat(ms_SteppingClipCurrentPhaseId);	
		static dev_float sf_InsideCornerTurnScale = 2.0f;
		fClipPhase = Min(1.0f, fClipPhase*sf_InsideCornerTurnScale);
		Vector3 vCoverDirection = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector());
		vCoverDirection.RotateZ(IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? HALF_PI : -HALF_PI);
		float fGoalHeading = fwAngle::LimitRadianAngle(rage::Atan2f(-vCoverDirection.x, vCoverDirection.y));
		fGoalHeading = m_fInitialPedCoverToCoverHeading + (SubtractAngleShorter(fGoalHeading, m_fInitialPedCoverToCoverHeading) * fClipPhase);
		float fCorrection = GetPed()->GetCurrentHeading();
		fCorrection = SubtractAngleShorter(fGoalHeading, fCorrection);	
		pPed->SetPedResetFlag(CPED_RESET_FLAG_SyncDesiredHeadingToCurrentHeading, false);
		pPed->GetMotionData()->SetExtraHeadingChangeThisFrame(fCorrection);

		static dev_float s_fInsideCornerTransisionRadius = 0.45f;
		pPed->SetTaskCapsuleRadius(s_fInsideCornerTransisionRadius);
	}

	if (m_MoveNetworkHelper.GetBoolean(ms_StepClipFinishedId))
	{
		SetState(State_Settle);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	
	return FSM_Continue;
}

CTask::FSM_Return CTaskMotionInCover::InsideCornerTransition_OnExit() 
{
	GetPed()->SetTaskCapsuleRadius(0.0f);
	return FSM_Continue;
}
////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::CoverToCover_OnEnter()
{
	CPed* pPed = GetPed();

	SetClipsFromAnimStateInfo();
	m_MoveNetworkHelper.SendRequest(ms_CoverToCoverRequestId);

	if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		ClearCoverFlag(CTaskCover::CF_FacingLeft);
	}
	else
	{
		SetCoverFlag(CTaskCover::CF_FacingLeft);
	}

	Vector3 vCurrentPedPos	= VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	Vector3 vNewCoverPos(Vector3::ZeroType);
	bool bFoundCoverPoint = false;

	if (pPed->IsNetworkClone())
	{
		if (AssertVerify(GetNetCoverPointPosition(*pPed, vNewCoverPos)))
		{
			bFoundCoverPoint = true;	
		}
	}
	else if (CalculateCoverPosition())
	{
		FindCoverEdgesAndUpdateCoverPos();

		if (pPed->GetCoverPoint()->GetCoverPointPosition(vNewCoverPos))
		{
			bFoundCoverPoint = true;
		}
	}

	if (bFoundCoverPoint)
		{
			vNewCoverPos.z = vCurrentPedPos.z;

#if DEBUG_DRAW
			ms_debugDraw.AddLine(RCC_VEC3V(vCurrentPedPos), RCC_VEC3V(vNewCoverPos), Color_green, 1000);
#endif // DEBUG_DRAW

			Vector3 vToCover = vNewCoverPos - vCurrentPedPos;
			m_fCoverToCoverDist = vToCover.XYMag();

#if DEBUG_DRAW
			vToCover.Scale(0.5f);
			Vector3 vTextPos = vCurrentPedPos + vToCover;
			char szDebugText[128];
			formatf(szDebugText, "Dist : %.4f", m_fCoverToCoverDist);
			ms_debugDraw.AddText(RCC_VEC3V(vTextPos), 0, 0, szDebugText, Color_green, 1000);
#endif // DEBUG_DRAW
		}

	m_bCoverToCoverHeadingReached = false;
	m_vInitialPedCoverToCoverPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	m_fInitialPedCoverToCoverHeading = pPed->GetCurrentHeading();
	m_fSideStartFixupPhase = -1.0f;
	m_fSideEndFixupPhase = -1.0f;
	m_bFire = false;
	m_bStoppedScalingCTCTrans = false;

	m_MoveNetworkHelper.WaitForTargetState(ms_CoverToCoverOnEnterId);
	return FSM_Continue;
}


////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::CoverToCover_OnUpdate()
{
	if (m_bStoppedScalingCTCTrans)
	{
		// Turn Physics Processing On To Keep The Ped In Cover
		SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);
	}

	CPed* pPed = GetPed();
	if (!m_MoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	static bool FORCE_ANIM = true;
	if (FORCE_ANIM)
		pPed->ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);
	else
		pPed->ForceMotionStateThisFrame(CPedMotionStates::MotionState_DoNothing);

	if (m_MoveNetworkHelper.GetBoolean(ms_CoverToCoverClipFinishedId))
	{
		SetState(State_StoppingAtEdge);
		return FSM_Continue;
	}
	else if (m_MoveNetworkHelper.GetBoolean(ms_TurnInterruptId))
	{
		if (CheckForTurn())
		{
			SetState(State_TurnEnter);
			return FSM_Continue;
		}
		else if (pPed->IsLocalPlayer())
		{
			if (static_cast<CTaskInCover*>(GetParent())->IsAimButtonHeldDown())
			{
				SetState(State_StoppingAtEdge);
				return FSM_Continue;
			}
#if FPS_MODE_SUPPORTED
			else if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
			{
				SetState(State_AtEdge);
				return FSM_Continue;
			}
#endif // FPS_MODE_SUPPORTED
		}
	}

	//try to fire (local players only for now)
	if (pPed->IsLocalPlayer())
	{
		CControl *pControl = pPed->GetControlFromPlayer();
		if (pControl->GetPedAttack().IsDown())
		{
			const crClip* pClip = m_MoveNetworkHelper.GetClip(ms_CoverToCoverClipId);
			float fireWindowStart = 1.0f; 
			float fireWindowEnd = 0.0f;
			float fClipPhase = m_MoveNetworkHelper.GetFloat(ms_CoverToCoverClipCurrentPhaseId);
			if (pClip)
			{
				CClipEventTags::FindEventStartEndPhases(pClip, CClipEventTags::Fire, fireWindowStart, fireWindowEnd);	
			}
			if (fClipPhase >= fireWindowStart && fClipPhase <= fireWindowEnd)
			{		
				m_bFire = true;
			}	
		}	
	}

#if DEBUG_DRAW
	ms_debugDraw.AddSphere(pPed->GetTransform().GetPosition(), 0.025f, Color_green, 100);
#endif
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::CoverToCover_OnExit()
{
	m_bCoverToCoverPointValid = false;

	if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		m_fHeight = 1.0f;
		m_bUseHighCoverAnims = true;
	}
	else
	{
		m_fHeight = 0.0f;
		m_bUseHighCoverAnims = false;
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::AtEdgeLowCover_OnEnter()
{
	if (GetPreviousState() != State_StoppingAtEdge)
	{
		m_MoveNetworkHelper.WaitForTargetState(ms_AtEdgeOnEnterId);
		m_MoveNetworkHelper.SendRequest(ms_StillRequestId);
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::AtEdgeLowCover_OnUpdate()
{
	ProcessUseMobilePhone();

	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);
	if (NeedsToFacePedInCorrectDirection())
		SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);

	if (!m_MoveNetworkHelper.IsInTargetState())
		return FSM_Continue;

	if (ShouldRestartStateDueToCameraSwitch(m_MoveNetworkHelper))
	{
		SetFlag(aiTaskFlags::RestartCurrentState);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}

	if (CheckForPeeking())
	{
		SetState(State_Peeking);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}

	if (CheckForTurn())
	{
		SetState(State_TurnEnter);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}

	if (GetTimeInState() >= ms_Tunables.m_EdgeLowCoverMoveTime)
	{
		if (CheckForMovingAbout())
		{
			SetState(State_Moving);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Peeking_OnEnter()
{
	static_cast<CTaskInCover*>(GetParent())->CheckForBlockedAim();

	CPed* pPed = GetPed();

	if (ms_Tunables.m_EnableCoverPeekingVariations && !pPed->IsAPlayerPed() && !NetworkInterface::IsGameInProgress())
	{
		fwMvClipSetId peekingVariationClipsetId = ChoosePeekingVariationClipSetForPed(*pPed, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint));
		
		if (peekingVariationClipsetId != CLIP_SET_ID_INVALID)
		{
			s32 iFlags = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? CTaskCover::AF_FaceLeft : 0;

			if (GetPreviousState() == State_AtEdge)
			{
				iFlags |= CTaskCover::AF_AtEdge;
			}
			else if ((iFlags & (CTaskCover::AF_Low|CTaskCover::AF_AtEdge)) == 0)
			{
				iFlags |= CTaskCover::AF_AtEdge;
			}

			const CTaskCover::CoverAnimStateInfo* pAnimStateInfo = CTaskCover::GetAnimStateInfoForState(ms_Tunables.m_PeekingVariationAnimStateInfos, iFlags);
			if (pAnimStateInfo)
			{
				for (s32 i=0; i<pAnimStateInfo->m_Clips.GetCount(); ++i)
				{	
					taskAssert(pAnimStateInfo->m_Clips[i] != CLIP_ID_INVALID);
					const crClip* pCoreClip = fwClipSetManager::GetClip(peekingVariationClipsetId, pAnimStateInfo->m_Clips[i]);
					if (taskVerifyf(pCoreClip, "NULL Clip"))
					{
						m_MoveNetworkHelper.SetClip(pCoreClip, GetCoreClipIdFromIndex(i));
					}
				}
				SetCoverFlag(CTaskCover::CF_RunningPeekVariation);
				m_bPeekVariationStarted = true;
				m_bPeekVariationFinished = false;
			}
		}
	}
	
	if (!IsCoverFlagSet(CTaskCover::CF_RunningPeekVariation))
	{
		SetClipsFromAnimStateInfo();
	}

	
	m_MoveNetworkHelper.SetFlag(true, ms_PeekingFlagId);
	m_MoveNetworkHelper.SetFlag(false, ms_IdleFlagId);
	m_MoveNetworkHelper.SetFlag(false, ms_AtEdgeFlagId);

	m_MoveNetworkHelper.WaitForTargetState(ms_PeekingOnEnterId);
	m_MoveNetworkHelper.SendRequest(ms_StillRequestId);
	
// 	if (pPed->IsAPlayerPed()) B* 814525
// 	{			
// 		m_MoveNetworkHelper.SetFlag(IsCoverFlagSet(CTaskCover::CF_AtCorner), ms_AtEdgeFlagId);
// 		m_MoveNetworkHelper.SetFlag(!IsCoverFlagSet(CTaskCover::CF_AtCorner), ms_IdleFlagId);		
// 	}
	m_bEnteredPeekState = true;

	RequestProcessMoveSignalCalls();
	m_MoveInTargetState = false;

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Peeking_OnUpdate()
{
	m_IdleVariationTimer.Tick(GetTimeStep());

	CPed* pPed = GetPed();

	// Quit if we have no cover point or are using the phone in cover and the use phone task has finished
	if (!pPed->IsNetworkClone() && !pPed->GetCoverPoint())
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	const bool bRunningPeekVariation = IsCoverFlagSet(CTaskCover::CF_RunningPeekVariation);

	ProcessUseMobilePhone();

	// Only do look IK for AI during the peek
	if(!pPed->IsAPlayerPed())
	{
		ProcessLookIK(pPed);
	}

	// Turn Physics Processing On To Keep The Ped In Cover
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);
	if (NeedsToFacePedInCorrectDirection())
		SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);

	if (!m_MoveInTargetState || GetTimeInState() == 0.0f)
		return FSM_Continue;

	if (IsCoverFlagSet(CTaskCover::CF_AtCorner) && CheckForCoverToCover())
	{
		SetState(State_CoverToCover);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	// Make ai peds who are peeking be pinned immediately
	else if (CheckForPinned(*pPed, true))
	{
		SetState(State_PinnedIntro);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (!CheckForPeeking(bRunningPeekVariation))
	{
		if (CheckForTurn(false, true, false))
		{
			SetState(State_TurnEnter);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else if (CheckForAtEdge())
		{
			SetState(State_AtEdge);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
		else
		{
			SetState(State_Idle);
			SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
			return FSM_Continue;
		}
	}
	else if (CheckForTurn(false, true, true))
	{
		SetState(State_TurnEnter);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForStepping())
	{
		SetState(State_Stepping);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (pPed->IsNetworkClone() && GetStateFromNetwork() == State_Moving)
	{
		SetState(State_Moving);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}
	else if (CheckForMovingAroundCorner())
	{
		SetState(State_EdgeTurn);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
		return FSM_Continue;
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::Peeking_OnProcessMoveSignals()
{
	const bool bRunningPeekVariation = IsCoverFlagSet(CTaskCover::CF_RunningPeekVariation);
	if (bRunningPeekVariation)
	{
		taskAssert(!GetPed()->IsAPlayerPed() && !NetworkInterface::IsGameInProgress());
		m_MoveNetworkHelper.SetBoolean(ms_LoopPeekClipId, false);	

		// Wait until we obtain the peeking finished event
		if (!m_bPeekVariationFinished && m_MoveNetworkHelper.GetBoolean(ms_PeekingClipFinishedId))
		{
			m_bPeekVariationFinished = true;
		}
	}
	else
	{
		m_MoveNetworkHelper.SetBoolean(ms_LoopPeekClipId, true);
	}

	m_MoveInTargetState = m_MoveNetworkHelper.IsInTargetState();
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Peeking_OnExit()
{
	if (!GetIsFlagSet(aiTaskFlags::InMakeAbortable))
	{
		m_MoveNetworkHelper.SetFlag(false, ms_PeekingFlagId);
	}
	ClearCoverFlag(CTaskCover::CF_RunningPeekVariation);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::PinnedIntro_OnEnter()
{
	SetVariationClip(m_PinnedClipSetId, ms_Tunables.m_PinnedIntroAnimStateInfos);
	SetCoverFlag(CTaskCover::CF_RunningPinnedVariation);
	m_MoveNetworkHelper.SetFlag(true, ms_PinnedFlagId);
	m_MoveNetworkHelper.WaitForTargetState(ms_PinnedIntroOnEnterId);

	RequestProcessMoveSignalCalls();
	m_MoveInTargetState = false;
	m_MoveClipFinished = false;

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::PinnedIntro_OnUpdate()
{
	if (!taskVerifyf(GetTimeInState() < 4.0f, "Ped 0x%p was stuck in pinned intro state for longer than 4 seconds, previous state %s", GetPed(), GetStaticStateName(GetState())))
	{
		return FSM_Quit;
	}

	if (!m_MoveInTargetState)
		return FSM_Continue;

	if(m_MoveClipFinished)
	{
		SetState(State_Pinned);
		return FSM_Continue;
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::PinnedIntro_OnProcessMoveSignals()
{
	m_MoveInTargetState = m_MoveNetworkHelper.IsInTargetState();
	if (m_MoveNetworkHelper.GetBoolean(ms_PinnedIntroClipFinishedId))
	{
		m_MoveClipFinished = true;
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Pinned_OnEnter()
{
	//Say the audio.
	if(fwRandom::GetRandomTrueFalse())
	{
		GetPed()->NewSay("PINNED_DOWN");
	}
	else
	{
		GetPed()->NewSay("NEED_SOME_HELP");
	}

	SetVariationClip(m_PinnedClipSetId, ms_Tunables.m_PinnedIdleAnimStateInfos);
	m_MoveNetworkHelper.SendRequest(ms_PinnedIdleRequestId);
	m_MoveNetworkHelper.WaitForTargetState(ms_PinnedIdleOnEnterId);
	m_StayPinnedTimer.Reset(ms_Tunables.m_MinTimeStayPinned, ms_Tunables.m_MaxTimeStayPinned);

	RequestProcessMoveSignalCalls();
	m_MoveInTargetState = false;

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::Pinned_OnUpdate()
{
	bool bIsPinned = CheckForPinned(*GetPed());
	if (bIsPinned)
	{
		m_StayPinnedTimer.Reset(ms_Tunables.m_MinTimeStayPinned, ms_Tunables.m_MaxTimeStayPinned);
	}
	else
	{
		// Stay pinned for a while
		bIsPinned = m_StayPinnedTimer.Tick(GetTimeStep()) ? false : true;
	}

	if(!m_MoveInTargetState)
		return FSM_Continue;

	//if (m_MoveNetworkHelper.GetBoolean(ms_PinnedIdleClipFinishedId))
	if (!bIsPinned)	// Let blend handle it
	{
		SetState(State_PinnedOutro);
		return FSM_Continue;
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::Pinned_OnProcessMoveSignals()
{
	// Note: in Pinned_OnUpdate(), we would only set this if bIsPinned came out as true.
	// But if it didn't, we would transition to another state anyway, so not sure that
	// it's a problem to set it to true when we are in this state?
	m_MoveNetworkHelper.SetBoolean(ms_LoopPinnedIdleId, true /*bIsPinned*/);

	m_MoveInTargetState = m_MoveNetworkHelper.IsInTargetState();
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::PinnedOutro_OnEnter()
{
	SetVariationClip(m_PinnedClipSetId, ms_Tunables.m_PinnedOutroAnimStateInfos);
	m_MoveNetworkHelper.SendRequest(ms_PinnedOutroRequestId);
	m_MoveNetworkHelper.WaitForTargetState(ms_PinnedOutroOnEnterId);

	RequestProcessMoveSignalCalls();
	m_MoveClipFinished = false;
	m_MoveInTargetState = false;

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskMotionInCover::PinnedOutro_OnUpdate()
{
	if (!m_MoveInTargetState)
		return FSM_Continue;

	if (m_MoveClipFinished)
	{
		ClearCoverFlag(CTaskCover::CF_RunningPinnedVariation);
		SetState(State_Idle);
		m_MoveNetworkHelper.SetFlag(false, ms_PinnedFlagId);
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::PinnedOutro_OnProcessMoveSignals()
{
	m_MoveInTargetState = m_MoveNetworkHelper.IsInTargetState();
	if (m_MoveNetworkHelper.GetBoolean(ms_PinnedOutroClipFinishedId))
	{
		m_MoveClipFinished = true;
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::ProcessStopping(s32 iNextState)
{
	SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);

	if (!m_MoveNetworkHelper.IsInTargetState())
		return;

	CPed* pPed = GetPed();
	Vector3 vCoverCoords(Vector3::ZeroType);
	Vector3 vTargetDirUnused;	
	CCover::FindCoverCoordinatesForPed(*pPed, vTargetDirUnused, vCoverCoords);
	vCoverCoords.z = 0.0f;

	Vector3 vPedPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	vPedPosition.z = 0.0f;

	Vector3 vToCover = vCoverCoords - vPedPosition;

	const float fDist2 = vToCover.Mag2();

	bool bIsCloseEnough = false;
	if (fDist2 < square(ms_Tunables.m_MinStoppingDist))
	{
		bIsCloseEnough = true;

		TUNE_GROUP_BOOL(COVER_TUNE, NULL_VELOCITY_WHEN_CLOSE, true);
		if (NULL_VELOCITY_WHEN_CLOSE)
		{
			NMovingGround::SetPedVelocity(pPed, Vec3V(V_ZERO));
			pPed->SetAnimatedVelocity(VEC3_ZERO);
		}
	}

	// Wait
	if (pPed->IsNetworkClone() && GetStateFromNetwork() == GetState())
	{
		return;
	}

	const float fVelSqd = pPed->GetVelocity().Mag2();
	
	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_SPEED_FOR_SKIP_STOP, 0.05f, 0.0f, 1.0f, 0.01f);
	if ((bIsCloseEnough && fVelSqd < square(MAX_SPEED_FOR_SKIP_STOP)) || GetTimeInState() > ms_Tunables.m_MaxStoppingDuration)
	{
		SetState(iNextState);
		SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::ProcessTurn(bool bLeft)
{
	SetCoverFlag(CTaskCover::CF_ShouldSlidePedIntoCover);

	if (!m_bCalculatedTurnInterruptPhase)
	{
		ComputeInterruptPhase();
	}

	const bool bClipFinished = m_MoveNetworkHelper.GetBoolean(ms_NormalTurnClipFinishedId);
	const bool bCanInterruptToMovement = m_MoveNetworkHelper.GetBoolean(ms_TurnInterruptToMovingId);
	const bool bCanInterruptToTurn = m_MoveNetworkHelper.GetBoolean(ms_TurnInterruptToTurnId);
	const bool bCanInterruptToAim = m_MoveNetworkHelper.GetBoolean(ms_TurnInterruptToAimId);
	
	if (bClipFinished || bCanInterruptToMovement || bCanInterruptToTurn || bCanInterruptToAim)
	{
		if (bLeft)
		{
			SetCoverFlag(CTaskCover::CF_FacingLeft);
		}
		else
		{
			ClearCoverFlag(CTaskCover::CF_FacingLeft);
		}

		if (bClipFinished)
		{	
			if (CheckForAtEdge())
			{
				SetState(State_StoppingAtEdge);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				return;
			}
			else
			{
				SetState(State_Idle);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				return;
			}
		}

		if (GetPed()->IsLocalPlayer())
		{
			if (bCanInterruptToTurn && CheckForTurn(true))
			{
				SetFlag(aiTaskFlags::RestartCurrentState);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				return;
			}
			else if (bCanInterruptToMovement && CheckForMovingAbout())
			{
				SetState(State_Moving);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				return;
			}
			else if (bCanInterruptToAim && GetPed()->GetPlayerInfo()->IsAiming())
			{
				SetState(State_Idle);
				SetFlag(aiTaskFlags::KeepCurrentSubtaskAcrossTransition);
				return;
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForMovingAbout() const
{
	const CPed& ped = *GetPed();

	if (ped.IsNetworkClone())
	{
		if (!m_bDoCloneTurn && GetStateFromNetwork() == State_Moving)
		{
			return true;
		}
	}
	else if (ped.IsLocalPlayer()) // Only player peds can move about cover currently
	{
		bool bCheckForMoving = true;

		if (GetState() == State_Stepping || GetState() == State_TurnEnd)
		{
			if (!m_MoveNetworkHelper.GetBoolean(ms_ToWalkId) && !GetIsHeightTransitioning())
			{
				bCheckForMoving = false;
			}
		}

		if (m_bRoundCornering)
		{
			if (!ped.GetControlFromPlayer()->GetPedJump().IsUp())		
				return false;				
		}
		return bCheckForMoving ? PlayerCheckForMovingAbout(ped, IsCoverFlagSet(CTaskCover::CF_FacingLeft), GetStickInput(), m_uTimeOfLastRoundCornerMove) : false;
	}
	//BANK_ONLY(if (CCoverDebug::ms_bEnableTaskDebugSpew) Displayf("CheckForMovingAbout FAILED in state %s",GetStateName(GetState()));)
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForTurn(bool bFromTurn, bool bCheckStickInput, bool bPeeking)
{
	CPed* pPed = GetPed();

	taskAssertf(!pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForcePedToFaceLeftInCover) || !pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForcePedToFaceRightInCover), "Ped has been forced to face both left and right, probably a script error");

	// Check for script overriding peds cover turning behaviour
	if (pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForcePedToFaceLeftInCover) && !IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		pPed->SetPedConfigFlag(CPED_CONFIG_FLAG_ForcePedToFaceLeftInCover, false);
		return true;
	}

	if (pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_ForcePedToFaceRightInCover) && IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		pPed->SetPedConfigFlag(CPED_CONFIG_FLAG_ForcePedToFaceRightInCover, false);
		return true;
	}

	if (pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_BlockPedFromTurningInCover))
	{
		return false;
	}

	if (pPed->IsNetworkClone())
	{
		if (m_bDoCloneTurn)
		{
			m_bDoCloneTurn = false;
			return true;
		}

		m_bDoCloneTurn = false;
	}
	else if (pPed->IsLocalPlayer())
	{
		Vector2 vStickInput(0.0f, 0.0f);
		if (bCheckStickInput)
		{
			vStickInput = GetStickInput();
		}
		bool bDisallowTurnUntilInputZeroed = false;
		return PlayerCheckForTurning(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), IsCoverFlagSet(CTaskCover::CF_AtCorner), bFromTurn, vStickInput, GetCameraHeadingVec(), IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), bPeeking, FPS_MODE_SUPPORTED_ONLY(bCheckStickInput ? m_bDisallowTurnUntilInputZeroed :) bDisallowTurnUntilInputZeroed);
	}
	else if (GetState() != State_Turning)	// Don't check for another turn until we've finished our initial one
	{
		if (!pPed->IsNetworkClone() && pPed->GetCoverPoint())
		{
			// Low cover or wall to neither we have both vantage points so are free to turn to get a better firing position
			bool bHasVantagePointOnOtherSide = (pPed->GetCoverPoint()->GetHeight() != CCoverPoint::COVHEIGHT_TOOHIGH) || (pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTONEITHER);

			if (!bHasVantagePointOnOtherSide)
			{
				// If we're facing the wrong way from the vantage point, then we are allowed to turn
				if ((pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTOLEFT && IsCoverFlagSet(CTaskCover::CF_FacingLeft)) ||
					(pPed->GetCoverPoint()->GetUsage() == CCoverPoint::COVUSE_WALLTORIGHT && !IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
				{
					bHasVantagePointOnOtherSide = true;
				}
			}

			if (bHasVantagePointOnOtherSide)
			{
				Vector3 vTargetPos(Vector3::ZeroType);
				const CWeaponTarget& weaponTarget = GetTarget();
				if (weaponTarget.GetIsValid() && weaponTarget.GetPositionWithFiringOffsets(pPed, vTargetPos))
				{
#if __BANK
					if(CPedDebugVisualiserMenu::ms_menuFlags.m_bDisplayCoverLineTests)
					{
						ms_debugDraw.AddLine(pPed->GetTransform().GetPosition(), RCC_VEC3V(vTargetPos), Color_red, 2000);
					}
#endif // __BANK
					return CTaskInCover::ShouldBeginFacingLeft(vTargetPos, *pPed);
				}
			}
		}
	}

	BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("CheckForTurn FAILED in state %s",GetStateName(GetState()));)
		return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForSettle() const
{
	const CPed& ped = *GetPed();

	if (ped.IsNetworkClone())
	{
		return (GetStateFromNetwork() == State_Settle || GetStateFromNetwork() == State_Idle || GetStateFromNetwork() == State_Peeking);
	}
	else
	{
		if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
		{
			if ((IsCoverFlagSet(CTaskCover::CF_FacingLeft) && m_MoveNetworkHelper.GetBoolean(ms_ToStandLSettleId)) ||
				(!IsCoverFlagSet(CTaskCover::CF_FacingLeft) && m_MoveNetworkHelper.GetBoolean(ms_ToStandRSettleId)))
			{
				return true;
			}
		}
		else
		{
			if ((IsCoverFlagSet(CTaskCover::CF_FacingLeft) && m_MoveNetworkHelper.GetBoolean(ms_ToCrouchLSettleId)) ||
				(!IsCoverFlagSet(CTaskCover::CF_FacingLeft) && m_MoveNetworkHelper.GetBoolean(ms_ToCrouchRSettleId)))
			{
				return true;
			}
		}
	}
	return false;
}


////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForIdle(bool bSearchForNewCover)
{
	CPed* pPed = GetPed();

	if (pPed->IsNetworkClone())
	{
		return (GetStateFromNetwork() != State_Moving && GetStateFromNetwork() != State_WalkStart);
	}
	else if (!pPed->IsLocalPlayer())
	{
		return true;
	}
	else
	{
		Vector2 vStickInput = GetStickInput();

		taskAssert(pPed->GetCoverPoint());

		if (!taskVerifyf(pPed->IsLocalPlayer(),"Only Player Peds should check for find cover edge!"))
		{
			// STOP!
			BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("CheckForStopping SUCCEEDED in state %s",GetStateName(GetState()));)
				return true;
		}

		CPed* pPlayerPed = pPed;

		// Work out the direction toward the cover
		Vector3 vCoverCenterPosition;
		pPlayerPed->GetCoverPoint()->GetCoverPointPosition(vCoverCenterPosition);
		//Vector3 vDirectionToTarget = vCoverCenterPosition - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());

		Vector3 vTarget(0.0f,0.0f,0.0f);

		const bool bPlayersLocalCoverpoint = pPlayerPed->GetPlayerInfo()->GetDynamicCoverPoint() == pPlayerPed->GetCoverPoint();

		if (!bPlayersLocalCoverpoint)
		{
			// STOP!
			BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("CheckForStopping SUCCEEDED in state %s",GetStateName(GetState()));)
				return true;
		}

		// Work out the desired direction to move in
		s32 iDesiredRotationalMovement = CalculateDesiredDirection(vTarget);	

		// We're at an inside corner 		
		if (GetState() == State_Moving && pPlayerPed->GetPlayerInfo()->DynamicCoverInsideCorner() && pPed->GetPlayerInfo()->GetInsideCornerDistance() <= ms_Tunables.m_InsideCornerStopDistance)
		{
			return true;
		}

		// Stop the task if no movement is requested or if the movement is in the wrong direction
		if (iDesiredRotationalMovement == 0)
		{
			BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("CheckForStopping SUCCEEDED in state %s",GetStateName(GetState()));)
				return true;
		}
		else if (!pPlayerPed->GetPlayerInfo()->IsRoundCover() && IsCoverFlagSet(CTaskCover::CF_FacingLeft) && iDesiredRotationalMovement > 0)
		{
			BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("CheckForStopping SUCCEEDED in state %s",GetStateName(GetState()));)
				return true;
		}
		else if (!pPlayerPed->GetPlayerInfo()->IsRoundCover() && !IsCoverFlagSet(CTaskCover::CF_FacingLeft) && iDesiredRotationalMovement < 0)
		{
			BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("CheckForStopping SUCCEEDED in state %s",GetStateName(GetState()));)
				return true;
		}
		else if (Abs(vStickInput.x) < CTaskInCover::ms_Tunables.m_MinStickInputToMoveInCover)
		{
			BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("CheckForStopping SUCCEEDED in state %s",GetStateName(GetState()));)
				return true;
		}

		if (!bSearchForNewCover)
		{
			BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("CheckForStopping FAILED in state %s",GetStateName(GetState()));)
				return false;
		}

	// 	if (!FindNewDynamicCoverPoint())
	// 	{
	// 		BANK_ONLY(if (CCoverDebug::ms_bEnableTaskDebugSpew) Displayf("CheckForStopping SUCCEEDED in state %s",GetStateName(GetState()));)
	// 			return true;
	// 	}

		pPlayerPed->GetCoverPoint()->ReserveCoverPointForPed(pPlayerPed);

		const bool bWantsToMoveRight = iDesiredRotationalMovement > 0;
		const bool bWantsToMoveLeft = iDesiredRotationalMovement < 0;
		const bool bCanMoveRight = pPlayerPed->GetPlayerInfo()->IsRoundCover() || pPlayerPed->GetPlayerInfo()->DynamicCoverCanMoveRight();
		const bool bCanMoveLeft = pPlayerPed->GetPlayerInfo()->IsRoundCover() || pPlayerPed->GetPlayerInfo()->DynamicCoverCanMoveLeft();
		const bool bCanMoveAboutDynamicCover = bPlayersLocalCoverpoint && 
			( /*m_bForcePedTowardsCover ||*/ (bWantsToMoveRight && bCanMoveRight) || (bWantsToMoveLeft && bCanMoveLeft ) );

		if (!bCanMoveAboutDynamicCover)
		{
			BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("CheckForStopping SUCCEEDED in state %s",GetStateName(GetState()));)
				return true;
		}

		// Find the desired heading to the cover point
		// 	static float TARGET_SCALE = 1.0f;
		// 	Vector3 vDir = pPlayerPed->GetCoverPoint()->GetLocalDirectionVector();
		// 	pPlayerPed->GetCoverPoint()->GetCoverPointPosition(vTarget);
		// 	if (IsCoverFlagSet(CF_facingLeft))
		// 	{
		// 		vDir.RotateZ(HALF_PI);
		// 		vDir.Scale(TARGET_SCALE);
		// 		vTarget += vDir;
		// 	}
		// 	else
		// 	{
		// 		vDir.RotateZ(-HALF_PI);
		// 		vDir.Scale(TARGET_SCALE);
		// 		vTarget += vDir;
		// 	}
		// 	const float fDesiredHeading = fwAngle::GetRadianAngleBetweenPoints(vTarget.x, vTarget.y, pPlayerPed->GetPosition().x, pPlayerPed->GetPosition().y);
		// 	pPlayerPed->SetDesiredHeading(fDesiredHeading);

		BANK_ONLY(if (CCoverDebug::ms_Tunables.m_EnableTaskDebugSpew) Displayf("CheckForStopping FAILED in state %s",GetStateName(GetState()));)
			return false;
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForAtEdge(bool bIgnoreEdgeCheck)
{
	CPed* pPed = GetPed();

	if (pPed->IsNetworkClone())
	{
		if (GetStateFromNetwork() == State_AtEdge || GetStateFromNetwork() == State_StoppingAtEdge)
		{
			return true;
		}
	}
	else
	{
		CCoverPoint* pCoverPoint = pPed->GetCoverPoint();
		if (pCoverPoint)
		{
			CCoverPoint::eCoverUsage usage = pCoverPoint->GetUsage();
			if (usage == CCoverPoint::COVUSE_WALLTOLEFT 
				|| usage == CCoverPoint::COVUSE_WALLTORIGHT 
				|| usage == CCoverPoint::COVUSE_WALLTONEITHER
				|| usage == CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT
				|| usage == CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT)
			{
				// Round cover
				if (pPed->IsLocalPlayer() && pPed->GetPlayerInfo()->IsRoundCover())
					return false;

				// We're at an inside corner 				
				if (pPed->IsLocalPlayer() && pPed->GetPlayerInfo()->DynamicCoverInsideCorner())
					return false;

				// If we're facing left and the cover point is a right edge, we are not 'at' the edge
				if (IsCoverFlagSet(CTaskCover::CF_FacingLeft) && (usage == CCoverPoint::COVUSE_WALLTOLEFT || usage == CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT))
					return false;

				// Similarly, if we're facing right and the cover point is a left edge
				if (!IsCoverFlagSet(CTaskCover::CF_FacingLeft) && (usage == CCoverPoint::COVUSE_WALLTORIGHT || usage == CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT))
					return false;

				// Turning to a low cover from a high one
				if (GetState() == State_Turning && !IsCoverFlagSet(CTaskCover::CF_FacingLeft) && usage == CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT)
					return true;

				if (GetState() == State_Turning && IsCoverFlagSet(CTaskCover::CF_FacingLeft) && usage == CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT)
					return true;

				if (GetPreviousState() == State_AtEdge && (usage == CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT || usage == CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT))
				{
					return false;
				}

				bool bAgainstVehicleDoor = false;
				if (pPed->IsLocalPlayer())
				{
					bAgainstVehicleDoor = CTaskCover::IsPlayerPedInCoverAgainstVehicleDoor(*pPed, *pCoverPoint);
				}

				CTaskInCover* pInCoverTask = static_cast<CTaskInCover*>(GetParent());
				if (pInCoverTask->GetPreviousState() != CTaskInCover::State_AimOutro && pInCoverTask->GetPreviousState() != CTaskInCover::State_BlindFiring 
					&& GetPreviousState() != State_Stopping && GetPreviousState() != State_Settle)
				{
					if (!bIgnoreEdgeCheck && (!HasJustEnteredCover() || bAgainstVehicleDoor))
					{
						FindCoverEdgesAndUpdateCoverPos();
					}
				}
				return true;
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForPinned(CPed& ped, bool bIgnoreMinPinned)
{
	fwMvClipSetId clipSet = CheckForPinnedAndGetClipSet(ped, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), bIgnoreMinPinned);
	if (clipSet != CLIP_SET_ID_INVALID)
	{
		m_PinnedClipSetId = clipSet;
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForIdleVariation(CPed& ped)
{
	TUNE_GROUP_BOOL(COVER_TUNE, ENABLE_PLAYER_IDLE_VARIATIONS, true);
	if (!ped.IsAPlayerPed())
	{
		if (m_IdleVariationTimer.IsFinished())
		{
			// Reset the idle variation timer so we don't just constantly check the distance to our target
			m_IdleVariationTimer.Reset(ms_Tunables.m_MinTimeBetweenIdleVariations, ms_Tunables.m_MaxTimeBetweenIdleVariations);

			// If we have a valid target then make sure we're outside of the minimum range
			const CWeaponTarget& weaponTarget = GetTarget();
			if(weaponTarget.GetIsValid())
			{
				Vector3 vTargetPosition;
				weaponTarget.GetPosition(vTargetPosition);

				ScalarV scDistSq = DistSquared(ped.GetTransform().GetPosition(), VECTOR3_TO_VEC3V(vTargetPosition));
				ScalarV scMinDistSq = ScalarVFromF32(square(ms_Tunables.m_MinDistanceToTargetForIdleVariations));
				if(IsLessThanAll(scDistSq, scMinDistSq))
				{
					return false;
				}
			}

			fwMvClipSetId clipSet = CheckForIdleVariationAndGetClipSet(ped, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint));
			if (clipSet != CLIP_SET_ID_INVALID)
			{
				m_IdleVarationClipSetId = clipSet;
				return true;
			}
		}
	}
	else if (ENABLE_PLAYER_IDLE_VARIATIONS && GetTimeInState() > ms_Tunables.m_MinWaitTimeToPlayPlayerIdleVariations)
	{
#if FPS_MODE_SUPPORTED
		if (ped.IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			return false;
		}
#endif // FPS_MODE_SUPPORTED
		if (ped.IsLocalPlayer() && CPhoneMgr::IsDisplayed())
		{
			return false;
		}
		else if (ped.GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_SWAP_WEAPON))
		{
			return false;
		}

		if (ped.GetCoverPoint() && m_IdleVariationTimer.IsFinished())
		{
			m_IdleVariationTimer.Reset(ms_Tunables.m_MinTimeBetweenPlayerIdleVariations, ms_Tunables.m_MaxTimeBetweenPlayerIdleVariations);

			fwMvClipSetId clipSet = CheckForIdleVariationAndGetClipSet(ped, IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint));
			if (clipSet != CLIP_SET_ID_INVALID)
			{
				m_IdleVarationClipSetId = clipSet;
				return true;
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskMotionInCover::CheckForPinnedAndGetClipSet(const CPed& ped, bool bIsHighCover, bool bIgnoreMinPinned)
{
	if (!ped.IsAPlayerPed() && (!NetworkInterface::IsGameInProgress() || ped.GetPedResetFlag(CPED_RESET_FLAG_CanBePinnedByFriendlyBullets)))
	{
#if __BANK
		if (ms_Tunables.m_ForcePinnedDown)
		{
			return ChoosePinnedVariationClipSetForPed(ped, bIsHighCover);
		}
#endif // __BANK

		u32 uPinnedTestThreshold = bIgnoreMinPinned ? 0 : ms_Tunables.m_PinnedDownThreshold;

		if (ped.GetPedIntelligence()->GetAmountPinnedDown() > (float)uPinnedTestThreshold)
		{
			return ChoosePinnedVariationClipSetForPed(ped, bIsHighCover);
		}
	}
	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskMotionInCover::CheckForIdleVariationAndGetClipSet(const CPed& ped, bool bIsHighCover)
{
	if (!NetworkInterface::IsGameInProgress())
	{
		// Don't do variations when pinned down - wonder if we should have pinned down player variations?
		if (ped.GetPedIntelligence()->GetAmountPinnedDown() == 0.0f)
		{
			return ChooseIdleVariationClipSetForPed(ped, bIsHighCover);
		}
	}
	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForMovingAroundCorner()
{
	// Wait until the clipset has loaded
	if (!CanUseTaskState(State_EdgeTurn))
	{
		return false;
	}

	TUNE_GROUP_BOOL(COVER_TUNE, WAIT_UNTIL_STOPPED, false);
	if (WAIT_UNTIL_STOPPED && (GetState() == State_Moving || GetState() == State_Stopping || GetState() == State_StoppingAtEdge))
	{
		return false;
	}

	taskAssert(GetState() == State_AtEdge || GetState() == State_Peeking || GetState() == State_PlayingIdleVariation || GetState() == State_Settle || GetState() == State_TurnEnd);

	CPed* pPed = GetPed();

	if (pPed->IsNetworkClone())
	{
		if (GetStateFromNetwork() == State_EdgeTurn)
		{
			return true;
		}
	}
	else if (pPed->IsLocalPlayer())
	{
		if (pPed->GetPlayerInfo()->IsRoundCover()) //no edge turns on round cover
		{
			return false;
		}

		if ( pPed->GetCoverPoint() && pPed->GetCoverPoint()->IsEdgeCoverPoint(IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
		{
			return PlayerCheckForMoveAroundCorner(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), GetStickInput(), !IsCoverPointTooHigh(), m_uTimeJumpLastPressed);
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForInsideCornerTransition()
{
	// Wait until the clipset has loaded
	if (!CanUseTaskState(State_Stepping))
	{
		return false;
	}

	taskAssert(GetState() == State_Idle || GetState() == State_PlayingIdleVariation || GetState() == State_Settle);

	CPed* pPed = GetPed();

	if (pPed->IsNetworkClone())
	{
		if (GetStateFromNetwork() == State_InsideCornerTransition)
		{
			return true;
		}
	}
	else if (pPed->IsLocalPlayer() && pPed->GetPlayerInfo()->DynamicCoverInsideCorner() && pPed->GetPlayerInfo()->GetInsideCornerDistance() <= ms_Tunables.m_InsideCornerStopDistance)
	{
		CControl* pControl = pPed->GetControlFromPlayer();
		bool bFacingLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);

		Vector2 vecStick = GetStickInput();
		if ((bFacingLeft && vecStick.x < -100.0f) || (!bFacingLeft && vecStick.x > 100.0f))
		{
			//Lock stick heading now before we change cover direction
			taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
			static_cast<CTaskInCover*>(GetParent())->SetStickHeadingLock(true);	

			if ((GetTimeInState()*1000.0f) >= (float)ms_Tunables.m_MinTimeForCornerMove && (pControl->GetPedWalkLeftRight().HistoryHeldDown(ms_Tunables.m_MinTimeForCornerMove, -1.0f, -ms_Tunables.m_MinStickInputToMoveAroundCorner) || pControl->GetPedWalkLeftRight().HistoryHeldDown(ms_Tunables.m_MinTimeForCornerMove, ms_Tunables.m_MinStickInputToMoveAroundCorner, 1.0f) ||
				pControl->GetPedWalkUpDown().HistoryHeldDown(ms_Tunables.m_MinTimeForCornerMove, -1.0f, -ms_Tunables.m_MinStickInputToMoveAroundCorner) || pControl->GetPedWalkUpDown().HistoryHeldDown(ms_Tunables.m_MinTimeForCornerMove, ms_Tunables.m_MinStickInputToMoveAroundCorner, 1.0f)))			
			{						
				CCoverPoint newCoverPoint;
				const bool bFoundNewCover = CPlayerInfo::ms_DynamicCoverHelper.FindNewCoverPointForInsideCornerTransition(&newCoverPoint, pPed,  bFacingLeft, !IsCoverPointTooHigh());
				if (bFoundNewCover)
				{
					pPed->GetPlayerInfo()->GetDynamicCoverPoint()->Copy(newCoverPoint);
					pPed->SetCoverPoint(pPed->GetPlayerInfo()->GetDynamicCoverPoint());
					pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
					return true;
				}			
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForCoverToCover()
{
	// Wait until the clipset has loaded
	if (!CanUseTaskState(State_CoverToCover))
	{
		return false;
	}

	CPed* pPed = GetPed();

	CTask* pTask = pPed->GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN);
	if (pTask)
	{
		m_bCoverToCoverPointValid = false;
		return false;
	}

	taskAssert(GetState() == State_AtEdge || GetState() == State_StoppingAtEdge || GetState() == State_Peeking || GetState() == State_PlayingIdleVariation || GetState() == State_Settle || GetState() == State_TurnEnd || (pPed->IsNetworkClone() && GetState() == State_Idle));

	if (pPed->IsNetworkClone())
	{
		if (GetStateFromNetwork() == State_CoverToCover)
		{
			Vector3 vCoverPos;
			if (GetNetCoverPointPosition(*pPed, vCoverPos))
			{
				Vector3 vPedPos = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
				Vector3 diff = vPedPos - vCoverPos;
				const float diffMag = diff.XYMag2();
				if (diffMag > square(0.25f))
				{
					return true;
				}
			}
		}
	}
	else if (pPed->IsLocalPlayer())
	{
		if (pPed->GetCoverPoint() && pPed->GetCoverPoint()->IsEdgeCoverPoint(IsCoverFlagSet(CTaskCover::CF_FacingLeft)))
		{
			if (m_bCoverToCoverPointValid)
			{
				pPed->GetPlayerInfo()->GetDynamicCoverPoint()->Copy(m_coverToCoverPoint);
				pPed->SetCoverPoint(pPed->GetPlayerInfo()->GetDynamicCoverPoint());
				pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
				return true;
			}
			else
			{
				m_bCoverToCoverPointValid = false;
			}
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForPeeking(bool bWaitForEndOfPeekVariation)
{
	if (bWaitForEndOfPeekVariation)
	{
		return !m_bPeekVariationFinished;
	}
	else if (static_cast<CTaskInCover*>(GetParent())->GetState() == CTaskInCover::State_Peeking)
	{
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForStepping() 
{
	const CPed& ped = *GetPed();

	if (ped.IsNetworkClone())
	{
		return !m_bDoCloneTurn && GetStateFromNetwork() == State_Stepping;
	}
	else if (ped.IsLocalPlayer())
	{
		if (ms_Tunables.m_UseNewStepAndWalkStarts && (m_bSteppingRequest || CheckForMovingAbout()))
		{
			if (m_bSteppingRequest)
			{
				m_bSteppingRequest = false;
				m_bSteppingRequestComplete = true;
			}
			else
				m_bSteppingRequestComplete = false;
			
			
			return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CheckForWalkStart() const
{
	const CPed& ped = *GetPed();

	if (ped.IsNetworkClone())
	{
		return !m_bDoCloneTurn && (GetStateFromNetwork() == State_WalkStart || GetStateFromNetwork() == State_Moving);
	}
	else if (ped.IsLocalPlayer() && (GetState() == State_Stepping || GetState() == State_Stopping || GetState() == State_Settle || GetState() == State_TurnEnd))
	{
		if (ms_Tunables.m_UseNewStepAndWalkStarts && CheckForMovingAbout())
		{
			return true;
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::HasJustEnteredCover() const
{
	// Don't re-search for cover edges when we first enter as this can change our cover pos slightly and cause minor sliding
	const CTaskCover* pCoverTask = static_cast<const CTaskCover*>(GetParent()->GetParent());
	if (pCoverTask->GetTimeInState() > 0.0f)
	{
		return false;
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

#if FPS_MODE_SUPPORTED
bool CTaskMotionInCover::IsIdleForFirstPerson() const
{
	switch(GetState())
	{
	case State_Start:
	case State_StreamAssets:
	case State_Idle:
	case State_Settle:
	case State_PlayingIdleVariation:
	case State_AtEdge:
	case State_EdgeTurn:
	case State_AtEdgeLowCover:
	case State_Peeking:
	case State_PinnedIntro:
	case State_PinnedOutro:
		return true;
	default:
		return false;
	}
}
#endif // FPS_MODE_SUPPORTED

bool CTaskMotionInCover::IsIdle() const
{
	switch(GetState())
	{
	case State_Start:
	case State_StreamAssets:
	case State_Idle:
	case State_Settle:
	case State_PlayingIdleVariation:
	case State_AtEdge:
	case State_Turning:
	case State_TurnEnter:
	case State_TurnEnd:
	case State_EdgeTurn:
	case State_AtEdgeLowCover:
	case State_Peeking:
	case State_PinnedIntro:
	case State_PinnedOutro:
		return true;
	default:
		return false;
	}
}

////////////////////////////////////////////////////////////////////////////////
void CTaskMotionInCover::DoCloneTurn()
{
	if (GetState() != State_Turning && GetState() != State_TurnEnter && GetState() != State_TurnEnd)
	{
		m_bDoCloneTurn = true;
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CanInterruptIdleVariation() 
{
	if (GetState()==State_PlayingIdleVariation)
	{
		const crClip* pClip = m_MoveNetworkHelper.GetClip(GetCoreClipIdFromIndex(0));
		if (pClip)
		{
			float fPhase = m_MoveNetworkHelper.GetFloat(ms_IdleVariationCurrentPhaseID);
			const crTag* pTag = CClipEventTags::FindLastEventTag(pClip, CClipEventTags::Interruptible, 0.0f, fPhase);
			if (pTag)
			{
				if (fPhase >= pTag->GetStart() && fPhase <= pTag->GetEnd())
					return true;
				return false;
			}			
		} else
			return true;
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipId CTaskMotionInCover::GetCoreClipIdFromIndex(s32 i)
{
	switch (i)
	{
		case 0: return ms_Clip0Id;
		case 1: return ms_Clip1Id;
		case 2: return ms_Clip2Id;
		case 3: return ms_Clip3Id;
		case 4: return ms_Clip4Id;
		case 5: return ms_Clip5Id;
		default: taskAssertf(0, "Unhandled Number Of Clips");
			break;
	}
	return CLIP_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipId CTaskMotionInCover::GetWeaponClipIdFromIndex(s32 i)
{
	switch (i)
	{
		case 0: return ms_WeaponClip0Id;
		case 1: return ms_WeaponClip1Id;
		case 2: return ms_WeaponClip2Id;
		case 3: return ms_WeaponClip3Id;
		default: taskAssertf(0, "Unhandled Number Of Clips");
			break;
	}
	return CLIP_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::SetClipsFromAnimStateInfo()
{
	s32 iState = GetState();
	SetClipsFromAnimStateInfo(iState);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::SetClipsFromAnimStateInfo(s32 iState)
{
	const CPed& rPed = *GetPed();
	if (rPed.IsLocalPlayer())
	{
		const bool bShouldUseFirstPersonAnims = ShouldUseFirstPersonLocoAnimations(rPed);
		m_bWasUsingFirstPersonAnims = bShouldUseFirstPersonAnims;
		m_MoveNetworkHelper.SetFlag(bShouldUseFirstPersonAnims, ms_IsFirstPersonFlagId);
		m_MoveNetworkHelper.SetClipSet(CTaskMotionInCover::ms_Tunables.GetCoreMotionClipSetIdForPed(rPed), CTaskMotionInCover::ms_CoreMotionClipSetId);
	}

	// We get the clip array for the current ai/anim state and set the clip params (named generically clip0, clip1 etc)
	// They should be in the same order they are declared in the metadata file
	const CTaskCover::CoverAnimStateInfo* pAnimStateInfo = GetAnimStateInfoForState();
	if (taskVerifyf(pAnimStateInfo, "NULL anim state info for state %s", GetStateName(iState)))
	{
		fwMvClipSetId coreMotionClipSetId = m_MoveNetworkHelper.GetClipSetId(CTaskMotionInCover::ms_CoreMotionClipSetId);
		fwMvClipSetId weaponMotionClipSetId = m_MoveNetworkHelper.GetClipSetId(CTaskMotionInCover::ms_UpperBodyWeaponMotionClipSetId);
		taskAssert(coreMotionClipSetId != CLIP_SET_ID_INVALID);

		if (DoesTaskStateRequireStreamedAnim(iState) && AreStreamedAnimsLoaded(iState))
		{
			// Use the full body base unarmed streamed set, merged with the weapon specific upperbody streamed set (if unarmed this will be invalid)
			coreMotionClipSetId = CTaskCover::ms_Tunables.GetStreamedUnarmedCoverMovementClipSetIdForPed(*GetPed());
			weaponMotionClipSetId = CTaskCover::GetStreamedClipSetForArmament(GetPed(), iState == State_CoverToCover ? true : false);
		}

		bool bUseWeaponHolding = false;
		const s32 iNumClips = pAnimStateInfo->m_Clips.GetCount();
		for (s32 i=0; i<iNumClips; ++i)
		{	
			taskAssert(pAnimStateInfo->m_Clips[i] != CLIP_ID_INVALID);
			const crClip* pCoreClip = fwClipSetManager::GetClip(coreMotionClipSetId, pAnimStateInfo->m_Clips[i]);
			if (taskVerifyf(pCoreClip, "Couldn't find clip %s in clipset %s", pAnimStateInfo->m_Clips[i].GetCStr(), coreMotionClipSetId.GetCStr()))
			{
				m_MoveNetworkHelper.SetClip(pCoreClip, GetCoreClipIdFromIndex(i));
			}

			const crClip* pWeaponClip = NULL;
			if (weaponMotionClipSetId != CLIP_SET_ID_INVALID)
			{
				pWeaponClip = fwClipSetManager::GetClip(weaponMotionClipSetId, pAnimStateInfo->m_Clips[i]);				
			}

			if (pWeaponClip)
			{
				bUseWeaponHolding = true;
				m_MoveNetworkHelper.SetClip(pWeaponClip, GetWeaponClipIdFromIndex(i));
				m_MoveNetworkHelper.SetFlag(bUseWeaponHolding, CTaskMotionInCover::ms_UseWeaponHoldingId);			
			}
		}		

		if (!bUseWeaponHolding)
			SetGripClip(GetPed(), m_MoveNetworkHelper);
		else
		{
			m_MoveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_UseGripClipId);
			const fwMvFilterId weaponHoldingFilterId = ms_Tunables.GetWeaponHoldingFilterIdForPed(*GetPed());
			if (weaponHoldingFilterId != FILTER_ID_INVALID)
			{
				crFrameFilter* pWeaponHoldingFrameFilter = g_FrameFilterDictionaryStore.FindFrameFilter(weaponHoldingFilterId);
				m_MoveNetworkHelper.SetFilter(pWeaponHoldingFrameFilter, ms_WeaponHoldingFilterId);		
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::SetVariationClip(fwMvClipSetId clipSetId, const atArray<CTaskCover::CoverAnimStateInfo>& clipArray)
{
	if (taskVerifyf(clipSetId != CLIP_SET_ID_INVALID, "Invalid clipset"))
	{
		s32 iFlags = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? CTaskCover::AF_FaceLeft : 0;

		const CTaskCover::CoverAnimStateInfo* pAnimStateInfo = CTaskCover::GetAnimStateInfoForState(clipArray, iFlags);
		if (pAnimStateInfo)
		{
			for (s32 i=0; i<pAnimStateInfo->m_Clips.GetCount(); ++i)
			{	
				taskAssert(pAnimStateInfo->m_Clips[i] != CLIP_ID_INVALID);
				const crClip* pCoreClip = fwClipSetManager::GetClip(clipSetId, pAnimStateInfo->m_Clips[i]);
				if (taskVerifyf(pCoreClip, "NULL Clip"))
				{
					m_MoveNetworkHelper.SetClip(pCoreClip, GetCoreClipIdFromIndex(i));
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::IsPedsheadingCloseEnoughToFacingDirection(const CPed& ped, const Vector3& vCoverDirection, bool bIsFacingLeft, float fCustomTolerance)
{
	float fFacingDirection = rage::Atan2f(-vCoverDirection.x, vCoverDirection.y);
	fFacingDirection += bIsFacingLeft ? HALF_PI : -HALF_PI;
	fFacingDirection = fwAngle::LimitRadianAngle(fFacingDirection);
	float fHeadingDiff = fwAngle::LimitRadianAngle(fFacingDirection - ped.GetCurrentHeading());

	const float fTolerance = fCustomTolerance > 0.0f ? fCustomTolerance : ms_Tunables.m_CoverHeadingCloseEnough;

	if (Abs(fHeadingDiff) < fTolerance)
	{
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::IsPedCloseEnoughToCover(const CPed& ped, const Vector3& vCoverPosition, float fCustomTolerance)
{
	const Vector3 vPedPos = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
	const float fDistanceTolerance = fCustomTolerance > 0.0f ? fCustomTolerance : ms_Tunables.m_CoverPositionCloseEnough;
	if ((vPedPos - vCoverPosition).XYMag2() <= rage::square(fDistanceTolerance))
	{
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

const CTaskCover::CoverAnimStateInfo* CTaskMotionInCover::GetAnimStateInfoForState()
{
	s32 iFlags = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? CTaskCover::AF_FaceLeft : 0;
	s32 iState = GetState();
	CPed& rPed = *GetPed();

 	if (iState == State_Moving)
 		return CTaskCover::GetAnimStateInfoForState(ms_Tunables.GetMovingAnimStateInfoForPed(rPed), iFlags);

	if (iState == State_Idle)
		return CTaskCover::GetAnimStateInfoForState(ms_Tunables.GetIdleAnimStateInfoForPed(rPed), iFlags);

	if (iState == State_StoppingAtEdge || iState == State_StoppingAtInsideEdge)
	{
		if (ms_Tunables.m_EnableWalkStops && (GetPreviousState() == State_Moving || GetPreviousState() == State_WalkStart) && CanUseTaskState(State_Stopping))
		{
			iState = State_Stopping;
		}
		else
		{
			iState = State_AtEdge;
			iFlags |= CTaskCover::AF_AtEdge;
		}
	}

	if (iState == State_Stopping)
	{
		m_bUsingWalkStop = true;
	}
	else
	{
		m_bUsingWalkStop = false;
	}

	if (iState == State_AtEdge)
	{
		iFlags |= CTaskCover::AF_AtEdge;
		return CTaskCover::GetAnimStateInfoForState(ms_Tunables.GetAtEdgeAnimStateInfoForPed(rPed), iFlags);	
	}

	if (!m_bUseHighCoverAnims)
		iFlags |= CTaskCover::AF_Low;

	if (iState == State_Peeking) 
	{
		if (rPed.IsAPlayerPed())
		{		
			if (IsCoverFlagSet(CTaskCover::CF_AtCorner))
			{
				if (!rPed.IsNetworkClone())
				{
					//iState = State_AtEdge;//players peek with B* 814525
					if (!rPed.IsLocalPlayer() ||  GetStickInput().y < 100.0f || (iFlags&CTaskCover::AF_Low) == 0)
						iFlags |= CTaskCover::AF_AtEdge;
				}
				else if (m_bUseHighCoverAnims)
				{
					iFlags |= CTaskCover::AF_AtEdge;
				}
			}
		}
		// Workarounds, this code should really be removed
		if ((iFlags & (CTaskCover::AF_Low|CTaskCover::AF_AtEdge)) == 0)
			iFlags |= CTaskCover::AF_AtEdge; //sometimes AI (and the rare player) try to do this in high cover while not at an edge, so need an animation B* 932643
		if (iFlags & CTaskCover::AF_Low && iFlags & CTaskCover::AF_AtEdge)
			iFlags &= ~CTaskCover::AF_AtEdge;
	}

	if (GetState() == State_CoverToCover)
	{
		if (rPed.GetCoverPoint())
		{
		if (rPed.GetCoverPoint()->GetHeight() == CCoverPoint::COVHEIGHT_TOOHIGH)
		{
			SetCoverFlag(CTaskCover::CF_TooHighCoverPoint);
		}
		else
		{
			ClearCoverFlag(CTaskCover::CF_TooHighCoverPoint);
		}
		}

		if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
		{
			iFlags |= CTaskCover::AF_ToLow;
		}

		Vector3 vCoverDirection;
		Vector3 vTargetDirUnused;
		if (rPed.IsNetworkClone() && CCover::FindCoverDirectionForPed(*GetPed(), vCoverDirection, vTargetDirUnused))
		{
			// Choose the closest heading to face the ped in cover
			float fPedHeading = rage::Atan2f(-vCoverDirection.x, vCoverDirection.y);
			const float fLeftCoverHeading = fPedHeading + HALF_PI;
			const float fRightCoverHeading = fPedHeading - HALF_PI;
			const float fLeftHeadingDelta = fwAngle::LimitRadianAngle(GetPed()->GetCurrentHeading() - fLeftCoverHeading);
			const float fRightHeadingDelta = fwAngle::LimitRadianAngle(GetPed()->GetCurrentHeading() - fRightCoverHeading);
			if (Abs(fLeftHeadingDelta) < Abs(fRightHeadingDelta))
			{
				iFlags |= CTaskCover::AF_FaceLeft;
			}
			else
			{
				iFlags &= ~CTaskCover::AF_FaceLeft;
			}
		}
	}

#if FPS_MODE_SUPPORTED
	// Only want to do this when unarmed (or using a melee weapon) as we go into an aiming state when the camera is pointing
	// away from the cover direction while holding a weapon that can fire
	bool bCanWeaponFire = false;
	CWeapon* pEquippedWeapon = rPed.GetWeaponManager() ? rPed.GetWeaponManager()->GetEquippedWeapon() : NULL;
	if (pEquippedWeapon)
	{
		const CWeaponInfo* pObjectWeaponInfo = rPed.GetWeaponManager()->GetEquippedWeaponInfoFromObject(); //verify object in hand is in synch (or non-existant)) B* 1500172
		bCanWeaponFire = (pEquippedWeapon->GetWeaponInfo()->GetIsGunOrCanBeFiredLikeGun() || pEquippedWeapon->GetWeaponInfo()->GetCanBeAimedLikeGunWithoutFiring()) && (!pObjectWeaponInfo || pObjectWeaponInfo == pEquippedWeapon->GetWeaponInfo());
	}
	if (!bCanWeaponFire && CTaskMotionInCover::ShouldUseFirstPersonLocoAnimations(rPed))
	{
		// Play normal turn when cam facing away from cover
		if (GetState() == State_TurnEnter || GetState() == State_TurnEnd)
		{
			const Vector3 vCamFront = camInterface::GetGameplayDirector().GetFrame().GetFront();
			const Vector3 vCoverDirection = static_cast<CTaskInCover*>(GetParent())->GetCoverDirection();
			const float fCamCovDot = vCamFront.Dot(vCoverDirection);
			if (fCamCovDot < 0.0f)
			{
				iFlags |= CTaskCover::AF_AimDirect;
			}
		}
	}
#endif // FPS_MODE_SUPPORTED

	const atArray<CTaskCover::CoverAnimStateInfo>* aMotionInCoverAnimStateInfos;

	switch (iState)
	{
		case State_Peeking:
			aMotionInCoverAnimStateInfos = &ms_Tunables.GetPeekingAnimStateInfoForPed(rPed);
			break;
		case State_Moving:
			aMotionInCoverAnimStateInfos = &ms_Tunables.GetMovingAnimStateInfoForPed(rPed);
			break;
		case State_Stopping:
			aMotionInCoverAnimStateInfos = &ms_Tunables.GetStoppingAnimStateInfoForPed(rPed);
			break;
		case State_CoverToCover:
			aMotionInCoverAnimStateInfos = &ms_Tunables.GetCoverToCoverAnimStateInfoForPed(rPed);
			break;
		case State_EdgeTurn:
			aMotionInCoverAnimStateInfos = &ms_Tunables.GetEdgeTurnAnimStateInfoForPed(rPed);
			break;
		case State_InsideCornerTransition:
		case State_Stepping:
			aMotionInCoverAnimStateInfos = &ms_Tunables.GetSteppingAnimStateInfoForPed(rPed);
			break;
		case State_WalkStart:
			{
				if (ms_Tunables.m_UseNewTurnWalkStarts && GetPreviousState() == State_TurnEnd)
				{
					aMotionInCoverAnimStateInfos = &ms_Tunables.GetTurnWalkStartAnimStateInfoForPed(rPed);
				}
				else
				{
					aMotionInCoverAnimStateInfos = &ms_Tunables.GetWalkStartAnimStateInfoForPed(rPed);
				}
			}
			break;
		case State_Settle:
			aMotionInCoverAnimStateInfos = &ms_Tunables.GetSettleAnimStateInfoForPed(rPed);
			break;
		case State_TurnEnter:
			aMotionInCoverAnimStateInfos = &ms_Tunables.GetTurnEnterAnimStateInfoForPed(rPed);
			break;
		case State_TurnEnd:
			aMotionInCoverAnimStateInfos = &ms_Tunables.GetTurnEndAnimStateInfoForPed(rPed);
			break;
		default:
			{
				taskAssertf(0,"Couldn't Find Anim State Info For State %s", GetStateName(iState));
				return NULL;
			}
	}

	return CTaskCover::GetAnimStateInfoForState(*aMotionInCoverAnimStateInfos, iFlags);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::SetCoverToCoverPoint(const CCoverPoint& newCoverPoint)
{
	m_coverToCoverPoint.Copy(newCoverPoint);
	m_bCoverToCoverPointValid = true;
}

////////////////////////////////////////////////////////////////////////////////

// bool CTaskMotionInCover::IsFlagValidForState(s32 iFlag)
// {
// 	if (iFlag == CTaskCover::AF_AtEdge)
// 	{
// 		switch (GetState())
// 		{
// 			case State_Turning:
// 				return false;
// 			case State_StoppingAtEdge:
// 
// 		}
// 	}
// }

////////////////////////////////////////////////////////////////////////////////

s32 CTaskMotionInCover::CalculateDesiredDirection(const Vector3& vTargetPos)
{
	CPed* pPed = GetPed();

	if (pPed->IsPlayer() /*&& !m_bForcePedTowardsCover*/ && pPed->GetCoverPoint() )
	{
		Vector3 vToTarget = vTargetPos - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		vToTarget.z = 0.0f;
		vToTarget.Normalize();
		Vector3 vCoverHeading = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector(&RCC_VEC3V(vToTarget)));
		CControl *pControl = pPed->GetControlFromPlayer();
		Vector2 vecStick(pControl->GetPedWalkLeftRight().GetNorm() * 127.0f, -pControl->GetPedWalkUpDown().GetNorm() * 127.0f);
		taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
		vecStick.Rotate(camInterface::GetGameplayDirector().GetFrame().ComputeHeading());				
		vecStick.Rotate(-rage::Atan2f(-vCoverHeading.x, vCoverHeading.y));		
		if( vecStick.x > MIN_STICK_INPUT_TO_MOVE_IN_COVER )
			return 1;
		else if( vecStick.x < -MIN_STICK_INPUT_TO_MOVE_IN_COVER )
			return -1;
	}
	return 0;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::SetCoverFlag(s32 iFlag)
{
	taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
	return static_cast<CTaskInCover*>(GetParent())->SetCoverFlag(iFlag);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::ClearCoverFlag(s32 iFlag)
{
	taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
	return static_cast<CTaskInCover*>(GetParent())->ClearCoverFlag(iFlag);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::IsCoverFlagSet(s32 iFlag) const
{
	taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
	return static_cast<const CTaskInCover*>(GetParent())->IsCoverFlagSet(iFlag);
}

////////////////////////////////////////////////////////////////////////////////

Vector3 CTaskMotionInCover::GetCoverCoords() const
{
	taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
	return static_cast<const CTaskInCover*>(GetParent())->GetCoverCoords();
}

////////////////////////////////////////////////////////////////////////////////

Vector3 CTaskMotionInCover::GetCoverDirection() const
{
	taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
	return static_cast<const CTaskInCover*>(GetParent())->GetCoverDirection();
}

////////////////////////////////////////////////////////////////////////////////

Vector2 CTaskMotionInCover::GetStickInput() const
{
	taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
	return static_cast<const CTaskInCover*>(GetParent())->GetStickInput();
}

////////////////////////////////////////////////////////////////////////////////

Vector3 CTaskMotionInCover::GetCameraHeadingVec() const
{
	taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
	return static_cast<const CTaskInCover*>(GetParent())->GetCameraHeadingVec();
}

////////////////////////////////////////////////////////////////////////////////

const CWeaponTarget& CTaskMotionInCover::GetTarget() const
{
	taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
	return static_cast<const CTaskInCover*>(GetParent())->GetTarget();
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::IsCoverPointTooHigh() const
{
	taskAssert(GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER);
	return static_cast<const CTaskInCover*>(GetParent())->IsCoverPointTooHigh();
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::FindNewDynamicCoverPoint(CPed* pPed, float fProbeOffset, bool bIsFacingLeft, bool bMovedAroundCorner, bool bIdle, bool bUseFacingDirection, bool bFromIdleTurn)
{
	if (!taskVerifyf(pPed && pPed->IsAPlayerPed() && !pPed->IsNetworkClone(),"Dynamic cover only available for local player"))
		return false;

	// Update dynamic cover point
	Vector3 vTestPos = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());

	// Use the collision capsule because it isn't affected by leg ik
	if (pPed->GetCurrentPhysicsInst())
		vTestPos.z = pPed->GetCurrentPhysicsInst()->GetMatrix().GetM23f(); // AI_NEW_VEC_LIB

	Vector3 vOffsetDirection = VEC3V_TO_VECTOR3(pPed->GetTransform().GetB());
	if (bUseFacingDirection && pPed->GetCoverPoint())
	{
		vOffsetDirection = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector());
		vOffsetDirection.RotateZ(bIsFacingLeft ? HALF_PI : -HALF_PI);
	}

	vTestPos += vOffsetDirection* fProbeOffset;

	// grcDebugDraw::Sphere(vTestPos, 0.025f, Color_blue);
	float fOverrideDirection = -999.0f;
	if (bMovedAroundCorner)
	{
		fOverrideDirection = fwAngle::LimitRadianAngle(pPed->GetCurrentHeading());
		fOverrideDirection += bIsFacingLeft ? -HALF_PI : HALF_PI;	// Want to look for cover perpendicular to facing direction
		fOverrideDirection = fwAngle::LimitRadianAngle(fOverrideDirection);
	}

	taskAssert(pPed->GetCoverPoint());
	CCoverPoint newCoverPoint;
	const bool bFoundNewCover = CPlayerInfo::ms_DynamicCoverHelper.UpdateCoverPoint(pPed->GetCoverPoint(), &newCoverPoint, pPed, vTestPos, bIdle, bIsFacingLeft, bFromIdleTurn);	
	if (bFoundNewCover)
	{
		pPed->GetPlayerInfo()->GetDynamicCoverPoint()->Copy(newCoverPoint);
		pPed->SetCoverPoint(pPed->GetPlayerInfo()->GetDynamicCoverPoint());
		pPed->GetCoverPoint()->ReserveCoverPointForPed(pPed);
	}
	return bFoundNewCover;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::ProcessStoppingPhysics(float fTimeStep)
{
#if __DEV
	TUNE_GROUP_BOOL(COVER_TUNE, DISABLE_STOPPING_PHYSICS, false);
	if (DISABLE_STOPPING_PHYSICS)
	{
		return true;
	}
#endif // __DEV


	CPed* pPed = GetPed();

	// Quit out if we can't get the cover position for some reason
	Vector3 vDirUnused;
	Vector3 vCoverCoords(Vector3::ZeroType);
	if (!CCover::FindCoverCoordinatesForPed(*pPed, vDirUnused, vCoverCoords))
		return false;

	vCoverCoords.z = 0.0f;

	Vector3 vPedPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	vPedPosition.z = 0.0f;

	Vector3 vToCover = vCoverCoords - vPedPosition;

	const float fDist = vToCover.Mag();
	//Displayf("Dist to cover point: %.2f", fDist);

	vToCover.Normalize();

	const bool bStopping = GetState() == State_StoppingAtEdge || GetState() == State_StoppingAtInsideEdge || GetState() == State_TurnEnd;
	Vector3 vDesiredVelocity = vToCover;
	if (m_fInitialAnimatedSpeed < 0.0f && !bStopping)
	{
		const Vector3& vPedAnimatedVelocity = pPed->GetAnimatedVelocity();

		m_fInitialAnimatedSpeed = vPedAnimatedVelocity.XYMag();
		vDesiredVelocity.Scale(MIN(m_fInitialAnimatedSpeed, fDist/fTimeStep));
		m_vInitialPedStoppingPosition = vPedPosition + vDesiredVelocity * fTimeStep;
		m_fInitialAnimatedSpeed = 0.0f;

		// Account for any vertical velocity due to slopes
		vDesiredVelocity.z = vPedAnimatedVelocity.z;
	}
	else
	{
		const Vector3 vPedDesiredVelocity = VEC3V_TO_VECTOR3(NMovingGround::GetPedDesiredVelocity(pPed));
		const float fDesiredSpeedXY = vPedDesiredVelocity.XYMag();

		if (bStopping)
		{
			TUNE_GROUP_FLOAT(COVER_TUNE, MIN_STOPPING_VEL, 1.5f, 0.0f, 10.0f, 0.01f);
			vDesiredVelocity.Scale(Max(fDesiredSpeedXY, MIN_STOPPING_VEL));
		}
		else
		{
			const float fDesiredSpeedThisTimestep = GetState() == State_Stepping ? CTaskInCover::ms_Tunables.m_SteppingMovementSpeed : CTaskInCover::ms_Tunables.m_InCoverMovementSpeed;
			if (GetState() == State_Stepping)
				vDesiredVelocity.Scale(MIN( fDesiredSpeedXY, MIN(fDesiredSpeedThisTimestep, fDist/fTimeStep)));
			else
				vDesiredVelocity.Scale(MIN(fDesiredSpeedThisTimestep, fDist/fTimeStep));
		}

		Vector3 vNewPedPos = vPedPosition + vDesiredVelocity * fTimeStep;
		Vector3 vNewToCover = vCoverCoords - vNewPedPos;
		vNewToCover.Normalize();

		if (vToCover.Dot(vNewToCover) < 0.0f)
		{	
			vDesiredVelocity = vToCover;
			float fSpeed = fDist/fTimeStep;
			TUNE_GROUP_FLOAT(COVER_TUNE, MAX_STOPPING_VELOCITY, 5.0f, 0.0f, 10.0f, 0.01f);
			fSpeed = Clamp(fSpeed, 0.0f, MAX_STOPPING_VELOCITY);
			vDesiredVelocity.Scale(fSpeed);
			aiDebugf1("Frame : %i, Overshot cover target", fwTimer::GetFrameCount());
		}

		// Account for any vertical velocity due to slopes
		vDesiredVelocity.z = vPedDesiredVelocity.z;
	}

	NMovingGround::SetPedDesiredVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredVelocity));
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::ProcessCoverToCoverPhysics(float fTimeStep)
{
	CPed* pPed = GetPed();

	// Quit out if we can't get the cover position/direction for some reason
	Vector3 vDirUnused;
	Vector3 vCoverPos(Vector3::ZeroType);
	Vector3 vCoverDir(Vector3::ZeroType);
	const bool bFoundCoverCoords = CCover::FindCoverCoordinatesForPed(*pPed, vDirUnused, vCoverPos);
	const bool bFoundCoverDir = CCover::FindCoverDirectionForPed(*pPed, vCoverDir, vDirUnused);
	if (!bFoundCoverCoords && !bFoundCoverDir)
		return false;
	
	// Wait until our animation has started to play before adjusting the velocity
	const crClip* pClip = m_MoveNetworkHelper.GetClip(ms_CoverToCoverClipId);

	// Cache the current phase of the anim
	const float fAnimPhase = rage::Clamp(m_MoveNetworkHelper.GetFloat(ms_CoverToCoverClipCurrentPhaseId), 0.0f, 1.0f);

	// When starting a cover to cover immediately after one has finished, we get a frame of the old clip and phase
	// prevent scaling in this case
	if (!pClip || fAnimPhase == 1.0f)
	{
		NMovingGround::SetPedDesiredVelocity(pPed, Vec3V(V_ZERO));
		NMovingGround::SetPedVelocity(pPed, Vec3V(V_ZERO));
		NMovingGround::SetPedDesiredAngularVelocity(pPed, Vec3V(V_ZERO));
		NMovingGround::SetPedAngVelocity(pPed, Vec3V(V_ZERO));
		return true;
	}

	// Scale translational velocity coming from the anim to get to the cover position
	if (!ms_Tunables.m_DisableCoverToCoverTranslationScaling && !m_bStoppedScalingCTCTrans)
		ScaleTranslationalVelocity(*pClip, fAnimPhase, vCoverPos, vCoverDir, fTimeStep);

	// Compute facing direction	
	const float fFacingHeading = ComputeDesiredPedHeadingFromCoverDirection(IsCoverFlagSet(CTaskCover::CF_FacingLeft), vCoverDir);

	// Scale rotational velocity coming from the anim to get to the facing heading
	if (!ms_Tunables.m_DisableCoverToCoverRotationScaling && !pPed->IsNetworkClone())
		ScaleRotationalVelocity(*pClip, fAnimPhase, fFacingHeading, fTimeStep);
	
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::ProcessTurningPhysics(float fTimeStep)
{
#if __DEV
	TUNE_GROUP_BOOL(COVER_TUNE, DISABLE_TURN_OVERSHOOT_PREVENTION, false);
	if (DISABLE_TURN_OVERSHOOT_PREVENTION)
	{
		return true;
	}
#endif // __DEV

	CPed* pPed = GetPed();
	// Quit out if we can't get the cover position/direction for some reason
	Vector3 vDirUnused;
	Vector3 vCoverDir(Vector3::ZeroType);
	if (!CCover::FindCoverDirectionForPed(*pPed, vCoverDir, vDirUnused))
		return false;

	float fCoverHeading = fwAngle::LimitRadianAngle(rage::Atan2f(-vCoverDir.x, vCoverDir.y));
	if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		fCoverHeading += HALF_PI;
	}
	else 
	{
		fCoverHeading -= HALF_PI;
	}
	fCoverHeading = fwAngle::LimitRadianAngle(fCoverHeading);
	const float fCurrentHeading =  pPed->GetMotionData()->GetCurrentHeading();
	const float fCurrentDeltaHeading = fwAngle::LimitRadianAngle(fCurrentHeading - fCoverHeading);
	Vector3 vDesiredAngVelocity = pPed->GetDesiredAngularVelocity();
	const float fAnimatedAngularVelocity = vDesiredAngVelocity.z;
	const float fNewHeading = fCurrentHeading + fAnimatedAngularVelocity * fTimeStep;
	const float fPredictedDeltaHeading = fwAngle::LimitRadianAngle(fNewHeading - fCoverHeading);
	if (Sign(fCurrentDeltaHeading) != Sign(fPredictedDeltaHeading))
	{
		vDesiredAngVelocity.z = 0.0f;
		NMovingGround::SetPedDesiredAngularVelocity(pPed, RCC_VEC3V(vDesiredAngVelocity));
		pPed->SetHeading(fCoverHeading);
#if __BANK
		aiDebugf2("Frame %i, Ped %s (%p) Detected over rotation on turn anim, setting heading", fwTimer::GetFrameCount(), pPed->GetDebugName(), pPed);
#endif // __BANK
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::ScaleTranslationalVelocity(const crClip& clip, float fAnimPhase, const Vector3& vCoverPos, const Vector3& vCoverDir, float fTimeStep)
{
	// We scale the translational velocity along and perpendicular to the original facing direction separately to try to
	// avoid catching the mover on edges

	CPed* pPed = GetPed();

	float fTransYFixupStartPhase = 0.0f;
	float fTransYFixupEndPhase = 0.8f;

	taskVerifyf(CClipEventTags::FindMoverFixUpStartEndPhases(&clip, fTransYFixupStartPhase, fTransYFixupEndPhase, true, CClipEventTags::CMoverFixupEventTag::eYAxis), "Clip missing translation Y fixup event");

	bool bSkipForwardsFixup = false;
	if (fAnimPhase < fTransYFixupStartPhase)
	{
		 bSkipForwardsFixup = true;
	}

	Vector3 vDesired = VEC3V_TO_VECTOR3(NMovingGround::GetPedDesiredVelocity(pPed));

	const Vector3 vPedPosition = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	Vector3 vToCover = vCoverPos - vPedPosition;

	const float fDistToCover = vToCover.XYMag();
	// Since we're using the same signal names for each cover to cover anim
	// it is possible to trigger it when the last anims signals are in the output buffer
	// The last condition prevents us from effectively warping to the cover point in this case.
// 	if (fAnimPhase >= fTransYFixupEndPhase && fDistToCover >= ms_Tunables.m_CoverToCoverDistTol)
// 	{
// 		Vector3 vDesired = vToCover;
// 		vDesired.z = 0.0f;
// 		vDesired.Normalize();
// 		const float fDistThisTimeStep = rage::Clamp(fDistToCover, 0.0f, ms_Tunables.m_CoverToCoverMaxDistToStep);
// 		vDesired.Scale(fDistThisTimeStep / fTimeStep);
// 		NMovingGround::SetPedDesiredVelocityClamped(pPed, VECTOR3_TO_VEC3V(vDesired), ms_Tunables.m_CoverToCoverMaxAccel);
// 		return;
// 	}

	const float fDepth = CTaskInCover::GetXYDot(vCoverDir, vToCover);
	//Displayf("Depth: %.4f", fDepth);
	 
	Vector3 vSideToCover = fDepth * vCoverDir;

	Vector3 vPedCoverForward(0.0f,1.0f,0.0f);
	vPedCoverForward.RotateZ(m_fInitialPedCoverToCoverHeading);
			
	const float fForward = CTaskInCover::GetXYDot(vPedCoverForward, vToCover);
	//Displayf("Forward: %.4f", fForward);
	
	Vector3 vForwardToCover = fForward * vPedCoverForward;
	vSideToCover.z = 0.0f;
	vForwardToCover.z = 0.0f;

#if DEBUG_DRAW
	Vector3 vDebugPos1 = vPedPosition;
	vDebugPos1.z += 1.0f;
	Vector3 vDebugPos2 = vDebugPos1 + vPedCoverForward;
	static u32 CTC_FORWARD_DIR_HASH = ATSTRINGHASH("CTC_FORWARD_DIR_HASH", 0xFE2E8487);
	static u32 CTC_SIDE_DIR_HASH = ATSTRINGHASH("CTC_FORWARD_DIR_HASH", 0xFE2E8487);
	ms_debugDraw.AddArrow(RCC_VEC3V(vDebugPos1), RCC_VEC3V(vDebugPos2), 0.1f, Color_blue, 1000, CTC_FORWARD_DIR_HASH);
	Vector3 vDebugPos3 = vPedPosition;
	vDebugPos3.z += 1.0f;
	Vector3 vDebugPos4 = vDebugPos3 + vSideToCover;
	ms_debugDraw.AddArrow(RCC_VEC3V(vDebugPos3), RCC_VEC3V(vDebugPos4), 0.1f, Color_orange, 1000, CTC_SIDE_DIR_HASH);
#endif

	float fDesiredForwardSpeed = vDesired.Mag();

	// Get the remaining translation change left in the clip
	Vector3 vClipTotalDist = fwAnimHelpers::GetMoverTrackTranslationDiff(clip, fAnimPhase, 1.f);
	const float fRemainingAnimDist = vClipTotalDist.Mag();
	//Displayf("Remaining Anim Dist : %.4f", fRemainingAnimDist);

	if (bSkipForwardsFixup || ComputeDesiredSpeedAlongVector(fDesiredForwardSpeed, Abs(fForward), fRemainingAnimDist, fAnimPhase, fTransYFixupStartPhase, 1.0f, clip.GetDuration(), fTimeStep, true))
	{
		//const float fRemainingTransAnimTime = (1.0f - fAnimPhase) * clip.GetDuration() / ms_Tunables.m_CoverToCoverClipRate;
// 		const float fDiffDist = Abs(fRemainingAnimDist - fDistToCover);
// 		if (fAnimPhase >= fTransYFixupEndPhase && fDiffDist >= ms_Tunables.m_CoverToCoverDistTol)
// 		{
// 			fDesiredForwardSpeed = fForward + (Min(fDiffDist, ms_Tunables.m_CoverToCoverMaxDistToStep) / fTimeStep);
// 		}

		fDesiredForwardSpeed *= Sign(fForward);
	}
	else
	{
		if (fAnimPhase >= fTransYFixupEndPhase && fDistToCover >= ms_Tunables.m_CoverToCoverDistTol && fDistToCover <= ms_Tunables.m_CoverToCoverMaxDistToStep)
		{
			Vector3 vDesired = vToCover;
			vDesired.z = 0.0f;
			vToCover.Normalize();
			vDesired.Scale(fDistToCover / fTimeStep);
			NMovingGround::SetPedDesiredVelocity(pPed, VECTOR3_TO_VEC3V(vDesired));
		}
		else
		{
			m_bStoppedScalingCTCTrans = true;
		}
		return;
	}

	float fDesiredSideSpeed = 0.0f;

	float fTransXFixupStartPhase = 0.0f;
	float fTransXFixupEndPhase = 1.0f;

	taskVerifyf(CClipEventTags::FindMoverFixUpStartEndPhases(&clip, fTransXFixupStartPhase, fTransXFixupEndPhase, true, CClipEventTags::CMoverFixupEventTag::eXAxis), "Clip missing translation X fixup event");

	if (Abs(fDepth) >= ms_Tunables.m_CoverToCoverMinDepthToScale)
	{
		Vector3 vOriginalForward(0.0f,1.0f,0.0f);
		vOriginalForward.RotateZ(m_fInitialPedCoverToCoverHeading);
		//Vector3 vFromOriginalPos = vPedPosition - m_vInitialPedCoverToCoverPosition;

		//const float fCurrentForward = CTaskInCover::GetXYDot(vOriginalForward, vFromOriginalPos);
		//Displayf("Current Forward : %.4f", fCurrentForward);
		if (fAnimPhase >= fTransXFixupStartPhase && fAnimPhase <= fTransXFixupEndPhase)
		{
			ComputeDesiredSpeedAlongVector(fDesiredSideSpeed, Abs(fDepth), 0.0f, fAnimPhase, fTransXFixupStartPhase, fTransXFixupEndPhase, clip.GetDuration(), fTimeStep);
		}
	}

	vSideToCover.Normalize();
	vForwardToCover.Normalize();
	
	//Displayf("Forward speed : %.4f", fDesiredForwardSpeed);
	//Displayf("Side speed : %.4f", fDesiredSideSpeed);
	Vector3 vDesiredVelocity = vSideToCover*fDesiredSideSpeed + vForwardToCover * fDesiredForwardSpeed;
	vDesiredVelocity.z = 0.0f;

	Vector3 vOldToTarget = vCoverPos - m_vInitialPedCoverToCoverPosition;
	vOldToTarget.z = 0.0f;

	Vector3 vNewPos = vPedPosition + vDesiredVelocity*fTimeStep;
	Vector3 vNewToCover = vCoverPos - vNewPos;

	// If the new to target is opposite from the initial we must have overshot the target position,
	// so scale it to go to the cover position
	if (vNewToCover.Dot(vOldToTarget) < 0.0f)
	{
		vDesiredVelocity = vToCover;
		vDesiredVelocity.z = 0.0f;
		vToCover.Normalize();
		vDesiredVelocity.Scale(fDistToCover/fTimeStep);
	}

	NMovingGround::SetPedDesiredVelocityClamped(pPed, VECTOR3_TO_VEC3V(vDesiredVelocity), ms_Tunables.m_CoverToCoverMaxAccel);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::ComputeDesiredSpeedAlongVector(float& fAnimatedSpeed, float fRemainingDistance, float fRemainingAnimatedDistance, float fAnimPhase, float fStartPhase, float fEndPhase, float fClipDuration, float UNUSED_PARAM(fTimeStep), bool UNUSED_PARAM(bForward))
{
	const float fRemainingTransAnimTime = (fEndPhase - fAnimPhase) * fClipDuration / ms_Tunables.m_CoverToCoverClipRate;

	if (fRemainingDistance >= ms_Tunables.m_CoverToCoverMinDistToScale)
	{
		if (fAnimPhase >= fStartPhase && fRemainingAnimatedDistance >= ms_Tunables.m_CoverToCoverMinDistToScale 
		WIN32_ONLY(&& fRemainingAnimatedDistance != 0.0f)) //prevent divide by zero warning on Durango
		{
			const float fScale = (fRemainingDistance / fRemainingAnimatedDistance);
			// 			if (bForward)
			// 				Displayf("Scale : %.4f", fScale);
			fAnimatedSpeed *= fScale;
		}
		else
		{
			fAnimatedSpeed = fRemainingDistance / fRemainingTransAnimTime;
		}	
		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::ScaleRotationalVelocity(const crClip& clip, float fAnimPhase, float fFacingHeading, float fTimeStep)
{
	CPed* pPed = GetPed();

	float fRotFixupStartPhase = 0.0f;
	float fRotFixupEndPhase = 1.0f;

	taskVerifyf(CClipEventTags::FindMoverFixUpStartEndPhases(&clip, fRotFixupStartPhase, fRotFixupEndPhase, false), "Clip missing rotation fixup event");

	const float fCurrentHeading = fwAngle::LimitRadianAngle(pPed->GetCurrentHeading());

	const float fLeftAngle = CClipHelper::ComputeHeadingDeltaFromLeft(fCurrentHeading, fFacingHeading);
	const float fRightAngle = CClipHelper::ComputeHeadingDeltaFromRight(fCurrentHeading, fFacingHeading);

	bool bLeftApproach = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? true : false;

	const float fAngToCover = bLeftApproach ? fLeftAngle : fRightAngle;

	const float fDir = bLeftApproach ? -1.0f : 1.0f;

	// Make it go in the correct direction
	float fRotationalVelocityZ = fDir * Min(Abs(NMovingGround::GetPedDesiredAngularVelocity(pPed).GetZf()), Abs(fAngToCover/fTimeStep));

	const float fSmallHeadingDelta = Min(Abs(fwAngle::LimitRadianAngle(fFacingHeading - pPed->GetCurrentHeading())),Abs(fwAngle::LimitRadianAngle(fCurrentHeading - fFacingHeading)));
	
	if (Abs(fAngToCover) < ms_Tunables.m_HeadingReachedTolerance || (fAnimPhase > 0.6f && Abs(fSmallHeadingDelta) < ms_Tunables.m_HeadingReachedTolerance))
	{
		m_bCoverToCoverHeadingReached = true;
	}

	if (!m_bCoverToCoverHeadingReached)
	{
		if (Abs(fSmallHeadingDelta) < ms_Tunables.m_CoverToCoverMinAng)
		{
			fRotationalVelocityZ = fSmallHeadingDelta/fTimeStep;
		}
		else if (fAnimPhase >= fRotFixupStartPhase)
		{
			const float fRemainingRotAnimTime = (fRotFixupEndPhase - fAnimPhase) * clip.GetDuration() / ms_Tunables.m_CoverToCoverClipRate;
			//Displayf("Rot Time remaining : %.4f", fRemainingRotAnimTime);

			// Get the remaining orientation change left in the clip
			Quaternion qClipTotalRot(fwAnimHelpers::GetMoverTrackRotation(clip, fAnimPhase));
			qClipTotalRot.Inverse();
			qClipTotalRot.Multiply(fwAnimHelpers::GetMoverTrackRotation(clip, 1.f));		

			// For rotation we're only interested in the heading
			Vector3 vClipRotEulers(Vector3::ZeroType);
			qClipTotalRot.ToEulers(vClipRotEulers);
			const float fRemainingRotation = fwAngle::LimitRadianAngle(vClipRotEulers.z);

			if (fAnimPhase <= fRotFixupStartPhase && (Abs(fRemainingRotation) >= ms_Tunables.m_CoverToCoverMinAngToScale))
			{
				const float fScale = Abs(fAngToCover / fRemainingRotation);
				//Displayf("Rot Scale: %.4f", fScale);
				fRotationalVelocityZ *= fScale;
			}
			else if (fAnimPhase >= fRotFixupEndPhase && (Abs(fRemainingRotation) < ms_Tunables.m_CoverToCoverMinAngToScale))
			{
				fRotationalVelocityZ = Abs(fAngToCover / Max(fTimeStep, fRemainingRotAnimTime));
			}
		}
	}

	// See if we'll overshoot if we apply this rotation and clamp it if needed
	const float fPredictedNewHeading = fwAngle::LimitRadianAngle(fCurrentHeading + fRotationalVelocityZ * fTimeStep);
	const float fPredictedHeadingDelta = bLeftApproach ? CClipHelper::ComputeHeadingDeltaFromLeft(fPredictedNewHeading, fFacingHeading) : CClipHelper::ComputeHeadingDeltaFromRight(fPredictedNewHeading, fFacingHeading);

	bool bRotateToTargetThisFrame = false;
	if (Abs(fPredictedHeadingDelta) > Abs(fAngToCover))
	{
		bRotateToTargetThisFrame = true;
	}

	if (bRotateToTargetThisFrame || m_bCoverToCoverHeadingReached)
	{
		m_bCoverToCoverHeadingReached = true;
		pPed->SetHeading(fFacingHeading);
		NMovingGround::SetPedDesiredAngularVelocity(pPed, Vec3V(V_ZERO));
		NMovingGround::SetPedAngVelocity(pPed, Vec3V(V_ZERO));
	}
	else
	{
		// Apply
#if __ASSERT
		if (fRotationalVelocityZ > 50.0f)
		{
			aiWarningf("Frame : %i, fRotationalVelocityZ = %.2f", fwTimer::GetFrameCount(), fRotationalVelocityZ);
		}
#endif // __ASSERT
		Vector3 vDesiredAngularVelocity(0.0f, 0.0f, fRotationalVelocityZ);
		NMovingGround::SetPedDesiredAngularVelocity(pPed, VECTOR3_TO_VEC3V(vDesiredAngularVelocity));
	}
}

////////////////////////////////////////////////////////////////////////////////

float CTaskMotionInCover::ComputeDesiredPedHeadingFromCoverDirection(bool bFacingLeft, const Vector3& vCoverDir)
{
	float fCoverDirection = rage::Atan2f(-vCoverDir.x, vCoverDir.y);
	if (bFacingLeft)
	{
		fCoverDirection += HALF_PI;
	}
	else 
	{
		fCoverDirection -= HALF_PI;
	}
	return fwAngle::LimitRadianAngle(fCoverDirection);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::NeedsToFacePedInCorrectDirection()
{
	const CPed& ped = *GetPed();
	if (ped.IsLocalPlayer() && ped.GetPlayerInfo() && ped.GetPlayerInfo()->IsRoundCover())
	{
		return false;
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::ComputeInterruptPhase()
{
	if (!m_bCalculatedTurnInterruptPhase)
	{
		const crClip* pClip = m_MoveNetworkHelper.GetClip(ms_TurnClipId);
		if (pClip)
		{
			const fwMvClipSetId clipsetId = m_MoveNetworkHelper.GetClipSetId();
			if (clipsetId != CLIP_SET_ID_INVALID)
			{
				fwClipSet* pClipSet = fwClipSetManager::GetClipSet(clipsetId);
				if (pClipSet)
				{
					taskVerifyf(CClipEventTags::FindEventPhase(pClip, CClipEventTags::Interruptible, m_fTurnInterruptPhase),"Clip %s From Dictionary %s doesn't have interruptible flag", pClip->GetName(), pClipSet->GetClipDictionaryName().TryGetCStr() ? pClipSet->GetClipDictionaryName().GetCStr() : "NULL");
				}
			}

			m_bCalculatedTurnInterruptPhase = true;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::SendHeightSignal()
{
	if (GetState() != State_CoverToCover)
	{
		float fDesiredHeight = 1.0f;
		if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
		{

		}
		else
		{
			fDesiredHeight = 0.0f;
		}

		TUNE_GROUP_FLOAT(COVER_TUNE, fHeightSmoothing, 0.15f, 0.0f, 1.0f, 0.01f);
		//Always update if already over halfway there
		if (!GetIsHeightTransitioning())
		{
			m_fHeight = rage::Lerp(fHeightSmoothing, m_fHeight, fDesiredHeight);
		}
		else //wait for a good state
		{
			switch(GetState())
			{		
			case State_Idle:
			case State_AtEdge:
			case State_AtEdgeLowCover:	
			case State_Moving:	
				{
					m_fHeight = rage::Lerp(fHeightSmoothing, m_fHeight, fDesiredHeight);
					break;
				}
			default:
				break;
			}		
		}
		
		//updated animated height
		if (m_bUseHighCoverAnims && m_fHeight < 0.5f)
			m_bUseHighCoverAnims = false;
		else if (!m_bUseHighCoverAnims && m_fHeight >= 0.5f)
			m_bUseHighCoverAnims = true;

		m_MoveNetworkHelper.SetFloat(ms_HeightId, m_fHeight);
	}
}

bool CTaskMotionInCover::GetIsHeightTransitioning() const
{
	if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
		return m_fHeight < 0.5f;
	else
		return m_fHeight > 0.5f;
}

//////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::SetGripClip(CPed* pPed, CMoveNetworkHelper& moveNetworkHelper)
{
	bool bUseGripClip = false;
	const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager() ? pPed->GetWeaponManager()->GetEquippedWeaponInfo() : NULL;
	if (pWeaponInfo && (pWeaponInfo->GetIsMelee() || pWeaponInfo->GetIsThrownWeapon() || pWeaponInfo->GetIsGun1Handed() || (pWeaponInfo->GetIsTwoHanded() && pWeaponInfo->GetIs1HandedInCover())))
	{
		fwMvClipSetId gripClipSet = pWeaponInfo->GetPedMotionClipSetId(*pPed, FPS_StreamThirdPerson); // Always use third person grip clip (not that we use these in first person anyway)
		if (gripClipSet != CLIP_SET_ID_INVALID)
		{	
			const crClip* pGripClip = NULL;				
			if (pWeaponInfo->GetIsMeleeFist())
			{
				pGripClip = fwClipSetManager::GetClip(gripClipSet, fwMvClipId("GRIP_IDLE",0x3ec63b58));
			}
			else
			{
				pGripClip = fwClipSetManager::GetClip(gripClipSet, fwMvClipId("idle",0x71C21326));
			}

			if (pGripClip)
			{
				crFrameFilter* pGripFrameFilter = NULL;
				if (pWeaponInfo->GetIsMeleeFist())
				{
					static fwMvFilterId s_GripFilterHashId("BothArms_filter",0x16f1d420);	
					pGripFrameFilter = g_FrameFilterDictionaryStore.FindFrameFilter(s_GripFilterHashId);
				}
				else
				{
					static fwMvFilterId s_GripFilterHashId("Grip_R_Only_Filter",0xB455BA3A);	
					pGripFrameFilter = g_FrameFilterDictionaryStore.FindFrameFilter(s_GripFilterHashId);
				}

				moveNetworkHelper.SetFilter(pGripFrameFilter, ms_GripFilterId);
				moveNetworkHelper.SetClip(pGripClip, CTaskMotionInCover::ms_GripClipId);
				bUseGripClip = true;				
			}	
		}
	}
	moveNetworkHelper.SetFlag(bUseGripClip, CTaskMotionInCover::ms_UseGripClipId);
	moveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_UseWeaponHoldingId);	
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::ProcessUseMobilePhone(bool bPutUpAnswerCall)
{
	//if (m_bRunMobilePhoneSubTask)
	{
		CPed& ped = *GetPed();
		if (bPutUpAnswerCall || CTaskPlayerOnFoot::CheckForUseMobilePhone(ped))
		{
			// if (ped.GetWeaponManager() && !ped.GetWeaponManager()->GetEquippedWeaponObject())
			{
				if (!ped.GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_RELOAD_GUN) &&
					!ped.GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_SWAP_WEAPON))
				{
					CTask* pTask = ped.GetPedIntelligence()->FindTaskActiveByTreeAndType(PED_TASK_TREE_SECONDARY, CTaskTypes::TASK_MOBILE_PHONE);
					if (!pTask)
					{
						ped.GetPedIntelligence()->AddTaskSecondary(rage_new CTaskMobilePhone(bPutUpAnswerCall ? CTaskMobilePhone::Mode_ToCall : CTaskMobilePhone::Mode_ToText), PED_TASK_SECONDARY_PARTIAL_ANIM);
					}
				}
			}
		}
	}
}

void CTaskMotionInCover::ProcessLookIK(CPed* pPed) 
{
	if (pPed->IsLocalPlayer())
		pPed->GetIkManager().LookAt(0, NULL, 1000, BONETAG_INVALID, NULL, LF_USE_CAMERA_FOCUS, 500, 500, CIkManager::IK_LOOKAT_HIGH);
	else
	{
		CPed* pCurrentTarget = pPed->GetPedIntelligence()->GetCurrentTarget();
		if (pCurrentTarget)
		{
			pPed->GetIkManager().LookAt(0, pCurrentTarget, 1000, BONETAG_INVALID, NULL, LF_WHILE_NOT_IN_FOV, 500, 500, CIkManager::IK_LOOKAT_HIGH);
		}
	}

}

bool CTaskMotionInCover::ShouldRestartStateDueToCameraSwitch(CMoveNetworkHelper& FPS_MODE_SUPPORTED_ONLY(rMoveNetworkHelper))
{
#if FPS_MODE_SUPPORTED
	CPed* pPed = GetPed();

	const bool bShouldUseFirstPersonAnims = ShouldUseFirstPersonLocoAnimations(*pPed);
	if (pPed->GetPlayerResetFlag(CPlayerResetFlags::PRF_CAMERA_VIEW_MODE_SWITCHED_TO_OR_FROM_FIRST_PERSON) || m_bRestartNextFrame)
	{
		m_bRestartNextFrame = false;
		// This works in the manual case because we're setting this in the post cam ai update, and then making the request the following frame,
		// so the signal is consumed the next frame
		rMoveNetworkHelper.SetFloat(ms_RestartStillBlendDurationId, 0.0f);
		return true;
	}
	
	if (m_bWasUsingFirstPersonAnims != bShouldUseFirstPersonAnims && !pPed->GetPlayerInfo()->AreControlsDisabled())
	{
		m_bRestartNextFrame = true;
	}
#endif // FPS_MODE_SUPPORTED
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::SendSpeedSignal()
{
#if FPS_MODE_SUPPORTED
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, MOVEMENT_CLIP_RATE, 1.0f, 0.0f, 2.0f, 0.01f);
		m_MoveNetworkHelper.SetFloat(ms_MovementClipRateId, MOVEMENT_CLIP_RATE);
		return;
	}
#endif // FPS_MODE_SUPPORTED

	float fCurrentMBR = GetPed()->GetMotionData()->GetCurrentMbrY();

	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_COVER_MOVEMENT_RATE, 0.5f, 0.0f, 1.0f, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_COVER_MOVEMENT_RATE, 1.0f, 0.0f, 1.0f, 0.01f);

	const float fMovementRate = MIN_COVER_MOVEMENT_RATE * (1.0f - fCurrentMBR ) + MAX_COVER_MOVEMENT_RATE * fCurrentMBR;
	aiDebugf1("Movement Rate = %.2f", fMovementRate);
	m_MoveNetworkHelper.SetFloat(ms_MovementClipRateId, fMovementRate);
}

////////////////////////////////////////////////////////////////////////////////

const crClip* CTaskMotionInCover::GetClipAndPhaseForState(float& fPhase)
{
	const crClip* pClip = m_MoveNetworkHelper.GetClip(ms_TurnClipId);
	if (pClip)
	{
		fPhase = m_MoveNetworkHelper.GetFloat(ms_TurnClipCurrentPhaseId);
		return pClip;
	}
	return NULL;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::CanUseTaskState(s32 iState) const
{
	if (DoesTaskStateRequireStreamedAnim(iState))
	{
		if (!AreStreamedAnimsLoaded(iState))
		{
			return false;
		}
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::AreStreamedAnimsLoaded(s32 iOverrideState) const
{
	if (!m_CoreStreamedClipsetRequestHelper.IsLoaded())
	{
		return false;
	}

	s32 iStateToCheck = iOverrideState > -1 ? iOverrideState : GetState();
	fwMvClipSetId streamedClipSetId = CTaskCover::GetStreamedClipSetForArmament(GetPed(), iStateToCheck == State_CoverToCover ? true : false);

	if (streamedClipSetId != CLIP_SET_ID_INVALID)
	{
		fwClipSet* pClipSet = fwClipSetManager::GetClipSet(streamedClipSetId);
		if (!pClipSet || !pClipSet->Request_DEPRECATED())
		{
			return false;
		}
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::DoesTaskStateRequireStreamedAnim(s32 iState) const
{
	switch (iState)
	{
		case State_Stopping:
			return (GetPed()->IsPlayer() && ms_Tunables.m_EnableWalkStops) ? true : false;
		case State_StoppingAtEdge:
			return (GetPed()->IsPlayer() && ms_Tunables.m_EnableWalkStops && (GetPreviousState() == State_Moving || GetPreviousState() == State_WalkStart)) ? true : false;
		case State_StoppingAtInsideEdge:
			return (GetPed()->IsPlayer() && ms_Tunables.m_EnableWalkStops && GetPreviousState() != State_CoverToCover) ? true : false;
		case State_CoverToCover:
		case State_EdgeTurn:
			return true;
		default: break;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::TestForObstructionsBehindPlayer(const CPed& rPed)
{
	const Vector3 vPedPos = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
	const Vector3 vPedFwd = VEC3V_TO_VECTOR3(rPed.GetTransform().GetB());
	TUNE_GROUP_FLOAT(COVER_TUNE, OBSTRUCTION_BEHIND_PROBE_LENGTH, 1.0f, 0.0f, 2.0f, 0.01f);
	Vector3 vStart = vPedPos;
	Vector3 vEnd = vStart - OBSTRUCTION_BEHIND_PROBE_LENGTH * vPedFwd;
	Vector3 vIntersectionPosUnused;
	const phInst* pHitInst = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPosUnused);
	return pHitInst ? true : false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskMotionInCover::IsCameraPointingInWrongDirectionForTurn(const CPed& rPed) const
{
#if FPS_MODE_SUPPORTED
	if (rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		Vector3 vCamFront = camInterface::GetGameplayDirector().GetFrame().GetFront();
		const Vector3 vCoverDirection = static_cast<const CTaskInCover*>(GetParent())->GetCoverDirection();
		const float fCrossZ = vCamFront.CrossZ(vCoverDirection);
		const bool bCamPointingLeft = fCrossZ < 0.0f;
		if (IsCoverFlagSet(CTaskCover::CF_FacingLeft) && bCamPointingLeft)
		{
			return true;
		}
		else if (!IsCoverFlagSet(CTaskCover::CF_FacingLeft) && !bCamPointingLeft)
		{
			return true;
		}
	}
#endif // FPS_MODE_SUPPORTED
	return false;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskMotionInCover::ChoosePeekingVariationClipSetForPed(CPed& ped, bool bIsHigh) const
{
	if (ped.GetPedIntelligence()->GetCombatBehaviour().IsFlagSet(CCombatData::BF_CanUsePeekingVariations))
	{
		if (ped.GetPedIntelligence()->GetCombatDirector())
		{
			if (ped.GetWeaponManager()->GetEquippedWeaponInfo() && !ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsRpg())
			{
				if (ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsTwoHanded())
				{
					return ped.GetPedIntelligence()->GetCombatDirector()->GetCoverPeekingVariations2HInfo(bIsHigh).ChooseClipSetForPed(ped);
				}
				else if (ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsGun1Handed())
				{
					return ped.GetPedIntelligence()->GetCombatDirector()->GetCoverPeekingVariations1HInfo(bIsHigh).ChooseClipSetForPed(ped);
				}
			}
		}
	}
	
	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskMotionInCover::ChoosePinnedVariationClipSetForPed(const CPed& ped, bool bIsHigh)
{
	if (ped.GetPedIntelligence()->GetCombatDirector())
	{
		if (ped.GetWeaponManager()->GetEquippedWeaponInfo() && !ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsRpg())
		{
			if (ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsTwoHanded())
			{
				return ped.GetPedIntelligence()->GetCombatDirector()->GetCoverPinnedVariations2HInfo(bIsHigh).ChooseClipSetForPed(ped);
			}
			else if (ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsGun1Handed())
			{
				return ped.GetPedIntelligence()->GetCombatDirector()->GetCoverPinnedVariations1HInfo(bIsHigh).ChooseClipSetForPed(ped);
			}
		}
	}

	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskMotionInCover::ChooseIdleVariationClipSetForPed(const CPed& ped, bool bIsHigh)
{
	const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfo();
	if (pWeaponInfo && !pWeaponInfo->GetDisableIdleVariations() && !pWeaponInfo->GetIsRpg())
	{
		if (ped.IsLocalPlayer())
		{
			CoverVariationsInfo::eArmamentType armamentType = CoverVariationsInfo::AT_Unarmed;
			if (ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsTwoHanded() && !ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIs1HandedInCover())
			{
				armamentType = CoverVariationsInfo::AT_TwoHanded;
			}
			return CPlayerCoverClipVariationHelper::GetInstance().GetCoverIdleVariationsInfo(armamentType, bIsHigh).ChooseClipSetForPed(ped);
		}
		else
		{
			if (ped.GetPedIntelligence()->GetCombatDirector())
			{
				if (ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsTwoHanded())
				{
					return ped.GetPedIntelligence()->GetCombatDirector()->GetCoverIdleVariations2HInfo(bIsHigh).ChooseClipSetForPed(ped);
				}
				else if (ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsGun1Handed())
				{
					return ped.GetPedIntelligence()->GetCombatDirector()->GetCoverIdleVariations1HInfo(bIsHigh).ChooseClipSetForPed(ped);
				}
			}
		}
	}

	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskMotionInCover::ComputeGaussianValueForRestrictedCameraPitch(float fX)
{
	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, A, 1.0f, 0.0f, 10.0f, 0.01f);
	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, B, 0.5f, -10.0f, 10.0f, 0.01f);
	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, C, 0.2f, 0.001f, 10.0f, 0.01f);
	float fY = A * expf(-square(fX-B) * 0.5f / square(C));
	return fY;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskMotionInCover::ComputeCoverHeading(const CPed& rPed)
{
	Vector3 vDirUnused;
	Vector3 vCoverDir(Vector3::ZeroType);
	if (CCover::FindCoverDirectionForPed(rPed, vCoverDir, vDirUnused))
	{
		return rage::Atan2f(-vCoverDir.x, vCoverDir.y);
	}
	return -1.0f;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskMotionInCover::ComputeFacingHeadingForCoverDirection(const Vector3& vCoverDir, bool bFacingLeft)
{
	float fFacingDirection = rage::Atan2f(-vCoverDir.x, vCoverDir.y);
	return ComputeFacingHeadingForCoverDirection(fFacingDirection, bFacingLeft);
}

////////////////////////////////////////////////////////////////////////////////

float CTaskMotionInCover::ComputeFacingHeadingForCoverDirection(float fCoverHeading, bool bFacingLeft)
{
	float fFacingDirection = fCoverHeading;
	fFacingDirection += bFacingLeft ? HALF_PI : -HALF_PI;
	return fwAngle::LimitRadianAngle(fFacingDirection);
}

////////////////////////////////////////////////////////////////////////////////

float CTaskMotionInCover::ComputeMvCamHeading() const
{
	const float fCamHeading = camInterface::GetGameplayDirector().GetFrame().ComputeHeading();
	const float fCovHeading = ComputeCoverHeading(*GetPed());
	const float fDelta = fwAngle::LimitRadianAngle(fCovHeading - fCamHeading);
	TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, SHRINK_RANGE, false);
	float fRange = TWO_PI;
	if (SHRINK_RANGE)
	{
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, SHRUNK_RANGE, 4.442f, 0.0f, TWO_PI, 0.01f);
		fRange = SHRUNK_RANGE;
	}
	float fMvCamHeading = rage::Clamp((fDelta + PI) / fRange, 0.0f, 1.0f);
	if (GetState() == State_TurnEnd)
	{
		fMvCamHeading = IsTurningLeft() ? fMvCamHeading : 1.0f - fMvCamHeading;
	}
	else
	{
		fMvCamHeading = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? fMvCamHeading : 1.0f - fMvCamHeading;
	}

	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, ZERO_CAM_HEADING_POINT, 0.8f, 0.0f, 1.0f, 0.01f);
	if (fMvCamHeading >= ZERO_CAM_HEADING_POINT)
	{
		fMvCamHeading = 0.0f;
	}
	return fMvCamHeading;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskMotionInCover::ForceResendOfSyncData(CPed& ped)
{
	if (ped.GetNetworkObject() && !ped.IsNetworkClone())
	{
		CNetObjPed* pPedNetObj = SafeCast(CNetObjPed, ped.GetNetworkObject());

		ped.GetPedIntelligence()->BuildQueriableState();
		pPedNetObj->ForceResendOfAllTaskData();
		pPedNetObj->ForceSendOfPositionData();
	}
}

////////////////////////////////////////////////////////////////////////////////

#if !__FINAL
void CTaskMotionInCover::Debug() const
{
#if DEBUG_DRAW
	if (GetPed()->IsLocalPlayer())
	{
#if FPS_MODE_SUPPORTED
		TUNE_GROUP_BOOL(GAUSSIAN_TUNE, RENDER_DEBUG, false);
		if (RENDER_DEBUG && GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			TUNE_GROUP_FLOAT(GAUSSIAN_TUNE, AXIS_START_X_POS, 0.75f, -1.0f, 1.0f, 0.01f);
			TUNE_GROUP_FLOAT(GAUSSIAN_TUNE, AXIS_START_Y_POS, 0.5f, -1.0f, 1.0f, 0.01f);

			TUNE_GROUP_FLOAT(GAUSSIAN_TUNE, HEIGHT, 0.1f, 0.0f, 1.0f, 0.01f);
			TUNE_GROUP_FLOAT(GAUSSIAN_TUNE, WIDTH, 0.1f, 0.0f, 1.0f, 0.01f);

			Vector2 v1(AXIS_START_X_POS, AXIS_START_Y_POS);
			Vector2 v2(AXIS_START_X_POS + WIDTH, AXIS_START_Y_POS);
			grcDebugDraw::Line(v1, v2, Color_grey);
			v2 = Vector2(AXIS_START_X_POS - WIDTH * 0.5f, AXIS_START_Y_POS);
			grcDebugDraw::Line(v1, v2, Color_grey);
			v2 = Vector2(AXIS_START_X_POS, AXIS_START_Y_POS - HEIGHT);
			grcDebugDraw::Line(v1, v2, Color_grey);

			TUNE_GROUP_FLOAT(GAUSSIAN_TUNE, XSCALE, 10.0f, 0.0f, 100.0f, 0.01f);
			TUNE_GROUP_FLOAT(GAUSSIAN_TUNE, YSCALE, 3.0f, 0.0f, 100.0f, 0.01f);
			TUNE_GROUP_INT(GAUSSIAN_TUNE, INCREMENTS, 1000, 0, 10000, 1);
			const float fIncWidth = 1.0f / (float)INCREMENTS;

			for (s32 i=0; i<INCREMENTS; ++i)
			{
				float fX = i*fIncWidth;
				float fY = ComputeGaussianValueForRestrictedCameraPitch(fX);
				fX /= XSCALE;
				fY /= YSCALE;
				TUNE_GROUP_FLOAT(GAUSSIAN_TUNE, RADIUS, 0.001f, 0.0f, 1.0f, 0.001f);
				Vector2 vPos = v1 + Vector2(fX , -fY);
				grcDebugDraw::Circle(vPos, RADIUS, Color_red);
			}

			float fHeading = camInterface::GetGameplayDirector().GetFrame().ComputeHeading();
			fHeading = fwAngle::LimitRadianAngle0to2PiSafe(fHeading);
			fHeading /= TWO_PI;

			float fX = fHeading;
			float fY = ComputeGaussianValueForRestrictedCameraPitch(fX);
			float fXPreScale = fX;
			float fYPreScale = fY;
			fX /= XSCALE;
			fY /= YSCALE;
			TUNE_GROUP_FLOAT(GAUSSIAN_TUNE, RADIUS_2, 0.002f, 0.0f, 1.0f, 0.001f);
			Vector2 vPos = v1 + Vector2(fX , -fY);
			grcDebugDraw::Circle(vPos, RADIUS_2, Color_blue);
			char szText[128];
			formatf(szText, "fHeading = %.2f, fX = %.2f, fY = %.2f", camInterface::GetGameplayDirector().GetFrame().ComputeHeading(), fXPreScale, fYPreScale);
			grcDebugDraw::Text(vPos, Color_green, szText);
		}
#endif // FPS_MODE_SUPPORTED
		grcDebugDraw::AddDebugOutput(Color_green, "MvCamHeading = %.2f", ComputeMvCamHeading());
	}
#endif // DEBUG_DRAW
}
#endif // !__FINAL
////////////////////////////////////////////////////////////////////////////////

// Statics
CTaskAimGunFromCoverIntro::Tunables CTaskAimGunFromCoverIntro::ms_Tunables;

IMPLEMENT_COMBAT_TASK_TUNABLES(CTaskAimGunFromCoverIntro, 0xefd51be0);

////////////////////////////////////////////////////////////////////////////////

const fwMvBooleanId CTaskAimGunFromCoverIntro::ms_AimIntroClipFinishedId("AimIntroClipFinished",0x53DEA5BB);
const fwMvBooleanId CTaskAimGunFromCoverIntro::ms_BlendInUpperBodyAimId("BlendInUpperBodyAim",0xC69950E0);
const fwMvRequestId	CTaskAimGunFromCoverIntro::ms_AimingId("Aiming",0x9A5B381);
const fwMvFlagId	CTaskAimGunFromCoverIntro::ms_AimDirectlyFlagId("AimDirectly",0xDCC73257);
const fwMvClipId	CTaskAimGunFromCoverIntro::ms_AimIntroClip0Id("AimIntroClip0",0x48CA336B);
const fwMvClipId	CTaskAimGunFromCoverIntro::ms_AimIntroClip1Id("AimIntroClip1",0x555B4C8D);
const fwMvFloatId	CTaskAimGunFromCoverIntro::ms_AimIntroBlendId("AimIntroBlend",0xEE21778A);
const fwMvFloatId	CTaskAimGunFromCoverIntro::ms_AimIntroClipCurrentPhaseId("AimIntroClipCurrentPhase",0x64F4C4FD);
const fwMvBooleanId	CTaskAimGunFromCoverIntro::ms_AimIntroInterruptId("AimIntroInterrupt",0xCFCAC4B6);

////////////////////////////////////////////////////////////////////////////////

Vector3 CTaskAimGunFromCoverIntro::ComputeCurrentStepOutPosition(bool bIsFacingLeft, const CPed& ped, s32 iCurrentNode, bool bInHighCoverNotAtEdge, bool bIsCloseToPossibleCorner)
{
	Vector3 vAimPosition = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
	if (taskVerifyf(ped.GetCoverPoint(), "Ped doesn't have a cover point"))
	{
		Vector3 vCoverDirection = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector());
		Vector3 vSide = vCoverDirection;
		if (bIsFacingLeft)
			vSide.RotateZ(HALF_PI);
		else
			vSide.RotateZ(-HALF_PI);

		const AimStepInfoSet& aimStepInfoSet = ms_Tunables.GetAimStepInfoSet(bIsFacingLeft);
		if (taskVerifyf(iCurrentNode > - 1 && iCurrentNode < aimStepInfoSet.m_StepInfos.GetCount(), "Step out node (%i) was invalid", iCurrentNode))
		{
			Vector3 vCoverPosition(Vector3::ZeroType);
			ped.GetCoverPoint()->GetCoverPointPosition(vCoverPosition);
			vCoverPosition.z += 1.0f;

#if FPS_MODE_SUPPORTED
			bool bIsFPSMode = ped.IsFirstPersonShooterModeEnabledForPlayer(false);
			INSTANTIATE_TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, DISABLE_AUTO_STEP_AROUND);
			if (DISABLE_AUTO_STEP_AROUND && bIsFPSMode && !ped.GetPlayerInfo()->IsAiming(false))
			{
				vAimPosition = vCoverPosition;
			}
			else
#endif // FPS_MODE_SUPPORTED
			// Pull the player to the side when aiming to the side, or more backwards when aiming towards the front
			if (ped.IsAPlayerPed() && bInHighCoverNotAtEdge FPS_MODE_SUPPORTED_ONLY(&& !bIsFPSMode))
			{
				const float fCoverHeading = fwAngle::LimitRadianAngle(rage::Atan2f(-vCoverDirection.x, vCoverDirection.y));

				Vector3 vCamFront(Vector3::ZeroType);
				float fDot = 0.0f;
				float fTargetHeading = 0.0f;

				if (ped.IsLocalPlayer())
				{
					const camFrame& aimCameraFrame = camInterface::GetPlayerControlCamAimFrame();
					vCamFront = aimCameraFrame.GetFront();
					vCamFront.z = 0.0f;
					vCamFront.Normalize();
					// Want to face the direction of the camera
					fTargetHeading = aimCameraFrame.ComputeHeading();
					fDot = rage::Clamp(vCamFront.Dot(vCoverDirection), 0.0f, 1.0f);
				}
				else
				{
					vCamFront = Vector3(0.0f, 1.0f, 0.0f);
					const float fDesiredHeading = ped.GetNetworkObject() ? static_cast<CNetObjPed*>(ped.GetNetworkObject())->GetDesiredHeading() : ped.GetDesiredHeading();
					vCamFront.RotateZ(fDesiredHeading);
					fTargetHeading = fDesiredHeading;
					fDot = rage::Clamp(vCamFront.Dot(vCoverDirection), 0.0f, 1.0f);
				}

				Vector3 vCoverDir(0.0f, 1.0f, 0.0f);
				vCoverDir.RotateZ(fCoverHeading);
				float fSideMult = 1.0f;
				const float fCamCrossCov = vCoverDir.CrossZ(vCamFront);
				if (bIsFacingLeft && fCamCrossCov > 0.0f)
				{
					fSideMult *= -1.0f;
				}
				else if (!bIsFacingLeft && fCamCrossCov < 0.0f)
				{
					fSideMult *= -1.0f;
				}
				// Possibly need per weapon / weapon size offsets :(
				TUNE_GROUP_FLOAT(COVER_TUNE, HIGH_CENTER_STEP_FIXED_BACK_DISTANCE, 0.3f, 0.0f, 2.0f, 0.01f);
				TUNE_GROUP_FLOAT(COVER_TUNE, HIGH_CENTER_STEP_EXTRA_BACK_DISTANCE, 0.5f, 0.0f, 2.0f, 0.01f);
				TUNE_GROUP_FLOAT(COVER_TUNE, HIGH_CENTER_STEP_OUT_DISTANCE, 0.5f, 0.0f, 2.0f, 0.01f);
				vAimPosition = vCoverPosition + (1.0f - fDot) * fSideMult * vSide * HIGH_CENTER_STEP_OUT_DISTANCE - vCoverDirection * (HIGH_CENTER_STEP_FIXED_BACK_DISTANCE + fDot * HIGH_CENTER_STEP_EXTRA_BACK_DISTANCE);
			}
			else
			{
				vAimPosition = vCoverPosition + aimStepInfoSet.m_StepInfos[iCurrentNode].m_StepOutX * vSide - aimStepInfoSet.m_StepInfos[iCurrentNode].m_StepOutY * vCoverDirection;

				if (bIsCloseToPossibleCorner FPS_MODE_SUPPORTED_ONLY(&& !bIsFPSMode))
				{
					TUNE_GROUP_FLOAT(COVER_TUNE, HIGH_CLOSE_TO_EDGE_STEP_EXTRA_BACK_DISTANCE, 0.5f, 0.0f, 2.0f, 0.01f);
					vAimPosition -= vCoverDirection * HIGH_CLOSE_TO_EDGE_STEP_EXTRA_BACK_DISTANCE;
				}
			}
		}
	}
	return vAimPosition;
}

////////////////////////////////////////////////////////////////////////////////

Vector3 CTaskAimGunFromCoverIntro::ComputeHighCoverStepOutPosition(bool bIsFacingLeft, const CPed& /*ped*/, const CCoverPoint& coverPoint)
{
	PF_FUNC(ComputeHighCoverStepOutPosition);

	Vector3 vStepOutOffset(Vector3::ZeroType);
	vStepOutOffset.x = bIsFacingLeft ? ms_Tunables.m_StepOutLeftX : ms_Tunables.m_StepOutRightX;
	vStepOutOffset.y = ms_Tunables.m_StepOutY;
	Vector3 vCoverDirection = VEC3V_TO_VECTOR3(coverPoint.GetCoverDirectionVector());
	float fEndHeading = rage::Atan2f(-vCoverDirection.x, vCoverDirection.y);
	Vector3 vCoverPosition;
	coverPoint.GetCoverPointPosition(vCoverPosition);
	Matrix34 coverMtx;
	coverMtx.FromEulers(Vector3(0.0f,0.0f,fEndHeading), "xyz");
	coverMtx.d = vCoverPosition;
	Vector3 vTargetPosition = vStepOutOffset;
	coverMtx.Transform3x3(vTargetPosition);
	vTargetPosition += coverMtx.d;
	vTargetPosition.z += 1.0f;

	// This probe was very expensive, and shouldn't be needed for most users of this function (if any).
	// It will have to be done elsewhere if it's needed at all.
	//	Vector3 vGroundPos(Vector3::ZeroType);
	//	if (CTaskVehicleFSM::FindGroundPos(&ped, vTargetPosition, 2.5f, vGroundPos))
	//	{
	//		vTargetPosition.z = vGroundPos.z;
	//	}

	return vTargetPosition;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunFromCoverIntro::CheckForBlockedAimPosition(bool& bForwardAimBlocked, bool& bSideAimBlocked, const CPed& rPed, bool bFacingLeft, bool bTooHighCover)
{
	if (rPed.GetCoverPoint() && !bTooHighCover)
	{
		Vector3 vCoverDirection = VEC3V_TO_VECTOR3(rPed.GetCoverPoint()->GetCoverDirectionVector());
		Vector3 vCoverPosition(Vector3::ZeroType);
		if (rPed.GetCoverPoint()->GetCoverPointPosition(vCoverPosition))
		{
			Vector3 vSide = vCoverDirection;
			Vector3 vRight = vSide;
			vRight.RotateZ(-HALF_PI);
			Vector3 vLeft = vSide;
			vLeft.RotateZ(HALF_PI);

			if (bFacingLeft)
				vSide = vLeft;
			else
				vSide = vRight;

			Vector3 vStart = vCoverPosition + ms_Tunables.m_LowXOffsetCapsuleTest * vSide + ms_Tunables.m_LowYOffsetCapsuleTest * vCoverDirection + ms_Tunables.m_LowZOffsetCapsuleTest * ZAXIS;
			Vector3 vEnd = vStart + ms_Tunables.m_LowOffsetCapsuleLength * vCoverDirection;
			Vector3 vUnused;

			bForwardAimBlocked = CDynamicCoverHelper::DoCapsuleTest(vStart, vEnd, vUnused, ms_Tunables.m_LowOffsetCapsuleRadius) ? true : false;

#if DEBUG_DRAW
			ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), ms_Tunables.m_LowOffsetCapsuleRadius, bForwardAimBlocked ? Color_red : Color_green, 2000, 0, false);
#endif
			if (bForwardAimBlocked)
			{
				vStart += ms_Tunables.m_LowXClearOffsetCapsuleTest * vSide;
				vEnd += ms_Tunables.m_LowXClearOffsetCapsuleTest * vSide;

				const phInst* pSideHitInst = NULL;
				const phInst* pHighHitInst = CDynamicCoverHelper::DoCapsuleTest(vStart, vEnd, vUnused, ms_Tunables.m_LowOffsetCapsuleRadius);
				const CEntity* pHighEntity = CPhysics::GetEntityFromInst(pHighHitInst);
				if (pHighEntity && pHighEntity->GetIsTypeObject() && !pHighEntity->GetIsAnyFixedFlagSet())
				{
					pHighHitInst = NULL;
				}

				if (!pHighHitInst)
				{
#if DEBUG_DRAW
					ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), ms_Tunables.m_LowOffsetCapsuleRadius, pHighHitInst ? Color_red : Color_green, 2000, 0, false);
#endif
					vStart = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
					vEnd = vStart + ms_Tunables.m_LowXClearOffsetCapsuleTest * vSide;

					pSideHitInst = CDynamicCoverHelper::DoCapsuleTest(vStart, vEnd, vUnused, ms_Tunables.m_LowOffsetCapsuleRadius);
					const CEntity* pLowEntity = CPhysics::GetEntityFromInst(pSideHitInst);
					if (pLowEntity && pLowEntity->GetIsTypeObject() && !pLowEntity->GetIsAnyFixedFlagSet())
					{
						pSideHitInst = NULL;
					}
				}

				bSideAimBlocked = pHighHitInst || pSideHitInst;
#if DEBUG_DRAW
				ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), ms_Tunables.m_LowOffsetCapsuleRadius, pSideHitInst ? Color_red : Color_green, 2000, 0, false);
#endif
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunFromCoverIntro::ApplyDesiredVelocityTowardsTarget(CPed& rPed, const Vector3& vTarget, float fTimeStep)
{
	// Compute a unit direction vector towards the intro position from our current position
	const Vector3 vCurrentPedPosition = VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition());
	Vector3 vCurrentToIntroPosition = vTarget - vCurrentPedPosition;
	vCurrentToIntroPosition.z = 0.0f;
	// Cache the distance to the target position
	const float fDistToTarget = vCurrentToIntroPosition.Mag();
	vCurrentToIntroPosition.Normalize();

	// Force the linear velocity towards the intro position
	Vector3 vDesiredVel(Vector3::ZeroType);
	float fDesiredSpeed = Mag(NMovingGround::GetPedDesiredVelocity(&rPed)).Getf();

	// Scale the velocity to avoid oscillating about the target position
	if (fDistToTarget < ms_Tunables.m_DistConsideredAtAimPosition)
	{
		fDesiredSpeed = 0.0f;
	}
	else if (fDistToTarget < fDesiredSpeed * fTimeStep)
	{
		taskAssert(fTimeStep > SMALL_FLOAT);
		fDesiredSpeed = rage::Clamp(fDistToTarget / fTimeStep, 0.0f, 10.0f);
	}
	vDesiredVel = vCurrentToIntroPosition;
	vDesiredVel.Scale(fDesiredSpeed);

	// Apply the calculated desired velocity back onto the ped
	NMovingGround::SetPedDesiredVelocityClamped(&rPed, VECTOR3_TO_VEC3V(vDesiredVel), CTaskMotionBase::ms_fAccelLimitHigher*fTimeStep);
}

////////////////////////////////////////////////////////////////////////////////

#if DEBUG_DRAW
Color32 CTaskAimGunFromCoverIntro::GetAimStepColor(s32 i)
{
	switch (i)
	{
		case 0: return Color_red;
		case 1: return Color_orange;
		case 2: return Color_blue;
		case 3: return Color_green;
		default: break;
	}
	return Color_white;
}
#endif // DEBUG_DRAW

////////////////////////////////////////////////////////////////////////////////

CTaskAimGunFromCoverIntro::CTaskAimGunFromCoverIntro(const Vector3& vTargetCoords, u32 iTaskConfigFlags, CMoveNetworkHelper& moveNetworkHelper)
: m_vTargetCoords(vTargetCoords)
, m_vDirToTarget(Vector3::ZeroType)
, m_Flags(iTaskConfigFlags)
, m_vInitialIntroPosition(Vector3::ZeroType)
, m_vTargetIntroPosition(Vector3::ZeroType)
, m_fInitialHeading(0.0f)
, m_fTargetIntroHeading(0.0f)
, m_fPreviousTargetIntroHeading(0.0f)
, m_fDesiredPitch(-1.0f)
, m_fCurrentPitch(-1.0f)
, m_fAimIntroBlendSignal(-1.0f)
, m_MoveNetworkHelper(moveNetworkHelper)
, m_bNoMoverFilterSet(false)
, m_bForwardBlocked(false)
, m_bSideBlocked(false)
, m_bForcedStepOut(false)
, m_fClipHeading(0.0f)
, m_fAnimatedHeadingMoved(0.0f)
, m_fExtraHeadingMoved(0.0f)
, m_fExtraHeadingNeeded(0.0f)
, m_fTargetHeading(0.0f)
, m_fClipDistance(0.0f)
, m_fAnimatedDistanceMoved(0.0f)
, m_fTargetDistance(0.0f)
, m_fDesiredDistanceMoved(0.0f)
{
	SetInternalTaskType(CTaskTypes::TASK_AIM_GUN_FROM_COVER_INTRO);
}

////////////////////////////////////////////////////////////////////////////////

CTaskAimGunFromCoverIntro::~CTaskAimGunFromCoverIntro()
{

}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunFromCoverIntro::CleanUp()
{
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunFromCoverIntro::ProcessPreFSM()
{
	CPed* pPed = GetPed();

	bool bCanFireLikeGun = pPed->GetWeaponManager() && pPed->GetWeaponManager()->GetIsArmedGunOrCanBeFiredLikeGun();
	bool bCanAimLikeGun = pPed->GetWeaponManager() && pPed->GetWeaponManager()->GetEquippedWeaponInfo() && pPed->GetWeaponManager()->GetEquippedWeaponInfo()->GetCanBeAimedLikeGunWithoutFiring();

	if (!(bCanFireLikeGun || bCanAimLikeGun))
	{
		return FSM_Quit;
	}

	// allows us to add additional heading
	pPed->SetPedResetFlag(CPED_RESET_FLAG_SyncDesiredHeadingToCurrentHeading, false);

	// Update the target location for ai peds so they track the target if its moving
	if (!pPed->IsLocalPlayer())
	{
		const CWeaponTarget& weaponTarget = static_cast<const CTaskInCover*>(GetParent())->GetTarget();
		Vector3 vNewTarget(VEC3_ZERO);
		if (weaponTarget.GetIsValid() && weaponTarget.GetPosition(vNewTarget))
		{
			m_vTargetCoords = vNewTarget;
		}
		else if (pPed->IsNetworkClone())
		{
			// Sometimes the weapon target hasn't been synced, see if we have a hostile target we can use instead
			CEntity* pTargetEnt = pPed->GetPedIntelligence()->GetQueriableInterface()->GetHostileTarget();
			if (pTargetEnt)
			{
				m_vTargetCoords = VEC3V_TO_VECTOR3(pTargetEnt->GetTransform().GetPosition());
			}
		}
		else
		{
			m_vTargetCoords = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition()) + (VEC3V_TO_VECTOR3(pPed->GetTransform().GetB()) * 5.0f);
		}
	}

	// Calculate a normalised directional vector between the ped and its target
	m_vDirToTarget = m_vTargetCoords - VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
	m_vDirToTarget.z = 0.0f;
	m_vDirToTarget.Normalize();

	taskAssert(IsFiniteAll(VECTOR3_TO_VEC3V(m_vDirToTarget)));

	Vector3 vCoords;

	if (pPed->IsNetworkClone())
	{
		if (!static_cast<CTaskInCover*>(GetParent())->GetNetCoverPointPosition(*pPed, vCoords))
		{
			return FSM_Quit;
		}

		// get the cover information from the cover task info
		CTaskInfo *taskInfo = pPed->GetPedIntelligence()->GetQueriableInterface()->GetTaskInfoForTaskType(CTaskTypes::TASK_COVER, PED_TASK_PRIORITY_MAX);
		bool bLowCorner = false;
		if(taskInfo)
		{
			CClonedCoverInfo* pCoverInfo = static_cast<CClonedCoverInfo*>(taskInfo);
			bLowCorner = pCoverInfo->GetIsLowCorner();
		}

		m_bForcedStepOut = bLowCorner;
	}
	else if(!pPed->GetCoverPoint())
	{
		if(pPed->IsLocalPlayer())
		{
			return FSM_Quit;
		}
	}
	else 
	{
		if(!CCover::FindCoordinatesCoverPoint(pPed->GetCoverPoint(), pPed, m_vDirToTarget, vCoords))
		{
			return FSM_Quit;
		}

		m_bForcedStepOut = !pPed->IsLocalPlayer() && pPed->GetCoverPoint()->GetFlag(CCoverPoint::COVFLAGS_IsLowCorner);	
	}

	// Compute the heading we would like the ped to be at 
	bool bInHighCoverNotAtEdge = (!IsCoverFlagSet(CTaskCover::CF_AtCorner) && IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint)) || static_cast<CTaskInCover*>(GetParent())->GetForcedStepBack();
	if (IsCoverFlagSet(CTaskCover::CF_CloseToPossibleCorner))
	{
		bInHighCoverNotAtEdge = false;
	}
	const bool bForceShortStep = pPed->IsFirstPersonShooterModeEnabledForPlayer(false) && m_Flags.IsFlagSet(CAF_ShortStep) && CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations;
	CTaskInCover::ComputeTargetIntroPositionAndHeading(*pPed, IsCoverFlagSet(CTaskCover::CF_FacingLeft), !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), m_vTargetIntroPosition, m_fTargetIntroHeading, bInHighCoverNotAtEdge, IsCoverFlagSet(CTaskCover::CF_CloseToPossibleCorner), bForceShortStep);

	if ( !rage::FPIsFinite(m_vDirToTarget.x) || !rage::FPIsFinite(m_vDirToTarget.y) )
		return FSM_Quit;

#if FPS_MODE_SUPPORTED
	// If in first-person mode in low cover we need to just track the camera
	if (!pPed->IsFirstPersonShooterModeEnabledForPlayer(false) || (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AimDirectly)))
#endif
	{
		m_fTargetIntroHeading = rage::Atan2f(-m_vDirToTarget.x, m_vDirToTarget.y);
	}
	m_fTargetIntroHeading = fwAngle::LimitRadianAngle(m_fTargetIntroHeading);
	pPed->SetDesiredHeading(m_fTargetIntroHeading);

	// Tell the ped we need to call ProcesPhysics for this task
	pPed->SetPedResetFlag( CPED_RESET_FLAG_ProcessPhysicsTasks, true );

	// Force the do nothing motion state so we don't get any underlying motion coming through
	pPed->ForceMotionStateThisFrame(CPedMotionStates::MotionState_AnimatedVelocity);

	bool bTooHigh = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
	if (!bTooHigh && IsCoverFlagSet(CTaskCover::CF_AimDirectly))
	{
		pPed->SetIsCrouching(true, -1, false, true);
	}
	else
	{
		pPed->SetIsCrouching(false);
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////
	
CTask::FSM_Return CTaskAimGunFromCoverIntro::UpdateFSM( const s32 iState, const FSM_Event iEvent )
{
	FSM_Begin

		FSM_State(State_Start)
			FSM_OnUpdate
				return Start_OnUpdate();	

		FSM_State(State_Intro)	
			FSM_OnEnter
				return Intro_OnEnter();
			FSM_OnUpdate
				return Intro_OnUpdate();

		FSM_State(State_Finish)
			FSM_OnUpdate
				return FSM_Quit;

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunFromCoverIntro::ProcessMoveSignals()
{
	const int state = GetState();
	if(state == State_Intro)
	{
		CPed& rPed = *GetPed();
		if (!CPedAILodManager::ShouldDoFullUpdate(rPed))
		{
			const float fPhase = m_fAimIntroBlendSignal == 0.0f ? m_MoveNetworkHelper.GetFloat(CClipScalingHelper::ms_Clip0PhaseId) : m_MoveNetworkHelper.GetFloat(CClipScalingHelper::ms_Clip1PhaseId);
			ProcessIntroRotation(rPed, fPhase, true);
		}
		fwMvBooleanId clipFinishedId = m_fAimIntroBlendSignal == 0.0f ? CClipScalingHelper::ms_Clip0FinishedId : CClipScalingHelper::ms_Clip1FinishedId;
		if (m_MoveNetworkHelper.GetBoolean(clipFinishedId))
		{
			m_bMoveClipFinished = true;
		}

#if FPS_MODE_SUPPORTED
		if(rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			float fPitchSignal = m_UpperBodyAimPitchHelper.GetCurrentPitch();
			m_MoveNetworkHelper.SetFloat(CTaskInCover::ms_PitchId, fPitchSignal);
		}
#endif
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunFromCoverIntro::ProcessPhysics(float fTimeStep, int UNUSED_PARAM(nTimeSlice))
{
	CPed& ped = *GetPed(); 

#if __DEV
	// Debug the accumulated animated velocities
	m_fAnimatedHeadingMoved += ped.GetAnimatedAngularVelocity() * fTimeStep;
	aiDebugf2("Animated Heading Moved = %.4f", m_fAnimatedHeadingMoved);
	m_fAnimatedDistanceMoved += ped.GetAnimatedVelocity().Mag() * fTimeStep;
	aiDebugf2("Animated Distance Moved = %.4f", m_fAnimatedDistanceMoved);
#endif // __DEV

	// Debug disable any velocity scaling
	if (ms_Tunables.m_DisableIntroScaling)
		return false;

#if FPS_MODE_SUPPORTED
	camFirstPersonShooterCamera* pCamera = camInterface::GetGameplayDirector().GetFirstPersonShooterCamera(&ped);
	if (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations && ped.IsFirstPersonShooterModeEnabledForPlayer(false) &&
		(IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) || pCamera == NULL || pCamera->GetLowCoverHeightTValue(ped) == 0.0f))
		return false;
#endif // FPS_MODE_SUPPORTED

	// No need to scale if aiming directly
	if (m_Flags.IsFlagSet(CAF_NoStep))
		return false;

	// Quit if no cover point
	if (ped.IsLocalPlayer() && !ped.GetCoverPoint())
		return false;

	// Get the cover coordinates based on the target direction
	Vector3 vCoords;
	if (!CCover::FindCoverCoordinatesForPed(ped, m_vDirToTarget, vCoords))
	{
		return false;
	}

	const bool bIsPlayer = ped.IsAPlayerPed();
	// Non player peds don't get their linear velocities scaled, but enfore the angular velocity in the direction of the target
	//This causes some bad oscillations (see B* 866463)  I corrected the heading calulation in ProcessPreFSM so it should no longer be necessary
// 	if (!bIsPlayer)
// 	{
// 		Vector3 vPedForward = VEC3V_TO_VECTOR3(ped.GetTransform().GetB());
// 		const bool bClockwiseHeading = vPedForward.CrossZ(m_vDirToTarget) > 0.0f;
// 		Vector3 vDesiredAngularVelocity = VEC3V_TO_VECTOR3(NMovingGround::GetPedDesiredAngularVelocity(&ped));
// 		vDesiredAngularVelocity.z = bClockwiseHeading ? Abs(vDesiredAngularVelocity.z) : -Abs(vDesiredAngularVelocity.z);
// 		NMovingGround::SetPedDesiredAngularVelocity(&ped, VECTOR3_TO_VEC3V(vDesiredAngularVelocity));
// 	}

	// Player peds, or peds forced to step out linear velocities are forced towards the intro position, angular velocity sorted by extra heading change
	const bool bShouldSideStep = (m_bForwardBlocked && !m_bSideBlocked);
	const bool bForcedBlockAimDirectly = static_cast<CTaskInCover*>(GetParent())->GetForcedBlockAimDirectly();
	if (bForcedBlockAimDirectly)
	{
		NMovingGround::SetPedDesiredVelocity(&ped, Vec3V(V_ZERO));
		NMovingGround::SetPedVelocity(&ped, Vec3V(V_ZERO));
	}
	else if (bIsPlayer || m_bForcedStepOut || bShouldSideStep)
	{
		ApplyDesiredVelocityTowardsTarget(ped, m_vTargetIntroPosition, fTimeStep);
#if __DEV
		m_fDesiredDistanceMoved += Mag(NMovingGround::GetPedDesiredVelocity(&ped)).Getf();
		aiDebugf2("Desired Distance Moved = %.4f", m_fDesiredDistanceMoved * fTimeStep);	
#endif // __DEV
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunFromCoverIntro::Start_OnUpdate()
{
	CPed& ped = *GetPed();

	// Cache the initial position / heading
	m_fInitialHeading = ped.GetCurrentHeading();
	m_vInitialIntroPosition = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());

	// Initialise the previous target intro heading
	m_fPreviousTargetIntroHeading = m_fTargetIntroHeading;

	if (!ped.IsAPlayerPed())
	{
		const fwMvClipSetId aiWeaponClipSetId = CTaskCover::GetWeaponClipSetForArmament(&ped, !ped.IsAPlayerPed());
		const bool bClipSetLoaded = CTaskCover::IsCoverClipSetLoaded(aiWeaponClipSetId);
#if __ASSERT
		aiDisplayf("4 : Frame : %i, Clipset %s %s for ped %s", fwTimer::GetFrameCount(), aiWeaponClipSetId.GetCStr(), bClipSetLoaded ? "LOADED": "NOT LOADED", GetPed()->GetDebugName());
#endif // __ASSERT
		if (!bClipSetLoaded) //B* 1052340
			return FSM_Continue;
	}

	if (NetworkInterface::IsNetworkOpen())
	{
		// Still need to use the upper body aim anims
		const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfo();
		fwMvClipSetId clipset = pWeaponInfo->GetPedCoverWeaponClipSetId(ped);

		if(pWeaponInfo->GetAlternativeClipSetWhenBlockedId(ped))
		{
			//Test to see if we should use the higher aim
			if(!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AimDirectly))
			{
				clipset = pWeaponInfo->GetAlternativeClipSetWhenBlockedId(ped);
				ped.SetPedResetFlag(CPED_RESET_FLAG_UseAlternativeWhenBlock, true);
			}
		}

		const bool bUpperBodyClipSetLoaded = CTaskCover::IsCoverClipSetLoaded(clipset);
#if __ASSERT
		aiDisplayf("4 : Frame : %i, Upperbody Clipset %s %s for ped %s", fwTimer::GetFrameCount(), clipset.GetCStr(), bUpperBodyClipSetLoaded ? "LOADED": "NOT LOADED", GetPed()->GetDebugName());
#endif // __ASSERT
		if (!bUpperBodyClipSetLoaded) //B* 1462698
			return FSM_Continue;
	}

	SetState(State_Intro);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunFromCoverIntro::Intro_OnEnter()
{
	RequestProcessMoveSignalCalls();
	m_bMoveClipFinished = false;

	CPed& ped = *GetPed();
	
	// Override the intro anims for ai peds
	if (!ped.IsAPlayerPed())
	{
		const fwMvClipSetId aiWeaponClipSetId = CTaskCover::GetWeaponClipSetForArmament(&ped, !ped.IsAPlayerPed());
		taskAssertf(CTaskCover::IsCoverClipSetLoaded(aiWeaponClipSetId), "Clipset %s wasn't loaded for ai ped", aiWeaponClipSetId.GetCStr());
		m_MoveNetworkHelper.SetClipSet(aiWeaponClipSetId, CTaskMotionInCover::ms_WeaponClipSetId);
	}

	if(!ped.IsNetworkClone() && ped.GetNetworkObject())
	{
		CNetObjPed* pPedObj = SafeCast(CNetObjPed, ped.GetNetworkObject());
		CPedSyncTreeBase *syncTree = SafeCast(CPedSyncTreeBase, pPedObj->GetSyncTree());
		if(syncTree)
		{
			syncTree->ForceSendOfNodeData(SERIALISEMODE_UPDATE, pPedObj->GetActivationFlags(), pPedObj, *syncTree->GetPedOrientationNode());
		}
	}	

	// Still need to use the upper body aim anims
	//@@: location CTASKAIMGUNFROMCOVERINTRO_INTRO_ONENTER
	const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfo();
	fwMvClipSetId clipset = pWeaponInfo->GetPedCoverWeaponClipSetId(ped);

	if(pWeaponInfo->GetAlternativeClipSetWhenBlockedId(ped))
	{
		//Test to see if we should use the higher aim
		if(!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AimDirectly))
		{
			clipset = pWeaponInfo->GetAlternativeClipSetWhenBlockedId(ped);
			ped.SetPedResetFlag(CPED_RESET_FLAG_UseAlternativeWhenBlock, true);
		}
	}
	taskAssertf(CTaskCover::IsCoverClipSetLoaded(clipset), "Frame: %i, Clipset %s wasn't loaded for %s ped %s", fwTimer::GetFrameCount(), clipset.GetCStr(), ped.IsLocalPlayer() ? "LOCAL PLAYER" : "AI", ped.GetModelName());
	m_MoveNetworkHelper.SetClipSet(clipset);
	
	// Check for blockages if low aiming so we can change the step out position
	m_bForwardBlocked = static_cast<CTaskInCover*>(GetParent())->IsForwardAimBlocked();
	m_bSideBlocked = static_cast<CTaskInCover*>(GetParent())->IsSideAimBlocked();

	// Send the blend signal
	m_fAimIntroBlendSignal = ComputeAimIntroBlendSignal();
	m_MoveNetworkHelper.SetFloat(ms_AimIntroBlendId, m_fAimIntroBlendSignal);

	// Pass the clips we'll use to the move network and cache mover track info
	SetClipsFromAnimStateInfo();

	// Determine the extra heading need from the delta between our desired heading and predicted heading after playing our clip(s)
	aiFatalAssertf(FPIsFinite(m_fInitialHeading), "m_fInitialHeading wasn't finite");
	aiFatalAssertf(FPIsFinite(m_fClipHeading), "m_fClipHeading wasn't finite");
	const float fPredictedHeading = fwAngle::LimitRadianAngle(m_fInitialHeading + m_fClipHeading);
	aiFatalAssertf(FPIsFinite(fPredictedHeading), "fPredictedHeading wasn't finite");
	aiFatalAssertf(FPIsFinite(m_fTargetIntroHeading), "m_fTargetIntroHeading wasn't finite");

	m_fExtraHeadingNeeded = fwAngle::LimitRadianAngle(m_fTargetIntroHeading - fPredictedHeading);

#if __DEV
	Vector3 vDiff = m_vTargetIntroPosition - m_vInitialIntroPosition;
	m_fTargetDistance = vDiff.Mag();
	aiDebugf2("Target Distance %.4f", m_fTargetDistance);
#endif // __DEV

 	// Tell the parent in cover task which 'arc' to use
	if (ped.IsAPlayerPed())
	{
		const bool bFacingLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
		const s32 iCurrentArcIndex = ped.IsNetworkClone() ? static_cast<CTaskInCover*>(GetParent())->GetCurrentCoverStepNodeIndex() : -1;
		const s32 iDesiredNode = CTaskInCover::ComputeDesiredArc(ped, bFacingLeft, iCurrentArcIndex);
		static_cast<CTaskInCover*>(GetParent())->SetCurrentCoverStepNodeIndex(iDesiredNode);

		//!Inform targeting that we can re-pick a soft lock target (even if we have been holding aim button).
		if (ped.IsLocalPlayer())
		{
			ped.GetPlayerInfo()->GetTargeting().ClearSoftAim();
		}
	}

#if FPS_MODE_SUPPORTED
	if(ped.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		fwMvClipSetId clipSet = m_UpperBodyAimPitchHelper.GetDefaultClipSet(ped);
		if(clipSet != CLIP_SET_ID_INVALID)
		{
			m_MoveNetworkHelper.SetClipSet(clipSet, CTaskMotionInCover::ms_FPSIntroGripClipSetId);
		}

		const CWeapon* pWeapon = ped.GetWeaponManager() ? ped.GetWeaponManager()->GetEquippedWeapon() : NULL;
		bool bFPSUseGripAttachment = pWeapon && pWeapon->HasGripAttachmentComponent();
		m_MoveNetworkHelper.SetFlag(bFPSUseGripAttachment, CTaskMotionAiming::ms_FPSUseGripAttachment);
	}
#endif

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunFromCoverIntro::Intro_OnUpdate()
{
	CPed& ped = *GetPed();
	ped.SetPedResetFlag(CPED_RESET_FLAG_IsDoingCoverAimIntro, true);

	const crClip* pClip = m_fAimIntroBlendSignal == 0.0f ? m_MoveNetworkHelper.GetClip(ms_AimIntroClip0Id) : m_MoveNetworkHelper.GetClip(ms_AimIntroClip1Id);
	const float fPhase = m_fAimIntroBlendSignal == 0.0f ? m_MoveNetworkHelper.GetFloat(CClipScalingHelper::ms_Clip0PhaseId) : m_MoveNetworkHelper.GetFloat(CClipScalingHelper::ms_Clip1PhaseId);
	
	const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfo();
	if(pWeaponInfo && m_MoveNetworkHelper.GetClipSetId() == pWeaponInfo->GetAlternativeClipSetWhenBlockedId(ped))
	{
		ped.SetPedResetFlag(CPED_RESET_FLAG_UseAlternativeWhenBlock, true);
	}
	
	const fwMvClipSetId firstUpperBodyPitchHelperClipSetId = m_UpperBodyAimPitchHelper.GetClipSet();
	const fwMvClipSetId desiredUpperBodyClipSetId = m_UpperBodyAimPitchHelper.GetDefaultClipSet(ped);
	if (!m_UpperBodyAimPitchHelper.IsBlendedIn())
	{
		TUNE_GROUP_FLOAT(COVER_AIM_INTRO_TUNE, DEFAULT_START_BLEND_IN_PHASE, 0.2f, 0.0f, 1.0f, 0.01f);
		TUNE_GROUP_FLOAT(COVER_AIM_INTRO_TUNE, DEFAULT_END_BLEND_IN_PHASE, 0.6f, 0.0f, 1.0f, 0.01f);
		float fStartPhase = DEFAULT_START_BLEND_IN_PHASE;
		float fEndPhase = DEFAULT_END_BLEND_IN_PHASE;
		CClipEventTags::FindBlendInUpperBodyAimStartEndPhases(pClip, fStartPhase, fEndPhase);
		if (fPhase >= fStartPhase && taskVerifyf(fEndPhase >= fStartPhase, "End blend in phase was greater than start blend in phase"))		
		{
			float fBlendInDuration = pClip->ConvertPhaseToTime(fEndPhase - fStartPhase);
#if __ASSERT
			fwMvClipSetId clipset = m_UpperBodyAimPitchHelper.GetDefaultClipSet(ped);
			if (clipset != CLIP_SET_ID_INVALID)
			{
				taskAssertf(CTaskCover::IsCoverClipSetLoaded(clipset), "Frame : %i, Clipset %s wasn't loaded, previous state %s", fwTimer::GetFrameCount(), clipset.GetCStr(), GetStaticStateName(GetPreviousState()));
			}
#endif // __ASSERT

			m_UpperBodyAimPitchHelper.BlendInUpperBodyAim(m_MoveNetworkHelper, ped, fBlendInDuration, false);
		}

	}
	else
	{
#if FPS_MODE_SUPPORTED
		if (ped.IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			if (!m_SecondUpperBodyAimPitchHelper.IsBlendedIn())
			{
				if (firstUpperBodyPitchHelperClipSetId != CLIP_SET_ID_INVALID && firstUpperBodyPitchHelperClipSetId != desiredUpperBodyClipSetId)
				{
					TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, AIM_INTRO_SWITCH_BLEND_IN, 0.125f, 0.0f, 1.0f, 0.01f);
					m_SecondUpperBodyAimPitchHelper.BlendInUpperBodyAim(m_MoveNetworkHelper, ped, AIM_INTRO_SWITCH_BLEND_IN);
				}
			}
			else
			{
				m_SecondUpperBodyAimPitchHelper.Update(ped);
			}
		}
#endif // FPS_MODE_SUPPORTED
		m_UpperBodyAimPitchHelper.Update(ped);
	}
	
	ProcessIntroRotation(ped, fPhase, false);

#if __DEV
	const float fDistMoved = (m_vInitialIntroPosition - VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition())).Mag();
	aiDebugf2("Dist Moved = %.4f, (Clip Dist %.4f), (Target Dist %.4f)", fDistMoved, m_fClipDistance, m_fTargetDistance);			
#endif // __DEV

	bool bShouldInterrupt = false;

	if (!IsCoverFlagSet(CTaskCover::CF_AimDirectly) && m_MoveNetworkHelper.GetBoolean(ms_AimIntroInterruptId))
	{
		if (ped.IsNetworkClone())
		{
			if (ped.GetPedIntelligence()->GetQueriableInterface()->IsTaskCurrentlyRunning(CTaskTypes::TASK_GUN))
			{
				bShouldInterrupt = true;
			}
		}
		else if (static_cast<CTaskInCover*>(GetParent())->IsAimButtonHeldDown() || !ped.IsPlayer())
		{
			const CWeaponTarget& weaponTarget = static_cast<const CTaskInCover*>(GetParent())->GetTarget();
			Vector3 vNewTarget(VEC3_ZERO);
			if (weaponTarget.GetPosition(vNewTarget))
			{
				// Calculate a normalised directional vector between the ped and its target
				Vector3 vTargetDir = vNewTarget - VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
				vTargetDir.z = 0.0f;
				vTargetDir.Normalize();
				Vector3 vPedForward =  VEC3V_TO_VECTOR3(ped.GetTransform().GetB());
				vPedForward.z = 0.0f;
				if (vTargetDir.Dot(vPedForward) >= (1.0f - ms_Tunables.m_AiAimIntroCloseEnoughTolerance))
				{
					bShouldInterrupt = true;
				}
			}			
		}
		else
		{
			bShouldInterrupt = true;
		}
	}

// 	if (IsCoverFlagSet(CTaskCover::CF_AimDirectly) && m_bHeadingReached && !m_bNoMoverFilterSet)
// 	{
// 		m_bNoMoverFilterSet = true;
// 		static_cast<CTaskInCover*>(GetParent())->SetAimIntroFilter(CTaskInCover::ms_NoMoverFilter);
// 	}

// 	TUNE_GROUP_FLOAT(COVER_INTRO_DEBUG, TEST_INTERRUPT_PHASE, 0.93f, 0.0f, 1.0f, 0.01f);
// 	if (ped.IsAPlayerPed() && !m_Flags.IsFlagSet(CAF_NoStep) && fPhase >= TEST_INTERRUPT_PHASE)
// 	{
// 		bShouldInterrupt = true;
// 	}

	//ProcessLookIK		
	if (ped.IsLocalPlayer())
		ped.GetIkManager().LookAt(0, NULL, 1000, BONETAG_INVALID, NULL, LF_USE_CAMERA_FOCUS, 500, 500, CIkManager::IK_LOOKAT_HIGH);
	else
	{
		CPed* pCurrentTarget = ped.GetPedIntelligence()->GetCurrentTarget();
		if (pCurrentTarget)
		{
			ped.GetIkManager().LookAt(0, pCurrentTarget, 1000, BONETAG_INVALID, NULL, LF_WHILE_NOT_IN_FOV, 500, 500, CIkManager::IK_LOOKAT_HIGH);
		}
	}

	if (bShouldInterrupt || m_bMoveClipFinished)
	{
		if (m_Flags.IsFlagSet(CAF_NoStep) && !m_bNoMoverFilterSet)
		{
			m_bNoMoverFilterSet = true;
			static_cast<CTaskInCover*>(GetParent())->SetAimIntroFilter(CTaskInCover::ms_NoMoverFilter);
		}

#if FPS_MODE_SUPPORTED
		if(ped.IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			// Clear intro grip clip set
			m_MoveNetworkHelper.SetClipSet(CLIP_SET_ID_INVALID, CTaskMotionInCover::ms_FPSIntroGripClipSetId);
		}
#endif

		ped.ForceMotionStateThisFrame(CPedMotionStates::MotionState_Aiming);
		SetState(State_Finish);
		return FSM_Continue;
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskAimGunFromCoverIntro::ComputeAimIntroBlendSignal() const
{
	float fAimIntroBlendSignal = 0.0f;
	bool bForceComputeAimIntroBlendSignal = false;
#if FPS_MODE_SUPPORTED
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false) && CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations)
	{
		bForceComputeAimIntroBlendSignal = true;
	}
#endif // FPS_MODE_SUPPORTED

	if (m_Flags.IsFlagSet(CAF_NoStep) || bForceComputeAimIntroBlendSignal)
	{
		const float fHeadingDelta = fwAngle::LimitRadianAngle(m_fTargetIntroHeading - m_fInitialHeading);
		fAimIntroBlendSignal = rage::Clamp(Abs(fHeadingDelta) / PI, 0.0f, 1.0f);
	}
	else if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		if (m_Flags.IsFlagSet(CAF_LongStep))
		{
			fAimIntroBlendSignal = 1.0f;
		}
		else if (m_Flags.IsFlagSet(CAF_ShortStep))
		{
			fAimIntroBlendSignal = 0.0f;
		}
	}
	else if (GetPed()->IsLocalPlayer() && (m_bSideBlocked || m_bForwardBlocked))
	{
		fAimIntroBlendSignal = ms_Tunables.m_LowBlockedBlend;
	}

	aiDebugf2("Aim Intro Blend Signal : %.4f", fAimIntroBlendSignal);
	return fAimIntroBlendSignal;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunFromCoverIntro::SetClipsFromAnimStateInfo()
{
	s32 iFlags = m_Flags.IsFlagSet(CAF_NoStep) ? CTaskCover::AF_AimDirect : 0;

	const bool bFacingLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
	const bool bSwitchedDirection = static_cast<CTaskInCover*>(GetParent())->GetSwitchedCoverDirection();
	if (bSwitchedDirection)
	{
		if (!bFacingLeft)
		{
			iFlags |= CTaskCover::AF_FaceLeft;
		}
	}
	else
	{
		if (bFacingLeft)
		{
			iFlags |= CTaskCover::AF_FaceLeft;
		}
	}

	const CPed& rPed = *GetPed();
	if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		iFlags |= CTaskCover::AF_Low;

#if FPS_MODE_SUPPORTED
		if (!m_Flags.IsFlagSet(CAF_NoStep) && m_bForwardBlocked && rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			static_cast<CTaskInCover*>(GetParent())->SetSteppedOutToAim(true);
			iFlags |= CTaskCover::AF_AtEdge;
		}
#endif // FPS_MODE_SUPPORTED
	}

	TUNE_GROUP_BOOL(FIRST_PERSON_COVER_TUNE, USE_SCOPE_INTROS, true);
	if (USE_SCOPE_INTROS && !m_Flags.IsFlagSet(CAF_NoStep) && rPed.IsFirstPersonShooterModeEnabledForPlayer(false) && rPed.GetMotionData()->GetIsFPSScope())
	{
		iFlags |= CTaskCover::AF_Scope;
	}

	fwMvClipSetId coreMotionClipSetId = CTaskCover::ms_Tunables.GetCoreWeaponAimingClipSetIdForPed(*GetPed());
	fwMvClipSetId weaponHoldingClipSetId = m_MoveNetworkHelper.GetClipSetId(CTaskMotionInCover::ms_WeaponClipSetId);

	TUNE_GROUP_BOOL(COVER_TUNE, USE_OLD_INTROS, true);
	const CWeaponInfo* pWeaponInfo = GetPed()->GetEquippedWeaponInfo(); 
	const bool bIsRpg = pWeaponInfo && pWeaponInfo->GetIsRpg();
	const bool bShouldUseOldIntros = USE_OLD_INTROS && !GetPed()->IsPlayer() && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !bIsRpg;

	if (!GetPed()->IsAPlayerPed() && !bIsRpg && (weaponHoldingClipSetId != CLIP_SET_ID_INVALID))
	{
		coreMotionClipSetId = weaponHoldingClipSetId;
	}

	taskAssert(coreMotionClipSetId != CLIP_SET_ID_INVALID);

	m_fClipHeading = 0.0f;

	for (s32 i=0; i<ms_Tunables.m_AimIntroClips.GetCount(); i++)
	{
		if (ms_Tunables.m_AimIntroClips[i].m_Flags == iFlags)
		{
			for (s32 j=0; j<ms_Tunables.m_AimIntroClips[i].m_Clips.GetCount(); ++j)
			{
				if (ms_Tunables.m_AimIntroClips[i].m_Clips[j] != CLIP_ID_INVALID)
				{
					// TEMP for ai intros
 					fwMvClipId clipId = ms_Tunables.m_AimIntroClips[i].m_Clips[j];
					
					if (bShouldUseOldIntros)
					{
						static fwMvClipId lowLeftIntroClipId("intro_low_l_centre",0x6FFF4F50);
						static fwMvClipId lowRightIntroClipId("intro_low_r_centre",0x2B56BD01);
						clipId = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? lowLeftIntroClipId : lowRightIntroClipId;
					}

					const crClip* pClip = fwClipSetManager::GetClip(coreMotionClipSetId, clipId);
					if (pClip)
					{			
						if (m_Flags.IsFlagSet(CAF_NoStep))
						{
							float fBlendWeight = j == 0 ? 1.0f - m_fAimIntroBlendSignal : m_fAimIntroBlendSignal;
							Quaternion qClipStartRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, 0.0f);
							Quaternion qClipEndRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, 1.0f);
							aiDebugf2("Start Fixup-End Heading %.4f", qClipStartRotation.TwistAngle(ZAXIS));
							aiDebugf2("End Fixup-End Heading %.4f", qClipEndRotation.TwistAngle(ZAXIS));
							m_fClipHeading += Abs(fwAngle::LimitRadianAngle(qClipEndRotation.TwistAngle(ZAXIS) - qClipStartRotation.TwistAngle(ZAXIS)) * fBlendWeight);
							m_fClipHeading = Abs(fwAngle::LimitRadianAngle(m_fClipHeading));
							if (!IsCoverFlagSet(CTaskCover::CF_FacingLeft))
							{
								m_fClipHeading *= -1.0f;
							}
							aiDebugf2("Clip Heading Rotation %.4f", m_fClipHeading);
							m_fClipDistance += fwAnimHelpers::GetMoverTrackTranslationDiff(*pClip, 0.0f, 1.0f).Mag();
							aiDebugf2("Clip Distance %.4f", m_fClipDistance);
						}
						else if ((m_Flags.IsFlagSet(CAF_ShortStep) && j == 0)  || (m_Flags.IsFlagSet(CAF_LongStep) && j == 1))
						{
							Quaternion qClipStartRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, 0.0f);
							Quaternion qClipEndRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, 1.0f);
							aiDebugf2("Start Fixup-End Heading %.4f", qClipStartRotation.TwistAngle(ZAXIS));
							aiDebugf2("End Fixup-End Heading %.4f", qClipEndRotation.TwistAngle(ZAXIS));
							m_fClipHeading = fwAngle::LimitRadianAngle(qClipEndRotation.TwistAngle(ZAXIS) - qClipStartRotation.TwistAngle(ZAXIS));
							aiDebugf2("Clip Heading Rotation %.4f", fwAngle::LimitRadianAngle(m_fClipHeading));
							m_fClipDistance = fwAnimHelpers::GetMoverTrackTranslationDiff(*pClip, 0.0f, 1.0f).Mag();
							aiDebugf2("Clip Distance %.4f", m_fClipDistance);
						}
						m_MoveNetworkHelper.SetClip(pClip, CTaskInCover::GetClipIdForIndex(j));
					}
					const crClip* pWeaponHoldingClip = fwClipSetManager::GetClip(weaponHoldingClipSetId, clipId);
					if (pWeaponHoldingClip)
					{
						m_MoveNetworkHelper.SetClip(pWeaponHoldingClip, CTaskInCover::GetWeaponClipIdForIndex(j));
					}
				}
			}
			break;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunFromCoverIntro::IsAimIntroFromPeek() const
{
	if (GetParent() && GetParent()->GetTaskType() == CTaskTypes::TASK_IN_COVER)
	{
		return GetParent()->GetPreviousState() == CTaskInCover::State_Peeking;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunFromCoverIntro::ProcessIntroRotation(CPed& rPed, float fPhase, bool bUseGameTimeStep)
{
	// If we changed the target intro heading during the intro, we'll need to compensate for the extra heading
	if (m_fTargetIntroHeading != m_fPreviousTargetIntroHeading)
	{
		m_fExtraHeadingNeeded += fwAngle::LimitRadianAngle(m_fTargetIntroHeading - m_fPreviousTargetIntroHeading);
		m_fPreviousTargetIntroHeading = m_fTargetIntroHeading;
	}

	const float fMinPhaseToApplyExtraHeading = rPed.IsAPlayerPed() ? ms_Tunables.m_MinPhaseToApplyExtraHeadingPlayer : ms_Tunables.m_MinPhaseToApplyExtraHeadingAi;
	if (fPhase >= fMinPhaseToApplyExtraHeading)
	{
		const float fTimeStep = bUseGameTimeStep ? fwTimer::GetTimeStep() : GetTimeStep();
		TUNE_GROUP_BOOL(COVER_INTRO_DEBUG, APPLY_EXTRA_HEADING, true);

#if FPS_MODE_SUPPORTED
		if (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations && rPed.IsFirstPersonShooterModeEnabledForPlayer(false) && IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !IsCoverFlagSet(CTaskCover::CF_AimDirectly))
		{
			return;
		}
#endif // FPS_MODE_SUPPORTED

		if (APPLY_EXTRA_HEADING && fTimeStep > 0.0f)
		{	
			float fMaxAngularHeadingVelocity = rPed.IsAPlayerPed() ? ms_Tunables.m_MaxAngularHeadingVelocityPlayer : ms_Tunables.m_MaxAngularHeadingVelocityAi;
			if (static_cast<CTaskInCover*>(GetParent())->GetForcedBlockAimDirectly())
			{
				fMaxAngularHeadingVelocity = ms_Tunables.m_MaxAngularHeadingVelocityPlayerForcedStandAim;
			}
			float fDesiredExtraHeading = rage::Clamp(m_fExtraHeadingNeeded / fTimeStep, -fMaxAngularHeadingVelocity, fMaxAngularHeadingVelocity);
			fDesiredExtraHeading *= fTimeStep;
			//Displayf("Extra Heading This TimeStep = %.4f, TS: %.4f", fDesiredExtraHeading, fTimeStep);
			m_fExtraHeadingNeeded -= fDesiredExtraHeading;
			//Displayf("Extra Heading Needed = %.4f", m_fExtraHeadingNeeded);			
			rPed.GetMotionData()->SetExtraHeadingChangeThisFrame(fDesiredExtraHeading);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

#if !__FINAL
void CTaskAimGunFromCoverIntro::Debug() const
{
#if DEBUG_DRAW
	grcDebugDraw::Sphere(m_vTargetIntroPosition, 0.05f, Color_orange, false);
#endif // DEBUG_DRAW
}
#endif // !__FINAL

////////////////////////////////////////////////////////////////////////////////

// Statics
CTaskAimGunFromCoverOutro::Tunables CTaskAimGunFromCoverOutro::ms_Tunables;

IMPLEMENT_COMBAT_TASK_TUNABLES(CTaskAimGunFromCoverOutro, 0x77b281e6);

////////////////////////////////////////////////////////////////////////////////

const fwMvBooleanId CTaskAimGunFromCoverOutro::ms_AimOutroClipFinishedId("AimOutroClipFinished",0xADB763);
const fwMvBooleanId CTaskAimGunFromCoverOutro::ms_OutroToIntroAimInterruptId("OutroToIntroAimInterrupt",0xAC941EBB);
const fwMvBooleanId CTaskAimGunFromCoverOutro::ms_OutroAimInterruptId("OutroAimInterrupt",0xC6F25EE3);
const fwMvBooleanId CTaskAimGunFromCoverOutro::ms_BlendOutUpperBodyAimId("BlendOutUpperBodyAim",0x899F0438);
const fwMvFloatId CTaskAimGunFromCoverOutro::ms_AimOutroBlendId("AimOutroBlend",0x9758EFB1);

////////////////////////////////////////////////////////////////////////////////

const atArray<CTaskCover::CoverAnimStateInfo>& CTaskAimGunFromCoverOutro::Tunables::GetAimOutroAnimStateInfoForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed))
{
	FPS_MODE_SUPPORTED_ONLY( if (CTaskMotionInCover::ShouldUseFirstPersonAimingAnimations(rPed)) return m_FirstPersonAnimStateInfos.m_AimOutroAnimStateInfos; )
		return m_ThirdPersonAnimStateInfos.m_AimOutroAnimStateInfos;
}

////////////////////////////////////////////////////////////////////////////////

CTaskAimGunFromCoverOutro::CTaskAimGunFromCoverOutro(const Vector3& vTargetCoords, u32 iTaskConfigFlags, CMoveNetworkHelper& moveNetworkHelper)
: m_vTargetCoords(vTargetCoords)
, m_Flags(iTaskConfigFlags)
, m_fPreviousTargetOutroHeading(0.0f)
, m_fTargetOutroHeading(0.0f)
, m_fDesiredPitch(-1.0f)
, m_fCurrentPitch(-1.0f)
, m_fInitialHeading(-1.0f)
, m_vInitialOutroPosition(Vector3::ZeroType)
, m_vDirToTarget(Vector3::ZeroType)
, m_MoveNetworkHelper(moveNetworkHelper)
, m_fOutroBlendParam(-1.0f)
, m_bMoveClipFinished(false)
, m_bHeadingReached(false)
, m_bPositionReached(false)
, m_fClipHeading(0.0f)
, m_fAnimatedHeadingMoved(0.0f)
, m_fExtraHeadingMoved(0.0f)
, m_fExtraHeadingNeeded(0.0f)
, m_fTargetHeading(0.0f)
, m_fClipDistance(0.0f)
, m_fAnimatedDistanceMoved(0.0f)
, m_fDesiredDistanceMoved(0.0f)
, m_fTargetDistance(0.0f)
, m_fExtraDistanceNeeded(0.0f)
, m_bReverseRotation(false)
, m_fCachedGroundHeight(LARGE_FLOAT)
{
	SetInternalTaskType(CTaskTypes::TASK_AIM_GUN_FROM_COVER_OUTRO);
}

////////////////////////////////////////////////////////////////////////////////

CTaskAimGunFromCoverOutro::~CTaskAimGunFromCoverOutro()
{

}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunFromCoverOutro::CleanUp()
{
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunFromCoverOutro::ProcessPreFSM()
{
	CPed& ped = *GetPed();

	if (!ped.GetCoverPoint() && !ped.IsNetworkClone())
	{
		return FSM_Quit;
	}

#if FPS_MODE_SUPPORTED
	if (m_Flags.IsFlagSet(CAF_ToPeek) && ped.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		ped.SetPedResetFlag(CPED_RESET_FLAG_IsDoingCoverOutroToPeek, true);
	}
#endif // FPS_MODE_SUPPORTED

	const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfoFromObject();
	if (!pWeaponInfo)
	{
		pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfo();
	}

	if (!pWeaponInfo || !(pWeaponInfo->GetIsGunOrCanBeFiredLikeGun() || pWeaponInfo->GetCanBeAimedLikeGunWithoutFiring()))
	{
		if (!ped.IsNetworkClone())
		{
			return FSM_Quit;
		}
	}
	
	// Calculate a normalised directional vector between the ped and its target
	m_vDirToTarget = m_vTargetCoords - VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
	m_vDirToTarget.z = 0.0f;
	m_vDirToTarget.Normalize();

	Vector3 vCoverDir(Vector3::ZeroType);
	Vector3 vCoords(Vector3::ZeroType);
	if (!CCover::FindCoverCoordinatesForPed(ped, m_vDirToTarget, vCoords) || !CCover::FindCoverDirectionForPed(ped, vCoverDir, m_vDirToTarget))
	{
		return FSM_Quit;
	}

	const bool bFacingLeft = IsCoverFlagSet(CTaskCover::CF_FacingLeft);
	m_fTargetOutroHeading = rage::Atan2f(-vCoverDir.x, vCoverDir.y);
	if (bFacingLeft)
	{
		m_fTargetOutroHeading += HALF_PI;
	}
	else
	{
		m_fTargetOutroHeading -= HALF_PI;
	}
	m_fTargetOutroHeading = fwAngle::LimitRadianAngle(m_fTargetOutroHeading);

	// allows us to add additional heading
	ped.SetPedResetFlag(CPED_RESET_FLAG_SyncDesiredHeadingToCurrentHeading, false);

	// Tell the ped we need to call ProcessPhysics for this task
	ped.SetPedResetFlag(CPED_RESET_FLAG_ProcessPhysicsTasksTimeSliced, true );
	ped.SetPedResetFlag(CPED_RESET_FLAG_CoverOutroRunning, true );
	ped.GetMotionData()->SetIsStrafing(true);

	if (m_fOutroBlendParam > -1.0f)
	{
		m_MoveNetworkHelper.SetFloat(ms_AimOutroBlendId, m_fOutroBlendParam);
	}

	if (m_MoveNetworkHelper.IsNetworkActive())
	{
		// Update pitch parameter for the pitch aim blend, yaw is handled by torso ik
		weaponAssert(GetPed()->GetWeaponManager());
		const CWeaponInfo* pWeaponInfo = GetPed()->GetWeaponManager()->GetEquippedWeaponInfo();
		if (pWeaponInfo)
		{
			float fSweepPitchMin = -QUARTER_PI;
			float fSweepPitchMax = QUARTER_PI;

			// Get the sweep ranges from the aiming info (if it exists)
			const CAimingInfo* pAimingInfo = pWeaponInfo->GetAimingInfo();
			if (pAimingInfo)
			{	
				fSweepPitchMin = pAimingInfo->GetSweepPitchMin() * DtoR;
				fSweepPitchMax = pAimingInfo->GetSweepPitchMax() * DtoR;
			}

			// Calculate the aim vector (this determines the heading and pitch angles to point the clips in the correct direction)
			Vector3 vStart(Vector3::ZeroType);
			Vector3 vEnd(Vector3::ZeroType);
			Vector3 vTargetPos(Vector3::ZeroType);
			CUpperBodyAimPitchHelper::CalculateAimVector(&ped, vStart, vEnd, vTargetPos);

			// Compute desired pitch angle value
			float fDesiredPitch = CTaskAimGun::CalculateDesiredPitch(&ped, vStart, vEnd);

			// Map the angle to the range 0.0->1.0
			float fDesiredPitchSignal = CTaskAimGun::ConvertRadianToSignal(fDesiredPitch, fSweepPitchMin, fSweepPitchMax, false);

			// Compute the final signal value
			// Map the angle to the range 0.0->1.0
			if(fDesiredPitchSignal < 0.f)
				fDesiredPitchSignal = ((fSweepPitchMin - fDesiredPitch) / fSweepPitchMin) * 0.5f;
			else
				fDesiredPitchSignal = (fDesiredPitch / fSweepPitchMax) * 0.5f + 0.5f;

			m_fDesiredPitch = fDesiredPitchSignal;

			// Smooth the input if we've exited the intro and not forcing param changes, otherwise, force the current heading equal to the desired
			// The desired heading is smoothed so it doesn't jump too much in a timestep
			if (m_fCurrentPitch >= 0.0f)
			{
				m_fCurrentPitch = CTaskAimGun::SmoothInput(m_fCurrentPitch, m_fDesiredPitch, CTaskMotionAiming::GetTunables().m_PitchChangeRate);
			}
			else
			{
				m_fCurrentPitch = m_fDesiredPitch;
			}
			m_MoveNetworkHelper.SetFloat(CTaskInCover::ms_PitchId, m_fCurrentPitch);

			//Displayf("Current Pitch : %.2f Desired Pitch : %.2f", m_fCurrentPitch, m_fDesiredPitch);
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunFromCoverOutro::UpdateFSM( const s32 iState, const FSM_Event iEvent )
{
	FSM_Begin

		FSM_State(State_Start)
			FSM_OnUpdate
				return Start_OnUpdate();	

		FSM_State(State_Outro)	
			FSM_OnEnter
				return Outro_OnEnter();
			FSM_OnUpdate
				return Outro_OnUpdate();

		FSM_State(State_Finish)
			FSM_OnUpdate
				return FSM_Quit;

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunFromCoverOutro::ProcessPhysics(float fTimeStep, int UNUSED_PARAM(nTimeSlice))
{
	CPed& ped = *GetPed();

#if __DEV
	m_fAnimatedHeadingMoved += ped.GetAnimatedAngularVelocity() * fTimeStep;
	aiDebugf2("Animated Heading Moved = %.4f", m_fAnimatedHeadingMoved);
	m_fAnimatedDistanceMoved += ped.GetAnimatedVelocity().Mag() * fTimeStep;
	aiDebugf2("Animated Distance Moved = %.4f", m_fAnimatedDistanceMoved);
#endif // __DEV

	// Debug disable any velocity scaling
	if (ms_Tunables.m_DisableOutroScaling)
		return false;

	// Get the cover coordinates based on the target direction
	Vector3 vCoords;
	if (!CCover::FindCoverCoordinatesForPed(ped, m_vDirToTarget, vCoords))
	{
		return false;
	}

#if __ASSERT
	if(ped.GetUsingRagdoll() && ped.GetPedIntelligence())
	{
		ped.GetPedIntelligence()->PrintTasks();
		Assertf(false,"CTaskAimGunFromCoverOutro::ProcessPhysics shouldn't be called while ragdolling");
	}
#endif

	const float fCurrentHeading = ped.GetCurrentHeading();
	Vec3V vDesiredAngVelocity = NMovingGround::GetPedDesiredAngularVelocity(&ped);
	if (m_bReverseRotation)
	{
		vDesiredAngVelocity.SetZf(-vDesiredAngVelocity.GetZf());
		NMovingGround::SetPedDesiredAngularVelocity(&ped, vDesiredAngVelocity);
	}
	const float fDesiredAngVelocity = fwAngle::LimitRadianAngleSafe(vDesiredAngVelocity.GetZf());
	const float fCurrentHeadingDelta = fwAngle::LimitRadianAngle(m_fTargetOutroHeading - fCurrentHeading);
	const float fNextHeadingDelta = fwAngle::LimitRadianAngle(fCurrentHeading + fDesiredAngVelocity + ped.GetMotionData()->GetExtraHeadingChangeThisFrame());

	TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, NEAR_HEADING_TOLERANCE_1, 0.01f, 0.0f, 1.0f, 0.01f);
	if (Abs(fCurrentHeadingDelta) < NEAR_HEADING_TOLERANCE_1 && Sign(fCurrentHeadingDelta) != Sign(fNextHeadingDelta))
	{
		m_bHeadingReached = true;
	}

	// Work out the cover direction and position
	vCoords.z += 1.0f;
	Vector3 vTargetdir = vCoords - VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
	vTargetdir.z = 0.0f;
	vTargetdir.Normalize();
	float fExtraVelocity = 0.0f;

	// As we're sometimes over/under rotating the mover procedurally to nail the heading we can lose some translation
	// so bump it up a bit to compensate
	const float fOutroPhase = rage::Clamp(m_MoveNetworkHelper.GetFloat(m_fOutroBlendParam == 0.0f ? CClipScalingHelper::ms_Clip0PhaseId : CClipScalingHelper::ms_Clip1PhaseId), 0.0f, 1.0f);
	TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, MIN_PHASE_TO_APPLY_EXTRA_VELOCITY, 0.15f, 0.0f, 1.0f, 0.01f);
	float fMultiplier = 1.0f;
	if (fOutroPhase >= MIN_PHASE_TO_APPLY_EXTRA_VELOCITY)
	{
		TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, MAX_EXTRA_VELOCITY, 1.5f, 0.0f, 10.0f, 0.01f);
		fExtraVelocity = rage::Clamp(m_fExtraDistanceNeeded / fTimeStep, -MAX_EXTRA_VELOCITY, MAX_EXTRA_VELOCITY);
		m_fExtraDistanceNeeded -= Abs(fExtraVelocity * fTimeStep);
		TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, EXTRA_VELOCITY_MULTIPLIER_FPS, 1.0f, 0.0f, 10.0f, 0.01f);
		TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, EXTRA_VELOCITY_MULTIPLIER, 1.075f, 0.0f, 10.0f, 0.01f);
		TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, EXTRA_VELOCITY_MULTIPLIER_AI_LOW, 1.2f, 0.0f, 10.0f, 0.01f);
		fMultiplier = ped.IsAPlayerPed() || IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) ? EXTRA_VELOCITY_MULTIPLIER : EXTRA_VELOCITY_MULTIPLIER_AI_LOW;
#if FPS_MODE_SUPPORTED
		if (ped.IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			fMultiplier = EXTRA_VELOCITY_MULTIPLIER_FPS;
		}
#endif // FPS_MODE_SUPPORTED
	}

	// Scale the velocity to avoid oscillating about the target position
	// Compute a unit direction vector towards the intro position from our current position
	const Vector3 vCurrentPedPosition = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
	Vector3 vCurrentToOutroPosition = vCoords - vCurrentPedPosition;
	vCurrentToOutroPosition.z = 0.0f;
	// Cache the distance to the target position
	const float fDistToTarget = vCurrentToOutroPosition.Mag();

	float fSpeed = Mag(NMovingGround::GetPedDesiredVelocity(&ped)).Getf() + fExtraVelocity;
	TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, CLOSE_POSITION_TOLERANCE, 0.1f, 0.0f, 1.0f, 0.01f);
	if (fDistToTarget < CLOSE_POSITION_TOLERANCE && fDistToTarget < fSpeed * fTimeStep)
	{
		taskAssert(fTimeStep > SMALL_FLOAT);
		fSpeed = rage::Clamp(fDistToTarget / fTimeStep, 0.0f, 10.0f);
		vTargetdir.Scale(fSpeed);
	}
	else
	{
		vTargetdir.Scale(fSpeed * fMultiplier);
	}
	NMovingGround::SetPedDesiredVelocityClamped(&ped, VECTOR3_TO_VEC3V(vTargetdir), CTaskMotionBase::ms_fAccelLimitHigher*fTimeStep);
	ped.SetDesiredHeading(m_fTargetOutroHeading);

	if (!m_bHeadingReached)
	{
		TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, NEAR_HEADING_TOLERANCE, 0.001f, 0.0f, 1.0f, 0.01f);
		m_bHeadingReached = Abs(fwAngle::LimitRadianAngle(fCurrentHeading - m_fTargetOutroHeading)) < NEAR_HEADING_TOLERANCE ? true : false;
	}

	TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, NEAR_POSITION_TOLERANCE, 0.005f, 0.0f, 1.0f, 0.01f);
	// Vector3 vPedPosition = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
	m_bPositionReached = fDistToTarget < NEAR_POSITION_TOLERANCE ? true : false;
	if (m_bHeadingReached)
	{
		ped.SetHeading(m_fTargetOutroHeading);
		NMovingGround::SetPedDesiredAngularVelocity(&ped, Vec3V(V_ZERO));
		NMovingGround::SetPedAngVelocity(&ped, Vec3V(V_ZERO));
	}
	if (m_bPositionReached)
	{
		TUNE_GROUP_FLOAT(COVER_TUNE, Z_OFFSET_FOR_OUTRO_REPOSITION_GROUND_PROBE, 1.0f, 0.0f, 5.0f, 0.01f);

		if (m_fCachedGroundHeight < LARGE_FLOAT && !ped.GetGroundPhysical())
		{
			vCoords.z = m_fCachedGroundHeight;
		}
		else
		{
			Vector3 vStart = vCurrentPedPosition;
			Vector3 vEnd = vStart - Vector3(0.0f, 0.0f, Z_OFFSET_FOR_OUTRO_REPOSITION_GROUND_PROBE);
			Vector3 vIntersectionPos;
			const phInst* pHitInst = CDynamicCoverHelper::DoLineProbeTest(vStart, vEnd, vIntersectionPos, NULL, NULL, true);
			if (pHitInst)
			{
				const float fNewZCoord = vIntersectionPos.GetZ() + PED_HUMAN_GROUNDTOROOTOFFSET;
				if (Abs(fNewZCoord - vCoords.z) < 0.25f)
				{
					m_fCachedGroundHeight = fNewZCoord;
					vCoords.z = fNewZCoord;
				}
			}
		}

		const float fHeightDiff = Abs(vCoords.z - ped.GetTransform().GetPosition().GetZf());
		if (fHeightDiff < Z_OFFSET_FOR_OUTRO_REPOSITION_GROUND_PROBE)
		{
			ped.SetPosition(vCoords);
		}
#if __ASSERT
		else
		{
			taskWarningf("%s Ped %s trying to be repositioned more than 1m (%.2f) in height from original position (%.2f,%.2f,%.2f)->(%.2f,%.2f,%.2f)", ped.IsNetworkClone() ? "CLONE" : "LOCAL", ped.GetDebugName(), fHeightDiff, ped.GetTransform().GetPosition().GetXf(), ped.GetTransform().GetPosition().GetYf(), ped.GetTransform().GetPosition().GetZf(), vCoords.x, vCoords.y, vCoords.z);
		}
#endif // __ASSERT
		
		NMovingGround::SetPedDesiredVelocity(&ped, Vec3V(V_ZERO));
		NMovingGround::SetPedVelocity(&ped, Vec3V(V_ZERO));
	}

	return (!m_bPositionReached || !m_bHeadingReached);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunFromCoverOutro::ProcessMoveSignals()
{
	const int state = GetState();
	if(state == State_Outro)
	{
		CPed& rPed = *GetPed();
		rPed.SetPedResetFlag(CPED_RESET_FLAG_SyncDesiredHeadingToCurrentHeading, false);
	
		if (!CPedAILodManager::ShouldDoFullUpdate(rPed))
		{
			ProcessOutroRotation(rPed, true);
		}
		fwMvBooleanId clipFinishedId = m_fOutroBlendParam == 0.0f ? CClipScalingHelper::ms_Clip0FinishedId : CClipScalingHelper::ms_Clip1FinishedId;
		if(m_MoveNetworkHelper.GetBoolean(clipFinishedId))
		{
			m_bMoveClipFinished = true;
		}

		return true;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunFromCoverOutro::Start_OnUpdate()
{
	CPed& ped = *GetPed();

	// Cache the initial position / heading
	m_fInitialHeading = ped.GetCurrentHeading();
	m_vInitialOutroPosition = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());

	// Initialise the previous target intro heading
	m_fPreviousTargetOutroHeading = m_fTargetOutroHeading;

	SetState(State_Outro);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunFromCoverOutro::Outro_OnEnter()
{
	CPed& ped = *GetPed();

	if (!ped.IsAPlayerPed())
	{		
		fwMvClipSetId clipsetId = ChooseOutroVariationClipSetForPed(ped);
		if (clipsetId != CLIP_SET_ID_INVALID)
		{
			m_MoveNetworkHelper.SetClipSet(clipsetId, CTaskMotionInCover::ms_WeaponClipSetId);
		}
	} 
	else
	{
		// Still need to use the upper body aim anims
		const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfoFromObject() ? ped.GetWeaponManager()->GetEquippedWeaponInfoFromObject() : ped.GetWeaponManager()->GetEquippedWeaponInfo();
		
		if (aiVerify(pWeaponInfo))
		{
			const fwMvClipSetId coverWeaponClipSetId = ped.IsAPlayerPed() ? pWeaponInfo->GetPedCoverWeaponClipSetId(ped) : CTaskCover::GetAIAimingClipSetHashForArmament(&ped);
#if __BANK
			if (coverWeaponClipSetId == CLIP_SET_ID_INVALID)
			{
				aiDisplayf("Frame %u, Ped %s had an invalid cover weapon clipset for weapon %s", fwTimer::GetFrameCount(), ped.GetModelName(), pWeaponInfo->GetName());
			}
			if (!CTaskCover::IsCoverClipSetLoaded(coverWeaponClipSetId))
			{
				AI_LOG_WITH_ARGS("[Cover] - Weapon clipset %s isn't loaded for ped %s, after transition to aim outro - Equipped weapon %s, Selected weapon %s", coverWeaponClipSetId.GetCStr(), AILogging::GetDynamicEntityNameSafe(&ped), pWeaponInfo->GetName(), ped.GetWeaponManager()->GetSelectedWeaponInfo() ? ped.GetWeaponManager()->GetSelectedWeaponInfo()->GetName() : "INVALID");
			}
#endif // __BANK
			m_MoveNetworkHelper.SetClipSet(coverWeaponClipSetId, CTaskMotionInCover::ms_WeaponClipSetId);
		}
	}

	// If we stood up from low cover to fire but are now aiming out directly we need to use the best high outro anims
	if (ped.IsAPlayerPed())
	{
		CTaskInCover* pParentCoverTask = static_cast<CTaskInCover*>(GetParent());
		const bool bHigh = IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
		if (pParentCoverTask->GetStoodUpToFire() && !bHigh)
		{
			Vector3 vDirUnused;
			Vector3 vCoverDirection;
			if (CCover::FindCoverDirectionForPed(ped, vCoverDirection, vDirUnused))
			{
				const Vector3 vPedFwd = VEC3V_TO_VECTOR3(ped.GetTransform().GetB());
				if (vCoverDirection.Dot(vPedFwd) < 0.0f)
				{
					// We don't have anims that rotate us the right way in this situation
					m_bReverseRotation = true;
					bool bFaceLeft = false;
					CTaskEnterCover::ComputeCloseFacingDirectionForPed(&ped, vCoverDirection, bFaceLeft);
					if (bFaceLeft)
					{
						if (!IsCoverFlagSet(CTaskCover::CF_FacingLeft))
						{
							m_fTargetOutroHeading = fwAngle::LimitRadianAngle(m_fTargetOutroHeading + PI);
						}
						pParentCoverTask->SetCoverFlag(CTaskCover::CF_FacingLeft);
					}
					else
					{
						if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
						{
							m_fTargetOutroHeading = fwAngle::LimitRadianAngle(m_fTargetOutroHeading + PI);
						}
						pParentCoverTask->ClearCoverFlag(CTaskCover::CF_FacingLeft);
					}
				}
			}
		}
	}


	// Check for blockages if low aiming so we can change the step out position
	m_fOutroBlendParam = ComputeAimOutroBlendSignal();
	m_MoveNetworkHelper.SetFloat(ms_AimOutroBlendId, m_fOutroBlendParam);
	SetClipsFromAnimStateInfo();
	if (!m_bReverseRotation)
	{
		aiDebugf2("Initial Heading %.4f", m_fInitialHeading);
		aiDebugf2("Target Heading %.4f", m_fTargetOutroHeading);
		const float fPredictedHeading = fwAngle::LimitRadianAngle(m_fInitialHeading + m_fClipHeading);
		aiDebugf2("Predicted Heading %.4f", fPredictedHeading);
		m_fExtraHeadingNeeded = fwAngle::LimitRadianAngle(m_fTargetOutroHeading - fPredictedHeading);
	}
	else
	{
		m_fClipHeading *= -1.0f;
	}

	// Get the cover coordinates based on the target direction
	Vector3 vCoords;
	if (CCover::FindCoverCoordinatesForPed(ped, m_vDirToTarget, vCoords))
	{
		vCoords.z += 1.0f;
		//Displayf("Extra Heading Needed %.4f", m_fExtraHeadingNeeded);
		Vector3 vDiff = (vCoords-m_vInitialOutroPosition);
		m_fTargetDistance = vDiff.Mag();
		//Displayf("Target Distance %.4f", m_fTargetDistance);
		m_fExtraDistanceNeeded = m_fClipDistance  < m_fTargetDistance ? Abs(m_fTargetDistance - m_fClipDistance) : 0.0f;
		TUNE_GROUP_FLOAT(COVER_OUTRO_TUNE, EXTRA_MULTIPLIER, 0.0f, 0.0f, 10.0f, 0.1f);
		TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_OUTRO_TUNE, FPS_EXTRA_MULTIPLIER, 1.1f, 0.0f, 10.0f, 0.1f);
		float fMultiplier = EXTRA_MULTIPLIER;
		if (ShouldUseLowEdgeAnims())
		{
			fMultiplier = FPS_EXTRA_MULTIPLIER;
		}
		m_fExtraDistanceNeeded *= fMultiplier;
		m_fExtraDistanceNeeded = rage::Clamp(m_fExtraDistanceNeeded, 0.0f, 1.0f);
		//Displayf("Extra Distance Needed %.4f", m_fExtraDistanceNeeded);
	}

	RequestProcessMoveSignalCalls();
	m_bMoveClipFinished = false;
	m_UpperBodyAimPitchHelper.BlendInUpperBodyAim(m_MoveNetworkHelper, ped, INSTANT_BLEND_DURATION);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunFromCoverOutro::Outro_OnUpdate()
{
	CTaskInCover* pParentCoverTask = static_cast<CTaskInCover*>(GetParent());
	bool bShouldInterrupt = pParentCoverTask->CheckForAimOutroInterrupt();

	if (m_bReverseRotation)
	{
		pParentCoverTask->SetCoverFlag(CTaskCover::CF_FacePedInCorrectDirection);
	}

	CPed& rPed = *GetPed();
	m_UpperBodyAimPitchHelper.Update(rPed);

	const CWeaponInfo* pWeaponInfo = rPed.GetWeaponManager()->GetEquippedWeaponInfoFromObject() ? rPed.GetWeaponManager()->GetEquippedWeaponInfoFromObject() : rPed.GetWeaponManager()->GetEquippedWeaponInfo();

	if (!pWeaponInfo)
	{
		SetState(State_Finish);
		return FSM_Continue;		
	}

	// Keep the ped's underlying anims in aiming otherwise loco fucks up the ped's heading sometimes
	rPed.ForceMotionStateThisFrame(CPedMotionStates::MotionState_Aiming);

	ProcessOutroRotation(rPed, false);

	//ProcessLookIK		
	if (rPed.IsLocalPlayer())
		rPed.GetIkManager().LookAt(0, NULL, 1000, BONETAG_INVALID, NULL, LF_USE_CAMERA_FOCUS, 500, 500, CIkManager::IK_LOOKAT_HIGH);
	else
	{
		CPed* pCurrentTarget = rPed.GetPedIntelligence()->GetCurrentTarget();
		if (pCurrentTarget)
		{
			rPed.GetIkManager().LookAt(0, pCurrentTarget, 1000, BONETAG_INVALID, NULL, LF_WHILE_NOT_IN_FOV, 500, 500, CIkManager::IK_LOOKAT_HIGH);
		}
	}

#if FPS_MODE_SUPPORTED
	if (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations && rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		if (m_Flags.IsFlagSet(CAF_ToPeek))
		{
			TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_TUNE, TIME_TO_CONSIDER_PEEKING, 0.2f, 0.0f, 1.0f, 0.01f);
			if (GetTimeInState() > TIME_TO_CONSIDER_PEEKING)
			{
				rPed.SetPedResetFlag(CPED_RESET_FLAG_IsPeekingFromCover, true);
			}
		}
	}

	if(rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		TUNE_GROUP_BOOL(FIRST_PERSON_COVER_BLEND_TUNE, DISABLE_RIGHT_ARM_IK_IN_AIM_DIRECT_OUTRO, true);
		bool bDisableRightArmIkInCoverOutro = false;

		if (DISABLE_RIGHT_ARM_IK_IN_AIM_DIRECT_OUTRO && m_Flags.IsFlagSet(CAF_NoStep))
		{
			bDisableRightArmIkInCoverOutro = true;
		}
		else
		{
			float fClip0Phase = m_MoveNetworkHelper.GetFloat(CClipScalingHelper::ms_Clip0PhaseId);
			float fClip1Phase = m_MoveNetworkHelper.GetFloat(CClipScalingHelper::ms_Clip1PhaseId);

			TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_BLEND_TUNE, fCoverOutroRightIKBlendOutPhase, 0.7f, 0.0f, 1.0f, 0.01f);
			if(fClip0Phase > fCoverOutroRightIKBlendOutPhase || fClip1Phase > fCoverOutroRightIKBlendOutPhase)
			{
				bDisableRightArmIkInCoverOutro = true;
			}
		}

		bool bDisableLeftArmIkInCoverOutro = false;
		if(pWeaponInfo->GetIsGun1Handed())
		{
			if(CTaskCover::IsPlayerAimingDirectlyInFirstPerson(rPed))
			{
				bDisableLeftArmIkInCoverOutro = true;
			}
			else
			{
				bDisableLeftArmIkInCoverOutro = bDisableRightArmIkInCoverOutro;
			}
		}

		rPed.SetPedResetFlag(CPED_RESET_FLAG_DisableRightArmIKInCoverOutroFPS, bDisableRightArmIkInCoverOutro);
		rPed.SetPedResetFlag(CPED_RESET_FLAG_DisableLeftArmIKInCoverOutroFPS, bDisableLeftArmIkInCoverOutro);
	}
#endif // FPS_MODE_SUPPORTED
	//const float fDistMoved = (m_vInitialPosition - VEC3V_TO_VECTOR3(rPed.GetTransform().GetPosition())).Mag();
	//Displayf("Dist Moved = %.4f, (Clip Dist %.4f), (Target Dist %.4f)", fDistMoved, m_fClipDistance, m_fTargetDistance);	

	if (bShouldInterrupt || m_bMoveClipFinished)
	{
		SetState(State_Finish);
		return FSM_Continue;
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskAimGunFromCoverOutro::ComputeAimOutroBlendSignal() const
{
	float fAimOutroBlendSignal = 0.0f;

	if (m_Flags.IsFlagSet(CAF_NoStep))
	{
		const float fHeadingDelta = fwAngle::LimitRadianAngle(m_fTargetOutroHeading - m_fInitialHeading);
		fAimOutroBlendSignal = rage::Clamp(Abs(fHeadingDelta) / PI, 0.0f, 1.0f);
	}
	else if (IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		if (m_Flags.IsFlagSet(CAF_LongStep))
		{
			fAimOutroBlendSignal = 1.0f;
		}
		else if (m_Flags.IsFlagSet(CAF_ShortStep))
		{
			fAimOutroBlendSignal = 0.0f;
		}
	}
	else if (GetPed()->IsLocalPlayer())
	{
		// Need to have enough animated velocity to 'get us back
		const bool bForwardBlocked = static_cast<const CTaskInCover*>(GetParent())->IsForwardAimBlocked();
		const bool bSideBlocked = static_cast<const CTaskInCover*>(GetParent())->IsSideAimBlocked();
		if (bForwardBlocked || bSideBlocked)
		{
			fAimOutroBlendSignal = 0.7f;
		}
	}

	aiDebugf2("Aim Outro Blend Signal : %.4f", fAimOutroBlendSignal);
	return fAimOutroBlendSignal;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CTaskAimGunFromCoverOutro::ChooseOutroVariationClipSetForPed(CPed& ped) const
{
	if (!m_Flags.IsFlagSet(CAF_ReactToFire) || ped.IsAPlayerPed())
	{
		return CTaskCover::GetWeaponClipSetForArmament(&ped, !ped.IsAPlayerPed());
	}
	else if (ped.GetPedIntelligence()->GetCombatDirector())
	{
		if (ped.GetWeaponManager()->GetEquippedWeaponInfo())
		{
			if (ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsTwoHanded())
			{
				return ped.GetPedIntelligence()->GetCombatDirector()->GetCoverReactOutroVariations2HInfo().ChooseClipSetForPed(ped);
			}
			else if (ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetIsGun1Handed())
			{
				return ped.GetPedIntelligence()->GetCombatDirector()->GetCoverReactOutroVariations1HInfo().ChooseClipSetForPed(ped);
			}
		}
	}
	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunFromCoverOutro::SetClipsFromAnimStateInfo()
{
	s32 iFlags = m_Flags.IsFlagSet(CAF_NoStep) ? CTaskCover::AF_AimDirect : 0;

	if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
	{
		iFlags |= CTaskCover::AF_FaceLeft;
	}

	const bool bShouldUseLowEdgeAnims = ShouldUseLowEdgeAnims();
	if (!IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint))
	{
		iFlags |= CTaskCover::AF_Low;
		if (bShouldUseLowEdgeAnims)
		{
			iFlags |= CTaskCover::AF_AtEdge;
		}
	}

	CPed& rPed = *GetPed();
#if FPS_MODE_SUPPORTED
	if (!bShouldUseLowEdgeAnims && !m_Flags.IsFlagSet(CAF_NoStep) && rPed.IsFirstPersonShooterModeEnabledForPlayer(false) && m_Flags.IsFlagSet(CAF_ToPeek))
	{
		iFlags |= CTaskCover::AF_ToPeek;
	}
#endif // FPS_MODE_SUPPORTED

	m_fClipHeading = 0.0f;

	fwMvClipSetId coreMotionClipSetId = CTaskCover::ms_Tunables.GetCoreWeaponAimingClipSetIdForPed(*GetPed());
	fwMvClipSetId weaponHoldingClipSetId = m_MoveNetworkHelper.GetClipSetId(CTaskMotionInCover::ms_WeaponClipSetId);

	TUNE_GROUP_BOOL(COVER_TUNE, USE_OLD_OUTROS, true);
	const CWeaponInfo* pWeaponInfo = rPed.GetEquippedWeaponInfo(); 
	const bool bIsRpg = pWeaponInfo && pWeaponInfo->GetIsRpg();
	const bool bUseOldOutros = USE_OLD_OUTROS && !rPed.IsPlayer() && !IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && !bIsRpg;

	if (!rPed.IsAPlayerPed() && !bIsRpg && weaponHoldingClipSetId != CLIP_SET_ID_INVALID)
	{
		coreMotionClipSetId = weaponHoldingClipSetId;
	}

	const atArray<CTaskCover::CoverAnimStateInfo>& rAnimStateInfoArray = ms_Tunables.GetAimOutroAnimStateInfoForPed(rPed);
	for (s32 i=0; i<rAnimStateInfoArray.GetCount(); i++)
	{
		if (rAnimStateInfoArray[i].m_Flags == iFlags)
		{
			for (s32 j=0; j<rAnimStateInfoArray[i].m_Clips.GetCount(); ++j)
			{
				if (rAnimStateInfoArray[i].m_Clips[j] != CLIP_ID_INVALID)
				{
					// TEMP for ai intros
					fwMvClipId clipId = rAnimStateInfoArray[i].m_Clips[j];
					
					if (bUseOldOutros)
					{
						static fwMvClipId lowLeftOutroClipId("outro_low_l_centre",0xB084DA9C);
						static fwMvClipId lowRightOutroClipId("outro_low_r_centre",0x34BAF2EA);
						clipId = IsCoverFlagSet(CTaskCover::CF_FacingLeft) ? lowLeftOutroClipId : lowRightOutroClipId;
					}

					const crClip* pClip = fwClipSetManager::GetClip(coreMotionClipSetId, clipId);
					if (pClip)
					{
						s32 iStepTargetIndex = -1;
						if (m_Flags.IsFlagSet(CAF_ShortStep))
						{
							iStepTargetIndex = 0;
						}
						else if (m_Flags.IsFlagSet(CAF_LongStep))
						{
#if FPS_MODE_SUPPORTED
							// We have 4 outro clips for first person, so this pushes out the index we need to use to compute by one
							iStepTargetIndex = rPed.IsFirstPersonShooterModeEnabledForPlayer(false) ? 2 : 1;
#else // FPS_MODE_SUPPORTED
							iStepTargetIndex = 1;
#endif // FPS_MODE_SUPPORTED
						}

						if (m_Flags.IsFlagSet(CAF_NoStep))
						{
							float fBlendWeight = j == 0 ? 1.0f - m_fOutroBlendParam : m_fOutroBlendParam;
							Quaternion qClipStartRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, 0.0f);
							Quaternion qClipEndRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, 1.0f);
							aiDebugf2("Start Fixup-End Heading %.4f", qClipStartRotation.TwistAngle(ZAXIS));
							aiDebugf2("End Fixup-End Heading %.4f", qClipEndRotation.TwistAngle(ZAXIS));
							m_fClipHeading += Abs(fwAngle::LimitRadianAngle(qClipEndRotation.TwistAngle(ZAXIS) - qClipStartRotation.TwistAngle(ZAXIS)) * fBlendWeight);
							m_fClipHeading = Abs(fwAngle::LimitRadianAngle(m_fClipHeading));
							if (IsCoverFlagSet(CTaskCover::CF_FacingLeft))
							{
								m_fClipHeading *= -1.0f;
							}
							aiDebugf2("Clip Heading Rotation %.4f", m_fClipHeading);
							//m_fClipDistance += fwAnimHelpers::GetMoverTrackTranslationDiff(*pClip, 0.0f, 1.0f).Mag();
							aiDebugf2("Clip Distance %.4f", m_fClipDistance);
						}
						else if ((m_Flags.IsFlagSet(CAF_ShortStep) && j == iStepTargetIndex)  || (m_Flags.IsFlagSet(CAF_LongStep) == 1.0f && j == iStepTargetIndex))
						{
							Quaternion qClipStartRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, 0.0f);
							Quaternion qClipEndRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, 1.0f);
							aiDebugf2("Start Fixup-End Heading %.4f", qClipStartRotation.TwistAngle(ZAXIS));
							aiDebugf2("End Fixup-End Heading %.4f", qClipEndRotation.TwistAngle(ZAXIS));
							m_fClipHeading = fwAngle::LimitRadianAngle(qClipEndRotation.TwistAngle(ZAXIS) - qClipStartRotation.TwistAngle(ZAXIS));
							aiDebugf2("Clip Heading Rotation %.4f", m_fClipHeading);
							m_fClipDistance = fwAnimHelpers::GetMoverTrackTranslationDiff(*pClip, 0.0f, 1.0f).Mag();
							aiDebugf2("Clip Distance %.4f", m_fClipDistance);
						}
						m_MoveNetworkHelper.SetClip(pClip, CTaskInCover::GetClipIdForIndex(j));
						if (weaponHoldingClipSetId != CLIP_SET_ID_INVALID)
						{
							const crClip* pWeaponHoldingClip = fwClipSetManager::GetClip(weaponHoldingClipSetId, clipId);
							if (pWeaponHoldingClip)
							{
								m_MoveNetworkHelper.SetClip(pWeaponHoldingClip, CTaskInCover::GetWeaponClipIdForIndex(j));
								m_MoveNetworkHelper.SetFlag(false, CTaskMotionInCover::ms_UseGripClipId);
							}
						}
					}
				}
			}
			break;
		}
	}
}


////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunFromCoverOutro::ProcessOutroRotation(CPed& rPed, bool bUseGameTimeStep)
{
	const bool bInHighCoverNotAtEdge = !IsCoverFlagSet(CTaskCover::CF_AtCorner) && IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint);
	TUNE_GROUP_FLOAT(COVER_OUTRO_DEBUG, MIN_PHASE_TO_APPLY_EXTRA_HEADING_HIGH_CENTER_COVER, 0.0f, 0.0f, 1.0f, 0.01f);
	TUNE_GROUP_FLOAT(COVER_OUTRO_DEBUG, MIN_PHASE_TO_APPLY_EXTRA_HEADING, 0.1f, 0.0f, 1.0f, 0.01f);
	const float fMinPhaseToApplyExtraHeading = bInHighCoverNotAtEdge ? MIN_PHASE_TO_APPLY_EXTRA_HEADING_HIGH_CENTER_COVER : MIN_PHASE_TO_APPLY_EXTRA_HEADING;
	const float fOutroPhase = rage::Clamp(m_MoveNetworkHelper.GetFloat(m_fOutroBlendParam == 0.0f ? CClipScalingHelper::ms_Clip0PhaseId : CClipScalingHelper::ms_Clip1PhaseId), 0.0f, 1.0f);
	if (fOutroPhase >= fMinPhaseToApplyExtraHeading)
	{
		const float fTimeStep = bUseGameTimeStep ? fwTimer::GetTimeStep() : GetTimeStep();
		TUNE_GROUP_BOOL(COVER_OUTRO_DEBUG, APPLY_EXTRA_HEADING, true);
		if (APPLY_EXTRA_HEADING && fTimeStep > 0.0f)
		{	
			float fMaxAngularHeadingVelocity = rPed.IsAPlayerPed() ? ms_Tunables.m_MaxAngularHeadingVelocityPlayer : ms_Tunables.m_MaxAngularHeadingVelocityAi;
#if FPS_MODE_SUPPORTED
			if (rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
			{
				fMaxAngularHeadingVelocity = ms_Tunables.m_MaxAngularHeadingVelocityPlayerFPS;
			}
#endif // FPS_MODE_SUPPORTED
			if (static_cast<CTaskInCover*>(GetParent())->GetForcedBlockAimDirectly())
			{
				fMaxAngularHeadingVelocity = ms_Tunables.m_MaxAngularHeadingVelocityPlayerForcedStandAim;
			}
			float fDesiredExtraHeading = rage::Clamp(m_fExtraHeadingNeeded / fTimeStep, -fMaxAngularHeadingVelocity, fMaxAngularHeadingVelocity);
			fDesiredExtraHeading *= fTimeStep;
			aiDebugf2("Extra Heading This TimeStep = %.4f, TS: %.4f", fDesiredExtraHeading, fTimeStep);
			m_fExtraHeadingNeeded -= fDesiredExtraHeading;
			aiDebugf2("Extra Heading Needed = %.4f", m_fExtraHeadingNeeded);			
			rPed.GetMotionData()->SetExtraHeadingChangeThisFrame(fDesiredExtraHeading);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunFromCoverOutro::ShouldUseLowEdgeAnims() const
{
#if FPS_MODE_SUPPORTED
	return !m_Flags.IsFlagSet(CAF_NoStep) && static_cast<const CTaskInCover*>(GetParent())->GetSteppedOutToAim() && GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false);
#else
	return false;
#endif 
}

////////////////////////////////////////////////////////////////////////////////

const fwMvBooleanId CTaskAimGunBlindFire::ms_BlockTransitionFromAimOutroId("BlockTransitionFromAimOutro", 0x35a7bd7c);
const fwMvBooleanId	CTaskAimGunBlindFire::ms_BlindFireOutroInterruptId("BlindFireOutroInterrupt",0x5F033115);
const fwMvBooleanId	CTaskAimGunBlindFire::ms_BlindFireIntroClipFinishedId("BlindFireIntroClipFinished",0x9B2D26);
const fwMvBooleanId	CTaskAimGunBlindFire::ms_BlindFireLoopClipFinishedId("BlindFireLoopClipFinished",0xEC97C029);
const fwMvBooleanId	CTaskAimGunBlindFire::ms_BlindFireOutroClipFinishedId("BlindFireOutroClipFinished",0xF631158D);
const fwMvBooleanId CTaskAimGunBlindFire::ms_CockGunClipFinishedId("CockGunClipFinished",0xE4BD4946);
const fwMvBooleanId CTaskAimGunBlindFire::ms_CockInterruptId("CockInterrupt",0x7EA953A4);
const fwMvBooleanId CTaskAimGunBlindFire::ms_InterruptToCockGunId("InterruptToCockGun",0x64992BB);

const fwMvRequestId	CTaskAimGunBlindFire::ms_NewBlindFireSolutionRequestId("NewBlindFireSolution",0xEA868CFE);
const fwMvRequestId	CTaskAimGunBlindFire::ms_BlindFireLoopRequestId("BlindFireLoop",0x8257C753);
const fwMvRequestId CTaskAimGunBlindFire::ms_BlindFireLoopRestartRequestId("RestartFireLoop",0x80514226);
const fwMvRequestId	CTaskAimGunBlindFire::ms_BlindFireOutroRequestId("BlindFireOutro",0x8D82E3B1);
const fwMvRequestId	CTaskAimGunBlindFire::ms_BlindFireIntroRequestId("BlindFireIntro",0x8E645BD3);
const fwMvRequestId	CTaskAimGunBlindFire::ms_CockGunRequestId("CockGun",0xBAB90FB6);

const fwMvBooleanId	CTaskAimGunBlindFire::ms_BlindFiringIntroOnEnterId("BlindFiringIntro_OnEnter",0x4D1D6565);
const fwMvBooleanId	CTaskAimGunBlindFire::ms_BlindFiringLoopOnEnterId("BlindFiringLoop_OnEnter",0xF8516EF8);
const fwMvBooleanId	CTaskAimGunBlindFire::ms_BlindFiringOutroOnEnterId("BlindFiringOutro_OnEnter",0xB98A8CF6);
const fwMvBooleanId CTaskAimGunBlindFire::ms_CockGunOnEnterId("CockGun_OnEnter",0x32D1E1DB);
const fwMvBooleanId	CTaskAimGunBlindFire::ms_IKLeftHandUseGripBoneId("IK_LH_UseGripBone", 0x339A6863);

const fwMvBooleanId	CTaskAimGunBlindFire::ms_FireClipFinishedId("Loop_Finished",0x82AF5D7);

const fwMvClipId CTaskAimGunBlindFire::ms_BlindFireIntroClipId("BlindFireIntroClip",0xF81C8054);
const fwMvClipId CTaskAimGunBlindFire::ms_BlindFireLoopClipId("BlindFireLoopClip",0xD197A250);
const fwMvClipId CTaskAimGunBlindFire::ms_BlindFireOutroClipId("BlindFireOutroClip",0xDE704624);
const fwMvClipId CTaskAimGunBlindFire::ms_BlindFireOutroClip1Id("BlindFireOutroClip1",0xa31002a1);

const fwMvFloatId CTaskAimGunBlindFire::ms_BlindFireIntroPhaseId("BlindFireIntroPhase",0xCBE9629C);
const fwMvFloatId CTaskAimGunBlindFire::ms_BlindFireIntroBlendId("BlindFireIntroBlend",0x30F629BE);
const fwMvFloatId CTaskAimGunBlindFire::ms_BlindFireSweepBlendId("BlindFireSweepBlend",0x21A83D00);
const fwMvFloatId CTaskAimGunBlindFire::ms_BlindFireSweepPhaseId("BlindFireSweepPhase",0x95FACDD7);

const fwMvFloatId CTaskAimGunBlindFire::ms_BlindFireAimBlendDurationId("BlindFireAimBlendDuration",0x701D5158);

// Recoil support
const fwMvClipSetVarId	CTaskAimGunBlindFire::ms_FireClipSetVarId("FireClipSet",0xC62DDEC0);
const fwMvClipId		CTaskAimGunBlindFire::ms_FireClipId("FIRE_MED",0xB71CA63A);
const fwMvClipId		CTaskAimGunBlindFire::ms_FireRecoilClipId("FIRE_RECOIL",0x16156B9F);
const fwMvBooleanId		CTaskAimGunBlindFire::ms_FireId("Fire",0xD30A036B);
const fwMvBooleanId		CTaskAimGunBlindFire::ms_FireLoopOnEnterId("FireLoop_OnEnter",0xC2FAEB5E);
const fwMvBooleanId		CTaskAimGunBlindFire::ms_FireLoop1OnExitId("FireLoop1_OnExit",0xCF9D5A3E);
const fwMvBooleanId		CTaskAimGunBlindFire::ms_FireLoop2OnExitId("FireLoop2_OnExit",0x41C0AD65);
const fwMvRequestId		CTaskAimGunBlindFire::ms_FireRequestId("Fire",0xD30A036B);
const fwMvRequestId		CTaskAimGunBlindFire::ms_FireFinishedRequestId("FireFinished",0xD30314E9);
const fwMvFloatId		CTaskAimGunBlindFire::ms_FireRateId("FireRate",0x41659CDC);
const fwMvFlagId		CTaskAimGunBlindFire::ms_FiringFlagId("Firing",0x544C888B);
const fwMvFlagId		CTaskAimGunBlindFire::ms_IsRightSideId("IsRightSide", 0x7d267d2e);

////////////////////////////////////////////////////////////////////////////////

// Statics
CTaskAimGunBlindFire::Tunables CTaskAimGunBlindFire::ms_Tunables;

IMPLEMENT_COMBAT_TASK_TUNABLES(CTaskAimGunBlindFire, 0xf76c42fe);

////////////////////////////////////////////////////////////////////////////////

float CTaskAimGunBlindFire::BlindFireAnimStateInfoNew::GetBlindFireMinPitchAngleForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed)) const
{
	FPS_MODE_SUPPORTED_ONLY( if (CTaskMotionInCover::ShouldUseFirstPersonAimingAnimations(rPed)) return m_FirstPersonPersonBlindFirePitchAngles.m_MinPitchAngle; )
	return m_ThirdPersonBlindFirePitchAngles.m_MinPitchAngle;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskAimGunBlindFire::BlindFireAnimStateInfoNew::GetBlindFireMaxPitchAngleForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed)) const
{
	FPS_MODE_SUPPORTED_ONLY( if (CTaskMotionInCover::ShouldUseFirstPersonAimingAnimations(rPed)) return m_FirstPersonPersonBlindFirePitchAngles.m_MaxPitchAngle; )
	return m_ThirdPersonBlindFirePitchAngles.m_MaxPitchAngle;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskAimGunBlindFire::BlindFireAnimStateInfoNew::GetBlindFireMinPitchAngle2HForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed)) const
{
	FPS_MODE_SUPPORTED_ONLY( if (CTaskMotionInCover::ShouldUseFirstPersonAimingAnimations(rPed)) return m_FirstPersonPersonBlindFirePitchAngles.m_MinPitchAngle2H; )
	return m_ThirdPersonBlindFirePitchAngles.m_MinPitchAngle2H;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskAimGunBlindFire::BlindFireAnimStateInfoNew::GetBlindFireMaxPitchAngle2HForPed(const CPed& FPS_MODE_SUPPORTED_ONLY(rPed)) const
{
	FPS_MODE_SUPPORTED_ONLY( if (CTaskMotionInCover::ShouldUseFirstPersonAimingAnimations(rPed)) return m_FirstPersonPersonBlindFirePitchAngles.m_MaxPitchAngle2H; )
	return m_ThirdPersonBlindFirePitchAngles.m_MaxPitchAngle2H;
}

////////////////////////////////////////////////////////////////////////////////

float CTaskAimGunBlindFire::CalculateDesiredYaw(const Matrix34& mRefMtx, const Vector3& vStart, const Vector3& vEnd)
{
	// Calculate the direction to the target
	Vector3 vDir = vEnd - vStart;
	vDir.Normalize();

	// Transform direction into peds local space to make it relative to the ped
	mRefMtx.UnTransform3x3(vDir);

	vDir.Normalize(); // normalize again in case of a non-orthonormal ped matrix.

	if (!taskVerifyf(rage::FPIsFinite(vDir.x) && rage::FPIsFinite(vDir.y), "Invalid direction vector vStart : (%.4f, %.4f, %.4f) : vEnd : (%.4f, %.4f, %.4f)", vStart.x, vStart.y, vStart.z, vEnd.x, vEnd.y, vEnd.z))
	{
		return 0.0f;
	}

	// Get the angle of rotation about the z axis, i.e. the yaw
	float fYaw = rage::Atan2f(vDir.x, vDir.y);
	return fwAngle::LimitRadianAngle(fYaw);
}

////////////////////////////////////////////////////////////////////////////////

CTaskAimGunBlindFire::CTaskAimGunBlindFire(const CWeaponController::WeaponControllerType weaponControllerType, const fwFlags32& iFlags, const CWeaponTarget& target, CMoveNetworkHelper& moveNetworkHelper, const CGunIkInfo& ikInfo)
: CTaskAimGun(weaponControllerType, iFlags, 0, target)
, m_MoveNetworkHelper(moveNetworkHelper)
, m_ikInfo(ikInfo)
, m_pTaskUseCoverMoveNetworkHelper(NULL)
, m_targetFireCounter(0)
, m_fIntroHeadingBlend(0.5f)
, m_fDesiredHeading(-1.0f)
, m_fCurrentHeading(-1.0f)
, m_fDesiredPitch(-1.0f)
, m_fCurrentPitch(0.5f)
, m_fOutroHeadingBlend(0.5f)
, m_CachedWeaponHash(0)
, m_fBlindFireAimBlendDuration(NORMAL_BLEND_DURATION)
, m_pCachedAnimStateInfoNew(NULL)
, m_bUsesFireEvents(false)
, m_bFire(false)
, m_bFirstFire(true)
, m_bFireLoopClipFinished(false)
, m_bFiredOnce(false)
, m_bFiredTwice(false)
, m_bFireLoopOnEnter(false)
, m_bOutroPending(false)
, m_bEndTaskRequested(false)
, m_bMoveFireLoopClipFinished(false)
, m_bMoveFireLoopOnEnter(false)
, m_bMoveFire(false)
, m_bMoveFireLoop1(false)
, m_bMoveFireLoop2(false)
, m_bMoveInterruptToCockGun(false)
, m_bMoveBlindFireIntroClipFinished(false)
, m_bMoveBlindFireOutroClipFinished(false)
, m_bMoveCockGunClipFinished(false)
, m_bMoveCockInterrupt(false)
, m_bMoveAimIntroInterrupt(false)
, m_bMoveIKLeftHandUseGripBone(false)
, m_bCornerToTopBlindFireTransition(false)
, m_bBlockOutroRefire(false)
, m_bAtDoor(false)
, m_bPopAimParams(false)
, m_bIsOverTheTop(false)
, m_bUsingAtEdgeAnims(false)
{
	SetInternalTaskType(CTaskTypes::TASK_AIM_GUN_BLIND_FIRE);
}

////////////////////////////////////////////////////////////////////////////////

CTaskAimGunBlindFire::~CTaskAimGunBlindFire()
{

}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunBlindFire::CleanUp()
{
	// Base class
	CTaskAimGun::CleanUp();
}

////////////////////////////////////////////////////////////////////////////////

// Returns the current weapon controller state for the specified ped
WeaponControllerState CTaskAimGunBlindFire::GetWeaponControllerState(const CPed* pPed) const
{
	return CWeaponControllerManager::GetController(m_weaponControllerType)->GetState(pPed, false);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunBlindFire::IsValidForFPSIk(bool bLowCover) const
{
	if (!GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
		return false;

	if (GetState() != State_OutroNew)
		return true;

	if (!m_pTaskUseCoverMoveNetworkHelper || !m_pTaskUseCoverMoveNetworkHelper->IsNetworkActive())
		return true;

	float fClip0Phase = m_pTaskUseCoverMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip0PhaseId);
	float fClip1Phase = m_pTaskUseCoverMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip1PhaseId);

	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_BLEND_TUNE, fCoverLowBlindFireOutroRightIKBlendOutPhase, 0.5f, 0.0f, 1.0f, 0.01f);
	TUNE_GROUP_FLOAT(FIRST_PERSON_COVER_BLEND_TUNE, fCoverHighBlindFireOutroRightIKBlendOutPhase, 0.1f, 0.0f, 1.0f, 0.01f);
	const float fPhaseToTest = bLowCover ? fCoverLowBlindFireOutroRightIKBlendOutPhase : fCoverHighBlindFireOutroRightIKBlendOutPhase;
	if(fClip0Phase > fPhaseToTest || fClip1Phase > fPhaseToTest)
	{
		return false;
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunBlindFire::CanInterruptOutro() const
{
	if (!m_pTaskUseCoverMoveNetworkHelper)
		return false;

	if (!m_pTaskUseCoverMoveNetworkHelper->IsNetworkActive())
		return false;

	return !m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_BlockTransitionFromAimOutroId);
}

////////////////////////////////////////////////////////////////////////////////

CTaskInfo *CTaskAimGunBlindFire::CreateQueriableState() const
{
	return rage_new CClonedAimGunBlindFireInfo(GetState(), m_fireCounter, m_iAmmoInClip, m_seed);
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunBlindFire::ReadQueriableState(CClonedFSMTaskInfo* pTaskInfo)
{
	CClonedAimGunBlindFireInfo *pAimGunInfo = static_cast<CClonedAimGunBlindFireInfo*>(pTaskInfo);

	if (pAimGunInfo->GetFireCounter() > m_fireCounter)
	{
		m_iAmmoInClip   = pAimGunInfo->GetAmmoInClip() + 1;
	}
	else
	{
		m_iAmmoInClip   = pAimGunInfo->GetAmmoInClip();
	}

	m_targetFireCounter = pAimGunInfo->GetFireCounter();
	m_seed              = pAimGunInfo->GetSeed();

	// Call the base implementation - syncs the state
	CTaskFSMClone::ReadQueriableState(pTaskInfo);
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::UpdateClonedFSM(const s32 iState, const FSM_Event iEvent)
{
	return UpdateFSM(iState, iEvent);
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::ProcessPreFSM()
{
	CPed* pPed = GetPed();

	if (!taskVerifyf(pPed->GetWeaponManager()->GetEquippedWeaponInfo(), "NULL weapon info"))
	{
		return FSM_Quit;
	}

	if (!pPed->GetWeaponManager()->GetIsArmedGunOrCanBeFiredLikeGun())
	{
		return FSM_Quit;
	}

	if (!pPed->GetCoverPoint() && !pPed->IsNetworkClone())
	{
		return FSM_Quit;
	}

	if(!pPed->IsNetworkClone())
	{
		CPedWeaponManager* pWeaponManager = GetPed()->GetWeaponManager();
		CWeapon* pEquippedWeapon = pWeaponManager->GetEquippedWeapon();
		if (pEquippedWeapon && pEquippedWeapon->GetWeaponInfo() && m_CachedWeaponHash > 0 )
		{
			if(pEquippedWeapon->GetWeaponInfo()->GetHash() != m_CachedWeaponHash)
			{
				return FSM_Quit;
			}
		}
	}

	// Apply the Ik - need to blend the ik in/out for intro/outro?
	m_ikInfo.ApplyIkInfo(pPed);
	
	pPed->SetPedResetFlag( CPED_RESET_FLAG_ProcessPostCamera, true );
	pPed->SetPedResetFlag( CPED_RESET_FLAG_ProcessPostPreRender, true );
	pPed->SetPedResetFlag( CPED_RESET_FLAG_IsBlindFiring, true );

	// Base class
	return CTaskAimGun::ProcessPreFSM();
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::UpdateFSM(const s32 iState, const FSM_Event iEvent)
{
	FSM_Begin

		FSM_State(State_Start)
			FSM_OnUpdate
				return Start_OnUpdate();	

		FSM_State(State_IntroNew)
			FSM_OnEnter
				return IntroNew_OnEnter();
			FSM_OnUpdate
				return IntroNew_OnUpdate();
			FSM_OnExit
				IntroNew_OnExit();
	
		FSM_State(State_FireNew)
			FSM_OnEnter
				return FireNew_OnEnter();
			FSM_OnUpdate
				return FireNew_OnUpdate();
			FSM_OnExit
				return FireNew_OnExit();
	
		FSM_State(State_OutroNew)
			FSM_OnEnter
				return OutroNew_OnEnter();
			FSM_OnUpdate
				return OutroNew_OnUpdate();
			FSM_OnExit
				OutroNew_OnExit();

		FSM_State(State_CockGun)
			FSM_OnEnter
				return CockGun_OnEnter();
			FSM_OnUpdate
				return CockGun_OnUpdate();

		FSM_State(State_Finish)
			FSM_OnUpdate
				return FSM_Quit;

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::ProcessPostFSM()
{	
	if (m_pTaskUseCoverMoveNetworkHelper && m_pTaskUseCoverMoveNetworkHelper->IsNetworkActive() && m_pCachedAnimStateInfoNew)
	{
		TUNE_GROUP_BOOL(COVER_BLINDFIRE_TUNE, DEBUG_SWEEPS, false);
		if (DEBUG_SWEEPS)
		{
			TUNE_GROUP_FLOAT(COVER_BLINDFIRE_TUNE, DEFAULT_INTRO_BLEND, 0.5f, 0.0f, 1.0f, 0.01f);
			TUNE_GROUP_FLOAT(COVER_BLINDFIRE_TUNE, DEFAULT_SWEEP_BLEND, 0.5f, 0.0f, 1.0f, 0.01f);
			TUNE_GROUP_FLOAT(COVER_BLINDFIRE_TUNE, DEFAULT_SWEEP_PHASE, 0.5f, 0.0f, 1.0f, 0.01f);

			m_pTaskUseCoverMoveNetworkHelper->SetFloat(ms_BlindFireIntroBlendId, DEFAULT_INTRO_BLEND);
			m_pTaskUseCoverMoveNetworkHelper->SetFloat(ms_BlindFireSweepBlendId, DEFAULT_SWEEP_BLEND);
			m_pTaskUseCoverMoveNetworkHelper->SetFloat(ms_BlindFireSweepPhaseId, DEFAULT_SWEEP_PHASE);
		}
		else
		{
			CPed* pPed = GetPed();

			TUNE_GROUP_FLOAT(COVER_BLINDFIRE_TUNE, HEADING_CHANGE_RATE, 1.0f, 0.0f, 10.0f, 0.01f);
			TUNE_GROUP_FLOAT(COVER_BLINDFIRE_TUNE, PITCH_CHANGE_RATE, 1.0f, 0.0f, 10.0f, 0.01f);
			const float fSweepHeadingMin = m_pCachedAnimStateInfoNew->m_MinHeadingAngle;
			const float fSweepHeadingMax = m_pCachedAnimStateInfoNew->m_MaxHeadingAngle;

			// Calculate the aim vector (this determines the heading and pitch angles to point the clips in the correct direction)
			Vector3 vStart(Vector3::ZeroType);
			Vector3 vEnd(Vector3::ZeroType);
			Matrix34 mWeapon;		
			const CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();		

			bool bIs2Handed = pWeapon && pWeapon->GetWeaponInfo() && pWeapon->GetWeaponInfo()->GetIsGun2Handed();
			const float fSweepPitchMin = bIs2Handed ? m_pCachedAnimStateInfoNew->GetBlindFireMinPitchAngle2HForPed(*pPed) : m_pCachedAnimStateInfoNew->GetBlindFireMinPitchAngleForPed(*pPed);
			const float fSweepPitchMax = bIs2Handed ? m_pCachedAnimStateInfoNew->GetBlindFireMaxPitchAngle2HForPed(*pPed) : m_pCachedAnimStateInfoNew->GetBlindFireMaxPitchAngleForPed(*pPed);

			const CObject* pWeaponObject = pPed->GetWeaponManager()->GetEquippedWeaponObject();
			if (pWeaponObject)
				pWeaponObject->GetMatrixCopy(mWeapon);
			bool bComputeParams=true;
			if (pWeapon && pPed->IsLocalPlayer() && 
				( pPed->GetWeaponManager()->GetIsArmedGunOrCanBeFiredLikeGun() || pPed->GetWeaponManager()->GetEquippedVehicleWeapon() ) && 
				pWeapon->CalcFireVecFromAimCamera(NULL, mWeapon, vStart, vEnd))		
			{
				if (pPed->GetPlayerInfo() && pPed->GetPlayerResetFlag(CPlayerResetFlags::PRF_ASSISTED_AIMING_ON))
				{
					CPlayerPedTargeting &targeting	= const_cast<CPlayerPedTargeting &>(pPed->GetPlayerInfo()->GetTargeting());
					if(targeting.GetLockOnTarget())
					{
						vEnd = targeting.GetLockonTargetPos();
					}
				}

				taskAssert(!vStart.IsEqual(VEC3_ZERO) && !vEnd.IsEqual(VEC3_ZERO));	

				if (GetState() != State_IntroNew)
				{				
					WorldProbe::CShapeTestHitPoint probeIsect;
					WorldProbe::CShapeTestResults probeResults(probeIsect);
					WorldProbe::CShapeTestProbeDesc probeDesc;
					probeDesc.SetResultsStructure(&probeResults);
					probeDesc.SetStartAndEnd(vStart, vEnd);
					probeDesc.SetIncludeFlags(ArchetypeFlags::GTA_WEAPON_TYPES);
					probeDesc.SetTypeFlags(ArchetypeFlags::GTA_WEAPON_TYPES);
					probeDesc.SetExcludeTypeFlags(TYPE_FLAGS_NONE);
					probeDesc.SetExcludeEntity(pPed, 0);
					probeDesc.SetContext(WorldProbe::LOS_GeneralAI);
					if(WorldProbe::GetShapeTestManager()->SubmitTest(probeDesc))
					{				
						vEnd = probeResults[0].GetHitPosition();
					} 		
				}
				vStart = pPed->GetBonePositionCached(BONETAG_NECK);

				Vector3 vMuzzle;
				pWeapon->GetMuzzlePosition(mWeapon, vMuzzle);
				Vector3 bulletDir = vEnd-mWeapon.d;
				bulletDir.Normalize();
				float error = bulletDir.Dot(mWeapon.a);
				if (fabs(error) < 0.5f)				
					m_iGunFireFlags.SetFlag(GFF_EnableDumbFire);				
				else
					m_iGunFireFlags.ClearFlag(GFF_EnableDumbFire);

			} 
			else if (!pWeapon || !CalculateFiringVector(pPed, vStart, vEnd)) 
			{
				bComputeParams = false;
			}
			else if (GetTarget().GetIsValid())
			{
				GetTarget().GetPosition(vEnd);
			}

			if (bComputeParams)
			{
				CTaskInCover* pTaskInCover = static_cast<CTaskInCover*>(pPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_IN_COVER));
				// Compute desired yaw angle value
				Matrix34 mCoverMtx = MAT34V_TO_MATRIX34(pPed->GetTransform().GetMatrix());
				static float ROTATE_Z = HALF_PI;
				if (pTaskInCover->IsCoverFlagSet(CTaskCover::CF_FacingLeft))
					mCoverMtx.RotateLocalZ(-ROTATE_Z);
				else
					mCoverMtx.RotateLocalZ(ROTATE_Z);

				float fDesiredYaw = CalculateDesiredYaw(mCoverMtx, vStart, vEnd);			

				// Map the desired target heading to 0-1, depending on the range of the sweep
				m_fDesiredHeading = CTaskAimGun::ConvertRadianToSignal(fDesiredYaw, fSweepHeadingMin, fSweepHeadingMax, false);

				// The desired heading is smoothed so it doesn't jump too much in a timestep
				if (m_bPopAimParams)
					m_fCurrentHeading = m_fDesiredHeading;
				else
					m_fCurrentHeading = CTaskAimGun::SmoothInput(m_fCurrentHeading, m_fDesiredHeading, HEADING_CHANGE_RATE);
				
				// Send the heading signal				
				m_pTaskUseCoverMoveNetworkHelper->SetFloat(ms_BlindFireSweepPhaseId, m_fCurrentHeading);

				// Compute desired pitch angle value
				float fDesiredPitch = CTaskAimGun::CalculateDesiredPitch(pPed, vStart, vEnd, true);

				// Map the angle to the range 0.0->1.0
				m_fDesiredPitch = CTaskAimGun::ConvertRadianToSignal(fDesiredPitch, fSweepPitchMin, fSweepPitchMax, false);

				// Compute the final signal value
				if (m_bPopAimParams)
				{
					m_fCurrentPitch = m_fDesiredPitch;
					m_bPopAimParams = false;
				}
				else
					m_fCurrentPitch = CTaskAimGun::SmoothInput(m_fCurrentPitch, m_fDesiredPitch, PITCH_CHANGE_RATE);

				// Send the signal
				if (!m_bIsOverTheTop)
				{
					m_pTaskUseCoverMoveNetworkHelper->SetFloat(ms_BlindFireIntroBlendId, m_fCurrentPitch);
				}
				else
				{
					m_pTaskUseCoverMoveNetworkHelper->SetFloat(ms_BlindFireIntroBlendId, m_fCurrentHeading);
				}
				m_pTaskUseCoverMoveNetworkHelper->SetFloat(ms_BlindFireSweepBlendId, m_fCurrentPitch);
			}
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunBlindFire::ProcessPostCamera()
{
	CPed *pPed = GetPed(); //Get the ped ptr.

	if(pPed->IsLocalPlayer())
	{
		const camGameplayDirector& gameplayDirector = camInterface::GetGameplayDirector();
		const bool isAnAimCameraActive = gameplayDirector.IsAiming(pPed);
		if(isAnAimCameraActive)
		{
			if(!pPed->GetUsingRagdoll() && !pPed->GetPlayerInfo()->AreControlsDisabled())
			{
				// Attempt to update the ped's orientation and IK aim target *after* the camera system has updated, but before the aim IK is updated

				// Update the ped's (desired) heading
				const camFrame& aimCameraFrame	= camInterface::GetPlayerControlCamAimFrame();
				float aimHeading				= aimCameraFrame.ComputeHeading();
				pPed->SetDesiredHeading(aimHeading);

				if(!m_iFlags.IsFlagSet(GF_DisableTorsoIk) && gameplayDirector.IsThirdPersonAiming(pPed))
				{
					//Force an update of the point gun target for the ped to avoid a frame of lag.
					const Matrix34& aimCameraWorldMatrix	= aimCameraFrame.GetWorldMatrix();
					Vector3 targetPosition					= aimCameraWorldMatrix.d + (aimCameraWorldMatrix.b * g_TargetDistanceFromCameraForAimIk);
					pPed->GetIkManager().PointGunAtPosition(targetPosition, -1.0f);
				}
			}
		}
	}

	//UpdateVisibility(*pPed);

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunBlindFire::ProcessPostPreRender()
{
	if (m_bFire)
	{
		CPed* pPed = GetPed();
		// Ignore fire events if we're not holding a gun weapon
		weaponAssert(pPed->GetWeaponManager());
		const CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();
		if (pWeapon && pPed->GetWeaponManager()->GetIsArmedGunOrCanBeFiredLikeGun())
		{
			// B* 1341595 [5/1/2013 musson]
			m_iGunFireFlags.SetFlag(GFF_FireFromMuzzle);
			if (FireGun(pPed))
			{
				if (m_bFiredOnce)
					m_bFiredTwice = true;

				m_bFire = false;
				m_bFiredOnce = true;
			}

			return true;
		}
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunBlindFire::ProcessMoveSignals()
{
	const int iState = GetState();

	if(iState == State_FireNew)
	{
		CPed* pPed = GetPed();
		const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();
		WeaponControllerState controllerState = GetWeaponControllerState(pPed);

		bool bControllerWantsToFire = (controllerState == WCS_Fire) || ((controllerState == WCS_FireHeld) && pWeaponInfo->GetIsAutomatic());
		bool bWantsToFire = (bControllerWantsToFire || GetGunFlags().IsFlagSet(GF_FireAtLeastOnce)) && pPed->GetPedIntelligence()->GetFiringPattern().WantsToFire();
		bool bReadyToFire = m_bFire || pPed->GetPedIntelligence()->GetFiringPattern().ReadyToFire();

		if (bWantsToFire && bReadyToFire)
		{
			pPed->GetPedAiLod().SetForceNoTimesliceIntelligenceUpdate(true);
		}
	}

	switch(iState)
	{
		case State_IntroNew:
			IntroNew_OnProcessMoveSignals();
			return true;
		case State_FireNew:
			FireNew_OnProcessMoveSignals();
			return true;
		case State_OutroNew:
			OutroNew_OnProcessMoveSignals();
			return true;
		case State_CockGun:
			CockGun_OnProcessMoveSignals();
			return true;
		default:
			break;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::Start_OnUpdate()
{
	s32 iFlags = 0;

	CPedWeaponManager* pWeaponManager = GetPed()->GetWeaponManager();
	CWeapon* pEquippedWeapon = pWeaponManager->GetEquippedWeapon();
	if (pEquippedWeapon && pEquippedWeapon->GetWeaponInfo() && (m_CachedWeaponHash == 0) )
	{
		m_CachedWeaponHash = pEquippedWeapon->GetWeaponInfo()->GetHash();
	}

	CTaskInCover* pUseCoverTask = static_cast<CTaskInCover*>(GetPed()->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_IN_COVER));
	if (pUseCoverTask)
	{
		m_pTaskUseCoverMoveNetworkHelper = pUseCoverTask->GetMoveNetworkHelper();
	}
#if __ASSERT
	if (!pUseCoverTask || !m_pTaskUseCoverMoveNetworkHelper)
	{
		aiWarningf("pUseCoverTask = %s, m_pTaskUseCoverMoveNetworkHelper = %s", pUseCoverTask ? "TRUE":"FALSE", m_pTaskUseCoverMoveNetworkHelper ? "TRUE":"FALSE");
	}
#endif // __ASSERT

	//Generate the direction flags.
	bool bLeft = GetGunFlags().IsFlagSet(GF_LeftCover);
	bool bLow = GetGunFlags().IsFlagSet(GF_LowCover);	
	if (bLow)
	{	
		CPed* pPed = GetPed();
		if (!CTaskInCover::CanBlindFireCorner(pPed))
		{
			GetGunFlags().ClearFlag(GF_CornerCover);
		}
#if FPS_MODE_SUPPORTED
		else if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			u8 uFudge;
			if (CTaskInCover::CheckForBlindFireOverheadClearance(pPed, uFudge))
			{
				const CControl* pControl = pPed->GetControlFromPlayer();
				if (pControl)
				{
					Vector2 vStick(pControl->GetPedWalkLeftRight().GetNorm(), -pControl->GetPedWalkUpDown().GetNorm());
					if (vStick.y > 0.1f)
					{
						GetGunFlags().ClearFlag(GF_CornerCover);
					}
				}
			}
		}	
#endif // FPS_MODE_SUPPORTED
	}
	bool bCorner = GetGunFlags().IsFlagSet(GF_CornerCover);

	if (bLeft)
	{
		iFlags |= CTaskCover::AF_FaceLeft;
	}

	if (bLow)
	{
		iFlags |= CTaskCover::AF_Low;
	}

	TUNE_GROUP_BOOL(FIRST_PERSON_BLINDFIRE_TUNE, DISABLE_LOW_CORNER_BLIND, false);
	if (DISABLE_LOW_CORNER_BLIND && bLow && GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		bCorner = false;
	}

	if (bCorner || !bLow)
	{
		iFlags |= CTaskCover::AF_AtEdge;
		m_bUsingAtEdgeAnims = true; 
	}
	else
	{
		m_bUsingAtEdgeAnims = false; 
	}

	if (bLow && !bCorner)
		m_bIsOverTheTop = true;

	for (s32 i=0; i<ms_Tunables.m_BlindFireAnimStateNewInfos.GetCount(); i++)
	{
		if (ms_Tunables.m_BlindFireAnimStateNewInfos[i].m_Flags == iFlags)
		{
			m_pCachedAnimStateInfoNew = &ms_Tunables.m_BlindFireAnimStateNewInfos[i];
			break;
		}
	}

	if (!taskVerifyf(m_pCachedAnimStateInfoNew, "Couldn't find cached anim state info. Flags %i", iFlags))
	{
		return FSM_Continue;
	}

	bool bAllClipsValid =
		m_pCachedAnimStateInfoNew->m_IntroClip0Id != CLIP_ID_INVALID && 
		m_pCachedAnimStateInfoNew->m_IntroClip1Id != CLIP_ID_INVALID && 
		m_pCachedAnimStateInfoNew->m_SweepClip0Id != CLIP_ID_INVALID && 
		m_pCachedAnimStateInfoNew->m_SweepClip1Id != CLIP_ID_INVALID &&
		m_pCachedAnimStateInfoNew->m_SweepClip2Id != CLIP_ID_INVALID &&
		m_pCachedAnimStateInfoNew->m_OutroClip0Id != CLIP_ID_INVALID;

	if (!taskVerifyf(bAllClipsValid, "A clip id wasn't valid, check metadata"))
	{
		SetState(State_Finish);
		return FSM_Continue;
	}
	else 
	{
		m_iFlags.SetFlag(GF_DisableTorsoIk);
		SetState(State_IntroNew);
		return FSM_Continue;
	}
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::IntroNew_OnEnter()
{
	if (!m_pTaskUseCoverMoveNetworkHelper)
	{
#if __ASSERT
		taskWarningf("Ped %s(%p) Quitting blind fire task due to null m_pTaskUseCoverMoveNetworkHelper", GetPed()->GetDebugName(), GetPed());
#endif // __ASSERT
		return FSM_Quit;
	}

#if FPS_MODE_SUPPORTED
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		const CWeaponInfo* pWeaponInfo = GetPed()->GetEquippedWeaponInfo();
		bool bFPSAnimatedRecoil = pWeaponInfo && pWeaponInfo->GetUseFPSAnimatedRecoil();

		TUNE_GROUP_BOOL(FIRST_PERSON_BLINDFIRE_TUNE, DISABLE_FIRST_PERSON_RECOIL, false);
		if (DISABLE_FIRST_PERSON_RECOIL)
		{			
			bFPSAnimatedRecoil = true;
		}
		m_pTaskUseCoverMoveNetworkHelper->SetFlag(bFPSAnimatedRecoil, CTaskMotionAiming::ms_FirstPersonAnimatedRecoil);
		m_pTaskUseCoverMoveNetworkHelper->SetFlag(!GetGunFlags().IsFlagSet(GF_LeftCover), ms_IsRightSideId);
		
		if (pWeaponInfo)
		{
			fwMvClipSetId fireClipSetId = pWeaponInfo->GetAppropriateWeaponClipSetId(GetPed());
			taskAssert(fireClipSetId != CLIP_SET_ID_INVALID);
			m_pTaskUseCoverMoveNetworkHelper->SetClipSet(fireClipSetId, ms_FireClipSetVarId);
		}
	}
#endif // FPS_MODE_SUPPORTED

	const fwMvClipSetId clipSetId = m_pTaskUseCoverMoveNetworkHelper->GetClipSetId(CTaskMotionInCover::ms_WeaponClipSetId);
	taskAssert(clipSetId != CLIP_SET_ID_INVALID);

	const crClip* pClip0 = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_IntroClip0Id);
	if (taskVerifyf(pClip0, "Couldn't find intro clip 0"))
	{
		m_pTaskUseCoverMoveNetworkHelper->SetClip(pClip0, CClipScalingHelper::ms_Clip0Id);
	}
	const crClip* pClip1 = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_IntroClip1Id);
	if (taskVerifyf(pClip1, "Couldn't find intro clip 1"))
	{
		m_pTaskUseCoverMoveNetworkHelper->SetClip(pClip1, CClipScalingHelper::ms_Clip1Id);
	}
	m_pTaskUseCoverMoveNetworkHelper->SendRequest(ms_NewBlindFireSolutionRequestId);
	m_pTaskUseCoverMoveNetworkHelper->SendRequest(ms_BlindFireIntroRequestId);
	m_pTaskUseCoverMoveNetworkHelper->WaitForTargetState(ms_BlindFiringIntroOnEnterId);

#if __DEV
	if (!ms_Tunables.m_DontRemoveReticuleDuringBlindFireNew)
	{	
		ms_Tunables.m_RemoveReticuleDuringBlindFire = true;
	}
#endif

	RequestProcessMoveSignalCalls();
	m_bMoveBlindFireIntroClipFinished = false;
	m_bPopAimParams = true;

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::IntroNew_OnUpdate()
{
	// Do not want ai / move network getting out of sync
	if (!m_pTaskUseCoverMoveNetworkHelper->IsInTargetState())
		return FSM_Continue;

	const fwMvClipSetId clipSetId = m_pTaskUseCoverMoveNetworkHelper->GetClipSetId(CTaskMotionInCover::ms_WeaponClipSetId);
	taskAssert(clipSetId != CLIP_SET_ID_INVALID);

	//Note: on the remote the m_bMoveBlindFireIntroClipFinished sometimes doesn't come through the network and the remote ped is stuck in this state when he knows he should be in the State_FireNew - not perfect but just proceed. lavalley.
	if (m_bMoveBlindFireIntroClipFinished || (GetPed() && GetPed()->IsNetworkClone() && (GetStateFromNetwork() == State_FireNew)))
	{
		SetState(State_FireNew);
		return FSM_Continue;
	}

	const crClip* pClip0 = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_IntroClip0Id);
	const crClip* pClip1 = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_IntroClip1Id);
	if (taskVerifyf(pClip0 && pClip1, "Couldn't find blind firing clips"))
	{
		const float fClip0CurrentPhase = m_pTaskUseCoverMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip0PhaseId);
		const float fClip1CurrentPhase = m_pTaskUseCoverMoveNetworkHelper->GetFloat(CClipScalingHelper::ms_Clip1PhaseId);

		if (fClip0CurrentPhase > 0.0f)
		{
			float fClip0StartPhase = 0.0f;
			float fClip1StartPhase = 0.0f;
			float fClip0EndPhase = 1.0f;
			float fClip1EndPhase = 1.0f;

			CClipEventTags::FindBlendInBlindFireAimStartEndPhases(pClip0, fClip0StartPhase, fClip0EndPhase);
			CClipEventTags::FindBlendInBlindFireAimStartEndPhases(pClip1, fClip1StartPhase, fClip1EndPhase);

			float fWeightedCurrentPhase = m_fCurrentHeading * fClip0CurrentPhase + (1.0f - m_fCurrentHeading) * fClip1CurrentPhase;
			float fWeightedStartPhase = m_fCurrentHeading * fClip0StartPhase + (1.0f - m_fCurrentHeading) * fClip1StartPhase;

			if (fWeightedCurrentPhase >= fWeightedStartPhase)		
			{
				float fClip0BlendDuration = pClip0->ConvertPhaseToTime(fClip0EndPhase - fClip0StartPhase);
				float fClip1BlendDuration = pClip1->ConvertPhaseToTime(fClip1EndPhase - fClip1StartPhase);

				TUNE_GROUP_BOOL(COVER_BLINDFIRE_TUNE, USE_DOMINANT_BLEND_DURATION_FOR_BLIND_FIRE, false);
				if (USE_DOMINANT_BLEND_DURATION_FOR_BLIND_FIRE)
				{
					m_fBlindFireAimBlendDuration = m_fCurrentHeading < 0.5f ? fClip1BlendDuration : fClip0BlendDuration;
				}
				else
				{
					m_fBlindFireAimBlendDuration = m_fCurrentHeading * fClip0BlendDuration + (1.0f - m_fCurrentHeading) * fClip1BlendDuration;
				}

				SetState(State_FireNew);
				return FSM_Continue;
			}
		}
	}
	
	return FSM_Continue;
}

void CTaskAimGunBlindFire::IntroNew_OnExit()
{
	if (!GetGunFlags().IsFlagSet(GF_LowCover) && GetGunFlags().IsFlagSet(GF_CornerCover))
	{
		CPed* pPed = GetPed();
		Vector3 vStart(Vector3::ZeroType);
		Vector3 vEnd(Vector3::ZeroType);

		CCoverPoint* pCoverPoint = pPed->GetCoverPoint();
		if (pCoverPoint)
		{			
			static dev_float sfBlindFireCapsuleRadius = 0.05f;
			vStart = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());				
			Vector3 vPedSide = VEC3V_TO_VECTOR3(pPed->GetTransform().GetB());		
			static dev_float sf_SideScale = 0.75f;
			vStart += sf_SideScale * vPedSide;

			Vector3 vCoverDir = VEC3V_TO_VECTOR3(pCoverPoint->GetCoverDirectionVector(NULL));
			vEnd = vStart;  
			vEnd.AddScaled(vCoverDir, 0.8f);

			//check for a door to open
			const s32 iCollisionFlags = ArchetypeFlags::GTA_MAP_TYPE_WEAPON | ArchetypeFlags::GTA_OBJECT_TYPE; 
			s32 iIgnoreFlags    = 0;
			const s32 iNumIntersections = 1;
			WorldProbe::CShapeTestHitPoint capsuleIsects[iNumIntersections];
			WorldProbe::CShapeTestResults capsuleResults(capsuleIsects, iNumIntersections);
			WorldProbe::CShapeTestCapsuleDesc capsuleDesc;
			capsuleDesc.SetResultsStructure(&capsuleResults);
			capsuleDesc.SetCapsule(vStart, vEnd, sfBlindFireCapsuleRadius);
			capsuleDesc.SetIncludeFlags(iCollisionFlags);
			capsuleDesc.SetExcludeEntity(pPed);
			capsuleDesc.SetOptions(iIgnoreFlags);
			capsuleDesc.SetContext(WorldProbe::LOS_GeneralAI);
			WorldProbe::GetShapeTestManager()->SubmitTest(capsuleDesc);
#if DEBUG_DRAW
			CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), sfBlindFireCapsuleRadius, Color_DarkGreen, 2500, 0, false);
#endif // DEBUG_DRAW
			for(WorldProbe::ResultIterator it = capsuleResults.begin(); it < capsuleResults.last_result(); ++it)
			{
				Assert(it->GetHitDetected());
				if(it->GetHitInst() && it->GetHitInst() != pPed->GetCurrentPhysicsInst())
				{
					CEntity* pHitEntity = CPhysics::GetEntityFromInst(it->GetHitInst());

					// Could still hit ped capsule if shape test takes the frag inst as exception over phys inst.
					if(pHitEntity)
					{
						if( pHitEntity->GetIsTypeObject() && ((CObject*)pHitEntity)->IsADoor() )
						{
							CDoor* pDoor = static_cast<CDoor*>( pHitEntity );

							// Make sure the door is unlocked and is of a particular type
							int nDoorType = pDoor->GetDoorType();
							m_bAtDoor = true;
							if( !pDoor->IsBaseFlagSet( fwEntity::IS_FIXED ) && ( nDoorType == CDoor::DOOR_TYPE_STD || nDoorType == CDoor::DOOR_TYPE_STD_SC ) )
							{							
								//static dev_float fOpenDoorThreshold = 0.9f;
								//static dev_float fMoveBlendRatioThreshold = 0.145f;  // Looks like the min movement ratio is 0.15
							
								bool bFront = CTaskOpenDoor::IsPedInFrontOfDoor( pPed, pDoor );

								// Invert the perp vector depending on the side and whether the door is inverted in model space
								float fTarget = 0.0f;
								if( pDoor->GetBoundingBoxMin().x > -pPed->GetCapsuleInfo()->GetHalfWidth() )
									fTarget = !bFront ? 1.0f : -1.0f; //opposite side door ... 
								else
									fTarget = bFront ? -1.0f : 1.0f;
								// Determine if we haven't already set the target ratio
								//if( pDoor->GetTargetDoorRatio() != fTarget )
								{					
									static dev_float fPushingForce = 150.0f;
									const Vector3 vHitImpulse = vCoverDir * fPushingForce;									
									pDoor->ApplyImpulse(vHitImpulse, VEC3_ZERO, it->GetHitComponent());								
									pDoor->SetTargetDoorRatio( fTarget, false );
									if(pDoor->GetDoorAudioEntity())
									{
										pDoor->GetDoorAudioEntity()->EntityWantsToOpenDoor(it->GetHitPosition(), pPed->GetVelocity().Mag());
										pDoor->GetDoorAudioEntity()->TriggerDoorImpact(pPed, it->GetHitPositionV(), true);
									}
								}
							}
						}					
					}
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunBlindFire::IntroNew_OnProcessMoveSignals()
{
	if (!m_pTaskUseCoverMoveNetworkHelper || !m_pTaskUseCoverMoveNetworkHelper->IsNetworkActive())
	{
		return;
	}

	m_bMoveBlindFireIntroClipFinished |= m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_BlindFireIntroClipFinishedId);
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::FireNew_OnEnter()
{
	const fwMvClipSetId clipSetId = m_pTaskUseCoverMoveNetworkHelper->GetClipSetId(CTaskMotionInCover::ms_WeaponClipSetId);
	taskAssert(clipSetId != CLIP_SET_ID_INVALID);

	const crClip* pClip0 = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_SweepClip0Id);
	if (taskVerifyf(pClip0, "Couldn't find sweep clip 0"))
	{
		m_pTaskUseCoverMoveNetworkHelper->SetClip(pClip0, CClipScalingHelper::ms_Clip0Id);
	}
	const crClip* pClip1 = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_SweepClip1Id);
	if (taskVerifyf(pClip1, "Couldn't find sweep clip 1"))
	{
		m_pTaskUseCoverMoveNetworkHelper->SetClip(pClip1, CClipScalingHelper::ms_Clip1Id);
	}
	const crClip* pClip2 = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_SweepClip2Id);
	if (taskVerifyf(pClip2, "Couldn't find sweep clip 2"))
	{
		m_pTaskUseCoverMoveNetworkHelper->SetClip(pClip2, CClipScalingHelper::ms_Clip2Id);
	}
	const CWeaponInfo* pWeaponInfo = GetPed()->GetWeaponManager()->GetEquippedWeaponInfo();
	if (pWeaponInfo)
	{
		TUNE_GROUP_BOOL(FIRST_PERSON_BLINDFIRE_TUNE, USE_FIRST_PERSON_WEAPON_CLIPSET_IN_FIRST_PERSON, true);
		fwMvClipSetId fireClipSetId = USE_FIRST_PERSON_WEAPON_CLIPSET_IN_FIRST_PERSON ? pWeaponInfo->GetAppropriateWeaponClipSetId(GetPed()) : pWeaponInfo->GetWeaponClipSetId();
		taskAssert(fireClipSetId != CLIP_SET_ID_INVALID);
		m_pTaskUseCoverMoveNetworkHelper->SetClipSet(fireClipSetId, ms_FireClipSetVarId);

		fwClipSet* pSet = fwClipSetManager::GetClipSet(fireClipSetId);
		if (pSet)
		{
			fwMvClipId fireClipId = ms_FireClipId;

#if FPS_MODE_SUPPORTED
			if (pWeaponInfo->GetUseFPSAimIK() && !pWeaponInfo->GetUseFPSAnimatedRecoil() && GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
			{
				fireClipId = ms_FireRecoilClipId;
			}
#endif // FPS_MODE_SUPPORTED

			crClip* pClip = pSet->GetClip(fireClipId);
			m_bUsesFireEvents = pClip && (CTaskMotionAiming::CountFiringEventsInClip(*pClip) > 0);
		}
	}

	m_pTaskUseCoverMoveNetworkHelper->SetFlag(true, ms_FiringFlagId);
	m_pTaskUseCoverMoveNetworkHelper->SetFloat(ms_BlindFireAimBlendDurationId, m_fBlindFireAimBlendDuration);
	m_pTaskUseCoverMoveNetworkHelper->SendRequest(ms_BlindFireLoopRequestId);
	m_pTaskUseCoverMoveNetworkHelper->WaitForTargetState(ms_BlindFiringLoopOnEnterId);

	m_bMoveIKLeftHandUseGripBone = false;

	RequestProcessMoveSignalCalls();
	ResetFire();

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::FireNew_OnUpdate()
{
	// Do not want ai / move network getting out of sync
	if (!m_pTaskUseCoverMoveNetworkHelper->IsInTargetState())
		return FSM_Continue;

	CPed& ped = *GetPed();

	TUNE_GROUP_BOOL(COVER_BLINDFIRE_TUNE, ALLOW_EXIT, true);
	if (!ALLOW_EXIT)
		return FSM_Continue;

	const CWeapon* pWeapon = ped.GetWeaponManager()->GetEquippedWeapon();
	const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfo();
	WeaponControllerState controllerState = GetWeaponControllerState(&ped);

	bool bCanSwitchState = true;
	bool bDoOutro = false;
	bool bMoveFire = m_bMoveFire;

	m_bMoveFire = false;

	if (pWeaponInfo == NULL)
	{
		bDoOutro = true;
	}

	bool bForcedBlockAimDirectly;
	CTaskInCover* pCoverTask = static_cast<CTaskInCover*>(ped.GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_IN_COVER));
	bool bIsAimFiring = ped.IsLocalPlayer() && ped.GetPlayerInfo()->IsAiming() && pCoverTask && pCoverTask->IsBlindFireWithAim();
	if(ped.IsLocalPlayer() && ((ped.GetPlayerInfo()->IsAiming() && !bIsAimFiring) || CTaskInCover::ShouldAimDirectly(ped, (pCoverTask && pCoverTask->IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint)), bForcedBlockAimDirectly, 0.0f, false, true) || bForcedBlockAimDirectly))
	{
		bDoOutro = true;
	}

	// See if our dynamic cover has moved
	if (ped.IsLocalPlayer() && ped.GetCoverPoint() && ped.GetPlayerInfo()->IsCoverGeneratedByDynamicEntity())
	{
		Vector3 vCoverPos(Vector3::ZeroType); 
		Vector3 vPlayerPos = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
		if (!ped.GetCoverPoint()->GetCoverPointPosition(vCoverPos) || (vCoverPos-vPlayerPos).XYMag2() > 1.0f)
		{
			bDoOutro = true;
			m_bBlockOutroRefire =  true;
		}
	}

	bool bNeedsCocking = pWeaponInfo && pWeaponInfo->GetNeedsGunCockingInCover();
	if (bNeedsCocking)
	{
		//process weapon MoVE interrupts
		CWeapon* pWeapon = GetPed()->GetWeaponManager()->GetEquippedWeapon();
		if (pWeapon)
		{
			CMoveNetworkHelper* pWeaponMoveNetworkHelper = pWeapon->GetMoveNetworkHelper();
			if (pWeaponMoveNetworkHelper)
			{
				const fwMvBooleanId	s_ExitToCoverId("ExitToCover",0x7be43d60);
				if (pWeaponMoveNetworkHelper->GetBoolean(s_ExitToCoverId))
				{
					pWeaponMoveNetworkHelper->SendRequest(CWeapon::ms_InterruptFireId);
					if (m_pCachedAnimStateInfoNew->m_CockGunClip0Id != CLIP_ID_INVALID)
					{
						bDoOutro = true;
					}
				}
			}
		}		
	}
	

	if ((controllerState == WCS_Reload) || WantsToReload())
	{
		m_bBlockOutroRefire = true;
		bDoOutro = true;
	}

	bool bControllerWantsToFire = (controllerState == WCS_Fire) || ((controllerState == WCS_FireHeld) && pWeaponInfo->GetIsAutomatic());
	bool bContinueFireLoopUntilEnd = GetGunFlags().IsFlagSet(GF_OnlyExitFireLoopAtEnd) && !(m_bMoveFireLoop1 || m_bMoveFireLoop2) && pWeaponInfo && pWeaponInfo->GetForceFullFireAnimation();
	bool bWantsToFire = (bControllerWantsToFire || bContinueFireLoopUntilEnd || bNeedsCocking || GetGunFlags().IsFlagSet(GF_FireAtLeastOnce)) && ped.GetPedIntelligence()->GetFiringPattern().WantsToFire();
	
	// Revolver: return to outro to force cock after every shot.
	if (bWantsToFire && m_fireCounter > 0 && bNeedsCocking && pWeaponInfo && pWeaponInfo->GetFlag(CWeaponInfoFlags::UseSingleActionBehaviour))
	{
		bWantsToFire = false;
	}

	if (!bWantsToFire)
		bDoOutro = true;
	
	// Calculate the aim vector (this determines the heading and pitch angles to point the clips in the correct direction)
	float gunAngleError = 1.0f;
	Matrix34 mWeapon;	
	const CObject* pWeaponObject = ped.GetWeaponManager()->GetEquippedWeaponObject();
	if (pWeaponObject)
		pWeaponObject->GetMatrixCopy(mWeapon);
	Vector3 vStart(Vector3::ZeroType);
	Vector3 vEnd(Vector3::ZeroType);
	bool bAimComputed = false;
	if (pWeapon && ped.IsLocalPlayer() && 
		( ped.GetWeaponManager()->GetIsArmedGunOrCanBeFiredLikeGun() || ped.GetWeaponManager()->GetEquippedVehicleWeapon() ) && 
		pWeapon->CalcFireVecFromAimCamera(NULL, mWeapon, vStart, vEnd))		
	{		
		bAimComputed = true;
	} 
	
	if (!bAimComputed && CalculateFiringVector(&ped, vStart, vEnd)) 
	{
		bAimComputed = true;
	}

	if(bAimComputed && ped.GetPlayerInfo() && ped.GetPlayerResetFlag(CPlayerResetFlags::PRF_ASSISTED_AIMING_ON))
	{
		CPlayerPedTargeting &targeting	= const_cast<CPlayerPedTargeting &>(ped.GetPlayerInfo()->GetTargeting());
		if(targeting.GetLockOnTarget())
		{
			vEnd = targeting.GetLockonTargetPos();
		}
	}

	if (bAimComputed && pWeapon)
	{
		Vector3 vMuzzle;
		pWeapon->GetMuzzlePosition(mWeapon, vMuzzle);
		Vector3 bulletDir = vEnd-mWeapon.d;
		bulletDir.z = 0;
		bulletDir.Normalize();
		Vector3 weaponNormal = mWeapon.a;
		weaponNormal.z = 0; weaponNormal.Normalize();
		gunAngleError = bulletDir.Dot(weaponNormal);
	}

	TUNE_GROUP_FLOAT(COVER_BLINDFIRE_TUNE, MIN_TIME_BEFORE_FIRING, 0.25f, 0.0f, 2.0f, 0.01f);
	TUNE_GROUP_FLOAT(COVER_BLINDFIRE_TUNE, MIN_ANGLE_ERROR_TO_FIRE, 0.5f, 0.0f, 1.0f, 0.01f);
	const float fBlendPhase  = m_pTaskUseCoverMoveNetworkHelper->GetFloat(ms_BlindFireIntroPhaseId);
	bool bIsOneShot = pWeaponInfo && (pWeaponInfo->GetOnlyFireOneShot() || pWeaponInfo->GetOnlyFireOneShotPerTriggerPress());
	bool bPassedGunAngleCheck = (m_bAtDoor || gunAngleError > MIN_ANGLE_ERROR_TO_FIRE);
	bool bWeaponReadyToFire = pWeapon && ((pWeapon->GetState() == CWeapon::STATE_READY) || 
		(!bIsOneShot && pWeapon->GetState() == CWeapon::STATE_WAITING_TO_FIRE));

	if (pWeaponInfo && fBlendPhase <0.0f && bPassedGunAngleCheck && (!pWeaponInfo->GetDelayedFiringAfterAutoSwap() || (GetTimeInState() >= MIN_TIME_BEFORE_FIRING)))
	{		
		bool bReadyToFire = bWeaponReadyToFire && ped.GetPedIntelligence()->GetFiringPattern().ReadyToFire();

		if (ped.IsNetworkClone())
		{
			bWantsToFire = bReadyToFire && (GetStateFromNetwork() == State_FireNew || GetStateFromNetwork() == State_OutroNew) && m_fireCounter < m_targetFireCounter;
			if (bWantsToFire)
			{
				m_bFire = bReadyToFire;
			}
			else if (GetStateFromNetwork() != State_FireNew)
			{
				bDoOutro = true;
			}
		}
		else
		{
			if (bWantsToFire)
			{
				m_bFire = bReadyToFire;
			}
			else
			{
				bDoOutro = true;
			}
		}
	}

	//wall penetration check	
	if (ped.IsLocalPlayer() && GetGunFlags().IsFlagSet(GF_LowCover) && !GetGunFlags().IsFlagSet(GF_CornerCover))
	{
		u8 uFudge;
		if (!CTaskInCover::CheckForBlindFireOverheadClearance(&ped, uFudge))
		{
			bDoOutro = true;
			m_bBlockOutroRefire = true;
		}
	}


	if (GetGunFlags().IsFlagSet(GF_LowCover) && GetGunFlags().IsFlagSet(GF_CornerCover))
	{
		u8 uFudge;
		if (!CTaskInCover::CanBlindFireCorner(&ped) && CTaskInCover::CheckForBlindFireOverheadClearance(&ped, uFudge))
		{
			GetGunFireFlags().ClearFlag(GF_CornerCover);
			m_bCornerToTopBlindFireTransition = true;
			bDoOutro = true;
		}
	}

	if (!ped.IsNetworkClone() && GetGunFlags().IsFlagSet(GF_FireAtLeastOnce) && m_fireCounter == 0)
	{
		bDoOutro = false;
	}

	if (!bPassedGunAngleCheck && fBlendPhase < 0)
	{ //we may never achieve target.
		bDoOutro = true;
		m_bBlockOutroRefire = true;
	}

	if (ped.IsLocalPlayer() && GetGunFlags().IsFlagSet(GF_CornerCover) && !GetGunFlags().IsFlagSet(GF_LowCover))
	{
		if (!CTaskInCover::CanBlindFireCorner(&ped))
		{
			bDoOutro = true; //illegal aim zone, abort!
			m_bBlockOutroRefire = true;
		}
	}

	//Guntask wants this task done, and I don't need to shoot first
	if (m_bEndTaskRequested && !bNeedsCocking)
	{
		bDoOutro = true; //illegal aim zone, abort!
		m_bBlockOutroRefire = true;
	}


	m_bOutroPending |= bDoOutro;

	if (pWeaponInfo)
	{
		// Check fire loop signals
		bool bFireLoopEvent = m_bMoveFireLoop1 || m_bMoveFireLoop2;
		m_bMoveFireLoop1 = false;
		m_bMoveFireLoop2 = false;

		if (bIsOneShot && bFireLoopEvent)
		{
			m_pTaskUseCoverMoveNetworkHelper->SendRequest(ms_FireFinishedRequestId);
			m_bFireLoopOnEnter = false;
		}
		m_bFireLoopOnEnter |= m_bMoveFireLoopOnEnter;

		// Apply recoil IK if necessary
		ProcessIK();

		bool bForceFireIfOneShotReady = !bIsOneShot || (bWantsToFire && bWeaponReadyToFire);

		if (m_bFiredOnce && GetGunFlags().IsFlagSet(GF_OnlyExitFireLoopAtEnd) && !bFireLoopEvent && !bForceFireIfOneShotReady)
		{
			m_pTaskUseCoverMoveNetworkHelper->SetFlag(false, ms_FiringFlagId);
			if (!bNeedsCocking && !bIsOneShot)
				bCanSwitchState = false;

			if (m_bOutroPending)
			{
				// Prevent fire events if outro is pending
				m_bFire = false;
			}
		}
		else
		{
			m_pTaskUseCoverMoveNetworkHelper->SetFlag(true, ms_FiringFlagId);
		}

		if (m_bFire)
		{
			m_bForceWeaponStateToFire = false;

			// Send fire signals to start fire loop
			m_pTaskUseCoverMoveNetworkHelper->SendRequest(ms_FireRequestId);
			m_pTaskUseCoverMoveNetworkHelper->SetFloat(ms_FireRateId, GetFiringAnimPlaybackRate());

			if (m_bUsesFireEvents)
			{
				m_bForceWeaponStateToFire = true;

				//Note: only reset this on the local - when this is done on the remote it is falsely preventing remote firing here. lavalley.
				if (!ped.IsNetworkClone())
				{
					m_bFire = bMoveFire;
				}
			}
		}
	}

	if (m_bOutroPending && bCanSwitchState)
	{
		if (pWeaponInfo && pWeaponInfo->GetHash() == ATSTRINGHASH("WEAPON_DBSHOTGUN",0xEF951FBB) && m_bFiredOnce && !m_bFiredTwice)
		{
			//Force the second shot for DBS shotgun if we need to outro between the shots
			FireGun(&ped);
		}
		SetState(State_OutroNew);
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::FireNew_OnExit()
{
	m_pTaskUseCoverMoveNetworkHelper->SendRequest(ms_FireFinishedRequestId);
	m_pTaskUseCoverMoveNetworkHelper->SetFlag(false, ms_FiringFlagId);

	if (m_bFireLoopOnEnter)
	{
		GetPed()->GetIkManager().AimWeapon(crIKSolverArms::RIGHT_ARM, AIK_USE_FULL_REACH);
	}

	if (GetPed()->GetWeaponManager() && GetPed()->GetWeaponManager()->GetEquippedWeapon())
		GetPed()->GetWeaponManager()->GetEquippedWeapon()->StoppedFiring();

	ResetFire();

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunBlindFire::FireNew_OnProcessMoveSignals()
{
	if (!m_pTaskUseCoverMoveNetworkHelper || !m_pTaskUseCoverMoveNetworkHelper->IsNetworkActive())
	{
		return;
	}

	m_bMoveFire |= m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_FireId);
	m_bMoveFireLoopOnEnter |= m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_FireLoopOnEnterId);
	m_bMoveFireLoop1 |= m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_FireLoop1OnExitId);
	m_bMoveFireLoop2 |= m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_FireLoop2OnExitId);
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::OutroNew_OnEnter()
{
	const fwMvClipSetId clipSetId = m_pTaskUseCoverMoveNetworkHelper->GetClipSetId(CTaskMotionInCover::ms_WeaponClipSetId);
	taskAssert(clipSetId != CLIP_SET_ID_INVALID);

	const crClip* pClip0 = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_OutroClip0Id);
	if (taskVerifyf(pClip0, "Couldn't find outro clip 0"))
	{
		m_pTaskUseCoverMoveNetworkHelper->SetClip(pClip0, ms_BlindFireOutroClipId);
	}
#if FPS_MODE_SUPPORTED
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		const crClip* pClip1 = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_OutroClip1Id);
		if (pClip1)
		{
			m_pTaskUseCoverMoveNetworkHelper->SetClip(pClip1, ms_BlindFireOutroClip1Id);
		}
	}
#endif // FPS_MODE_SUPPORTED
	m_pTaskUseCoverMoveNetworkHelper->SendRequest(ms_BlindFireOutroRequestId);
	m_pTaskUseCoverMoveNetworkHelper->WaitForTargetState(ms_BlindFiringOutroOnEnterId);

	RequestProcessMoveSignalCalls();
	m_bMoveInterruptToCockGun = false;
	m_bMoveBlindFireOutroClipFinished = false;	
	m_bMoveIKLeftHandUseGripBone = false;

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::OutroNew_OnUpdate()
{
	if (!m_pTaskUseCoverMoveNetworkHelper->IsInTargetState())
		return FSM_Continue;

	CPed& ped = *GetPed();

#if FPS_MODE_SUPPORTED
	if (ped.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		ped.SetPedResetFlag(CPED_RESET_FLAG_DisableCameraConstraintFallBackThisFrame, true);

		if (CTaskMotionInCover::ms_Tunables.m_EnableFirstPersonAimingAnimations && GetTimeInState() > CTaskCover::ms_Tunables.m_FPSBlindFireOutroBlendOutPelvisOffsetTime)
		{
			ped.GetIkManager().SetExternallyDrivenPelvisOffset(0.0f);
		}
	}
#endif // FPS_MODE_SUPPORTED

	const bool bWantsToCockGun = !m_bEndTaskRequested && m_fireCounter > 0 && ped.GetWeaponManager()->GetEquippedWeaponInfo() && ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetNeedsGunCockingInCover() && !ped.GetPedIntelligence()->FindTaskSecondaryByType(CTaskTypes::TASK_RELOAD_GUN);
	const bool bChargedWeaponWaitingToFire = ped.GetWeaponManager()->GetEquippedWeapon() && ped.GetWeaponManager()->GetEquippedWeaponInfo()->GetDisplayRechargeTimeHUD() && ped.GetWeaponManager()->GetEquippedWeapon()->GetTimeBeforeNextShot() > 0.0f;

	const CTaskInCover* pInCoverTask = static_cast<CTaskInCover*>(ped.GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_IN_COVER));
	WeaponControllerState controllerState = GetWeaponControllerState(&ped);
	bool bForcedBlockAimDirectly;	
	bool bIsAimFiring = ped.IsLocalPlayer() && ped.GetPlayerInfo()->IsAiming() && pInCoverTask && pInCoverTask->IsBlindFireWithAim();
	if (!m_bCornerToTopBlindFireTransition && !m_bBlockOutroRefire && !bWantsToCockGun && !m_bEndTaskRequested && controllerState == WCS_Fire && 
		!WantsToReload() && ped.IsLocalPlayer() && (!ped.GetPlayerInfo()->IsAiming() || bIsAimFiring) && 
		!CTaskInCover::ShouldAimDirectly(ped, pInCoverTask->IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint), bForcedBlockAimDirectly, 0.0f, false, true) &&
		CanInterruptOutro() && !bChargedWeaponWaitingToFire)
	{
		//changed my mind
		GetGunFlags().SetFlag(GF_FireAtLeastOnce);
		m_fireCounter = 0;

		if(NetworkInterface::IsGameInProgress() && !ped.IsNetworkClone())
		{
			//the replay random seed value is used to synchronize the shotgun blast pattern on the local to the remote
			if (ped.GetEquippedWeaponInfo()->GetGroup() == WEAPONGROUP_SHOTGUN)
			{
				u32 tmpseed = g_ReplayRand.GetSeed();
				if (tmpseed == m_seed)
					m_seed = fwRandom::GetRandomNumber(); //need to reset random with random as seed is the same as last time
				else
					m_seed = tmpseed;

				g_ReplayRand.Reset(m_seed); //IMPORTANT: need to reset the seed here with the seed we will use otherwise the m_seed1 will not be set appropriately on all consoles A/B/C...
			}
			else
			{
				m_seed = 0;
			}

			const CWeapon* pWeapon = ped.GetWeaponManager()->GetEquippedWeapon();
			m_iAmmoInClip = (u8) (pWeapon ? pWeapon->GetAmmoInClip() : 0);
		}

		m_bOutroPending = false;
		SetState(State_FireNew);
		return FSM_Continue;
	}

	if (bWantsToCockGun && m_bMoveInterruptToCockGun)
	{
		SetState(State_CockGun);
		return FSM_Continue;
	}

	bool bShouldInterrupt = !bWantsToCockGun && (pInCoverTask ? pInCoverTask->CheckForAimOutroInterrupt() : false);

#if FPS_MODE_SUPPORTED
	if (bShouldInterrupt && !pInCoverTask->IsCoverFlagSet(CTaskCover::CF_TooHighCoverPoint) && ped.IsFirstPersonShooterModeEnabledForPlayer(false) && WantsToReload())
	{
		bShouldInterrupt = CanInterruptOutro();
	}
#endif // FPS_MODE_SUPPORTED
	
	if (m_bMoveBlindFireOutroClipFinished || bShouldInterrupt)
	{
		if (m_bCornerToTopBlindFireTransition)
		{
			m_bCornerToTopBlindFireTransition = false;
			m_bMoveIKLeftHandUseGripBone = false;
			SetState(State_Start);
			return FSM_Continue;
		}
		if (bWantsToCockGun)
		{
			SetState(State_CockGun);
			return FSM_Continue;
		}
		else
		{
			SetState(State_Finish);
			m_ikInfo.SetDisablePitchFixUp(true);
			m_ikInfo.ApplyIkInfo(&ped);
			return FSM_Continue;
		}
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunBlindFire::OutroNew_OnExit()
{
#if FPS_MODE_SUPPORTED
	CPed& rPed = *GetPed();
	if (rPed.IsFirstPersonShooterModeEnabledForPlayer(false))
		rPed.GetIkManager().SetExternallyDrivenPelvisOffset(0.0f);
#endif // FPS_MODE_SUPPORTED
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunBlindFire::OutroNew_OnProcessMoveSignals()
{
	if (!m_pTaskUseCoverMoveNetworkHelper || !m_pTaskUseCoverMoveNetworkHelper->IsNetworkActive())
	{
		return;
	}

	m_bMoveInterruptToCockGun |= m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_InterruptToCockGunId);
	m_bMoveBlindFireOutroClipFinished |= m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_BlindFireOutroClipFinishedId);
	m_bMoveIKLeftHandUseGripBone |= m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_IKLeftHandUseGripBoneId);
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::CockGun_OnEnter()
{
	taskAssert(m_pCachedAnimStateInfoNew->m_CockGunClip0Id != CLIP_ID_INVALID);
	const fwMvClipSetId clipSetId = m_pTaskUseCoverMoveNetworkHelper->GetClipSetId(CTaskMotionInCover::ms_WeaponClipSetId);
	taskAssert(clipSetId != CLIP_SET_ID_INVALID);

	const crClip* pClip = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_CockGunClip0Id);
	if (taskVerifyf(pClip, "Couldn't find outro clip 0, %s %s", clipSetId.GetCStr(), m_pCachedAnimStateInfoNew->m_CockGunClip0Id.GetCStr()))
	{
		m_pTaskUseCoverMoveNetworkHelper->SetClip(pClip, CClipScalingHelper::ms_Clip0Id);

		// Perform a clip on the weapon if one is specified
		CWeapon* pWeapon = GetPed()->GetWeaponManager()->GetEquippedWeapon();
		if (pWeapon)
		{
			pWeapon->StartAnim(clipSetId, m_pCachedAnimStateInfoNew->m_CockGunWeaponClipId, NORMAL_BLEND_DURATION);
		}		
	}

#if FPS_MODE_SUPPORTED
	if (GetPed()->IsFirstPersonShooterModeEnabledForPlayer(false) && m_pCachedAnimStateInfoNew->m_CockGunClip1Id != CLIP_ID_INVALID)
	{
		const crClip* pClip1 = fwClipSetManager::GetClip(clipSetId, m_pCachedAnimStateInfoNew->m_CockGunClip1Id);
		m_pTaskUseCoverMoveNetworkHelper->SetClip(pClip1, CClipScalingHelper::ms_Clip1Id);
	}
#endif // FPS_MODE_SUPPORTED

	m_pTaskUseCoverMoveNetworkHelper->SendRequest(ms_CockGunRequestId);
	m_pTaskUseCoverMoveNetworkHelper->WaitForTargetState(ms_CockGunOnEnterId);

	RequestProcessMoveSignalCalls();
	m_bMoveCockGunClipFinished = false;
	m_bMoveCockInterrupt = false;

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTask::FSM_Return CTaskAimGunBlindFire::CockGun_OnUpdate()
{
	CPed& ped = *GetPed();
#if FPS_MODE_SUPPORTED
	if (ped.IsFirstPersonShooterModeEnabledForPlayer(false))
	{
		ped.SetPedResetFlag(CPED_RESET_FLAG_DisableCameraConstraintFallBackThisFrame, true);
	}
#endif // FPS_MODE_SUPPORTED

	if (!m_pTaskUseCoverMoveNetworkHelper->IsInTargetState())
		return FSM_Continue;

	if (m_bMoveCockGunClipFinished || m_bMoveCockInterrupt)
	{
		CWeapon* pWeapon = ped.GetWeaponManager()->GetEquippedWeapon();
		if (pWeapon)
		{
			pWeapon->SetWeaponIdleFlag(true);
		}

		WeaponControllerState controllerState = GetWeaponControllerState(&ped);
		if (controllerState != WCS_Fire || WantsToReload() || (ped.IsLocalPlayer() && ped.GetPlayerInfo()->IsAiming()))
		{
			SetState(State_Finish);
			return FSM_Continue;
		}
		else
		{
			m_fireCounter = 0;

			if(NetworkInterface::IsGameInProgress() && !ped.IsNetworkClone())
			{
				//the replay random seed value is used to synchronize the shotgun blast pattern on the local to the remote
				if (ped.GetEquippedWeaponInfo()->GetGroup() == WEAPONGROUP_SHOTGUN)
				{
					u32 tmpseed = g_ReplayRand.GetSeed();
					if (tmpseed == m_seed)
						m_seed = fwRandom::GetRandomNumber(); //need to reset random with random as seed is the same as last time
					else
						m_seed = tmpseed;

					g_ReplayRand.Reset(m_seed); //IMPORTANT: need to reset the seed here with the seed we will use otherwise the m_seed1 will not be set appropriately on all consoles A/B/C...

				}
				else
				{
					m_seed = 0;
				}

				m_iAmmoInClip = (u8) (pWeapon ? pWeapon->GetAmmoInClip() : 0);
			}

			SetState(State_IntroNew);
			return FSM_Continue;
		}
	}

	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

void CTaskAimGunBlindFire::CockGun_OnProcessMoveSignals()
{
	if (!m_pTaskUseCoverMoveNetworkHelper || !m_pTaskUseCoverMoveNetworkHelper->IsNetworkActive())
	{
		return;
	}

	m_bMoveCockGunClipFinished |= m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_CockGunClipFinishedId);
	m_bMoveCockInterrupt |= m_pTaskUseCoverMoveNetworkHelper->GetBoolean(ms_CockInterruptId);
}

////////////////////////////////////////////////////////////////////////////////

bool CTaskAimGunBlindFire::ShouldFire()
{
	CPed* pPed = GetPed();

	// Check if the weapon and the peds firing pattern are in a good state to fire
	CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();

	if (pWeapon && (pWeapon->GetState() == CWeapon::STATE_READY)
		&& pPed->GetPedIntelligence()->GetFiringPattern().WantsToFire() && pPed->GetPedIntelligence()->GetFiringPattern().ReadyToFire())
	{
		const CWeaponInfo* pWeaponInfo = pPed->GetWeaponManager()->GetEquippedWeaponInfo();

		taskFatalAssertf(pWeaponInfo,"NULL weapon info in CTaskAimGunBlindFire::ShouldFire");

		// Check if we're firing
		if (GetWeaponControllerState(pPed) == WCS_Fire)
		{
			return true;
		}
		// Check if we're holding fire with an automatic weapon, of force firing at least once
		else if ((GetWeaponControllerState(pPed) == WCS_FireHeld && pWeaponInfo->GetIsAutomatic()) || m_iFlags.IsFlagSet(GF_FireAtLeastOnce))
		{
			return true;
		}
	}

	return false;
}

void CTaskAimGunBlindFire::DoFire()
{
	m_bFire = true;
}

void CTaskAimGunBlindFire::ResetFire()
{
	m_bOutroPending = false;
	m_bFireLoopOnEnter = false;
	m_bFiredOnce = false;
	m_bFiredTwice = false;
	m_bFire = false;

	m_bMoveFireLoopOnEnter = false;
	m_bMoveFire = false;
	m_bMoveFireLoop1 = false;
	m_bMoveFireLoop2 = false;
}

bool CTaskAimGunBlindFire::WantsToReload() const
{
	const CPed* pPed = GetPed();
	const CWeapon* pWeapon = pPed->GetWeaponManager()->GetEquippedWeapon();

	if (pWeapon && (pWeapon->GetNeedsToReload(true) || pWeapon->GetAmmoTotal() == 0) && !pPed->IsNetworkClone())
	{
		return true;
	}
	return false;
}

void CTaskAimGunBlindFire::ProcessIK()
{
	CPed* pPed = GetPed();
	CIkManager& ikManager = pPed->GetIkManager();
	s32 aimFlags = AIK_USE_FULL_REACH;

	if (GetState()==State_FireNew && m_bFireLoopOnEnter)
	{
#if FPS_MODE_SUPPORTED
		if (pPed->IsFirstPersonShooterModeEnabledForPlayer(false))
		{
			aimFlags |= AIK_APPLY_ALT_SRC_RECOIL;
		}
		else
#endif // FPS_MODE_SUPPORTED
		{
			CIkRequestBodyRecoil bodyRecoilRequest;
			ikManager.Request(bodyRecoilRequest);

			aimFlags |= AIK_APPLY_RECOIL;
		}
	}

	ikManager.AimWeapon(crIKSolverArms::RIGHT_ARM, aimFlags);
}

#if !__FINAL
void CTaskAimGunBlindFire::Debug() const
{
#if DEBUG_DRAW
	if (CDebugScene::FocusEntities_Get(0) == GetPed())
	{
		grcDebugDraw::AddDebugOutput(Color_blue, "Low Flag Set : %u",	GetGunFlags().IsFlagSet(GF_LowCover));
		grcDebugDraw::AddDebugOutput(Color_blue, "Left Flag Set : %u",	GetGunFlags().IsFlagSet(GF_LeftCover));
		grcDebugDraw::AddDebugOutput(Color_blue, "Corner Flag Set : %u", GetGunFlags().IsFlagSet(GF_CornerCover));
	}
#endif
}
#endif // !__FINAL

CClonedAimGunBlindFireInfo::CClonedAimGunBlindFireInfo() : m_fireCounter(0), m_iAmmoInClip(0), m_seed(0)
{
}

CClonedAimGunBlindFireInfo::CClonedAimGunBlindFireInfo(s32 aimGunBlindFireState, u8 fireCounter, u8 ammoInClip, u32 seed) : m_fireCounter(fireCounter), m_iAmmoInClip(ammoInClip), m_seed(seed)
{
	SetStatusFromMainTaskState(aimGunBlindFireState);

	m_bHasSeed = (seed != 0);
}

void CClonedAimGunBlindFireInfo::Serialise(CSyncDataBase& serialiser)
{
	CSerialisedFSMTaskInfo::Serialise(serialiser);

	const unsigned SIZEOF_AMMO_IN_CLIP = 8;

	SERIALISE_UNSIGNED(serialiser, m_iAmmoInClip, SIZEOF_AMMO_IN_CLIP, "Ammo In Clip");
	SERIALISE_UNSIGNED(serialiser, m_fireCounter, sizeof(m_fireCounter)<<3, "Fire counter");
	SERIALISE_BOOL(serialiser, m_bHasSeed, "m_bHasSeed");
	if (m_bHasSeed)
	{
		SERIALISE_UNSIGNED(serialiser, m_seed, 32, "m_seed");
	}
	else
	{
		m_seed = 0;
	}
}

////////////////////////////////////////////////////////////////////////////////

void CoverVariationsInfo::InitCoverVariations(const atArray<fwMvClipSetId>& clipsets, 
											  atFixedArray<CPrioritizedClipSetRequestHelper, sMaxCoverVariationClipsets>& requesthelpers,
											  SemiShuffledSequence& shuffler,
											  s32& shufflerIndex)
{
	const u32 uClipsetCount = clipsets.GetCount();
	if (uClipsetCount > 0)
	{
		shuffler.SetNumElements(uClipsetCount);

		for (s32 i=0; i<requesthelpers.GetCount(); ++i)
		{
			s32 iIndex = shuffler.GetElement(shufflerIndex);
			requesthelpers[i].Request(clipsets[iIndex]);
			++shufflerIndex;
			//Reset when we've reached the end
			if (shufflerIndex >= uClipsetCount)
			{
				shufflerIndex = 0;
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

const atArray<fwMvClipSetId>* CoverVariationsInfo::GetClipSetArrayForVariationType(eVariationType variationType, eArmamentType armamentType, bool bHigh)
{
	switch (variationType)
	{
		case VT_AiPeeking:
			{
				switch (armamentType)
				{
					case AT_OneHanded: return bHigh ? &CTaskMotionInCover::ms_Tunables.m_PeekingHigh1HVariationClipsets : &CTaskMotionInCover::ms_Tunables.m_PeekingLow1HVariationClipsets;
					case AT_TwoHanded: return bHigh ? &CTaskMotionInCover::ms_Tunables.m_PeekingHigh2HVariationClipsets : &CTaskMotionInCover::ms_Tunables.m_PeekingLow2HVariationClipsets;
					default: break;
				}	
			}
		case VT_AiPinned:
			{
				switch (armamentType)
				{
					case AT_OneHanded: return bHigh ? &CTaskMotionInCover::ms_Tunables.m_PinnedHigh1HVariationClipsets : &CTaskMotionInCover::ms_Tunables.m_PinnedLow1HVariationClipsets;
					case AT_TwoHanded: return bHigh ? &CTaskMotionInCover::ms_Tunables.m_PinnedHigh2HVariationClipsets : &CTaskMotionInCover::ms_Tunables.m_PinnedLow2HVariationClipsets;
					default: break;
				}	
			}
		case VT_AiIdle:
			{
				switch (armamentType)
				{
					case AT_OneHanded: return bHigh ? &CTaskMotionInCover::ms_Tunables.m_IdleHigh1HVariationClipsets : &CTaskMotionInCover::ms_Tunables.m_IdleLow1HVariationClipsets;
					case AT_TwoHanded: return bHigh ? &CTaskMotionInCover::ms_Tunables.m_IdleHigh2HVariationClipsets : &CTaskMotionInCover::ms_Tunables.m_IdleLow2HVariationClipsets;
					default: break;
				}	
			}
		case VT_PlayerIdle:
			{
				switch (armamentType)
				{
					case AT_Unarmed:	return bHigh ? &CTaskMotionInCover::ms_Tunables.m_PlayerIdleHigh0HVariationClipsets : &CTaskMotionInCover::ms_Tunables.m_PlayerIdleLow0HVariationClipsets;
					case AT_OneHanded:  return bHigh ? &CTaskMotionInCover::ms_Tunables.m_PlayerIdleHigh1HVariationClipsets : &CTaskMotionInCover::ms_Tunables.m_PlayerIdleLow1HVariationClipsets;
					case AT_TwoHanded:  return bHigh ? &CTaskMotionInCover::ms_Tunables.m_PlayerIdleHigh2HVariationClipsets : &CTaskMotionInCover::ms_Tunables.m_PlayerIdleLow2HVariationClipsets;
					default: break;
				}	
			}
		case VT_AiOutroReact:
			{
				switch (armamentType)
				{
				case AT_OneHanded: return &CTaskMotionInCover::ms_Tunables.m_OutroReact1HVariationClipsets;
				case AT_TwoHanded: return &CTaskMotionInCover::ms_Tunables.m_OutroReact2HVariationClipsets;
				default: break;
				}	
			}
		default: aiAssertf(0, "Unhandled variation type %i, armament type %i", variationType, armamentType); break;
	}
	return NULL;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipSetId CoverVariationsInfo::ChooseClipSetForPed(const CPed& ped)
{
	if (ped.GetWeaponManager()->GetEquippedWeaponInfo())
	{
		const CPrioritizedClipSetRequestHelper& rClipSetRequestHelper = m_aVariationClipsetRequestHelpers[m_iCurrentIndex++];
		if (m_iCurrentIndex == m_aVariationClipsetRequestHelpers.GetCount())
		{
			m_iCurrentIndex = 0;
		}

		if (rClipSetRequestHelper.IsActive())
		{
			const fwMvClipSetId chosenClipsetId = rClipSetRequestHelper.GetClipSetId();
			if (fwClipSetManager::IsStreamedIn_DEPRECATED(chosenClipsetId))
			{
				++m_uNumTimesUsed;
				return chosenClipsetId;
			}
		}
	}
	return CLIP_SET_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

CAiCoverClipVariationHelper::Tunables CAiCoverClipVariationHelper::sm_Tunables;

IMPLEMENT_COMBAT_TASK_TUNABLES(CAiCoverClipVariationHelper, 0x2a5cad7d);

////////////////////////////////////////////////////////////////////////////////

CAiCoverClipVariationHelper::CAiCoverClipVariationHelper()
: m_coverLowPeeking1HVariationsInfo(sm_Tunables.m_MinUsesForPeekingVariationChange, sm_Tunables.m_MaxUsesForPeekingVariationChange)
, m_coverLowPeeking2HVariationsInfo(sm_Tunables.m_MinUsesForPeekingVariationChange, sm_Tunables.m_MaxUsesForPeekingVariationChange)
, m_coverHighPeeking1HVariationsInfo(sm_Tunables.m_MinUsesForPeekingVariationChange, sm_Tunables.m_MaxUsesForPeekingVariationChange)
, m_coverHighPeeking2HVariationsInfo(sm_Tunables.m_MinUsesForPeekingVariationChange, sm_Tunables.m_MaxUsesForPeekingVariationChange)
, m_coverLowPinned1HVariationsInfo(sm_Tunables.m_MinUsesForPinnedVariationChange, sm_Tunables.m_MaxUsesForPinnedVariationChange)
, m_coverLowPinned2HVariationsInfo(sm_Tunables.m_MinUsesForPinnedVariationChange, sm_Tunables.m_MaxUsesForPinnedVariationChange)
, m_coverHighPinned1HVariationsInfo(sm_Tunables.m_MinUsesForPinnedVariationChange, sm_Tunables.m_MaxUsesForPinnedVariationChange)
, m_coverHighPinned2HVariationsInfo(sm_Tunables.m_MinUsesForPinnedVariationChange, sm_Tunables.m_MaxUsesForPinnedVariationChange)
, m_coverReactOutro1HVariationsInfo(sm_Tunables.m_MinUsesForOutroReactVariationChange, sm_Tunables.m_MaxUsesForOutroReactVariationChange)
, m_coverReactOutro2HVariationsInfo(sm_Tunables.m_MinUsesForOutroReactVariationChange, sm_Tunables.m_MaxUsesForOutroReactVariationChange)
, m_coverLowIdle1HVariationsInfo(sm_Tunables.m_MinUsesForIdleVariationChange, sm_Tunables.m_MaxUsesForIdleVariationChange)
, m_coverLowIdle2HVariationsInfo(sm_Tunables.m_MinUsesForIdleVariationChange, sm_Tunables.m_MaxUsesForIdleVariationChange)
, m_coverHighIdle1HVariationsInfo(sm_Tunables.m_MinUsesForIdleVariationChange, sm_Tunables.m_MaxUsesForIdleVariationChange)
, m_coverHighIdle2HVariationsInfo(sm_Tunables.m_MinUsesForIdleVariationChange, sm_Tunables.m_MaxUsesForIdleVariationChange)
{

}

////////////////////////////////////////////////////////////////////////////////

CAiCoverClipVariationHelper::~CAiCoverClipVariationHelper()
{

}

////////////////////////////////////////////////////////////////////////////////

void CAiCoverClipVariationHelper::InitCoverVariationsFromInfo(CoverVariationsInfo& variationInfo, bool bTwoHanded, bool bHigh, CoverVariationsInfo::eVariationType variationType)
{
	const atArray<fwMvClipSetId>* apClipsetIds = CoverVariationsInfo::GetClipSetArrayForVariationType(variationType, bTwoHanded ? CoverVariationsInfo::AT_TwoHanded : CoverVariationsInfo::AT_OneHanded, bHigh);
	if (apClipsetIds)
	{
		CoverVariationsInfo::InitCoverVariations(*apClipsetIds,
												variationInfo.m_aVariationClipsetRequestHelpers, 
												variationInfo.m_CoverClipsetShuffler, 
												variationInfo.m_iCoverClipsetIndex);
	}
}

////////////////////////////////////////////////////////////////////////////////

void CAiCoverClipVariationHelper::Init()
{
	InitCoverVariationsFromInfo(m_coverHighPeeking1HVariationsInfo, false, true, CoverVariationsInfo::VT_AiPeeking);
	InitCoverVariationsFromInfo(m_coverLowPeeking1HVariationsInfo, false, false, CoverVariationsInfo::VT_AiPeeking);
	InitCoverVariationsFromInfo(m_coverHighPeeking2HVariationsInfo, true, true, CoverVariationsInfo::VT_AiPeeking);
	InitCoverVariationsFromInfo(m_coverLowPeeking2HVariationsInfo, true, false, CoverVariationsInfo::VT_AiPeeking);

	InitCoverVariationsFromInfo(m_coverHighPinned1HVariationsInfo, false, true, CoverVariationsInfo::VT_AiPinned);
	InitCoverVariationsFromInfo(m_coverLowPinned1HVariationsInfo, false, false, CoverVariationsInfo::VT_AiPinned);
	InitCoverVariationsFromInfo(m_coverHighPinned2HVariationsInfo, true, true, CoverVariationsInfo::VT_AiPinned);
	InitCoverVariationsFromInfo(m_coverLowPinned2HVariationsInfo, true, false, CoverVariationsInfo::VT_AiPinned);

	InitCoverVariationsFromInfo(m_coverReactOutro1HVariationsInfo, false, true, CoverVariationsInfo::VT_AiOutroReact);
	InitCoverVariationsFromInfo(m_coverReactOutro2HVariationsInfo, true, true, CoverVariationsInfo::VT_AiOutroReact);

	InitCoverVariationsFromInfo(m_coverHighIdle1HVariationsInfo, false, true, CoverVariationsInfo::VT_AiIdle);
	InitCoverVariationsFromInfo(m_coverLowIdle1HVariationsInfo, false, false, CoverVariationsInfo::VT_AiIdle);
	InitCoverVariationsFromInfo(m_coverHighIdle2HVariationsInfo, true, true, CoverVariationsInfo::VT_AiIdle);
	InitCoverVariationsFromInfo(m_coverLowIdle2HVariationsInfo, true, false, CoverVariationsInfo::VT_AiIdle);
}

////////////////////////////////////////////////////////////////////////////////

void CAiCoverClipVariationHelper::UpdateClipVariationStreaming(u32 uNumPedsWith1HWeapons, u32 uNumPedsWith2HWeapons)
{
	if (uNumPedsWith1HWeapons > 0)
	{
		UpdateCover1HVariations();
	}
	if (uNumPedsWith2HWeapons > 0)
	{
		UpdateCover2HVariations();
	}
}

////////////////////////////////////////////////////////////////////////////////

void CAiCoverClipVariationHelper::UpdateCover1HVariations()
{
	UpdateCoverVariationsFromInfo(m_coverLowPeeking1HVariationsInfo, false, false, CoverVariationsInfo::VT_AiPeeking);
	UpdateCoverVariationsFromInfo(m_coverHighPeeking1HVariationsInfo, false, true, CoverVariationsInfo::VT_AiPeeking);
	UpdateCoverVariationsFromInfo(m_coverLowPinned1HVariationsInfo, false, false, CoverVariationsInfo::VT_AiPinned);
	UpdateCoverVariationsFromInfo(m_coverHighPinned1HVariationsInfo, false, true, CoverVariationsInfo::VT_AiPinned);
	UpdateCoverVariationsFromInfo(m_coverReactOutro1HVariationsInfo, false, true, CoverVariationsInfo::VT_AiOutroReact);
	UpdateCoverVariationsFromInfo(m_coverLowIdle1HVariationsInfo, false, false, CoverVariationsInfo::VT_AiIdle);
	UpdateCoverVariationsFromInfo(m_coverHighIdle1HVariationsInfo, false, true, CoverVariationsInfo::VT_AiIdle);
}

////////////////////////////////////////////////////////////////////////////////

void CAiCoverClipVariationHelper::UpdateCover2HVariations()
{
	UpdateCoverVariationsFromInfo(m_coverLowPeeking2HVariationsInfo, true, false, CoverVariationsInfo::VT_AiPeeking);
	UpdateCoverVariationsFromInfo(m_coverHighPeeking2HVariationsInfo, true, true, CoverVariationsInfo::VT_AiPeeking);
	UpdateCoverVariationsFromInfo(m_coverLowPinned2HVariationsInfo, true, false, CoverVariationsInfo::VT_AiPinned);
	UpdateCoverVariationsFromInfo(m_coverHighPinned2HVariationsInfo, true, true, CoverVariationsInfo::VT_AiPinned);
	UpdateCoverVariationsFromInfo(m_coverReactOutro2HVariationsInfo, true, true, CoverVariationsInfo::VT_AiOutroReact);
	UpdateCoverVariationsFromInfo(m_coverLowIdle2HVariationsInfo, true, false, CoverVariationsInfo::VT_AiIdle);
	UpdateCoverVariationsFromInfo(m_coverHighIdle2HVariationsInfo, true, true, CoverVariationsInfo::VT_AiIdle);
}

////////////////////////////////////////////////////////////////////////////////

void CAiCoverClipVariationHelper::UpdateCoverVariationsFromInfo(CoverVariationsInfo& variationInfo, bool bTwoHanded, bool bHigh, CoverVariationsInfo::eVariationType variationType)
{
	if (variationInfo.m_uNumTimesUsed > variationInfo.m_uMaxNumTimesUsed)
	{
		variationInfo.Reset();
		InitCoverVariationsFromInfo(variationInfo, bTwoHanded, bHigh, variationType);
	}
	else
	{
		//Keep requesting our current clipsets
		for (s32 i=0; i<variationInfo.m_aVariationClipsetRequestHelpers.GetCount(); ++i)
		{
			variationInfo.m_aVariationClipsetRequestHelpers[i].Request();
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

CPlayerCoverClipVariationHelper::Tunables CPlayerCoverClipVariationHelper::sm_Tunables;
CPlayerCoverClipVariationHelper CPlayerCoverClipVariationHelper::sm_Instance;

IMPLEMENT_COMBAT_TASK_TUNABLES(CPlayerCoverClipVariationHelper, 0x076c9abc);

////////////////////////////////////////////////////////////////////////////////

CPlayerCoverClipVariationHelper::CPlayerCoverClipVariationHelper()
: m_coverLowIdle0HVariationsInfo(sm_Tunables.m_MinUsesForIdleVariationChange, sm_Tunables.m_MaxUsesForIdleVariationChange)
, m_coverLowIdle1HVariationsInfo(sm_Tunables.m_MinUsesForIdleVariationChange, sm_Tunables.m_MaxUsesForIdleVariationChange)
, m_coverLowIdle2HVariationsInfo(sm_Tunables.m_MinUsesForIdleVariationChange, sm_Tunables.m_MaxUsesForIdleVariationChange)
, m_coverHighIdle0HVariationsInfo(sm_Tunables.m_MinUsesForIdleVariationChange, sm_Tunables.m_MaxUsesForIdleVariationChange)
, m_coverHighIdle1HVariationsInfo(sm_Tunables.m_MinUsesForIdleVariationChange, sm_Tunables.m_MaxUsesForIdleVariationChange)
, m_coverHighIdle2HVariationsInfo(sm_Tunables.m_MinUsesForIdleVariationChange, sm_Tunables.m_MaxUsesForIdleVariationChange)
, m_bInitialised(false)
{

}

////////////////////////////////////////////////////////////////////////////////

CPlayerCoverClipVariationHelper::~CPlayerCoverClipVariationHelper()
{

}

////////////////////////////////////////////////////////////////////////////////

void CPlayerCoverClipVariationHelper::InitCoverVariationsFromInfo(CoverVariationsInfo& variationInfo, CoverVariationsInfo::eArmamentType armamentType, bool bHigh, CoverVariationsInfo::eVariationType variationType)
{
	const atArray<fwMvClipSetId>* apClipsetIds = CoverVariationsInfo::GetClipSetArrayForVariationType(variationType, armamentType, bHigh);
	if (apClipsetIds)
	{
		CoverVariationsInfo::InitCoverVariations(*apClipsetIds,
												variationInfo.m_aVariationClipsetRequestHelpers, 
												variationInfo.m_CoverClipsetShuffler, 
												variationInfo.m_iCoverClipsetIndex);
	}
}

////////////////////////////////////////////////////////////////////////////////

void CPlayerCoverClipVariationHelper::ClearClipVariationStreaming()
{
	UpdateCoverVariationsFromInfo(m_coverLowIdle0HVariationsInfo, CoverVariationsInfo::AT_Unarmed, false, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverHighIdle0HVariationsInfo, CoverVariationsInfo::AT_Unarmed, true, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverLowIdle1HVariationsInfo, CoverVariationsInfo::AT_OneHanded, false, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverHighIdle1HVariationsInfo, CoverVariationsInfo::AT_OneHanded, true, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverLowIdle2HVariationsInfo, CoverVariationsInfo::AT_TwoHanded, false, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverHighIdle2HVariationsInfo, CoverVariationsInfo::AT_TwoHanded, true, CoverVariationsInfo::VT_PlayerIdle, false);
}

void CPlayerCoverClipVariationHelper::UpdateClipVariationStreaming(const CPed& ped)
{
	if (ped.GetWeaponManager())
	{
		const CWeaponInfo* pWeaponInfo = ped.GetWeaponManager()->GetEquippedWeaponInfo();
		if (pWeaponInfo)
		{
			if (pWeaponInfo->GetIsMelee())
			{
				UpdateCover0HVariations();
			}
			else if (pWeaponInfo->GetIsGun1Handed())
			{
				UpdateCover1HVariations();
			}
			else if(pWeaponInfo->GetIsGun2Handed())
			{
				UpdateCover2HVariations();
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CPlayerCoverClipVariationHelper::UpdateCover0HVariations()
{
	UpdateCoverVariationsFromInfo(m_coverLowIdle0HVariationsInfo, CoverVariationsInfo::AT_Unarmed, false, CoverVariationsInfo::VT_PlayerIdle, true);
	UpdateCoverVariationsFromInfo(m_coverHighIdle0HVariationsInfo, CoverVariationsInfo::AT_Unarmed, true, CoverVariationsInfo::VT_PlayerIdle, true);
	UpdateCoverVariationsFromInfo(m_coverLowIdle1HVariationsInfo, CoverVariationsInfo::AT_OneHanded, false, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverHighIdle1HVariationsInfo, CoverVariationsInfo::AT_OneHanded, true, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverLowIdle2HVariationsInfo, CoverVariationsInfo::AT_TwoHanded, false, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverHighIdle2HVariationsInfo, CoverVariationsInfo::AT_TwoHanded, true, CoverVariationsInfo::VT_PlayerIdle, false);
}

////////////////////////////////////////////////////////////////////////////////

void CPlayerCoverClipVariationHelper::UpdateCover1HVariations()
{
	UpdateCoverVariationsFromInfo(m_coverLowIdle0HVariationsInfo, CoverVariationsInfo::AT_Unarmed, false, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverHighIdle0HVariationsInfo, CoverVariationsInfo::AT_Unarmed, true, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverLowIdle1HVariationsInfo, CoverVariationsInfo::AT_OneHanded, false, CoverVariationsInfo::VT_PlayerIdle, true);
	UpdateCoverVariationsFromInfo(m_coverHighIdle1HVariationsInfo, CoverVariationsInfo::AT_OneHanded, true, CoverVariationsInfo::VT_PlayerIdle, true);
	UpdateCoverVariationsFromInfo(m_coverLowIdle2HVariationsInfo, CoverVariationsInfo::AT_TwoHanded, false, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverHighIdle2HVariationsInfo, CoverVariationsInfo::AT_TwoHanded, true, CoverVariationsInfo::VT_PlayerIdle, false);
}

////////////////////////////////////////////////////////////////////////////////

void CPlayerCoverClipVariationHelper::UpdateCover2HVariations()
{
	UpdateCoverVariationsFromInfo(m_coverLowIdle0HVariationsInfo, CoverVariationsInfo::AT_Unarmed, false, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverHighIdle0HVariationsInfo, CoverVariationsInfo::AT_Unarmed, true, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverLowIdle1HVariationsInfo, CoverVariationsInfo::AT_OneHanded, false, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverHighIdle1HVariationsInfo, CoverVariationsInfo::AT_OneHanded, true, CoverVariationsInfo::VT_PlayerIdle, false);
	UpdateCoverVariationsFromInfo(m_coverLowIdle2HVariationsInfo, CoverVariationsInfo::AT_TwoHanded, false, CoverVariationsInfo::VT_PlayerIdle, true);
	UpdateCoverVariationsFromInfo(m_coverHighIdle2HVariationsInfo, CoverVariationsInfo::AT_TwoHanded, true, CoverVariationsInfo::VT_PlayerIdle, true);
}

////////////////////////////////////////////////////////////////////////////////

void CPlayerCoverClipVariationHelper::UpdateCoverVariationsFromInfo(CoverVariationsInfo& variationInfo, CoverVariationsInfo::eArmamentType armamentType, bool bHigh, CoverVariationsInfo::eVariationType variationType, bool bStreamIn)
{
	if(bStreamIn)
	{
		if ((variationInfo.m_uNumTimesUsed > variationInfo.m_uMaxNumTimesUsed) || !variationInfo.HasActiveRequests())
		{
			variationInfo.Reset();
			InitCoverVariationsFromInfo(variationInfo, armamentType, bHigh, variationType);
		}
		else
		{
			//Keep requesting our current clipsets
			for (s32 i=0; i<variationInfo.m_aVariationClipsetRequestHelpers.GetCount(); ++i)
			{
				variationInfo.m_aVariationClipsetRequestHelpers[i].Request();
			}
		}
	}
	else
	{
		//Release our current clipsets
		for (s32 i=0; i<variationInfo.m_aVariationClipsetRequestHelpers.GetCount(); ++i)
		{
			variationInfo.m_aVariationClipsetRequestHelpers[i].Release();
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

#define BANK_COVER_DEBUG(x) BANK_ONLY(if (CCoverDebug::ms_bEnableTaskDebugSpew) x)
#define BANK_COVER_MOVE_DEBUG(x) BANK_ONLY(if (CCoverDebug::ms_bEnableMoveStateDebugSpew) x)

dev_float CENTER_CP_WIDTH	= 0.2f;
dev_float CENTRE_Y_OFFSET = -0.2f;
dev_float CENTER_LENGTH		= 2.0f;
dev_float OUTER_CP_WIDTH	= 0.3f;
dev_float OUTER_CP_WIDTH2	= 0.85f;
dev_float OUTER_Y_OFFSET = -0.2f;
dev_float OUTER_LENGTH		= 2.0f;
dev_float LOWER_CP_HEIGHT	= -0.2f;
dev_float UPPER_CP_HEIGHT	= 0.65f;
dev_float CAPSULE_RADIUS	= 0.05f;

dev_float EXTRA_LOW_CAPSULE_RADIUS = 0.2f;
dev_float EXTRA_LOW_HEIGHT = -0.6f;
dev_bool sbUseCullBox = true;

static CollisionTestType MAIN_TEST_TYPE = CTT_Capsule;
dev_float RUNNING_EXTENDED_DISTANCE_FPS = 5.0f;
dev_float RUNNING_EXTENDED_DISTANCE = 8.0f;
dev_float WALKING_EXTENDED_DISTANCE_FPS = 4.0f;
dev_float WALKING_EXTENDED_DISTANCE = 5.0f;
//dev_float DISTANCE_FROM_COVER_TO_STAND_LOW = 0.15f;
//dev_float DISTANCE_FROM_COVER_TO_STAND_HIGH = 0.15f;
dev_float DISTANCE_TO_EVALUATE_COVER_FROM_CURRENT_POS = 1.0f;
dev_float DISTANCE_TO_ONLY_ACCEPT_COVER_IN_DIRECTION = 3.0f;
dev_float COVER_DIRECTION_TOLERANCE = -0.707f;

PF_PAGE(GTADynamicCover, "GTA player dynamic cover");
PF_GROUP(CollisionChecks);
PF_LINK(GTADynamicCover, CollisionChecks);

PF_TIMER(Total, CollisionChecks);
PF_TIMER(CoverEdge, CollisionChecks);

dev_float DIRECTIONAL_LERP_SPEED = 1.0f;
static CollisionTestType initialTestType = CTT_Los;

////////////////////////////////////////////////////////////////////////////////

// Statics
CDynamicCoverHelper::Tunables CDynamicCoverHelper::ms_Tunables;

IMPLEMENT_COMBAT_TASK_TUNABLES(CDynamicCoverHelper, 0xf77da316);

////////////////////////////////////////////////////////////////////////////////

bank_float CDynamicCoverHelper::ms_fCenterCPWidth			= 0.2f;
bank_float CDynamicCoverHelper::ms_fCenterCPWidth2			= 0.1f;
bank_float CDynamicCoverHelper::ms_fCenterYOffset			= -0.2f;
bank_float CDynamicCoverHelper::ms_fOuterCPWidth				= 0.5f;
bank_float CDynamicCoverHelper::ms_fOuterCPWidth2			= 0.85f;
bank_float CDynamicCoverHelper::ms_fOuterYOffset				= -0.2f;

bank_float CDynamicCoverHelper::ms_fMovingCenterBackwardCPWidth  = -0.2f;
bank_float CDynamicCoverHelper::ms_fMovingCenterForwardCPWidth   = 0.2f;
bank_float CDynamicCoverHelper::ms_fMovingInnerForwardCPWidth	= 0.4f;
bank_float CDynamicCoverHelper::ms_fMovingInnerForwardCPWidth2	= 0.4f;
bank_float CDynamicCoverHelper::ms_fMovingOuterForwardCPWidth	= 0.45f;
bank_float CDynamicCoverHelper::ms_fMovingOuterForwardCPWidth2	= 0.8f;
bank_float CDynamicCoverHelper::ms_fYInnerStartOffset			= -0.2f;
bank_float CDynamicCoverHelper::ms_fYInnerEndOffset				= 1.0f;
bank_float CDynamicCoverHelper::ms_fYOuterStartOffset			= -0.2f;
bank_float CDynamicCoverHelper::ms_fYOuterEndOffset				= 1.0f;

bank_float CDynamicCoverHelper::ms_fCapsuleRadius			= 0.05f;
bank_float CDynamicCoverHelper::ms_fExtraLowCapsuleRadius	= 0.2f;
bank_float CDynamicCoverHelper::ms_fExtraLowHeight			= -0.6f;

bank_float CDynamicCoverHelper::ms_fObstructionTestHeight	= -0.4f;
bank_float CDynamicCoverHelper::ms_fObstructionTestHeadingTol = 0.785f;
bank_float CDynamicCoverHelper::ms_fOptimumDistToLeftInsideEdge = 0.4f;
bank_float CDynamicCoverHelper::ms_fOptimumDistToRightInsideEdge = 0.4f;
bank_float CDynamicCoverHelper::ms_fOptimumDistToLeftInsideEdgeCrouched = 0.5f;
bank_float CDynamicCoverHelper::ms_fOptimumDistToRightInsideEdgeCrouched = 0.5f;
bank_float CDynamicCoverHelper::ms_fMinInsideEdgeOffset = 0.05f;
bank_float CDynamicCoverHelper::ms_fMaxInsideEdgeOffset = 0.8f;

#if __BANK
const char* CDynamicCoverHelper::ms_IdleLineProbeStrings[] =
{
	"ILP_LeftLow",
	"ILP_FrontLowL",
	"ILP_FrontLowC",
	"ILP_FrontLowR",
	"ILP_RightLow",
	"ILP_LeftHigh",
	"ILP_FrontHighL",
	"ILP_FrontHighC",
	"ILP_FrontHighR",
	"ILP_RightHigh",
	"ILP_LowCentre",
	"ILP_Max"
};

const char* CDynamicCoverHelper::ms_MovingLineProbeStrings[] =
{
	"MLP_CenterBackwardLow",
	"MLP_CenterLow",
	"MLP_CenterForwardLow",
	"MLP_InnerForwardLow",
	"MLP_OuterForwardLow",
	"MLP_CenterBackwardHigh",
	"MLP_CenterHigh",
	"MLP_CenterForwardHigh",
	"MLP_InnerForwardHigh",
	"MLP_OuterForwardHigh",
	"MLP_LowCentre",
	"MLP_Max"
};
#endif // __BANK

////////////////////////////////////////////////////////////////////////////////

float CDynamicCoverHelper::LimitRadianAngle2PI(float fLimitAngle)
{
	// Clip the value to avoid nasty input breaking the game.
	fLimitAngle = MAX(-25.0f, fLimitAngle);
	fLimitAngle = MIN(25.0f, fLimitAngle);
	fLimitAngle = fwAngle::LimitRadianAngle0to2PiSafe(fLimitAngle);

	return fLimitAngle;
}

////////////////////////////////////////////////////////////////////////////////

Vector2 CDynamicCoverHelper::GetStickInputForCoverSearch(const CPed& ped)
{
	Vector2 vStickInput(0.0f,0.0f);
	const CControl* pControl = ped.GetControlFromPlayer();
	if (pControl)
	{
		if (ms_Tunables.m_UseStickHistoryForCoverSearch)
		{
			const CTaskPlayerOnFoot* pPlayerTask = static_cast<CTaskPlayerOnFoot*>(ped.GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_PLAYER_ON_FOOT));
			if (pPlayerTask)
			{
				pPlayerTask->GetLastStickInputIfValid(vStickInput);
			}
		}
		else
		{
			vStickInput.x = pControl->GetPedWalkLeftRight().GetNorm();
			vStickInput.y = -pControl->GetPedWalkUpDown().GetNorm();
		}
	}
	return vStickInput;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::VehicleHasCoverBounds(const CVehicle& rVeh)
{
	return rVeh.GetVehicleCoverBoundOffsetInfo() && rVeh.GetVehicleCoverBoundOffsetInfo()->GetCoverBoundInfoArray().GetCount() > 0;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::CanPedBeInCoverOnEntity(const CPed& rPed, const CEntity* pEnt, bool& bIsVehicleThatDoesntProvideCover)
{
	if (!pEnt)
		return false;

	if (!pEnt->GetIsTypeVehicle())
		return false;

	const CVehicle& rVeh = *static_cast<const CVehicle*>(pEnt);
	if (!rVeh.m_nVehicleFlags.bDoesProvideCover)
	{
		bIsVehicleThatDoesntProvideCover = true;
		return false;
	}

	if (rPed.GetGroundPhysical() != pEnt)
		return false;

	if (!rVeh.GetVehicleModelInfo() || !rVeh.CanPedsStandOnTop() || rVeh.GetVehicleModelInfo()->GetVehicleFlag(CVehicleModelInfoFlags::FLAG_CANNOT_TAKE_COVER_WHEN_STOOD_ON))
	{
		bIsVehicleThatDoesntProvideCover = true;
		return false;
	}
	
	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::DoLineTestAgainstVehicleDummyBounds(const CPed& rPed, const CVehicle& vehicle, const Vector3& vStart, const Vector3& vEnd, Vector3& vIntersectionPos)
{
	if (rPed.IsLocalPlayer() && VehicleHasCoverBounds(vehicle))
	{
		s32 iActiveBoundIndex = CPlayerInfo::ms_DynamicCoverHelper.GetActiveVehicleCoverBoundIndex();
		const atArray<CVehicleCoverBoundInfo>& rCoverBoundInfoArray = vehicle.GetVehicleCoverBoundOffsetInfo()->GetCoverBoundInfoArray();
		const s32 iNumCoverBounds = rCoverBoundInfoArray.GetCount();
		const Matrix34 vehMtx = MAT34V_TO_MATRIX34(vehicle.GetTransform().GetMatrix());
		float fClosestSegmentT1 = -1.0f;

		for (s32 i=0; i<iNumCoverBounds; ++i)
		{
			// Check if the bound we're about to test against is considered active (based on the bound we're active on)
			// skip over this bound if its inactive
			const CVehicleCoverBoundInfo& rCoverBoundInfo = rCoverBoundInfoArray[i];
			if (iActiveBoundIndex > -1 && iActiveBoundIndex < iNumCoverBounds)
			{
				if (!CVehicleCoverBoundInfo::IsBoundActive(rCoverBoundInfoArray[iActiveBoundIndex], rCoverBoundInfo))
				{
					continue;
				}
			}

			Matrix34 mtx = vehMtx;
			Vector3 vNewPosition = rCoverBoundInfo.m_Position;
			mtx.Transform(vNewPosition);
			mtx.d = vNewPosition;
			float fSegmentT1;
			Vector3 vNormal1; 

			// Local copies
			Vector3 vPointA = vStart;
			Vector3 vPointB = vEnd;

			// Get start and end relative to the vehicle bound
			mtx.UnTransform(vPointA);
			mtx.UnTransform(vPointB);

			Vector3 vPointAToPointB = vPointB - vPointA;
			Vector3 vBoxMin = -Vector3(rCoverBoundInfo.m_Width, rCoverBoundInfo.m_Length, rCoverBoundInfo.m_Height) * 0.5f;
			Vector3 vBoxMax = Vector3(rCoverBoundInfo.m_Width, rCoverBoundInfo.m_Length, rCoverBoundInfo.m_Height) * 0.5f;

			// Do line / box test, take closest intersection pos
			if (geomBoxes::TestSegmentToBox(vPointA, vPointAToPointB, vBoxMin, vBoxMax, &fSegmentT1, &vNormal1, NULL, NULL, NULL, NULL))
			{
				if (fClosestSegmentT1 < 0.0f || fSegmentT1 < fClosestSegmentT1)
				{
					fClosestSegmentT1 = fSegmentT1;
					vPointAToPointB.Scale(fSegmentT1);
					vIntersectionPos = vPointA + vPointAToPointB;
					mtx.Transform(vIntersectionPos);
				}
			}
		}

		if (fClosestSegmentT1 > -1.0f)
		{
			return true;
		}
	}
	else
	{
		Vec3V vMin, vMax;
		if (CVehicle::GetMinMaxBoundsFromDummyVehicleBound(vehicle, vMin, vMax))
		{
			// World space min/max
			Matrix34 vehMtx = MAT34V_TO_MATRIX34(vehicle.GetTransform().GetMatrix());

			float fSegmentT1;
			Vector3 vNormal1; 

			// Local copies
			Vector3 vPointA = vStart;
			Vector3 vPointB = vEnd;

			// Get start and end relative to the vehicle
			vehMtx.UnTransform(vPointA);
			vehMtx.UnTransform(vPointB);

			Vector3 vPointAToPointB = vPointB - vPointA;
			Vector3 vBoxMin = RCC_VECTOR3(vMin);
			Vector3 vBoxMax = RCC_VECTOR3(vMax);

			// Do line / box test, take first intersection pos
			if (geomBoxes::TestSegmentToBox(vPointA, vPointAToPointB, vBoxMin, vBoxMax, &fSegmentT1, &vNormal1, NULL, NULL, NULL, NULL))
			{
				vPointAToPointB.Scale(fSegmentT1);
				vIntersectionPos = vPointA + vPointAToPointB;
				vehMtx.Transform(vIntersectionPos);
				return true;
			}
		}
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

const phInst* CDynamicCoverHelper::DoLineProbeTest(const Vector3& vStart, const Vector3& vEnd, Vector3& vIntersectionPos, s32* pHitComponentIndex, bool* pbHitStairs, bool bAllowNotCover, Vector3* vIntersectionNormal)
{
	WorldProbe::CShapeTestFixedResults<> probeResult;
	s32 iTypeFlags = ArchetypeFlags::GTA_ALL_MAP_TYPES|ArchetypeFlags::GTA_VEHICLE_TYPE|ArchetypeFlags::GTA_OBJECT_TYPE|ArchetypeFlags::GTA_MAP_TYPE_COVER;
	WorldProbe::CShapeTestProbeDesc probeDesc;
	probeDesc.SetResultsStructure(&probeResult);
	probeDesc.SetStartAndEnd(vStart, vEnd);
	probeDesc.SetIncludeFlags(iTypeFlags);
	probeDesc.SetTypeFlags(ArchetypeFlags::GTA_AI_TEST);
	probeDesc.SetIsDirected(true);
	if (!bAllowNotCover)
		probeDesc.SetOptions(WorldProbe::LOS_IGNORE_NOT_COVER);
	WorldProbe::GetShapeTestManager()->SubmitTest(probeDesc);
	
	if (!probeResult[0].GetHitDetected())
	{
#if DEBUG_DRAW
		CTask::ms_debugDraw.AddLine(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), Color_green, 2500, 0);
#endif // DEBUG_DRAW
		return NULL;
	}

	vIntersectionPos = probeResult[0].GetHitPosition();

#if __BANK
	if(CPedDebugVisualiserMenu::ms_menuFlags.m_bDisplayCoverLineTests)
	{
		CTask::ms_debugDraw.AddLine(RCC_VEC3V(vStart), RCC_VEC3V(vIntersectionPos), Color_red, 2500, 0);
	}
#endif // __BANK

	if (pHitComponentIndex)
	{
		*pHitComponentIndex = probeResult[0].GetHitComponent();
	}

	if (pbHitStairs && PGTAMATERIALMGR->GetPolyFlagStairs(probeResult[0].GetHitMaterialId()))
	{
		*pbHitStairs = true;
	}

	if (vIntersectionNormal)
	{
		*vIntersectionNormal = probeResult[0].GetHitNormal();
	}

	return probeResult[0].GetHitInst();
}

////////////////////////////////////////////////////////////////////////////////

const phInst* CDynamicCoverHelper::DoCapsuleTest(const Vector3& vStart, const Vector3& vEnd, Vector3& vIntersectionPos, float fCapsuleRadius)
{
	WorldProbe::CShapeTestFixedResults<> capsuleResult;
	s32 iTypeFlags = ArchetypeFlags::GTA_ALL_MAP_TYPES|ArchetypeFlags::GTA_VEHICLE_TYPE|ArchetypeFlags::GTA_OBJECT_TYPE;
	WorldProbe::CShapeTestCapsuleDesc capsuleDesc;
	capsuleDesc.SetResultsStructure(&capsuleResult);
	capsuleDesc.SetCapsule(vStart, vEnd, fCapsuleRadius);
	capsuleDesc.SetIncludeFlags(iTypeFlags);
	capsuleDesc.SetTypeFlags(ArchetypeFlags::GTA_AI_TEST);
	capsuleDesc.SetIsDirected(true);
	capsuleDesc.SetDoInitialSphereCheck(true);
	capsuleDesc.SetOptions(WorldProbe::LOS_IGNORE_NOT_COVER);
	WorldProbe::GetShapeTestManager()->SubmitTest(capsuleDesc);
	
	if (!capsuleResult[0].GetHitDetected())
	{
#if DEBUG_DRAW
		CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), ms_Tunables.m_PedToCoverCapsuleRadius, Color_green, 2500, 0, false);
#endif // DEBUG_DRAW
		return NULL;
	}

	vIntersectionPos = capsuleResult[0].GetHitPosition();

#if DEBUG_DRAW
	CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vIntersectionPos), ms_Tunables.m_PedToCoverCapsuleRadius, Color_red, 2500, 0, false);
#endif // DEBUG_DRAW

	return capsuleResult[0].GetHitInst();
}

////////////////////////////////////////////////////////////////////////////////

const phInst* CDynamicCoverHelper::IsThereAnObstructionsBetweenPedAndCover(const CPed& ped, const Vector3& vCoverPos)
{
	Vector3 vStart = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
	Vector3 vPedToCover = vCoverPos - vStart;
	vPedToCover.Normalize();
	Vector3 vEnd = vCoverPos - ms_Tunables.m_PedToCoverEndPullBackDistance * vPedToCover + Vector3(0.0f, 0.0f, ms_Tunables.m_PedToCoverEndZOffset);

	WorldProbe::CShapeTestFixedResults<> capsuleResult;
	s32 iTypeFlags = ArchetypeFlags::GTA_ALL_TYPES_MOVER;

	WorldProbe::CShapeTestCapsuleDesc capsuleDesc;
	capsuleDesc.SetResultsStructure(&capsuleResult);
	capsuleDesc.SetCapsule(vStart, vEnd, ms_Tunables.m_PedToCoverCapsuleRadius);
	capsuleDesc.SetIncludeFlags(iTypeFlags);
	capsuleDesc.SetExcludeEntity(&ped);
	capsuleDesc.SetTypeFlags(ArchetypeFlags::GTA_AI_TEST);
	capsuleDesc.SetIsDirected(false);
	capsuleDesc.SetDoInitialSphereCheck(true);
	WorldProbe::GetShapeTestManager()->SubmitTest(capsuleDesc);

	if (!capsuleResult[0].GetHitDetected())
	{
#if DEBUG_DRAW
		CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), ms_Tunables.m_PedToCoverCapsuleRadius, Color_green, 2500, 0, false);
#endif // DEBUG_DRAW
		return NULL;
	}

#if DEBUG_DRAW
	CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(capsuleResult[0].GetHitPosition()), ms_Tunables.m_PedToCoverCapsuleRadius, Color_red, 2500, 0, false);
#endif // DEBUG_DRAW

	return capsuleResult[0].GetHitInst();
}

////////////////////////////////////////////////////////////////////////////////

CDynamicCoverHelper::CDynamicCoverHelper()
: m_bSearchStarted(false)
, m_eSearchMode(eInvalidSearchMode)
, m_bFoundDynamicCover(false)
, m_pPed(NULL)
, m_vTestPos(Vector3::ZeroType)
, m_bFacingLeft(false)
, m_pCoverEntryEntity(NULL)
, m_pCoverEntryMaterial(NULL)
, m_fOverrideDir(-999.0f)
, m_fLastTestZHeight(-LARGE_FLOAT)
, m_bFromIdleTurn(false)
, m_bIgnoreClearCheck(false)
, m_vCachedCoverEntryEntityPosition(Vector3::ZeroType)
#if __BANK
, m_bIsDebugMode(false)
, m_fDebugSearchHeading(0.0f)
#endif
{

}

////////////////////////////////////////////////////////////////////////////////

CDynamicCoverHelper::~CDynamicCoverHelper()
{

}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::Reset()
{
	m_pOldCoverPoint = NULL;
	m_pNewCoverPoint = NULL;
	m_bSearchStarted = false;
	m_eSearchMode = eInvalidSearchMode;
	m_pPed = NULL;
	m_bFromIdleTurn = false;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::FindNewCoverPoint( CCoverPoint* pNewCoverPoint, CPed* pPed, const Vector3& vTestPos, float fOverrideDir, bool bIgnoreOldCoverDir)
{
	m_fLastTestZHeight = -LARGE_FLOAT;
	m_iActiveBoundIndex = -1;
	m_pNewCoverPoint = pNewCoverPoint;
	m_bSearchStarted = true;
	m_eSearchMode = eFindNewCover;
	m_bFromIdleTurn = false;
	m_vTestPos = vTestPos;
	m_pPed = pPed;
	m_fOverrideDir = fOverrideDir;
	m_bIgnoreOldCoverDir = bIgnoreOldCoverDir;

	Update();
	taskAssertf(GetState() == State_Finished, "Expected cover search to complete instantly");
	return m_bFoundDynamicCover;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::UpdateCoverPoint(const CCoverPoint* pOldCoverPoint, CCoverPoint* pNewCoverPoint, CPed* pPed, const Vector3& vTestPos, bool bFromIdle, bool bFacingLeft, bool bFromIdleTurn)
{
	m_pOldCoverPoint = pOldCoverPoint;
	m_pNewCoverPoint = pNewCoverPoint;
	m_bSearchStarted = true;
	m_eSearchMode = bFromIdle ? eUpdateCoverWhileIdle : eUpdateCoverWhileMoving;
	m_bFromIdleTurn = bFromIdleTurn;
	m_vTestPos = vTestPos;
	m_pPed = pPed;
	m_bFacingLeft = bFacingLeft;
	m_fOverrideDir = -999.0f;
	m_vCachedGroundNormal.Zero();

	Update();
	taskAssertf(GetState() == State_Finished, "Expected cover search to complete instantly");
	return m_bFoundDynamicCover;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::FindNewCoverPointAroundCorner(CCoverPoint* pNewCoverPoint, CPed* pPed, bool bFacingLeft, bool bCrouched, bool bIgnoreClearCheck)
{
	m_pNewCoverPoint = pNewCoverPoint;
	m_bSearchStarted = true;
	m_eSearchMode = eTestForMovingAroundCorner;
	m_bFromIdleTurn = false;
	//m_vTestPos = vTestPos;
	m_pPed = pPed;
	m_bFacingLeft = bFacingLeft;
	m_bCrouched = bCrouched;
	m_bIgnoreClearCheck = bIgnoreClearCheck;
	m_fOverrideDir = -999.0f;

	Update();
	taskAssertf(GetState() == State_Finished, "Expected cover search to complete instantly");
	return m_bFoundDynamicCover;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::FindNewCoverPointForInsideCornerTransition(CCoverPoint* pNewCoverPoint, CPed* pPed, bool bFacingLeft, bool bCrouched)
{
	m_iActiveBoundIndex = -1;
	m_pNewCoverPoint = pNewCoverPoint;
	m_bSearchStarted = true;
	m_eSearchMode = eTestForInsideCornerTransition;	
	m_bFromIdleTurn = false;
	m_pPed = pPed;
	m_bFacingLeft = bFacingLeft;
	m_bCrouched = bCrouched;
	m_fOverrideDir = -999.0f;

	Update();
	taskAssertf(GetState() == State_Finished, "Expected cover search to complete instantly");
	return m_bFoundDynamicCover;
}


////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::FindNewCoverToCoverPoint(CCoverPoint* pNewCoverPoint, CPed* pPed, bool bFacingLeft, bool bCrouched)
{
	m_iActiveBoundIndex = -1;
	m_pNewCoverPoint = pNewCoverPoint;
	m_bSearchStarted = true;
	m_eSearchMode = eTestForCoverToCover;
	m_bFromIdleTurn = false;
	//m_vTestPos = vTestPos;
	m_pPed = pPed;
	m_bFacingLeft = bFacingLeft;
	m_bCrouched = bCrouched;
	m_fOverrideDir = -999.0f;

	Update();
	taskAssertf(GetState() == State_Finished, "Expected cover search to complete instantly");
	return m_bFoundDynamicCover;
}

////////////////////////////////////////////////////////////////////////////////

CTaskHelperFSM::FSM_Return CDynamicCoverHelper::UpdateFSM(const s32 iState, const FSM_Event iEvent)
{
	FSM_Begin

		FSM_State(State_Start)
			FSM_OnUpdate
				return Start_OnUpdate();

		FSM_State(State_FindNewCover)
			FSM_OnUpdate
				return FindNewCover_OnUpdate();

		FSM_State(State_UpdateCoverWhileMoving)
			FSM_OnUpdate
				return UpdateCoverWhileMoving_OnUpdate();

		FSM_State(State_UpdateCoverWhileIdle)
			FSM_OnUpdate
				return UpdateCoverWhileIdle_OnUpdate();

		FSM_State(State_TestForMovingAroundCorner)
			FSM_OnUpdate
				return TestForMovingAroundCorner_OnUpdate();

		FSM_State(State_TestForInsideCornerTransition)
			FSM_OnUpdate
				return TestForInsideCornerTransition_OnUpdate();		

		FSM_State(State_TestForCoverToCover)
			FSM_OnUpdate
				return TestForCoverToCover_OnUpdate();

		FSM_State(State_Finished)
			FSM_OnEnter
				return Finished_OnEnter();
			FSM_OnUpdate
				return Finished_OnUpdate();

	FSM_End
}

////////////////////////////////////////////////////////////////////////////////

CTaskHelperFSM::FSM_Return CDynamicCoverHelper::Start_OnUpdate()
{
	if (m_bSearchStarted)
	{
		m_bFoundDynamicCover = false;

		switch (m_eSearchMode)
		{
		case eFindNewCover: 
			{
				SetState(State_FindNewCover); 
				return FSM_Continue;
			}
		case eUpdateCoverWhileMoving: 
			{
				SetState(State_UpdateCoverWhileMoving);
				return FSM_Continue;
			}
		case eUpdateCoverWhileIdle: 
			{
				SetState(State_UpdateCoverWhileIdle);
				return FSM_Continue;
			}
		case eTestForMovingAroundCorner:
			{
				SetState(State_TestForMovingAroundCorner);
				return FSM_Continue;
			}
		case eTestForInsideCornerTransition:
			{
				SetState(State_TestForInsideCornerTransition);
				return FSM_Continue;
			}

		case eTestForCoverToCover:
			{
				SetState(State_TestForCoverToCover);
				return FSM_Continue;
			}
		default: taskAssertf(0, "Unhandled State");
		}
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTaskHelperFSM::FSM_Return CDynamicCoverHelper::FindNewCover_OnUpdate()
{
 	ProbeResults aProbeResults[LP_Max];
 
 	float fSearchDir = ComputeInitialSearchDirection(m_pPed);

 	DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkGreen);)

	// Do line probes to find potential cover
	DoInitialCollisionCheck(m_pPed, m_vTestPos, fSearchDir, aProbeResults, initialTestType);

	Vector3 vNormal;
	Vector3 vPos;

	// analyze the results to find a cover position and normal
	if (CheckForCoverAndCalculateNormal(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, 1, fSearchDir, false))
	{
#if DEBUG_DRAW
		RenderNewCoverPositionAndNormal(RCC_VEC3V(vPos), RCC_VEC3V(vNormal), true);
#endif // DEBUG_DRAW

		// Do a second check in the opposite direction of the normal found in the first check
		float fDir = rage::Atan2f(vNormal.x, -vNormal.y);
		
		DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkSlateBlue, true);)

		// With the recalculated direction, search again
		ProbeResults aProbeResults[LP_Max];

		//Adjust the start position
		m_vTestPos = vPos+ZAXIS;

#if __BANK
		CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(m_vTestPos), 0.025f, Color_yellow, 1000);
#endif 

		// This time do capsule tests
		DoInitialCollisionCheck(m_pPed, m_vTestPos, fDir, aProbeResults);

		// Find cover position and normal
		static bool OLD_WAY = false;
		Vector3 vPedPos = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetPosition());
		if (OLD_WAY)
		{
			vPedPos = m_vTestPos;
		}
		Vector3 vRoundCoverCenter(Vector3::ZeroType);
		float fRoundCoverRadius = 0;
		if (CheckForCoverAndCalculateNormal(*m_pPed, aProbeResults, vPedPos, vNormal, vPos, 2, fDir, false, false, true, &vRoundCoverCenter, &fRoundCoverRadius) )
		{
#if DEBUG_DRAW
			RenderNewCoverPositionAndNormal(RCC_VEC3V(vPos), RCC_VEC3V(vNormal), false);
#endif // DEBUG_DRAW

			Vector3 vThreatDir = camInterface::GetFront();
			vThreatDir.z = 0.0f;
			vThreatDir.Normalize();
			if (CTaskPlayerOnFoot::sm_Tunables.m_EvaluateThreatFromCoverPoints)
			{
				// Compute the desired protection direction from this cover's position
				CTaskCover::ComputeDesiredProtectionDirection(*m_pPed, vPos, vThreatDir);
			}

			UpdateCoverPointFromResults(m_pPed, aProbeResults, vNormal, vPos, false);

			if (CTaskPlayerOnFoot::TestIfRouteToCoverPointIsClear(*m_pNewCoverPoint, *m_pPed, vThreatDir))
			{
				// We disallow cover points too far and at an actue angle from the camera (unless the cover provides protection against the threat)
				Vector3 vCoverDir = VEC3V_TO_VECTOR3(m_pNewCoverPoint->GetCoverDirectionVector());
				const bool bProvidesCoverFromThreat = CTaskCover::DoesCoverPointProvideCoverFromThreat(vCoverDir, vThreatDir);

				// Always reject cover points that aren't close and not orientated vaguely towards the cam direction
				// to avoid taking cover offscreen
				if ((bProvidesCoverFromThreat || !CTaskCover::IsCoverPointPositionTooFarAndAcute(*m_pPed, vPos)) && CTaskCover::IsCoverValid(*m_pNewCoverPoint, *m_pPed))
				{
					if (CCover::IsPointWithinValidArea(vPos, m_pNewCoverPoint->GetType(), true))
					{
						m_bFoundDynamicCover = true;
						if (!vRoundCoverCenter.IsZero())
							m_pPed->GetPlayerInfo()->SetRoundCover(vRoundCoverCenter, fRoundCoverRadius);
					}
				}
				else
				{
					aiDisplayf("Invalidated dynamic coverpoint because too far and too acute from camera");
				}		
			}
		}
	}

 	m_pPed->GetPlayerInfo()->SetDynamicCoverInsideCorner(false);

	SetState(State_Finished);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTaskHelperFSM::FSM_Return CDynamicCoverHelper::UpdateCoverWhileMoving_OnUpdate()
{
	if (DetectObstructionsInFrontOfPed(m_bFacingLeft))
	{
		m_bFoundDynamicCover = true;
		SetState(State_Finished);
		return FSM_Continue;
	}

	ProbeResults aProbeResults[MLP_Max];

	float fSearchDir = ComputeSearchDirectionFromCoverPoint(m_pPed);

	DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkGreen);)

	// Do line probes to find potential cover
	DoCollisionCheckForMovementInCover(m_pPed, m_vTestPos, fSearchDir, aProbeResults, initialTestType, m_bFacingLeft);

	Vector3 vNormal;
	Vector3 vPos;

	// analyze the results to find a cover position and normal	
	bool bCoverFound = CheckForCoverAndCalculateNormalWhenMoving(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, 1, fSearchDir);
	if (bCoverFound)
	{
		// Do a second check in the direction of the normal found in the first check
		float fDir = rage::Atan2f(vNormal.x, -vNormal.y);

		DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkSlateBlue, true);)

		// With the recalculated direction, search again
		ProbeResults aProbeResults[LP_Max];

		//Adjust the start position
		m_vTestPos = vPos+ZAXIS;

		// This time do capsule tests
		DoCollisionCheckForMovementInCover(m_pPed, m_vTestPos, fDir, aProbeResults, CTT_Capsule,  m_bFacingLeft);

		//Round cover, use round cover normal.
		bool bIsRoundCover = m_pPed->IsLocalPlayer() && m_pPed->GetPlayerInfo()->IsRoundCover();

		// Find cover position and normal
		if (CheckForCoverAndCalculateNormalWhenMoving(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, (bIsRoundCover ? 1 : 2), fDir) )
		{
			if (CCover::IsPointWithinValidArea(vPos, m_pNewCoverPoint->GetType(), true))
			{
#if __ASSERT
				// Detect bad cover position
				const Vector3 vPedPos = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetPosition());
				Vector3 vToCover = vPos - vPedPos;
				const float fXYDistToCover = (vToCover).XYMag();
				if (fXYDistToCover > 1.0f)
				{
					const Vector3 vPedFwd = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetB());
					vToCover.Normalize();
					const float fDot = vPedFwd.Dot(vToCover);
					if (fDot < 0.0f)
					{
						aiDisplayf("fXYDistToCover = %.2f, fDot = %.2f", fXYDistToCover, fDot);
						aiDisplayf("vPedPos = (%.2f,%.2f,%.2f), vPos = (%.2f,%.2f,%.2f)", VEC3V_ARGS(RCC_VEC3V(vPedPos)), VEC3V_ARGS(RCC_VEC3V(vPos)));
						aiAssertf(0, "New cover point is more than 1m from ped position and behind the ped, ped will slide unnaturally");
					}
				}
#endif // __ASSERT
				
				UpdateCoverPointFromResults(m_pPed, aProbeResults, vNormal, vPos, true);
				m_bFoundDynamicCover = true;
			}
		}
	}

	SetState(State_Finished);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTaskHelperFSM::FSM_Return CDynamicCoverHelper::UpdateCoverWhileIdle_OnUpdate()
{
	if (DetectObstructionsInFrontOfPed(m_bFacingLeft))
	{
		m_bFoundDynamicCover = true;
		SetState(State_Finished);
		return FSM_Continue;
	}

	ProbeResults aProbeResults[LP_Max];

	float fSearchDir = ComputeSearchDirectionFromCoverPoint(m_pPed);

	DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkGreen);)

	// Do line probes to find potential cover
	static dev_float s_fIdleTestLength = 1.0f;
	DoCollisionCheckWhenIdleInCover(m_pPed, m_vTestPos, fSearchDir, aProbeResults, initialTestType, s_fIdleTestLength);

	Vector3 vNormal;
	Vector3 vPos;

	// Analyze the results to find a cover position and normal
	if (CheckForCoverAndCalculateNormal(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, 1, fSearchDir, true))
	{
		// Do a second check in the direction of the normal found in the first check
		float fDir = rage::Atan2f(vNormal.x, -vNormal.y);

		DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkSlateBlue, true);)

		// With the recalculated direction, search again
		ProbeResults aProbeResults[LP_Max];

		//Adjust the start position
		m_vTestPos = vPos+ZAXIS;

		// This time do capsule tests
		DoCollisionCheckWhenIdleInCover(m_pPed, m_vTestPos, fDir, aProbeResults, CTT_Unknown, s_fIdleTestLength);

		// If we're against a dynamic cover object, assume its still valid cover if we've got one collision B*820870
		const u32 iNumConcurrentCollisionsRequired = m_pPed->GetPlayerInfo()->IsCoverGeneratedByDynamicEntity() ? 1 : 2;
		
		// Find cover position and normal
		if (CheckForCoverAndCalculateNormal(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, iNumConcurrentCollisionsRequired, fDir, true) )
		{
			if (CCover::IsPointWithinValidArea(vPos, m_pNewCoverPoint->GetType(), true))
			{
				UpdateCoverPointFromResults(m_pPed, aProbeResults, vNormal, vPos, false);
				m_bFoundDynamicCover = true;
			}
		}
	}

	SetState(State_Finished);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTaskHelperFSM::FSM_Return CDynamicCoverHelper::TestForMovingAroundCorner_OnUpdate()
{
	CVehicle* pCoverVehicle = NULL;
	if (m_pPed->IsLocalPlayer())
	{
		if (m_pCoverEntryEntity && m_pCoverEntryEntity->GetIsTypeVehicle())
		{
			pCoverVehicle = static_cast<CVehicle*>(m_pCoverEntryEntity.Get());
		}
	}

	const bool bDynamicCoverCanMoveLeft = m_pPed->GetPlayerInfo()->DynamicCoverCanMoveLeft();
	const bool bDynamicCoverCanMoveRight = m_pPed->GetPlayerInfo()->DynamicCoverCanMoveRight();

	if (m_bIgnoreClearCheck || IsAreaAroundCornerClear(m_pPed, pCoverVehicle))
	{
		// Treat all vehicle bounds as active
		m_iActiveBoundIndex = -1;

		ProbeResults aProbeResults[LP_Max];

		float fSearchDir = fwAngle::LimitRadianAngle(m_pPed->GetCurrentHeading() + PI);

		DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkGreen);)

		Vector3 vPedForward = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetB());
		Vector3 vPedSide = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetA());

		if (!m_bFacingLeft)
		{
			vPedSide.Scale(-1.0f);
		}

		m_vTestPos = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetPosition());
		const float fForwardOffset = m_bCrouched ? ms_Tunables.m_OCMCrouchedForwardClearanceOffset : ms_Tunables.m_OCMStandingForwardClearanceOffset;
		m_vTestPos += vPedForward * fForwardOffset;
		m_vTestPos += vPedSide * ms_Tunables.m_OCMSideTestDepth;

		// Do line probes to find potential cover
		DoInitialCollisionCheck(m_pPed, m_vTestPos, fSearchDir, aProbeResults, initialTestType);

		Vector3 vNormal;
		Vector3 vPos;

		// Analyse the results to find a cover position and normal
		if (CheckForCoverAndCalculateNormal(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, 1, fSearchDir, true))
		{
			// Do a second check in the direction of the normal found in the first check
			float fDir = rage::Atan2f(vNormal.x, -vNormal.y);

			DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkSlateBlue, true);)

			// With the recalculated direction, search again
			ProbeResults aProbeResults[LP_Max];

			//Adjust the start position
			m_vTestPos = vPos+ZAXIS;

			// This time do capsule tests
			DoInitialCollisionCheck(m_pPed, m_vTestPos, fDir, aProbeResults);

			// Find cover position and normal
			if (CheckForCoverAndCalculateNormal(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, 2, fDir, true, false, true) )
			{
				UpdateCoverPointFromResults(m_pPed, aProbeResults, vNormal, vPos, false);

				Vector3 vPedForward	= VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetB());
				Vector3 vCurrentPedPos	= VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetPosition());
				Vector3 vNewCoverPos(Vector3::ZeroType);
				if (m_pNewCoverPoint->GetCoverPointPosition(vNewCoverPos))
				{
					Vector3 vToCover = vNewCoverPos - vCurrentPedPos;
					vToCover.Normalize();

					// Make sure the cover is in front of us
					if (vToCover.Dot(vPedForward) > 0.0f && CTaskCover::IsCoverValid(*m_pNewCoverPoint, *m_pPed))
					{
						m_bFoundDynamicCover = true;
					}
					else
					{
						// Restore the old values
						m_pPed->GetPlayerInfo()->SetDynamicCoverCanMoveLeft(bDynamicCoverCanMoveLeft);
						m_pPed->GetPlayerInfo()->SetDynamicCoverCanMoveRight(bDynamicCoverCanMoveRight);
					}
				}
			}
		}

		m_pPed->GetPlayerInfo()->SetDynamicCoverInsideCorner(false);
	}

	SetState(State_Finished);
	return FSM_Continue;
}


CTaskHelperFSM::FSM_Return CDynamicCoverHelper::TestForInsideCornerTransition_OnUpdate()
{
	ProbeResults aProbeResults[LP_Max];

	float fSearchDir = fwAngle::LimitRadianAngle(m_pPed->GetCurrentHeading());

	DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkGreen);)

	Vector3 vPedSide = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetA());

	if (!m_bFacingLeft)
	{
		vPedSide.Scale(-1.0f);
	}

	static dev_float sfPedSideScale = -0.4f;
	m_vTestPos = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetPosition());
	m_vTestPos += vPedSide * sfPedSideScale;

	static dev_float sf_InsideCornerTestDepth = 1.0f;
	// Do line probes to find potential cover
	DoInitialCollisionCheck(m_pPed, m_vTestPos, fSearchDir, aProbeResults, initialTestType, sf_InsideCornerTestDepth);

	Vector3 vNormal;
	Vector3 vPos;

	// analyze the results to find a cover position and normal
	if (CheckForCoverAndCalculateNormal(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, 1, fSearchDir, true))
	{
		// Do a second check in the direction of the normal found in the first check
		float fDir = rage::Atan2f(vNormal.x, -vNormal.y);

		DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkSlateBlue, true);)

		// With the recalculated direction, search again
		ProbeResults aProbeResults[LP_Max];

		//Adjust the start position
		m_vTestPos = vPos+ZAXIS;

		// This time do capsule tests
		DoInitialCollisionCheck(m_pPed, m_vTestPos, fDir, aProbeResults, CTT_Unknown, sf_InsideCornerTestDepth);

		// Find cover position and normal
		if (CheckForCoverAndCalculateNormal(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, 2, fDir, true, false, true) )
		{
			UpdateCoverPointFromResults(m_pPed, aProbeResults, vNormal, vPos, false);

			//Vector3 vPedForward	= VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetB());
			//Vector3 vCurrentPedPos	= VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetPosition());
			Vector3 vNewCoverPos(Vector3::ZeroType);
			if (m_pNewCoverPoint->GetCoverPointPosition(vNewCoverPos))
			{
				Vector3 vPedPosition = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetPosition());
				TUNE_GROUP_FLOAT(INSIDE_COVER_TUNE, MAX_DIST_TO_NEW_COVER, 1.5f, 0.0f, 5.0f, 0.01f);
				if (vPedPosition.Dist2(vNewCoverPos) < square(MAX_DIST_TO_NEW_COVER) && CTaskCover::IsCoverValid(*m_pNewCoverPoint, *m_pPed))
				{
					m_bFoundDynamicCover = true;
				}
			}
		}
	}
	
	SetState(State_Finished);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTaskHelperFSM::FSM_Return CDynamicCoverHelper::TestForCoverToCover_OnUpdate()
{
	TUNE_BOOL(DISABLE_CTC_COVERPOINT_TEST, false);
	if (FindNearbyCollisionAndComputeTestPosition(m_pPed) && !DISABLE_CTC_COVERPOINT_TEST)
	{
		ProbeResults aProbeResults[LP_Max];

		float fSearchDir = ComputeSearchDirectionFromCoverPoint(m_pPed);

		DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkGreen);)

		// Do line probes to find potential cover
		DoCollisionCheckWhenIdleInCover(m_pPed, m_vTestPos, fSearchDir, aProbeResults, initialTestType);

		Vector3 vNormal;
		Vector3 vPos;

		// Analyse the results to find a cover position and normal
		if (CheckForCoverAndCalculateNormal(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, 1, fSearchDir, false, true))
		{
			// Do a second check in the direction of the normal found in the first check
			float fDir = rage::Atan2f(vNormal.x, -vNormal.y);

			DEBUG_DRAW_ONLY(RenderSearchDirection(*m_pPed, fSearchDir, Color_DarkSlateBlue, true);)

			// With the recalculated direction, search again
			ProbeResults aProbeResults[LP_Max];

			//Adjust the start position
			m_vTestPos = vPos+ZAXIS;

			// This time do capsule tests
			DoCollisionCheckWhenIdleInCover(m_pPed, m_vTestPos, fDir, aProbeResults);

			// Find cover position and normal
			if (CheckForCoverAndCalculateNormal(*m_pPed, aProbeResults, m_vTestPos, vNormal, vPos, 1, fDir, false, true) )
			{
				UpdateCoverPointFromResults(m_pPed, aProbeResults, vNormal, vPos, false, true);

				if (m_pNewCoverPoint)
				{
					if (m_pNewCoverPoint->GetUsage() == CCoverPoint::COVUSE_WALLTORIGHT ||
						m_pNewCoverPoint->GetUsage() == CCoverPoint::COVUSE_WALLTOLEFT ||
						m_pNewCoverPoint->GetUsage() == CCoverPoint::COVUSE_WALLTONEITHER)
					{
						if (IsNewCoverToCoverPointValid(*m_pPed, *m_pNewCoverPoint) && CTaskCover::IsCoverValid(*m_pNewCoverPoint, *m_pPed))
						{
							m_bFoundDynamicCover = true;
						}
					}
				}
			}
		}
	}

	SetState(State_Finished);
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTaskHelperFSM::FSM_Return CDynamicCoverHelper::Finished_OnEnter()
{
	m_bSearchStarted = false;
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CTaskHelperFSM::FSM_Return CDynamicCoverHelper::Finished_OnUpdate()
{
	if (m_bSearchStarted)
	{
		SetState(State_Start);
	}
	return FSM_Continue;
}

////////////////////////////////////////////////////////////////////////////////

CVehicle* CDynamicCoverHelper::GetCoverVehicle(const CPed& ped)
{
	if (ped.GetGroundPhysical() && ped.GetGroundPhysical()->GetIsTypeVehicle())
	{
		return NULL;
	}

	if (m_pCoverEntryEntity && m_pCoverEntryEntity->GetIsTypeVehicle())
	{
		CVehicle* pVehicle = static_cast<CVehicle*>(m_pCoverEntryEntity.Get());
		
		if (pVehicle->InheritsFromAutomobile() || pVehicle->InheritsFromBike() || pVehicle->InheritsFromQuadBike() || pVehicle->InheritsFromAmphibiousQuadBike())
		{
			return pVehicle;
		}
	}
	return NULL;
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::SetSegment (s32 iProbe,
										 Mat34V_ConstRef testMtx, 
										 Vec3V_ConstRef vStart,
										 Vec3V_ConstRef vEnd,
										 float fExtendedCheckLength,
										 phSegment* aSegments,
										 float fHeightOffset)
{
	//Assume high probes are done by low probes
	if (iProbe >= LP_LeftHigh && iProbe <= LP_RightHigh)
		return;

	Vec3V vA = vStart;
	Vec3V vB = vEnd;
	// Push the central probes out further so the player can take cover a larger distance away.
	const bool bCentralProbe = ( (iProbe >= LP_FrontLowL && iProbe <= LP_FrontLowR) || (iProbe >= LP_FrontHighL && iProbe <= LP_FrontHighR) );
	Vec3V fExtendedCheckLengthV(-FLT_MAX, fExtendedCheckLength, -FLT_MAX);
	if( bCentralProbe )
		vB = Max(fExtendedCheckLengthV, vB);

	vA = Transform(testMtx, vA);
	vB = Transform(testMtx, vB);
	aSegments[iProbe].Set(RCC_VECTOR3(vA), RCC_VECTOR3(vB));

	//Set the high probe too.  Doing high probes this way maintains low and high X/Z positions for height checks
	if (iProbe <= LP_RightLow)
	{
		vA.SetZf( vA.GetZf()+fHeightOffset);
		vB.SetZf( vB.GetZf()+fHeightOffset);		
		aSegments[iProbe+LP_LeftHigh].Set(RCC_VECTOR3(vA), RCC_VECTOR3(vB));
	}	
}


////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::DoVehicleCoverBoundBoxTests(	Mat34V_ConstRef testMtx, 
								 const CVehicle& vehicle,
								 s32 iMaxShapeTests,
								 float fExtendedCheckLength,
								 sShapeTestInfo* aShapeTestInfos, 
								 phIntersection* aIntersections, 
								 phSegment* aSegments,
								 ProbeResults* apProbeResults, 
								 s32& iActiveBoundIndex,
								 const CPed* pPed,
								 bool bUseClosestProbeForActiveIndex)
{
	const atArray<CVehicleCoverBoundInfo>& rCoverBoundInfoArray = vehicle.GetVehicleCoverBoundOffsetInfo()->GetCoverBoundInfoArray();
	const s32 iNumCoverBounds = rCoverBoundInfoArray.GetCount();
	const Matrix34 vehMtx = MAT34V_TO_MATRIX34(vehicle.GetTransform().GetMatrix());

	s32 iClosestProbeBound = iActiveBoundIndex;

	// For each shapetest, test against each bound considered to be active, take the results of the closest intersection point
	for (int i=0; i<iMaxShapeTests; i++)
	{
		SetSegment(i, testMtx, RCC_VEC3V(aShapeTestInfos[i].vStart), RCC_VEC3V(aShapeTestInfos[i].vEnd), fExtendedCheckLength, aSegments, ms_Tunables.m_HighCoverProbeHeight - ms_Tunables.m_LowCoverProbeHeight);

		// Reset any previous collisions
		apProbeResults[i].m_bCollided = false;
		aIntersections[i].Reset();
		
		float fClosestSegmentT1 = -1.0f;

		for (s32 j=0; j<iNumCoverBounds; ++j)
		{
			// Check if the bound we're about to test against is considered active (based on the bound we're active on)
			// skip over this bound if its inactive
			const CVehicleCoverBoundInfo& rCoverBoundInfo = rCoverBoundInfoArray[j];
			if (iActiveBoundIndex > -1 && iActiveBoundIndex < iNumCoverBounds)
			{
				if (!CVehicleCoverBoundInfo::IsBoundActive(rCoverBoundInfoArray[iActiveBoundIndex], rCoverBoundInfo))
				{
					//aiDisplayf("Cover Bound %i Skipped Due To Active Bound %i", j, iActiveBoundIndex);
					continue;
				}
			}
			
			Matrix34 mtx = vehMtx;
			Vector3 vNewPosition = rCoverBoundInfo.m_Position;
			mtx.Transform(vNewPosition);
			mtx.d = vNewPosition;
			float fSegmentT1;
			Vector3 vNormal1; 

			// Get start and end relative to the cover bound
			Vector3 vPointA = aSegments[i].A;
			Vector3 vPointB = aSegments[i].B;
			mtx.UnTransform(vPointA);
			mtx.UnTransform(vPointB);
			Vector3 vPointAToPointB = vPointB - vPointA;
			Vector3 vBoxMin = -Vector3(rCoverBoundInfo.m_Width, rCoverBoundInfo.m_Length, rCoverBoundInfo.m_Height) * 0.5f;
			Vector3 vBoxMax = Vector3(rCoverBoundInfo.m_Width, rCoverBoundInfo.m_Length, rCoverBoundInfo.m_Height) * 0.5f;

			// Perform line test against this bound, only overwrite the collision data if we find a closer intersection
			// Never set results to not collide if we previously had a collision
			if (geomBoxes::TestSegmentToBox(vPointA, vPointAToPointB, vBoxMin, vBoxMax, &fSegmentT1, &vNormal1, NULL, NULL, NULL, NULL))
			{
				apProbeResults[i].m_bCollided = true;
				if (fClosestSegmentT1 < 0.0f || fSegmentT1 < fClosestSegmentT1)
				{
					//aiDisplayf("Cover Bound %i Set To Closest For Probe %i", j, i);
					fClosestSegmentT1 = fSegmentT1;
					if (bUseClosestProbeForActiveIndex && pPed)
					{
						const bool bFacingLeft = pPed->GetPedResetFlag(CPED_RESET_FLAG_InCoverFacingLeft);
						if ((bFacingLeft && i == LP_RightLow) || (!bFacingLeft && i == LP_LeftLow))
						{
							iClosestProbeBound = j;
						}
					}
					else
					{
						if (i == LP_FrontLowC)
						{
							iClosestProbeBound = j;
						}
					}
					vPointAToPointB.Scale(fSegmentT1);
					Vec3V vIntersectionPos = RCC_VEC3V(vPointA) + RCC_VEC3V(vPointAToPointB);
					vIntersectionPos = Transform(MATRIX34_TO_MAT34V(mtx), vIntersectionPos);
					aIntersections[i].SetPosition(vIntersectionPos);
					aIntersections[i].SetNormal(RCC_VEC3V(vNormal1));
					if (vehicle.GetCurrentPhysicsInst())
					{
						aIntersections[i].SetInstance(vehicle.GetCurrentPhysicsInst()->GetLevelIndex(), PHLEVEL->GetGenerationID(vehicle.GetCurrentPhysicsInst()->GetLevelIndex()));
					}
				}
			}
			else
			{
				//aiDisplayf("Cover Bound %i Missed For Probe %i", j, i);

				if (fClosestSegmentT1 < 0.0f)
				{
					apProbeResults[i].m_bCollided = false;
				}
			}
		}
	}

	if (iClosestProbeBound > -1)
	{
		//aiDisplayf("Active Bound %i", iClosestCentralProbeBound);
		iActiveBoundIndex = iClosestProbeBound;
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::DoVehicleBoxTests(	Mat34V_ConstRef testMtx, 
												const CVehicle& vehicle,
												s32 iMaxShapeTests,
												float fExtendedCheckLength,
												sShapeTestInfo* aShapeTestInfos, 
												phIntersection* aIntersections, 
												phSegment* aSegments,
												ProbeResults* apProbeResults)
{
	Vec3V vMin, vMax;
	if (CVehicle::GetMinMaxBoundsFromDummyVehicleBound(vehicle, vMin, vMax))
	{
#if DEBUG_DRAW
		CCoverDebug::GetDebugContext(CCoverDebug::DEFAULT).AddOBB(vMin, vMax, vehicle.GetTransform().GetMatrix(), Color_blue, 2000);
#endif // DEBUG_DRAW

		// World space min/max
		Matrix34 vehMtx = MAT34V_TO_MATRIX34(vehicle.GetTransform().GetMatrix());

		for (int i=0; i<iMaxShapeTests; i++)
		{
			SetSegment(i, testMtx, RCC_VEC3V(aShapeTestInfos[i].vStart), RCC_VEC3V(aShapeTestInfos[i].vEnd), fExtendedCheckLength, aSegments, ms_Tunables.m_HighCoverProbeHeight - ms_Tunables.m_LowCoverProbeHeight);
			
			// Reset any previous collisions
			apProbeResults[i].m_bCollided = false;
			aIntersections[i].Reset();

			float fSegmentT1;
			Vector3 vNormal1; 

			// Get start and end relative to the vehicle
			Vector3 vPointA = aSegments[i].A;
			Vector3 vPointB = aSegments[i].B;
			vehMtx.UnTransform(vPointA);
			vehMtx.UnTransform(vPointB);

			Vector3 vPointAToPointB = vPointB - vPointA;
			Vector3 vBoxMin = RCC_VECTOR3(vMin);
			Vector3 vBoxMax = RCC_VECTOR3(vMax);
			if (geomBoxes::TestSegmentToBox(vPointA, vPointAToPointB, vBoxMin, vBoxMax, &fSegmentT1, &vNormal1, NULL, NULL, NULL, NULL))
			{
				apProbeResults[i].m_bCollided = true;
				vPointAToPointB.Scale(fSegmentT1);
				Vec3V vIntersectionPos = RCC_VEC3V(vPointA) + RCC_VEC3V(vPointAToPointB);
				vIntersectionPos = Transform(MATRIX34_TO_MAT34V(vehMtx), vIntersectionPos);
				aIntersections[i].SetPosition(vIntersectionPos);
				aIntersections[i].SetNormal(RCC_VEC3V(vNormal1));
				if (vehicle.GetCurrentPhysicsInst())
				{
					aIntersections[i].SetInstance(vehicle.GetCurrentPhysicsInst()->GetLevelIndex(), PHLEVEL->GetGenerationID(vehicle.GetCurrentPhysicsInst()->GetLevelIndex()));
				}
			}
			else
			{
				apProbeResults[i].m_bCollided = false;
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::DetermineIfCoverShouldBeLow( Mat34V_ConstRef testMtx, 
														  sShapeTestInfo* aShapeTestInfos,
														  phIntersection* aIntersections)
{
	// Do an actual line probe against the world to make sure we're getting the correct height
	// Bbox doesn't quite cut it for vehicles like taxi / van's where cover is mostly high except for the front
	Vector3 vStart = aShapeTestInfos[LP_FrontHighC].vStart;
	Vector3 vEnd = aShapeTestInfos[LP_FrontHighC].vEnd;
	RCC_MATRIX34(testMtx).Transform(vStart);
	RCC_MATRIX34(testMtx).Transform(vEnd);

	Vector3 vIntersectionPosUnused;
	if (!DoLineProbeTest(vStart, vEnd, vIntersectionPosUnused))
	{
		aIntersections[LP_FrontHighC].SetInstance(0, 0);
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::DoBatchShapeTests(Mat34V_Ref testMtx, 
											   CollisionTestType overrideMainTestType,
											   s32 iMaxShapeTests,
										       float fExtendedCheckLength,
											   sShapeTestInfo* aShapeTestInfos, 
											   phIntersection* aIntersections, 
											   phSegment* aSegments,
											   ProbeResults* apProbeResults,
											   float fTestLength)
{
	// Get material flags to ignore
	static phMaterialMgrGta::Id nIgnoreMaterialFlags = PGTAMATERIALMGR->GetPackedPolyFlagValue(POLYFLAG_STAIRS) |
													   PGTAMATERIALMGR->GetPackedPolyFlagValue(POLYFLAG_NOT_COVER);

	// Create a shape tester with batched tests. The spaces inside the phShapeTest declaration are necessary for PS3 builds (maybe it's confused by >>).
	phShapeTest< phShapeBatch > batchTester;
	batchTester.GetShape().AllocateSweptSpheres(iMaxShapeTests);
	batchTester.GetShape().AllocateProbes(iMaxShapeTests);

	// Build a batch set of capsule swept spheres	
	for (int i=0; i<iMaxShapeTests; i++)
	{
		SetSegment(i, testMtx, RCC_VEC3V(aShapeTestInfos[i].vStart), RCC_VEC3V(aShapeTestInfos[i].vEnd), fExtendedCheckLength, aSegments, ms_Tunables.m_HighCoverProbeHeight - ms_Tunables.m_LowCoverProbeHeight);

		// Reset any previous collisions
		apProbeResults[i].m_bCollided = false;
		aIntersections[i].Reset();

		CollisionTestType testType = MAIN_TEST_TYPE;
		if( overrideMainTestType != CTT_Unknown )
			testType = overrideMainTestType;
		// Init each swept sphere, no need to specify a capsule index, it increments and initialises them in order
		if( testType == CTT_Capsule )
			batchTester.InitSweptSphere(aSegments[i],aShapeTestInfos[i].fCapsuleRadius,&aIntersections[i], 1);
		else if( testType == CTT_Los )
			batchTester.InitProbe(aSegments[i],&aIntersections[i], 1);
	}

	batchTester.GetShape().SetIgnoreMaterialFlags(nIgnoreMaterialFlags);
	Vec3V vecMin(-ms_fOuterCPWidth2- ms_fCapsuleRadius, rage::Min(ms_fCenterYOffset, ms_fOuterYOffset) - ms_fCapsuleRadius,	ms_fExtraLowHeight - ms_fExtraLowCapsuleRadius);
	Vec3V vecMax( ms_fOuterCPWidth2 + ms_fCapsuleRadius, rage::Max(fExtendedCheckLength, fTestLength) + ms_fCapsuleRadius,		ms_Tunables.m_HighCoverProbeHeight + ms_fCapsuleRadius);
	Vec3V vecHalfWidth = ScalarV(V_HALF) * (vecMax - vecMin);
	vecHalfWidth = And(vecHalfWidth, Vec3V(V_MASKXYZ));
	vecMin = Transform(testMtx, vecMin);
	vecMax = Transform(testMtx, vecMax);
	testMtx.SetCol3(ScalarV(V_HALF) * (vecMin + vecMax));

	phCullShape cullShape; // SetUserProvidedCullShape doesn't copy, it just stores a pointer to the cullshape
	if(sbUseCullBox)
	{
		static bool USE_NEW_CULL_BOX = true;
		if (USE_NEW_CULL_BOX)
		{
			cullShape.InitCull_Box(testMtx, vecHalfWidth);
			batchTester.GetShape().SetUserProvidedCullShape(cullShape);
		}
		else
		{
			batchTester.GetShape().SetCullBox(RCC_MATRIX34(testMtx), VEC3V_TO_VECTOR3(vecHalfWidth));
		}
#if __BANK
		if(CCoverDebug::ms_Tunables.m_RenderBatchProbeOBB)
			CCoverDebug::ms_debugDraw.AddOBB(-vecHalfWidth, vecHalfWidth, testMtx, Color_red, 1000);
#endif
	}

	// Test the batched set in the world
	s32 iTypeFlags = ArchetypeFlags::GTA_MAP_TYPE_MOVER|ArchetypeFlags::GTA_VEHICLE_TYPE|ArchetypeFlags::GTA_OBJECT_TYPE|ArchetypeFlags::GTA_MAP_TYPE_COVER;
	batchTester.TestInLevel(NULL, iTypeFlags, TYPE_FLAGS_ALL, phLevelBase::STATE_FLAGS_ALL,0,CPhysics::GetLevel());
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::DoCoverToCoverBatchShapeTests(	float fDirection,
															Mat34V_Ref testMtx, 
														    s32 iMaxShapeTests,
														    sShapeTestInfo* aShapeTestInfos, 
														    phIntersection* aIntersections, 
														    phSegment* aSegments,
														    ProbeResults* apProbeResults)
{
	// get material flags to ignore
	static phMaterialMgrGta::Id nIgnoreMaterialFlags = PGTAMATERIALMGR->GetPackedPolyFlagValue(POLYFLAG_STAIRS) |
		PGTAMATERIALMGR->GetPackedPolyFlagValue(POLYFLAG_NOT_COVER);

	// Create a shape tester with batched tests. The spaces inside the phShapeTest declaration are necessary for PS3 builds (maybe it's confused by >>).
	phShapeTest< phShapeBatch > batchTester;
	batchTester.GetShape().AllocateSweptSpheres(iMaxShapeTests);


	// Build a batch set of capsule swept spheres
	for (int i=0; i<iMaxShapeTests; i++)
	{
		Vec3V vLineStart = RCC_VEC3V(aShapeTestInfos[i].vStart);
		Vec3V vLineEnd = RCC_VEC3V(aShapeTestInfos[i].vEnd);
		vLineStart = Transform(testMtx, vLineStart);
		vLineEnd = Transform(testMtx, vLineEnd);
		aSegments[i].Set(RCC_VECTOR3(vLineStart), RCC_VECTOR3(vLineEnd));
		aIntersections[i].Reset();

		batchTester.InitSweptSphere(aSegments[i],ms_Tunables.m_CTCCapsuleRadius,&aIntersections[i], 1);
	}

	batchTester.GetShape().SetIgnoreMaterialFlags(nIgnoreMaterialFlags);

	const float fXMin = rage::Min(fDirection * ms_Tunables.m_CTCSideOffset, fDirection * ms_Tunables.m_CTCSideOffset + fDirection*ms_Tunables.m_CTCProbeDepth);
	const float fXMax = rage::Max(fDirection * ms_Tunables.m_CTCSideOffset, fDirection * ms_Tunables.m_CTCSideOffset + fDirection*ms_Tunables.m_CTCProbeDepth);
	Vec3V vecMin(fXMin - ms_Tunables.m_CTCCapsuleRadius, ms_Tunables.m_CTCForwardOffset + 1.0f * ms_Tunables.m_CTCSpacingOffset - ms_Tunables.m_CTCCapsuleRadius,	ms_Tunables.m_CTCHeightOffset - ms_Tunables.m_CTCCapsuleRadius);
	Vec3V vecMax(fXMax + ms_Tunables.m_CTCCapsuleRadius, ms_Tunables.m_CTCForwardOffset + CTCP_Max * ms_Tunables.m_CTCSpacingOffset + ms_Tunables.m_CTCCapsuleRadius,	ms_Tunables.m_CTCHeightOffset + ms_Tunables.m_CTCCapsuleRadius);
	Vec3V vecHalfWidth = ScalarV(V_HALF) * (vecMax - vecMin);
	vecHalfWidth = And(vecHalfWidth, Vec3V(V_MASKXYZ));
	vecMin = Transform(testMtx, vecMin);
	vecMax = Transform(testMtx, vecMax);
	testMtx.SetCol3(ScalarV(V_HALF) * (vecMin + vecMax));

	if(sbUseCullBox)
	{
		batchTester.GetShape().SetCullBox(RCC_MATRIX34(testMtx), VEC3V_TO_VECTOR3(vecHalfWidth));
#if __BANK
		if(true /*CCoverDebug::ms_bRenderBatchProbeOBB*/)
			CCoverDebug::ms_debugDraw.AddOBB(-vecHalfWidth, vecHalfWidth, testMtx, Color_red, 1000);
#endif
	}

	// Reset any previous collisions
	for( s32 i = 0; i < CTCP_Max; i++ )
	{
		apProbeResults[i].m_bCollided = false;
	}

	// Test the batched set in the world
	s32 iTypeFlags = ArchetypeFlags::GTA_MAP_TYPE_MOVER|ArchetypeFlags::GTA_VEHICLE_TYPE|ArchetypeFlags::GTA_OBJECT_TYPE|ArchetypeFlags::GTA_MAP_TYPE_COVER;
	batchTester.TestInLevel(NULL, iTypeFlags, TYPE_FLAGS_ALL, phLevelBase::STATE_FLAGS_ALL,0,CPhysics::GetLevel());
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::DetectObstructionsInFrontOfPed(bool bFacingLeft)
{
	TUNE_GROUP_BOOL(COVER_TUNE, DISABLE_OBSTRUCTION_TESTS, false);

	m_pPed->GetPlayerInfo()->SetDynamicCoverHitPed(false);
	m_pPed->GetPlayerInfo()->SetDynamicCoverInsideCorner(false);
	if (DISABLE_OBSTRUCTION_TESTS)
		return false;

	Vector3 vCoverDirection = VEC3V_TO_VECTOR3(m_pPed->GetCoverPoint()->GetCoverDirectionVector(NULL));

	// Only do the obstruction test if we've orientated to the correct direction
	float fFacingDirection = rage::Atan2f(-vCoverDirection.x, vCoverDirection.y);
	fFacingDirection += m_bFacingLeft ? HALF_PI : -HALF_PI;
	fFacingDirection = fwAngle::LimitRadianAngle(fFacingDirection);
	float fHeadingDiff = SubtractAngleShorter(fFacingDirection, m_pPed->GetCurrentHeading());

	if (Abs(fHeadingDiff) > ms_fObstructionTestHeadingTol)
	{
		return false;
	}

	static float ms_fOffset = -0.1f;
	static float ms_fStartOffset = 0.2f;
	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_OBSTRUCTION_END_OFFSET, 1.5f, 0.0f, 3.0f, 0.01f);
	static dev_float sf_MIN_OBSTRUCTION_END_OFFSET = 1.0f; 
	const float fOffsetScale = Mag(NMovingGround::GetPedVelocity(m_pPed)).Getf() / CTaskMotionInCover::ms_Tunables.m_MaxMoveSpeedInCover;
	const float fProbeLength = Max(sf_MIN_OBSTRUCTION_END_OFFSET, fOffsetScale * MAX_OBSTRUCTION_END_OFFSET);
	float fOffset = Max(1.0f, m_pPed->GetMotionData()->GetDesiredMbrY()) * fProbeLength;
	const float fDirectionMultiplier = bFacingLeft ? 1.0f : -1.0f;
	Vector3 vStart(fDirectionMultiplier*ms_fOffset, ms_fStartOffset,	ms_fObstructionTestHeight);
	Vector3 vEnd(fDirectionMultiplier*ms_fOffset	, fOffset ,	ms_fObstructionTestHeight);

	Matrix34 mat;
	mat.MakeRotateZ(m_pPed->GetCurrentHeading());
	mat.d = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetPosition());
	mat.Transform(vStart);
	mat.Transform(vEnd);

	WorldProbe::CShapeTestFixedResults<> capsuleResult;
	s32 iTypeFlags = ArchetypeFlags::GTA_ALL_MAP_TYPES|ArchetypeFlags::GTA_VEHICLE_TYPE|ArchetypeFlags::GTA_OBJECT_TYPE|ArchetypeFlags::GTA_PED_TYPE;
	WorldProbe::CShapeTestCapsuleDesc capsuleDesc;
	capsuleDesc.SetResultsStructure(&capsuleResult);
	capsuleDesc.SetExcludeEntity(m_pPed);
	capsuleDesc.SetCapsule(vStart, vEnd, EDGE_CAPSULE_RADIUS);
	capsuleDesc.SetIncludeFlags(iTypeFlags);
	capsuleDesc.SetTypeFlags(ArchetypeFlags::GTA_AI_TEST);
	capsuleDesc.SetIsDirected(true);
	capsuleDesc.SetDoInitialSphereCheck(true);
	WorldProbe::GetShapeTestManager()->SubmitTest(capsuleDesc);

#if DEBUG_DRAW
	//static u32 sObstructionLineHash = ATSTRINGHASH("OBSTRUCTION_LINE", 0x66C6D85A);
	static u32 sObstructionSphereHash = ATSTRINGHASH("OBSTRUCTION_SPHERE", 0x97BE876A);

	if (!capsuleResult[0].GetHitDetected())
	{
		CCoverDebug::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), EDGE_CAPSULE_RADIUS, Color_DarkGreen, 1000, 0, false);
	}
#endif // DEBUG_DRAW

	if (capsuleResult[0].GetHitDetected())
	{		
		Vector3 vHitNormal = capsuleResult[0].GetHitNormal();

		//slopes ok
		static dev_float s_fVerticalTolerance = 0.7f;
		if (vHitNormal.z >= s_fVerticalTolerance)
			return false;

		//Check stairs
		bool bIgnoreDotCheckDueToSideStairsHit = false;
		if(PGTAMATERIALMGR->GetPolyFlagStairs(capsuleResult[0].GetHitMaterialId()))
		{
			//Are we on stairs moving up?
			if (m_pPed->GetPedConfigFlag(CPED_CONFIG_FLAG_OnStairs))
			{
				WorldProbe::CShapeTestFixedResults<> stairCapsuleResult;
				capsuleDesc.SetResultsStructure(&stairCapsuleResult);
				capsuleDesc.SetIncludeFlags(ArchetypeFlags::GTA_STAIR_SLOPE_TYPE);
				if (WorldProbe::GetShapeTestManager()->SubmitTest(capsuleDesc))
				{
					Vector3 vDir = vEnd-vStart; vDir.Normalize();
					Vector3 vNormal = stairCapsuleResult[0].GetHitNormal();
					vNormal.z=0; vNormal.Normalize();
					float dot = vNormal.Dot(vDir);
					static dev_float sf_StairSlopeDotTolerance = -0.7f;
					if (dot < sf_StairSlopeDotTolerance)
						return false;
				}
			}

			//Prevent failing the test if we hit sides of stairs B*1408988
			static dev_float s_fStairVerticalTolerance = 0.1f;
			if (vHitNormal.z > s_fStairVerticalTolerance)
			{
				return false;
			}
			bIgnoreDotCheckDueToSideStairsHit = true;
#if __DEV
			TUNE_GROUP_BOOL(COVER_TUNE, DISABLE_IGNORE_DOT_DUE_TO_STAIRS, false);
			if (DISABLE_IGNORE_DOT_DUE_TO_STAIRS)
			{
				bIgnoreDotCheckDueToSideStairsHit = false;
			}
#endif // __DEV
		}
		
		vHitNormal.z = 0.0f; vHitNormal.Normalize();		
		Vector3 vPedNormal = VEC3V_TO_VECTOR3(m_pPed->GetTransform().GetForward());
		vPedNormal.Negate(); vPedNormal.z = 0.0f; vPedNormal.Normalize();
		float fDot = vPedNormal.Dot(vHitNormal);

		//check normal as I may be able to slide up against this B* 807570
		static dev_float s_fBlockTolerance = 0.7f;
#if DEBUG_DRAW
		CCoverDebug::ms_debugDraw.AddSphere(VECTOR3_TO_VEC3V(capsuleResult[0].GetHitPosition()), 0.1f, (fabs(fDot) > s_fBlockTolerance) ? Color_blue : Color_red, 1000, sObstructionSphereHash);			
		CCoverDebug::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), EDGE_CAPSULE_RADIUS, Color_DarkOrange, 1000,0, false);		
#endif // DEBUG_DRAW
		if (fabs(fDot) < s_fBlockTolerance)
			return false;

		taskAssert(m_pPed->GetCoverPoint());
		// Copy the existing cover point details
		m_pNewCoverPoint->Copy(*m_pPed->GetCoverPoint());

		// Don't update the coverpoint when idle turning, as we aren't playing a step anim to cover the slide
		if (m_bFromIdleTurn)
			return true;

		float fOptimumLeftDist = ms_fOptimumDistToLeftInsideEdge;
		float fOptimumRightDist = ms_fOptimumDistToRightInsideEdge;
		if (m_pPed->GetCoverPoint() && m_pPed->GetCoverPoint()->GetHeight() != CCoverPoint::COVHEIGHT_TOOHIGH)
		{
			fOptimumLeftDist = ms_fOptimumDistToLeftInsideEdgeCrouched;
			fOptimumRightDist = ms_fOptimumDistToRightInsideEdgeCrouched;
		}

		Vector3 vCoverRight = VEC3V_TO_VECTOR3(m_pPed->GetCoverPoint()->GetCoverDirectionVector(NULL));
		vCoverRight.RotateZ(-HALF_PI);

		Vector3 vCoverCoords(Vector3::ZeroType);
		m_pPed->GetCoverPoint()->GetCoverPointPosition(vCoverCoords);

		bool bSetNewCoverPoint = false;
		if (bFacingLeft)
		{
			const float fLeftEdge = -vCoverRight.Dot(capsuleResult[0].GetHitPosition() - vCoverCoords);
			float fDifference = fOptimumLeftDist - fLeftEdge;
			if (ABS(fDifference) > ms_fMinInsideEdgeOffset && ABS(fDifference) < ms_fMaxInsideEdgeOffset)
			{
				Vector3 vNewCoverCoords = vCoverCoords + (vCoverRight*fDifference);
				float dot = (vNewCoverCoords-vCoverCoords).Dot(vCoverRight);
				if (dot > 0 || bIgnoreDotCheckDueToSideStairsHit)
				{
					bSetNewCoverPoint = true;
					m_pNewCoverPoint->SetWorldPosition(vNewCoverCoords);
				}
			} else if (ABS(fDifference) <= ms_fMinInsideEdgeOffset)
				bSetNewCoverPoint = true; //keep current cover point
		}
		else
		{
			const float fRightEdge = vCoverRight.Dot(capsuleResult[0].GetHitPosition() - vCoverCoords);
			float fDifference = fOptimumRightDist - fRightEdge;
			if (ABS(fDifference) > ms_fMinInsideEdgeOffset && ABS(fDifference) < ms_fMaxInsideEdgeOffset)
			{
				Vector3 vNewCoverCoords = vCoverCoords - (vCoverRight*fDifference);
				float dot = (vNewCoverCoords-vCoverCoords).Dot(vCoverRight);
				if (dot < 0 || bIgnoreDotCheckDueToSideStairsHit)
				{
					bSetNewCoverPoint = true;
					m_pNewCoverPoint->SetWorldPosition(vNewCoverCoords);
				}
			} else if (ABS(fDifference) <= ms_fMinInsideEdgeOffset)
				bSetNewCoverPoint = true; //keep current cover point.
		}

		m_pPed->GetCoverPoint()->GetCoverPointPosition(vCoverCoords);
		Vector3 vDist = capsuleResult[0].GetHitPosition() - vCoverCoords;
		vDist.z=0; 
		float fCornerDistance = vDist.Mag();
		m_pPed->GetPlayerInfo()->SetDynamicCoverInsideCorner(true, fCornerDistance);

		//stop early if hitting a ped, B* 1415632
		bool bHitPed = capsuleResult[0].GetHitEntity() && capsuleResult[0].GetHitEntity()->GetIsTypePed();
		if (bHitPed || fCornerDistance <= CTaskMotionInCover::ms_Tunables.m_InsideCornerStopDistance)
		{		
			m_pPed->GetPlayerInfo()->SetDynamicCoverHitPed(bHitPed);

			if (m_bFacingLeft)
			{
				m_pPed->GetPlayerInfo()->SetDynamicCoverCanMoveLeft(false);
				m_pPed->GetPlayerInfo()->SetDynamicCoverCanMoveRight(true);
			}
			else
			{
				m_pPed->GetPlayerInfo()->SetDynamicCoverCanMoveLeft(true);
				m_pPed->GetPlayerInfo()->SetDynamicCoverCanMoveRight(false);
			}
			return true;
		}
		return bSetNewCoverPoint;
	}
	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::IsAreaAroundCornerClear(CPed* pPed, CVehicle* pVehicle)
{
	Vector3 vPedForward = VEC3V_TO_VECTOR3(pPed->GetTransform().GetB());
	Vector3 vPedSide = VEC3V_TO_VECTOR3(pPed->GetTransform().GetA());

	if (!m_bFacingLeft)
	{
		vPedSide.Scale(-1.0f);
	}

	bool bFinishedLowTest = false;
	bool bFinishedHighTest = m_bCrouched ?  true : false;
	
	while (!bFinishedLowTest || !bFinishedHighTest)
	{
		Vector3 vStart = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());

		bool bHighTest = false;

		if (!bFinishedHighTest)
		{
			bHighTest = bFinishedLowTest ? false : true;
		}

		const float fForwardOffset = m_bCrouched ? ms_Tunables.m_OCMCrouchedForwardClearanceOffset : ms_Tunables.m_OCMStandingForwardClearanceOffset;

		if (bHighTest)
		{
			bFinishedHighTest = true;
		}
		else
		{
			bFinishedLowTest = true;
		}

		vStart += vPedForward * fForwardOffset;
		vStart.z += bHighTest ? ms_Tunables.m_OCMStandingHeightOffset : ms_Tunables.m_OCMCrouchedHeightOffset;
		Vector3 vEnd = vStart;
		vEnd += vPedSide * ms_Tunables.m_OCMSideClearanceDepth;

		Vector3 vIntersectionPos(Vector3::ZeroType);
		bool bHitDetected = false;
		if (pVehicle && pVehicle->GetVehicleCoverBoundOffsetInfo())
		{
			bHitDetected = CDynamicCoverHelper::DoLineTestAgainstVehicleDummyBounds(*pPed, *pVehicle, vStart, vEnd, vIntersectionPos);
		}
		else
		{
			bHitDetected = CDynamicCoverHelper::DoCapsuleTest(vStart, vEnd, vIntersectionPos) ? true : false;
		}

#if DEBUG_DRAW
		char szDebugText[128];
		formatf(szDebugText, "CORNER_MOVE_CLEARANCE_TEST_%u", bHighTest);
		CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), ms_Tunables.m_OCMClearanceCapsuleRadius, bHitDetected ? Color_red :Color_green, 1000, atStringHash(szDebugText), false);

		if (bHitDetected)
		{
			formatf(szDebugText, "CORNER_MOVE_CLEARANCE_TEST_INTERSECTION_%u", bHighTest);
			CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vIntersectionPos), 0.1f, Color_red, 1000, atStringHash(szDebugText));
		}
#endif // DEBUG_DRAW

		if (bHitDetected)
		{		
			return false;
		}
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::FindNearbyCollisionAndComputeTestPosition(CPed* pPed)
{
	ProbeResults apProbeResults[CTCP_Max];

	const float fDirection = m_bFacingLeft ? 1.0f : -1.0f;
	
	const s32 iMaxShapeTests = CTCP_Max;
	sShapeTestInfo shapeTestInfos[CTCP_Max];
	
	for (s32 i=0; i<CTCP_Max; ++i)
	{
		shapeTestInfos[i].vStart =	Vector3(fDirection * ms_Tunables.m_CTCSideOffset,	ms_Tunables.m_CTCForwardOffset + i * ms_Tunables.m_CTCSpacingOffset,	ms_Tunables.m_CTCHeightOffset);
		shapeTestInfos[i].vEnd =		Vector3(fDirection * ms_Tunables.m_CTCSideOffset + fDirection*ms_Tunables.m_CTCProbeDepth,	ms_Tunables.m_CTCForwardOffset + i * ms_Tunables.m_CTCSpacingOffset,	ms_Tunables.m_CTCHeightOffset);
	}

	bool bCheckedForVehicle = false;
	bool bNeedToTestAgainstVehicle = false;

	while (!bCheckedForVehicle)
	{
		phIntersection aIntersections[iMaxShapeTests];
		phSegment aSegments[iMaxShapeTests];
		const float fDir = pPed->GetCurrentHeading();
		Vec3V vStartPos = pPed->GetTransform().GetPosition();
		Mat34V testMtx;
		Mat34VFromZAxisAngle(testMtx, ScalarVFromF32(fDir), vStartPos);

// 		if (bNeedToTestAgainstVehicle && GetCoverVehicle(*pPed))
// 		{
// 			DoVehicleBoxTests(testMtx, *GetCoverVehicle(*pPed), iMaxShapeTests, 0.0f, shapeTestInfos, aIntersections, aSegments, apProbeResults);
// 			bCheckedForVehicle = true;
// 		}
// 		else
		{
			DoCoverToCoverBatchShapeTests(fDirection, testMtx, iMaxShapeTests, shapeTestInfos, aIntersections, aSegments, apProbeResults);
		}

		// Copy any collision results into the probe results
		for( s32 i = 0; i < CTCP_Max; i++ )
		{
			apProbeResults[i].m_bCollided = aIntersections[i].IsAHit();
			if(apProbeResults[i].m_bCollided)
			{
				phInst* pHitInst = aIntersections[i].GetInstance();
				CEntity *pHitEntity = (CEntity *)CPhysics::GetEntityFromInst(pHitInst);

// 				if (pHitEntity && pHitEntity->GetIsTypeVehicle())
// 				{
 					m_pCoverEntryEntity = pHitEntity;
// 					bNeedToTestAgainstVehicle = true;
// 					break;
// 				}

				const bool bUnableToTakeCoverOnDoor = pHitEntity && pHitEntity->GetIsTypeObject() && ((CObject*)pHitEntity)->IsADoor() && !pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED) && !pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED_BY_NETWORK);
#if HACK_RDR3
				// We want covers on quickly moving vehicles
				const bool bIsMovingTooQuickly = false;
#else
				bool bIsVehicleThatDoesntProvideCover = false;
				const bool bVehicleCanStandOn = CanPedBeInCoverOnEntity(*pPed, pHitEntity, bIsVehicleThatDoesntProvideCover);
				const bool bIsMovingTooQuickly = pHitEntity && (pHitEntity->GetIsPhysical() && static_cast<CPhysical*>(pHitEntity)->GetVelocity().Mag2() > rage::square(2.0f) ) && !bVehicleCanStandOn;
#endif
				const bool bFlaggedToNotProvideCover = pHitEntity && pHitEntity->IsArchetypeSet() && pHitEntity->GetBaseModelInfo()->GetDoesNotProvidePlayerCover();
				if( bUnableToTakeCoverOnDoor || bIsMovingTooQuickly || bFlaggedToNotProvideCover || bIsVehicleThatDoesntProvideCover)
				{
					apProbeResults[i].m_bCollided = false;
				}
				else
				{
					apProbeResults[i].m_vCapsuleStart = aSegments[i].A;
					apProbeResults[i].m_pHitEntity = pHitEntity;
					apProbeResults[i].m_bCollidedWithFixed = pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED);
					apProbeResults[i].m_vPosition = RCC_VECTOR3(aIntersections[i].GetPosition());
					apProbeResults[i].m_vNormal = RCC_VECTOR3(aIntersections[i].GetNormal());
					apProbeResults[i].m_bCollidedWithSeeThrough = PGTAMATERIALMGR->GetIsSeeThrough(aIntersections[i].GetMaterialId());
					apProbeResults[i].m_fDepth = (RCC_VECTOR3(aIntersections[i].GetPosition()).Dist(apProbeResults[i].m_vCapsuleStart)) + shapeTestInfos[i].vStart.y;										
					apProbeResults[i].m_bHitRoundCover = CheckForRoundCover( &aIntersections[i], apProbeResults[i].m_vRoundCoverCenter, apProbeResults[i].m_fRoundCoverRadius);
					// Move the test position forward and to the side in case we have hit the edge of a wall
					Vec3V vPosition = m_pPed->GetTransform().UnTransform(aIntersections[i].GetPosition());
					static dev_float X_OFFSET = -0.45f;
					static dev_float Y_OFFSET = 0.05f;
					Vec3V vIn(fDirection*X_OFFSET, vPosition.GetYf() + Y_OFFSET, 0.0f);
					m_vTestPos = VEC3V_TO_VECTOR3(m_pPed->GetTransform().Transform(vIn));
#if __DEV
					CTask::ms_debugDraw.AddSphere(RCC_VEC3V(m_vTestPos), 0.025f, Color_yellow, 1000);
					RenderCollisionResult(RCC_VEC3V(aSegments[i].A), RCC_VEC3V(aSegments[i].B), CTT_Capsule, apProbeResults, i, false, "CTC");
#endif
					return true;
				}
			}

			if (!bNeedToTestAgainstVehicle)
			{
				bCheckedForVehicle = true;
			}
#if __DEV
			RenderCollisionResult(RCC_VEC3V(aSegments[i].A), RCC_VEC3V(aSegments[i].B), CTT_Capsule, apProbeResults, i, false, "CTC");
#endif
		}
	}
	return false;
}

//////////////////////////////////////////////////////////////////////////
void CDynamicCoverHelper::ComputeTestMatrix(CPed* pPed, Vector3& vStartPos, float fDir, Mat34V& testMtx, const Vector3* vGroundNormalOverride)
{
	Mat34VFromZAxisAngle(testMtx, ScalarVFromF32(fDir), RCC_VEC3V(vStartPos));
	float slope = 0;
	Vector3 groundNormal = vGroundNormalOverride ? *vGroundNormalOverride : pPed->GetGroundNormal();
	Vector3 groundDirection(groundNormal.x, groundNormal.y, 0.0f);	
	if ( groundDirection.IsNonZero() ) 
	{
		groundDirection.Normalize();
		slope = groundNormal.Angle( ZAXIS );		
		const float modulate = VEC3V_TO_VECTOR3( pPed->GetTransform().GetB() ).Dot( groundDirection );
		slope = fabs(modulate) * slope;		
		float dot = groundDirection.Dot(VEC3V_TO_VECTOR3(testMtx.GetCol0()));		
		if (dot < 0)
			slope = -slope;
		Mat34VRotateLocalY(testMtx, ScalarVFromF32(slope));
	}

	TUNE_GROUP_BOOL(COVER_TUNE, USE_HEIGHT_DELTA_TEST, true);
	if (USE_HEIGHT_DELTA_TEST)
	{
		// Avoid oscillation between test heights because this can cause unwanted height changes
		// if we're on a kerb or ground edge of some sort
		if (m_fLastTestZHeight > -LARGE_FLOAT)
		{
			TUNE_GROUP_FLOAT(COVER_TUNE, MAX_SLOPE_DELTA, 0.3f, 0.0f, 1.0f, 0.01f);
			const float fSlopeScale = Clamp(Abs(slope), 0.0f, MAX_SLOPE_DELTA);
			TUNE_GROUP_FLOAT(COVER_TUNE, MIN_TEST_HEIGHT_DELTA_TO_USE_TEST_MTX, 0.05f, 0.0f, 1.0f, 0.01f);
			TUNE_GROUP_FLOAT(COVER_TUNE, MAX_TEST_HEIGHT_DELTA_TO_USE_TEST_MTX, 0.2f, 0.0f, 1.0f, 0.01f);
			const float fMinHeightDelta = fSlopeScale * MIN_TEST_HEIGHT_DELTA_TO_USE_TEST_MTX + (1.0f - fSlopeScale) * MAX_TEST_HEIGHT_DELTA_TO_USE_TEST_MTX;
			const float fHeightDelta = Abs(testMtx.GetCol3().GetZf() - m_fLastTestZHeight);
			if (fHeightDelta < fMinHeightDelta)
			{
				Vec3V vPos = testMtx.GetCol3();
				vPos.SetZf(m_fLastTestZHeight);
				testMtx.SetCol3(vPos);
			}
		}
		else
		{
			m_fLastTestZHeight = testMtx.GetCol3().GetZf();
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::DoInitialCollisionCheck(CPed* pPed, Vector3& vStartPos, float fDir, ProbeResults* apProbeResults, CollisionTestType overrideMainTestType, float fTestLength)
{
	const s32 iMaxShapeTests = LP_Max;

	float fCenterCPWidth2 = pPed ? pPed->GetCapsuleInfo()->GetHalfWidth() + ms_fCenterCPWidth2 : (PED_HUMAN_RADIUS) + ms_fCenterCPWidth2;
	static float fLowYOffset = -0.2f;
	sShapeTestInfo shapeTestInfos[LP_Max] = 
	{
		//								Start																//								End
		{ Vector3(-ms_fOuterCPWidth,	ms_fOuterYOffset,		ms_Tunables.m_LowCoverProbeHeight	),		Vector3(-ms_fOuterCPWidth2,		fTestLength,	ms_Tunables.m_LowCoverProbeHeight),		ms_fCapsuleRadius },
		{ Vector3(-ms_fCenterCPWidth,	ms_fCenterYOffset,		ms_Tunables.m_LowCoverProbeHeight	),		Vector3(-fCenterCPWidth2,		fTestLength,	ms_Tunables.m_LowCoverProbeHeight),		ms_fCapsuleRadius },
		{ Vector3(0.0f,					ms_fCenterYOffset,		ms_Tunables.m_LowCoverProbeHeight	),		Vector3(0.0f,					fTestLength,	ms_Tunables.m_LowCoverProbeHeight),		ms_fCapsuleRadius },
		{ Vector3(ms_fCenterCPWidth,	ms_fCenterYOffset,		ms_Tunables.m_LowCoverProbeHeight	),		Vector3(fCenterCPWidth2,		fTestLength,	ms_Tunables.m_LowCoverProbeHeight),		ms_fCapsuleRadius },
		{ Vector3(ms_fOuterCPWidth,		ms_fOuterYOffset,		ms_Tunables.m_LowCoverProbeHeight	),		Vector3(ms_fOuterCPWidth2,		fTestLength,	ms_Tunables.m_LowCoverProbeHeight),		ms_fCapsuleRadius },

		{ Vector3(-ms_fOuterCPWidth,	ms_fOuterYOffset,		ms_Tunables.m_HighCoverProbeHeight	),		Vector3(-ms_fOuterCPWidth2,		fTestLength,	ms_Tunables.m_HighCoverProbeHeight),		ms_fCapsuleRadius },
		{ Vector3(-ms_fCenterCPWidth,	ms_fCenterYOffset,		ms_Tunables.m_HighCoverProbeHeight	),		Vector3(-fCenterCPWidth2,		fTestLength,	ms_Tunables.m_HighCoverProbeHeight),		ms_fCapsuleRadius },
		{ Vector3(0.0f,					ms_fCenterYOffset,		ms_Tunables.m_HighCoverProbeHeight	),		Vector3(0.0f,					fTestLength,	ms_Tunables.m_HighCoverProbeHeight),		ms_fCapsuleRadius },
		{ Vector3(ms_fCenterCPWidth,	ms_fCenterYOffset,		ms_Tunables.m_HighCoverProbeHeight	),		Vector3(fCenterCPWidth2,		fTestLength,	ms_Tunables.m_HighCoverProbeHeight),		ms_fCapsuleRadius },
		{ Vector3(ms_fOuterCPWidth,		ms_fOuterYOffset,		ms_Tunables.m_HighCoverProbeHeight	),		Vector3(ms_fOuterCPWidth2,		fTestLength,	ms_Tunables.m_HighCoverProbeHeight),		ms_fCapsuleRadius }, 
		{ Vector3(0.0f,					fLowYOffset,			ms_fExtraLowHeight					),		Vector3(0.0f,					fTestLength,	ms_fExtraLowHeight),	ms_fExtraLowCapsuleRadius },
	};

	float fExtendedCheckLength = 0.0f;
	bool bIsFPS = false;
#if FPS_MODE_SUPPORTED
	bIsFPS = pPed->IsFirstPersonShooterModeEnabledForPlayer(false);
#endif // FPS_MODE_SUPPORTED

	if( pPed->GetMotionData()->GetIsRunning() || pPed->GetMotionData()->GetIsSprinting()) 
	{
		fExtendedCheckLength = bIsFPS ? RUNNING_EXTENDED_DISTANCE_FPS : RUNNING_EXTENDED_DISTANCE;
	}
	else if( pPed->GetMotionData()->GetIsWalking() )
	{
		fExtendedCheckLength = bIsFPS ? WALKING_EXTENDED_DISTANCE_FPS : WALKING_EXTENDED_DISTANCE;
	}

	phIntersection aIntersections[iMaxShapeTests];
	phSegment aSegments[iMaxShapeTests];

	Mat34V testMtx;
	ComputeTestMatrix(pPed, vStartPos, fDir, testMtx);

	if (overrideMainTestType == initialTestType && GetState() == State_FindNewCover)
	{
		// See if the low probe we're about to do will hit the vehicle
		// Dodgy? - Might need to test vehicle is in same dir as we are testing for.
		CEntityScannerIterator nearbyVehicles = pPed->GetPedIntelligence()->GetNearbyVehicles();
		CVehicle* pNearestVehicle = static_cast<CVehicle*>(nearbyVehicles.GetFirst());
		if (pNearestVehicle && pNearestVehicle->GetVehicleCoverBoundOffsetInfo())
		{
			Vector3 vStart = shapeTestInfos[LP_LowCentre].vStart;
			Vector3 vEnd = shapeTestInfos[LP_LowCentre].vEnd;
			vEnd.y = Max(fExtendedCheckLength, vEnd.y);
			MAT34V_TO_MATRIX34(testMtx).Transform(vStart);
			MAT34V_TO_MATRIX34(testMtx).Transform(vEnd);
			Vector3 vIntersectionPos;
			if (CDynamicCoverHelper::DoLineTestAgainstVehicleDummyBounds(*pPed, *pNearestVehicle, vStart, vEnd, vIntersectionPos))
			{
				m_pCoverEntryEntity = pNearestVehicle;
			}
			else
			{
				m_pCoverEntryEntity = NULL;
			}
		}
		else
		{
			m_pCoverEntryEntity = NULL;
		}
	}

	CVehicle* pCoverVehicle = GetCoverVehicle(*pPed);
	if (pCoverVehicle && pCoverVehicle->GetVehicleCoverBoundOffsetInfo())
	{
		if (VehicleHasCoverBounds(*pCoverVehicle))
		{
			DoVehicleCoverBoundBoxTests(testMtx, *pCoverVehicle, iMaxShapeTests, fExtendedCheckLength, shapeTestInfos, aIntersections, aSegments, apProbeResults, m_iActiveBoundIndex, pPed, false);
		}
		else
		{
			DoVehicleBoxTests(testMtx, *pCoverVehicle, iMaxShapeTests, fExtendedCheckLength, shapeTestInfos, aIntersections, aSegments, apProbeResults);
			DetermineIfCoverShouldBeLow(testMtx, shapeTestInfos, aIntersections);
		}
	}
	else
	{
		DoBatchShapeTests(testMtx, overrideMainTestType, iMaxShapeTests, fExtendedCheckLength, shapeTestInfos, aIntersections, aSegments, apProbeResults, fTestLength);
	}

	// TODO: move the results copying into a common function?
	static s32 COVER_ENTRY_PROBE = LP_FrontLowC;

	// Copy any collision results into the probe results
	for( s32 i = 0; i < LP_Max; i++ )
	{
		// Should have already set the probe results in DoVehicleBoxTests
		if (!pCoverVehicle)
		{
			apProbeResults[i].m_bCollided = aIntersections[i].IsAHit();
		}

#if DEBUG_DRAW
		RenderCollisionResultNew(RCC_VEC3V(aSegments[i].A), RCC_VEC3V(aSegments[i].B), aIntersections[i].GetPosition(), overrideMainTestType, apProbeResults, i);
#endif // DEBUG_DRAW

		if(apProbeResults[i].m_bCollided)
		{
			phInst* pHitInst = aIntersections[i].GetInstance();
			CEntity *pHitEntity = (CEntity *)CPhysics::GetEntityFromInst(pHitInst);

			// pBoxBound->SetMaterial(MATERIALMGR.FindMaterialId("car_metal")); ?
			if (i == COVER_ENTRY_PROBE && overrideMainTestType == initialTestType)		// Not sure how to get the correct material in the vehicle case??
			{
				m_pCoverEntryEntity = pHitEntity;
				if (!pCoverVehicle)
				{
					m_pCoverEntryMaterial = g_CollisionAudioEntity.GetMaterialFromIntersection(&aIntersections[i]);
				}
			}

			const bool bUnableToTakeCoverOnDoor = pHitEntity && pHitEntity->GetIsTypeObject() && ((CObject*)pHitEntity)->IsADoor() && !pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED) && !pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED_BY_NETWORK);
#if HACK_RDR3
			// We want covers on quickly moving vehicles
			const bool bIsMovingTooQuickly = false;
#else
			bool bIsVehicleThatDoesntProvideCover = false;
			const bool bVehicleCanStandOn = CanPedBeInCoverOnEntity(*pPed, pHitEntity, bIsVehicleThatDoesntProvideCover);
			const bool bIsMovingTooQuickly = pHitEntity && (pHitEntity->GetIsPhysical() && static_cast<CPhysical*>(pHitEntity)->GetVelocity().Mag2() > rage::square(2.0f) ) && !bVehicleCanStandOn;
#endif
			const bool bFlaggedToNotProvideCover = (i != LP_LowCentre) && pHitEntity && pHitEntity->IsArchetypeSet() && pHitEntity->GetBaseModelInfo()->GetDoesNotProvidePlayerCover();

			if( bUnableToTakeCoverOnDoor || bIsMovingTooQuickly || bFlaggedToNotProvideCover || bIsVehicleThatDoesntProvideCover)
			{
				apProbeResults[i].m_bCollided = false;
			}
			else
			{
				apProbeResults[i].m_vCapsuleStart = aSegments[i].A;
				apProbeResults[i].m_pHitEntity = pHitEntity;
				apProbeResults[i].m_bCollidedWithFixed = pHitEntity ? pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED) : false;
				apProbeResults[i].m_vPosition = RCC_VECTOR3(aIntersections[i].GetPosition());
				apProbeResults[i].m_vNormal = RCC_VECTOR3(aIntersections[i].GetNormal());
				apProbeResults[i].m_bCollidedWithSeeThrough = PGTAMATERIALMGR->GetIsSeeThrough(aIntersections[i].GetMaterialId());
				apProbeResults[i].m_fDepth = (RCC_VECTOR3(aIntersections[i].GetPosition()).Dist(apProbeResults[i].m_vCapsuleStart)) + shapeTestInfos[i].vStart.y;								
				apProbeResults[i].m_bHitRoundCover = CheckForRoundCover( &aIntersections[i], apProbeResults[i].m_vRoundCoverCenter, apProbeResults[i].m_fRoundCoverRadius);
			}
		}
#if __DEV
		RenderCollisionResult(RCC_VEC3V(aSegments[i].A), RCC_VEC3V(aSegments[i].B), overrideMainTestType, apProbeResults, i, false);
#endif
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::DoCollisionCheckForMovementInCover(CPed* pPed, Vector3& vStartPos, float fDir, ProbeResults* apProbeResults, CollisionTestType testType, bool bFacingLeft)
{
	const s32 iMaxShapeTests = LP_Max;
	const float fDirectionMultiplier = bFacingLeft ? -1.0f : 1.0f;

	sShapeTestInfo shapeTestInfos[LP_Max] = 
	{
		//								Start																									//								End
		{ Vector3(fDirectionMultiplier * ms_fMovingCenterBackwardCPWidth,	ms_fYInnerStartOffset,		ms_Tunables.m_LowCoverProbeHeight),		Vector3(fDirectionMultiplier * ms_fMovingCenterBackwardCPWidth,		ms_fYInnerEndOffset,		ms_Tunables.m_LowCoverProbeHeight	),	ms_fCapsuleRadius},
		{ Vector3(0.0f,														ms_fYInnerStartOffset,		ms_Tunables.m_LowCoverProbeHeight),		Vector3(0.0f,														ms_fYInnerEndOffset,		ms_Tunables.m_LowCoverProbeHeight	),	ms_fCapsuleRadius},
		{ Vector3(fDirectionMultiplier * ms_fMovingCenterForwardCPWidth,	ms_fYInnerStartOffset,		ms_Tunables.m_LowCoverProbeHeight),		Vector3(fDirectionMultiplier * ms_fMovingCenterForwardCPWidth,		ms_fYInnerEndOffset,		ms_Tunables.m_LowCoverProbeHeight	),	ms_fCapsuleRadius},
		{ Vector3(fDirectionMultiplier * ms_fMovingInnerForwardCPWidth,		ms_fYInnerStartOffset,		ms_Tunables.m_LowCoverProbeHeight),		Vector3(fDirectionMultiplier * ms_fMovingInnerForwardCPWidth2,		ms_fYInnerEndOffset,		ms_Tunables.m_LowCoverProbeHeight	),	ms_fCapsuleRadius},
		{ Vector3(fDirectionMultiplier * ms_fMovingOuterForwardCPWidth,		ms_fYOuterStartOffset,		ms_Tunables.m_LowCoverProbeHeight),		Vector3(fDirectionMultiplier * ms_fMovingOuterForwardCPWidth2,		ms_fYOuterEndOffset,		ms_Tunables.m_LowCoverProbeHeight	),	ms_fCapsuleRadius},
		
		{ Vector3(fDirectionMultiplier * ms_fMovingCenterBackwardCPWidth,	ms_fYInnerStartOffset,		ms_Tunables.m_HighCoverProbeHeight),	Vector3(fDirectionMultiplier * ms_fMovingCenterBackwardCPWidth,		ms_fYInnerEndOffset,		ms_Tunables.m_HighCoverProbeHeight	),	ms_fCapsuleRadius},
		{ Vector3(0.0f,														ms_fYInnerStartOffset,		ms_Tunables.m_HighCoverProbeHeight),	Vector3(0.0f,														ms_fYInnerEndOffset,		ms_Tunables.m_HighCoverProbeHeight	),	ms_fCapsuleRadius},
		{ Vector3(fDirectionMultiplier * ms_fMovingCenterForwardCPWidth,	ms_fYInnerStartOffset,		ms_Tunables.m_HighCoverProbeHeight),	Vector3(fDirectionMultiplier * ms_fMovingCenterForwardCPWidth,		ms_fYInnerEndOffset,		ms_Tunables.m_HighCoverProbeHeight	),	ms_fCapsuleRadius},
		{ Vector3(fDirectionMultiplier * ms_fMovingInnerForwardCPWidth,		ms_fYInnerStartOffset,		ms_Tunables.m_HighCoverProbeHeight),	Vector3(fDirectionMultiplier * ms_fMovingInnerForwardCPWidth2,		ms_fYInnerEndOffset,		ms_Tunables.m_HighCoverProbeHeight	),	ms_fCapsuleRadius},
		{ Vector3(fDirectionMultiplier * ms_fMovingOuterForwardCPWidth,		ms_fYOuterStartOffset,		ms_Tunables.m_HighCoverProbeHeight),	Vector3(fDirectionMultiplier * ms_fMovingOuterForwardCPWidth2,		ms_fYOuterEndOffset,		ms_Tunables.m_HighCoverProbeHeight	),	ms_fCapsuleRadius},
		{ Vector3(0.0f,														0.0f,						ms_fExtraLowHeight),					Vector3(0.0f,														ms_fYInnerEndOffset,		ms_fExtraLowHeight					),	ms_fExtraLowCapsuleRadius},
	};

	phIntersection aIntersections[iMaxShapeTests];
	phSegment aSegments[iMaxShapeTests];
	Mat34V testMtx;

	//Find test position ground normal
	Vector3 vStart  = vStartPos + Vector3(0.0f, 0.0f, -0.5f); 
	Vector3 vEnd  = vStart + Vector3(0.0f, 0.0f, -1.5f); 
	Vector3 vUnused;	
	if (m_vCachedGroundNormal.IsNonZero() || DoLineProbeTest(vStartPos, vEnd, vUnused, NULL, NULL, true, &m_vCachedGroundNormal ))	
	{
		ComputeTestMatrix(pPed, vStartPos, fDir, testMtx, &m_vCachedGroundNormal);
	} 
	else
	{
		ComputeTestMatrix(pPed, vStartPos, fDir, testMtx);
	}


	CVehicle* pCoverVehicle = GetCoverVehicle(*pPed);
	if (pCoverVehicle && pCoverVehicle->GetVehicleCoverBoundOffsetInfo())
	{
		if (VehicleHasCoverBounds(*pCoverVehicle))
		{
			DoVehicleCoverBoundBoxTests(testMtx, *pCoverVehicle, iMaxShapeTests, 0.0f, shapeTestInfos, aIntersections, aSegments, apProbeResults, m_iActiveBoundIndex, pPed, true);
		}
		else
		{
			DoVehicleBoxTests(testMtx, *pCoverVehicle, iMaxShapeTests, 0.0f, shapeTestInfos, aIntersections, aSegments, apProbeResults);
			DetermineIfCoverShouldBeLow(testMtx, shapeTestInfos, aIntersections);
		}
	}
	else
	{
		DoBatchShapeTests(testMtx, testType, iMaxShapeTests, 0.0f, shapeTestInfos, aIntersections, aSegments, apProbeResults);
	}

	// Copy any collision results into the probe results
	for( s32 i = 0; i < MLP_Max; i++ )
	{
		// Should have already set the probe results in DoVehicleBoxTests
		if (!pCoverVehicle)
		{
			apProbeResults[i].m_bCollided = aIntersections[i].IsAHit();
		}
		if(apProbeResults[i].m_bCollided)
		{
			phInst* pHitInst = aIntersections[i].GetInstance();
			CEntity *pHitEntity = (CEntity *)CPhysics::GetEntityFromInst(pHitInst);

			static s32 COVER_ENTRY_PROBE = MLP_LowCentre;
			if (i == COVER_ENTRY_PROBE && !pCoverVehicle)
			{
				m_pCoverEntryEntity = pHitEntity;
				m_pCoverEntryMaterial = g_CollisionAudioEntity.GetMaterialFromIntersection(&aIntersections[i]);
			}

			const bool bUnableToTakeCoverOnDoor = pHitEntity && pHitEntity->GetIsTypeObject() && ((CObject*)pHitEntity)->IsADoor() && !pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED) && !pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED_BY_NETWORK);
#if HACK_RDR3
			// We want covers on quickly moving vehicles
			const bool bIsMovingTooQuickly = false;
#else
			bool bIsVehicleThatDoesntProvideCover = false;
			const bool bVehicleCanStandOn = CanPedBeInCoverOnEntity(*pPed, pHitEntity, bIsVehicleThatDoesntProvideCover);
			const bool bIsMovingTooQuickly = pHitEntity && (pHitEntity->GetIsPhysical() && static_cast<CPhysical*>(pHitEntity)->GetVelocity().Mag2() > rage::square(2.0f) ) && !bVehicleCanStandOn;
#endif
			const bool bFlaggedToNotProvideCover = (i != LP_LowCentre) && pHitEntity && pHitEntity->IsArchetypeSet() && pHitEntity->GetBaseModelInfo()->GetDoesNotProvidePlayerCover();

			if( bUnableToTakeCoverOnDoor || bIsMovingTooQuickly || bFlaggedToNotProvideCover || bIsVehicleThatDoesntProvideCover)
			{
				apProbeResults[i].m_bCollided = false;
			}
			else
			{
				apProbeResults[i].m_vCapsuleStart = aSegments[i].A;
				apProbeResults[i].m_pHitEntity = pHitEntity;
				apProbeResults[i].m_bCollidedWithFixed = pHitEntity && pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED);
				apProbeResults[i].m_vPosition = RCC_VECTOR3(aIntersections[i].GetPosition());
				apProbeResults[i].m_vNormal = RCC_VECTOR3(aIntersections[i].GetNormal());
				apProbeResults[i].m_bCollidedWithSeeThrough = PGTAMATERIALMGR->GetIsSeeThrough(aIntersections[i].GetMaterialId());
				apProbeResults[i].m_fDepth = (RCC_VECTOR3(aIntersections[i].GetPosition()).Dist(apProbeResults[i].m_vCapsuleStart)) + shapeTestInfos[i].vStart.y;								
				apProbeResults[i].m_bHitRoundCover = CheckForRoundCover( &aIntersections[i], apProbeResults[i].m_vRoundCoverCenter, apProbeResults[i].m_fRoundCoverRadius);
			}
		}

#if __DEV
		RenderCollisionResult(RCC_VEC3V(aSegments[i].A), RCC_VEC3V(aSegments[i].B), testType, apProbeResults, i, true);
#endif
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::DoCollisionCheckWhenIdleInCover(CPed* pPed, Vector3& vStartPos, float fDir, ProbeResults* apProbeResults, CollisionTestType overrideMainTestType, float fTestLength)
{
	const s32 iMaxShapeTests = LP_Max;

	float fCenterCPWidth2 = pPed ? pPed->GetCapsuleInfo()->GetHalfWidth() + ms_fCenterCPWidth2 : (PED_HUMAN_RADIUS) + ms_fCenterCPWidth2;

	sShapeTestInfo shapeTestInfos[LP_Max] = 
	{
		{ Vector3(-ms_fOuterCPWidth,	ms_Tunables.m_IdleYStartOffset,		ms_Tunables.m_LowCoverProbeHeight),		Vector3(-ms_fOuterCPWidth2,		fTestLength,	ms_Tunables.m_LowCoverProbeHeight),		ms_fCapsuleRadius},
		{ Vector3(-ms_fCenterCPWidth,	ms_Tunables.m_IdleYStartOffset,		ms_Tunables.m_LowCoverProbeHeight),		Vector3(-fCenterCPWidth2,		fTestLength,	ms_Tunables.m_LowCoverProbeHeight),		ms_fCapsuleRadius},
		{ Vector3(0.0f,					ms_Tunables.m_IdleYStartOffset,		ms_Tunables.m_LowCoverProbeHeight),		Vector3(0.0f,					fTestLength,	ms_Tunables.m_LowCoverProbeHeight),		ms_fCapsuleRadius},
		{ Vector3(ms_fCenterCPWidth,	ms_Tunables.m_IdleYStartOffset,		ms_Tunables.m_LowCoverProbeHeight),		Vector3(fCenterCPWidth2,		fTestLength,	ms_Tunables.m_LowCoverProbeHeight),		ms_fCapsuleRadius},
		{ Vector3(ms_fOuterCPWidth,		ms_Tunables.m_IdleYStartOffset,		ms_Tunables.m_LowCoverProbeHeight),		Vector3(ms_fOuterCPWidth2,		fTestLength,	ms_Tunables.m_LowCoverProbeHeight),		ms_fCapsuleRadius},

		{ Vector3(-ms_fOuterCPWidth,	ms_Tunables.m_IdleYStartOffset,		ms_Tunables.m_HighCoverProbeHeight),		Vector3(-ms_fOuterCPWidth2,		fTestLength,	ms_Tunables.m_HighCoverProbeHeight),		ms_fCapsuleRadius},
		{ Vector3(-ms_fCenterCPWidth,	ms_Tunables.m_IdleYStartOffset,		ms_Tunables.m_HighCoverProbeHeight),		Vector3(-fCenterCPWidth2,		fTestLength,	ms_Tunables.m_HighCoverProbeHeight),		ms_fCapsuleRadius},
		{ Vector3(0.0f,					ms_Tunables.m_IdleYStartOffset,		ms_Tunables.m_HighCoverProbeHeight),		Vector3(0.0f,					fTestLength,	ms_Tunables.m_HighCoverProbeHeight),		ms_fCapsuleRadius},
		{ Vector3(ms_fCenterCPWidth,	ms_Tunables.m_IdleYStartOffset,		ms_Tunables.m_HighCoverProbeHeight),		Vector3(fCenterCPWidth2,		fTestLength,	ms_Tunables.m_HighCoverProbeHeight),		ms_fCapsuleRadius},
		{ Vector3(ms_fOuterCPWidth,		ms_Tunables.m_IdleYStartOffset,		ms_Tunables.m_HighCoverProbeHeight),		Vector3(ms_fOuterCPWidth2,		fTestLength,	ms_Tunables.m_HighCoverProbeHeight),		ms_fCapsuleRadius},
		{ Vector3(0.0f,					0.0f,								ms_fExtraLowHeight),	Vector3(0.0f,					fTestLength,	ms_fExtraLowHeight),	ms_fExtraLowCapsuleRadius },
	};

	phIntersection aIntersections[iMaxShapeTests];
	phSegment aSegments[iMaxShapeTests];

	Mat34V testMtx;
	ComputeTestMatrix(pPed, vStartPos, fDir, testMtx);

	// get material flags to ignore
	//static phMaterialMgrGta::Id nIgnoreMaterialFlags = PGTAMATERIALMGR->GetPackedPolyFlagValue(POLYFLAG_STAIRS) | PGTAMATERIALMGR->GetPackedPolyFlagValue(POLYFLAG_NOT_COVER);

	bool bShouldDoBatchShapeTests = false;
	CVehicle* pCoverVehicle = GetCoverVehicle(*pPed);
	if (pCoverVehicle && pCoverVehicle->GetVehicleCoverBoundOffsetInfo())
	{
		if (pPed->GetCoverPoint())
		{
			bShouldDoBatchShapeTests = CTaskCover::IsPlayerPedInCoverAgainstVehicleDoor(*pPed, *pPed->GetCoverPoint());
		}
		
		if (!bShouldDoBatchShapeTests)
		{
			if (VehicleHasCoverBounds(*pCoverVehicle))
			{
				DoVehicleCoverBoundBoxTests(testMtx, *pCoverVehicle, iMaxShapeTests, 0.0f, shapeTestInfos, aIntersections, aSegments, apProbeResults, m_iActiveBoundIndex, pPed, false);
			}
			else
			{
				DoVehicleBoxTests(testMtx, *pCoverVehicle, iMaxShapeTests, 0.0f, shapeTestInfos, aIntersections, aSegments, apProbeResults);
				DetermineIfCoverShouldBeLow(testMtx, shapeTestInfos, aIntersections);
			}
		}
	}
	else
	{
		 bShouldDoBatchShapeTests = true;
	}
	
	if (bShouldDoBatchShapeTests)
	{
		DoBatchShapeTests(testMtx, overrideMainTestType, iMaxShapeTests, 0.0f, shapeTestInfos, aIntersections, aSegments, apProbeResults, fTestLength);
	}

	// Copy any collision results into the probe results
	for( s32 i = 0; i < LP_Max; i++ )
	{
		// Should have already set the probe results in DoVehicleBoxTests
		if (!pCoverVehicle || bShouldDoBatchShapeTests)
		{
			apProbeResults[i].m_bCollided = aIntersections[i].IsAHit();
		}
		if(apProbeResults[i].m_bCollided)
		{
			phInst* pHitInst = aIntersections[i].GetInstance();
			CEntity *pHitEntity = (CEntity *)CPhysics::GetEntityFromInst(pHitInst);
			const bool bUnableToTakeCoverOnDoor = pHitEntity && pHitEntity->GetIsTypeObject() && ((CObject*)pHitEntity)->IsADoor() && !pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED) && !pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED_BY_NETWORK);
#if HACK_RDR3
			// We want covers on quickly moving vehicles
			const bool bIsMovingTooQuickly = false;
#else
			bool bIsVehicleThatDoesntProvideCover = false;
			const bool bVehicleCanStandOn = CanPedBeInCoverOnEntity(*pPed, pHitEntity, bIsVehicleThatDoesntProvideCover);
			const bool bIsMovingTooQuickly = pHitEntity && (pHitEntity->GetIsPhysical() && static_cast<CPhysical*>(pHitEntity)->GetVelocity().Mag2() > rage::square(2.0f) ) && !bVehicleCanStandOn;
#endif
			const bool bFlaggedToNotProvideCover = (i != LP_LowCentre) && pHitEntity && pHitEntity->IsArchetypeSet() && pHitEntity->GetBaseModelInfo()->GetDoesNotProvidePlayerCover();
			if( bUnableToTakeCoverOnDoor || bIsMovingTooQuickly || bFlaggedToNotProvideCover || bIsVehicleThatDoesntProvideCover)
			{
				apProbeResults[i].m_bCollided = false;
			}
			else
			{
				apProbeResults[i].m_vCapsuleStart = aSegments[i].A;
				apProbeResults[i].m_pHitEntity = pHitEntity;
				apProbeResults[i].m_bCollidedWithFixed = pHitEntity && pHitEntity->IsBaseFlagSet(fwEntity::IS_FIXED);
				apProbeResults[i].m_vPosition = RCC_VECTOR3(aIntersections[i].GetPosition());
				apProbeResults[i].m_vNormal = RCC_VECTOR3(aIntersections[i].GetNormal());
				apProbeResults[i].m_bCollidedWithSeeThrough = PGTAMATERIALMGR->GetIsSeeThrough(aIntersections[i].GetMaterialId());
				apProbeResults[i].m_fDepth = (RCC_VECTOR3(aIntersections[i].GetPosition()).Dist(apProbeResults[i].m_vCapsuleStart)) + shapeTestInfos[i].vStart.y;				
				apProbeResults[i].m_bHitRoundCover = CheckForRoundCover( &aIntersections[i], apProbeResults[i].m_vRoundCoverCenter, apProbeResults[i].m_fRoundCoverRadius);
			}
		}

#if __DEV
		RenderCollisionResult(RCC_VEC3V(aSegments[i].A), RCC_VEC3V(aSegments[i].B), overrideMainTestType, apProbeResults, i, false);
#endif
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::CheckForCoverAndCalculateNormalWhenMoving(const CPed& ped,  ProbeResults* apProbeResults, Vector3& vPedPosition, Vector3& vNormal, Vector3& vCoverPosition, s32 iNumRequiredConcurrentCollisions, float fSearchDir)
{
	s32 iConcurrentIntersections = 0;
	s32 iNumCollisions = 0;
	Vector3 vNormalFromLowPosition(0.0f, 0.0f, 0.0f);
	Vector3 vNormalFromHighPosition(0.0f, 0.0f, 0.0f);
	s32 iMaxNumLowConcurrentIntersections = 0;
	s32 iMaxNumHighConcurrentIntersections = 0;
	Vector3 vNormalFromCollisionNormal(0.0f, 0.0f, 0.0f);
	vNormal.Zero();
	vCoverPosition.Zero();
	float fNearestCollision = 999.0f;

	float fLowDepth = 999.0f;
	float fMidDepth = 999.0f;
	float fHighDepth = 999.0f;

	// Removes edge results that are deeper than the central results
	RemoveFarEdgeResultsWhenMoving(apProbeResults);

	if (!ped.GetPlayerInfo()->IsRoundCover() && ms_Tunables.m_EnableConflictingNormalCollisionRemoval)
	{
		RemoveConflictingNormalResults(apProbeResults);
	}

	// To have cover there must be at least 2 concurrent intersections
	// The intersection positions are used to calculate a normal vector
	// To calculate the position, work out the average position of all collisions
	// Then pull that back to the distance of the closest collision
	FindConcurrentCollisionsWhenMoving(apProbeResults, vCoverPosition, iNumCollisions, fNearestCollision, vNormalFromCollisionNormal, fLowDepth, fMidDepth, fHighDepth, iMaxNumLowConcurrentIntersections, vNormalFromLowPosition, iMaxNumHighConcurrentIntersections, vNormalFromHighPosition);

	// If the collisions at the different heights seem to have detected a slope
	// Either rule out completely if a slope from the lowest detection
	// Or if a solid base is found ignore the highest collision results
	if( !DetectAndRemoveSlopes(fLowDepth, fMidDepth, fHighDepth, iMaxNumLowConcurrentIntersections, iMaxNumHighConcurrentIntersections, apProbeResults) )
	{
		return false;
	}

	// 	iConcurrentIntersections = MAX(iMaxNumLowConcurrentIntersections, iMaxNumHighConcurrentIntersections);
	// 	if( iMaxNumLowConcurrentIntersections > 1 )
	// 	{
	// 		vNormal = vNormalFromLowPosition;
	// 	}
	// 	else if( iMaxNumHighConcurrentIntersections > 1 )
	// 	{
	// 		vNormal = vNormalFromHighPosition;
	// 	}
	iConcurrentIntersections = iMaxNumLowConcurrentIntersections;
	if( iMaxNumLowConcurrentIntersections > 0 )
	{
		vNormal = vNormalFromLowPosition;
	}

#if __DEV
	if (CCoverDebug::ms_Tunables.m_RenderNormals)
	{
		RenderCollisionNormal(RCC_VEC3V(apProbeResults[LP_FrontLowC].m_vPosition), RCC_VEC3V(vNormalFromLowPosition), true);
		RenderCollisionNormal(RCC_VEC3V(apProbeResults[LP_FrontHighC].m_vPosition), RCC_VEC3V(vNormalFromHighPosition), false);
	}
#endif

	//Round cover, use round cover normal.
	if (ped.IsLocalPlayer() && ped.GetPlayerInfo()->IsRoundCover())
	{
		vNormal = ProcessRoundCoverDirection(&ped, ped.GetPlayerInfo()->GetRoundCoverCenter());
		vNormal.Negate();	
	} 
	else
	{
		// Rotate the position normal to be away from the collisions
		vNormal.z = 0.0f;
		vNormal.RotateZ(HALF_PI);
		vNormal.Normalize();
	}

#if __DEV
	if (CCoverDebug::ms_Tunables.m_RenderNormals)
	{
		Vec3V vDebugPos = RCC_VEC3V(apProbeResults[LP_FrontHighC].m_vPosition);
		Vec3V vDebugNormal = RCC_VEC3V(vNormal);

		RenderCoverNormal(vDebugPos, vDebugNormal, false);

		if( iMaxNumLowConcurrentIntersections > 0 )
		{
			vDebugPos = RCC_VEC3V(apProbeResults[LP_FrontLowC].m_vPosition);
		}
		RenderCoverNormal(vDebugPos, vDebugNormal, true);
	}
#endif

	if( iConcurrentIntersections >= iNumRequiredConcurrentCollisions )
	{
		float fDistanceFromCover = 0.0f;
		// Pull the average collision position back towards the player

		// Distance mover should be away from the wall
		fDistanceFromCover = (iMaxNumHighConcurrentIntersections > 1) ? ms_Tunables.m_DistanceToWallStanding : ms_Tunables.m_DistanceToWallCrouching;



		Assert(iNumCollisions>0);
		vCoverPosition.Scale( 1.0f / iNumCollisions );
		const float fDistanceToCover = vCoverPosition.Dist2(vPedPosition);
		Vector3 vSearchDir(0.0f, 1.0f, 0.0f);
		vSearchDir.RotateZ(fSearchDir);


		float fNearestCollToNewCoverPoint = 999.0f;
		Vector3 vInverseNormal = -vNormal;
		for( s32 i = 0; i < LP_Max; i++ )
		{
			if( apProbeResults[i].m_bCollided )
			{
				fNearestCollToNewCoverPoint = MIN(fNearestCollToNewCoverPoint, vInverseNormal.Dot(apProbeResults[i].m_vPosition - vCoverPosition));
			}
		}

		if( ( fDistanceToCover > rage::square(DISTANCE_TO_ONLY_ACCEPT_COVER_IN_DIRECTION ) ) && (vNormal.Dot(vSearchDir) > COVER_DIRECTION_TOLERANCE ))
		{
			return false;
		}

		static bool RENDER_COMPUTED_COVER_POSITION = true;
		if (RENDER_COMPUTED_COVER_POSITION)
		{
#if __BANK
			static u32 OLD_COVER_POSITION = ATSTRINGHASH("OLD_COVER_POSITION", 0x17243458);
			CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(vCoverPosition), 0.05f, Color_yellow, OLD_COVER_POSITION);
#endif	//__BANK
		}

		if((fDistanceToCover > rage::square(DISTANCE_TO_EVALUATE_COVER_FROM_CURRENT_POS)))
		{
			vCoverPosition += vNormal * (fDistanceFromCover-fNearestCollToNewCoverPoint);
		}
		else
		{
			vCoverPosition = (vPedPosition-ZAXIS) + ( -vNormal * ( fNearestCollision - fDistanceFromCover ));
		}

		if (RENDER_COMPUTED_COVER_POSITION)
		{
#if __BANK
			static u32 NEW_COVER_POSITION = ATSTRINGHASH("NEW_COVER_POSITION", 0x2F8B9E54);
			CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(vCoverPosition), 0.05f, Color_green, NEW_COVER_POSITION);
#endif	//__BANK
		}

		Vector3 vTestPos = vCoverPosition;
		if( CPedPlacement::FindZCoorForPed(BOTTOM_SURFACE,&vTestPos, NULL, NULL, NULL, 0.5f, 99.5f, ArchetypeFlags::GTA_ALL_MAP_TYPES|ArchetypeFlags::GTA_VEHICLE_TYPE|ArchetypeFlags::GTA_OBJECT_TYPE) )
		{
			vCoverPosition = vTestPos-ZAXIS;
		}
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::CheckForCoverAndCalculateNormal(const CPed& ped, ProbeResults* apProbeResults, Vector3& vPedPosition, Vector3& vNormal, Vector3& vCoverPosition, s32 iNumRequiredConcurrentCollisions, float fSearchDir, bool bCalledWhilstAlreadyInCover, bool bIsCoverToCover, bool bIsFinalCover, Vector3* pRoundCoverCenter, float* pfRoundCoverRadius )
{
	s32 iConcurrentIntersections = 0;
	s32 iNumCollisions = 0;
	Vector3 vNormalFromLowPosition(0.0f, 0.0f, 0.0f);
	Vector3 vNormalFromHighPosition(0.0f, 0.0f, 0.0f);
	s32 iMaxNumLowConcurrentIntersections = 0;
	s32 iMaxNumHighConcurrentIntersections = 0;
	Vector3 vNormalFromCollisionNormal(0.0f, 0.0f, 0.0f);
	vNormal.Zero();
	vCoverPosition.Zero();
	float fNearestCollision = 999.0f;

	float fLowDepth = 999.0f;
	float fMidDepth = 999.0f;
	float fHighDepth = 999.0f;

	// Removes edge results that are deeper than the central results
	const bool bCheckForCorners = !bCalledWhilstAlreadyInCover || bIsCoverToCover;
	bool bAlwaysReposition = RemoveFarEdgeResults(apProbeResults, bCheckForCorners);

	// Allow for idle cover checks
	if (!ped.GetPlayerInfo()->IsRoundCover())
	{
		RemoveConflictingNormalResults(apProbeResults);
	}

	// To have cover there must be at least 2 concurrent intersections
	// The intersection positions are used to calculate a normal vector
	// To calculate the position, work out the average position of all collisions
	// Then pull that back to the distance of the closest collision
	FindConcurrentCollisions(apProbeResults, vCoverPosition, iNumCollisions, fNearestCollision, vNormalFromCollisionNormal, fLowDepth, fMidDepth, fHighDepth, iMaxNumLowConcurrentIntersections, vNormalFromLowPosition, iMaxNumHighConcurrentIntersections, vNormalFromHighPosition);


	iConcurrentIntersections = iMaxNumLowConcurrentIntersections;
	if( iMaxNumLowConcurrentIntersections > 0 )
	{
		TUNE_GROUP_BOOL(COVER_TUNE, INVALID_COVER_DUE_TO_BAD_NORMAL, true);
		if (INVALID_COVER_DUE_TO_BAD_NORMAL && vNormalFromLowPosition.IsClose(VEC3_ZERO, SMALL_FLOAT))
		{
			aiDisplayf("Frame %i: Cover check failed as normal was invalid, iMaxNumLowConcurrentIntersections %i", fwTimer::GetFrameCount(), iMaxNumLowConcurrentIntersections);
			return false;
		}
		vNormal = vNormalFromLowPosition;
	}

#if __DEV
	if (CCoverDebug::ms_Tunables.m_RenderNormals)
	{
		// The normals are computed from the collision positions
		Vec3V vDebugNormalPos = RCC_VEC3V(apProbeResults[LP_FrontLowC].m_vPosition);
		Vec3V vDebugNormal = vDebugNormalPos + RCC_VEC3V(vNormalFromLowPosition);
		static u32 LOW_COVER_COLLISION_KEY = ATSTRINGHASH("LOW_COVER_COLLISION_KEY", 0xFF23F93D);
		CCoverDebug::ms_debugDraw.AddArrow(vDebugNormalPos, vDebugNormal, 0.25f, Color_red, 500, LOW_COVER_COLLISION_KEY);
		vDebugNormalPos = RCC_VEC3V(apProbeResults[LP_FrontHighC].m_vPosition);
		vDebugNormal = vDebugNormalPos + RCC_VEC3V(vNormalFromHighPosition);
		static u32 HIGH_COVER_COLLISION_KEY = ATSTRINGHASH("HIGH_COVER_COLLISION_KEY", 0x13887EFD);
		CCoverDebug::ms_debugDraw.AddArrow(vDebugNormalPos, vDebugNormal, 0.25f, Color_red, 500, HIGH_COVER_COLLISION_KEY);
	}
#endif

	static s32 iLastProbe = LP_Max;
	bool bIsRoundCover = false;
	//Round cover, use round cover normal.
	if (ped.IsLocalPlayer() && ped.GetPlayerInfo()->IsRoundCover())
	{
		vNormal = ProcessRoundCoverDirection(&ped, ped.GetPlayerInfo()->GetRoundCoverCenter());
		vNormal.Negate();
		if (iNumCollisions>0)
		{
			float storeZ = vCoverPosition.z/iNumCollisions;
			vCoverPosition = ped.GetPlayerInfo()->GetRoundCoverCenter() + (vNormal * ped.GetPlayerInfo()->GetRoundCoverRadius());
			vCoverPosition.z = storeZ;
			iNumCollisions = 1;
		}		
		bIsRoundCover = true;
	}
	else if (iNumCollisions > 0)
	{
		if (ENABLE_ROUND_COVER)
		{
			for( s32 i = 0; i < iLastProbe; i++ )
			{
				if( apProbeResults[i].m_bCollided )
				{
					if (apProbeResults[i].m_bHitRoundCover)
					{
						//compare with LowCentre probe
						static dev_float sf_MinRoundCoverDelta = 0.5f;
						if (fabs(apProbeResults[i].m_fDepth - fLowDepth) < sf_MinRoundCoverDelta)
						{
							vNormal = ProcessRoundCoverDirection(&ped, apProbeResults[i].m_vRoundCoverCenter, &apProbeResults[i].m_vPosition);
							vNormal.Negate();
							bIsRoundCover = true;
							iNumCollisions = 1;
							vCoverPosition = apProbeResults[i].m_vPosition;
							if (pRoundCoverCenter)
							{
								*pRoundCoverCenter = apProbeResults[i].m_vRoundCoverCenter;
								*pfRoundCoverRadius = apProbeResults[i].m_fRoundCoverRadius;
							}
							break;
						}						
					}
				}
			}
		}

		if (!bIsRoundCover)
		{
			// Rotate the position normal to be away from the collisions
			vNormal.z = 0.0f;
			vNormal.RotateZ(HALF_PI);
			vNormal.Normalize();
		}		
	}

	// If the collisions at the different heights seem to have detected a slope
	// Either rule out completely if a slope from the lowest detection
	// Or if a solid base is found ignore the highest collision results
	if( !DetectAndRemoveSlopes(fLowDepth, fMidDepth, fHighDepth, iMaxNumLowConcurrentIntersections, iMaxNumHighConcurrentIntersections, apProbeResults) )
	{
		return false;
	}

#if __DEV
	if (CCoverDebug::ms_Tunables.m_RenderNormals)
	{
		Vec3V vDebugPos = RCC_VEC3V(apProbeResults[LP_FrontHighC].m_vPosition);
		Vec3V vDebugNormal = RCC_VEC3V(vNormal);

		static u32 HIGH_COVER_NORMAL_KEY = ATSTRINGHASH("HIGH_COVER_NORMAL_KEY", 0x7A19C855);
		CCoverDebug::ms_debugDraw.AddArrow(vDebugPos, vDebugPos + vDebugNormal, 0.25f, Color_orange, HIGH_COVER_NORMAL_KEY);

		if( iMaxNumLowConcurrentIntersections > 0 )
		{
			vDebugPos = RCC_VEC3V(apProbeResults[LP_FrontLowC].m_vPosition);
		}
		vDebugNormal += vDebugPos;

		static u32 LOW_COVER_NORMAL_KEY = ATSTRINGHASH("LOW_COVER_NORMAL_KEY", 0xBA113395);
		CCoverDebug::ms_debugDraw.AddArrow(vDebugPos, vDebugNormal, 0.25f, Color_orange, LOW_COVER_NORMAL_KEY);
	}
#endif

	if( iConcurrentIntersections >= iNumRequiredConcurrentCollisions  || (bIsRoundCover && iNumCollisions>0))
	{
		float fDistanceFromCover = 0.0f;
		// Pull the average collision position back towards the player

		// Distance mover should be away from the wall
		fDistanceFromCover = (iMaxNumHighConcurrentIntersections > 1) ? CDynamicCoverHelper::ms_Tunables.m_DistanceToWallStanding : CDynamicCoverHelper::ms_Tunables.m_DistanceToWallCrouching;

		Assert(iNumCollisions>0);
		vCoverPosition.Scale( 1.0f / iNumCollisions );
		const float fDistanceToCover = vCoverPosition.Dist2(vPedPosition);
		Vector3 vSearchDir(0.0f, 1.0f, 0.0f);
		vSearchDir.RotateZ(fSearchDir);

		float fNearestCollToNewCoverPoint = 999.0f;
		Vector3 vInverseNormal = -vNormal;

#if __BANK
		CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(vCoverPosition), 0.025f, Color_red, 1000);
		Vector3 vEnd = vCoverPosition + vInverseNormal;
		CCoverDebug::ms_debugDraw.AddArrow(RCC_VEC3V(vCoverPosition), RCC_VEC3V(vEnd), 0.05f, Color_red, 1000);
#endif

		for( s32 i = 0; i < iLastProbe; i++ )
		{
			if( apProbeResults[i].m_bCollided  && ((i >= LP_FrontLowL && i <= LP_FrontLowR) || (i >= LP_FrontHighL && i <= LP_FrontHighR) ))
			{
				fNearestCollToNewCoverPoint = MIN(fNearestCollToNewCoverPoint, vInverseNormal.Dot(apProbeResults[i].m_vPosition - vCoverPosition));
			}
		}

		if( ( fDistanceToCover > rage::square(DISTANCE_TO_ONLY_ACCEPT_COVER_IN_DIRECTION ) ) && (vNormal.Dot(vSearchDir) > COVER_DIRECTION_TOLERANCE ))
		{
			return false;
		}

		const float fPedRadius = GetCapsuleRadiusFromPed(ped);

		if( bIsFinalCover || bAlwaysReposition || (fDistanceToCover > rage::square(DISTANCE_TO_EVALUATE_COVER_FROM_CURRENT_POS)) )
		{
			if (bIsFinalCover)
			{
				const float fAdjustDist = (fPedRadius + (fDistanceFromCover-fNearestCollToNewCoverPoint));
				vCoverPosition += vNormal * fAdjustDist;
			}
			else
			{
				const float fAdjustDist = (fDistanceFromCover-fNearestCollToNewCoverPoint);
				vCoverPosition += vNormal * fAdjustDist;
			}
		}
		else
		{
			vCoverPosition = (vPedPosition-ZAXIS) + ( -vNormal * ( fNearestCollision - fDistanceFromCover ));
		}		

#if __BANK
		CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(vCoverPosition), 0.025f, Color_green, 1000);
#endif

		Vector3 vTestPos = vCoverPosition;
		// Push the test out if for the initial test
		if (!bIsFinalCover)
		{
			vTestPos += fPedRadius * vNormal;
		}

		const float fPedRootToGroundOffset = GetPedRootToGroundOffsetFromPed(ped);

		if( CPedPlacement::FindZCoorForPed(BOTTOM_SURFACE,&vTestPos, NULL, NULL, NULL, 0.5f, 99.5f, ArchetypeFlags::GTA_ALL_MAP_TYPES|ArchetypeFlags::GTA_VEHICLE_TYPE|ArchetypeFlags::GTA_OBJECT_TYPE) )
		{
			TUNE_GROUP_BOOL(COVER_TUNE, IGNORE_HEIGHT_TOLERANCE, false);
			const float fPedZPosition = ped.GetTransform().GetPosition().GetZf();
			if (IGNORE_HEIGHT_TOLERANCE || Abs(fPedZPosition - vTestPos.z) < 3.0f)
			{
				const float fTestZPosWithoutPedOffset = vTestPos.z - fPedRootToGroundOffset;
#if __BANK
				CCoverDebug::ms_debugDraw.AddLine(RCC_VEC3V(vCoverPosition), RCC_VEC3V(vTestPos), Color_purple, 1000);
				CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(vTestPos), 0.025f, Color_blue, 1000);
#endif
				vCoverPosition.z = fTestZPosWithoutPedOffset;
#if __BANK
				CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(vCoverPosition), 0.025f, Color_red, 1000);
#endif

				if (bIsFinalCover && Abs(vCoverPosition.z + fPedRootToGroundOffset - fPedZPosition) > ms_Tunables.m_MaxZDiffBetweenPedPos)
				{
					// Allow a larger tolerance if we hit stairs
					bool bHitStairs = false;
					Vector3 vStart = vCoverPosition + Vector3(0.0f, 0.0f, 0.2f);
					Vector3 vEnd  = vCoverPosition + Vector3(0.0f, 0.0f, -0.2f); 
					Vector3 vUnused;
					DoLineProbeTest(vStart, vEnd, vUnused, NULL, &bHitStairs);
					if (!bHitStairs)
					{
						return false;
					}
				}
			}
		}
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::RemoveFarEdgeResults( ProbeResults* apProbeResults, bool bCheckForCorners )
{
	// The direction of the previous edge
	Vec3V vPreviousEdgeDirection(V_ZERO);
	// The previously used collision position
	Vec3V vPrevPos(V_ZERO);
	// Do we have a valid previous collition position
	bool bValidPreviousPoint = false;
	// Do we have a previous edge direction
	bool bHasPreviousEdgeDirection = false;

	// We're using 5 probes per height, which gives a maximum of 4 edges
	static const u32 MAX_NUM_EDGES = ((ILP_Max - 1) / 2) - 1;
	// We can have a turn point between 2 edges, so we have a maximum of 3 turn points
	static const u32 MAX_NUM_TURN_POINTS = MAX_NUM_EDGES -1;

	// Store some turn point information, we store the probe index the turn occurs at,
	// the number of concurrent edges before and after the turn point
	struct sTurnPointInfo
	{
		sTurnPointInfo()
			: iTurnPointIndex(-1)
			, iNumConcurrentEdgesBeforeTurn(0)
			, iNumConcurrentEdgesAfterTurn(0)
		{

		}

		s32 iTurnPointIndex;
		s32 iNumConcurrentEdgesAfterTurn;
		s32 iNumConcurrentEdgesBeforeTurn;
		bool bRemovePriorTurnpoint;
		bool bRemoveAfterTurnpoint;
	};

	// How many turn points we've found so far
	s32 iNumTurnPoints = 0;

	// Array of turn point infos
	sTurnPointInfo aTurnPointInfos[MAX_NUM_TURN_POINTS];

	// Should we reposition the cover search position for the next set of tests?
	bool bRepositionCoverpoint = false;

	// Should we remove points before or after the best turn point
	bool bRemovePriorTurnpoint = false;
	bool bRemoveAfterTurnpoint = false;

	// Look for corner detection, ruling out cases where we're at a corner of about 45o
	if (bCheckForCorners)
	{
		for (s32 i = ILP_LeftLow; i <= ILP_RightLow; i++)
		{
			// If we have a collision
			if (apProbeResults[i].m_bCollided)
			{
				// See if this is the first collision
				if (!bValidPreviousPoint)
				{
					vPrevPos = RCC_VEC3V(apProbeResults[i].m_vPosition);
					bValidPreviousPoint = true;
				}
				// If its not the first, check if we have computed a previous edge direction
				else if (!bHasPreviousEdgeDirection)
				{
#if DEBUG_DRAW
					RenderCoverEdge(RCC_VEC3V(apProbeResults[i].m_vPosition), vPrevPos, i);
#endif // DEBUG_DRAW

					// Compute edge direction and update the previous position, we now have one concurrent edge before the next turn point
					vPreviousEdgeDirection = RCC_VEC3V(apProbeResults[i].m_vPosition) - vPrevPos;
					vPreviousEdgeDirection.SetZ(ScalarV(V_ZERO));
					vPreviousEdgeDirection = Normalize(vPreviousEdgeDirection);
					bHasPreviousEdgeDirection = true;
					vPrevPos = RCC_VEC3V(apProbeResults[i].m_vPosition);
					aTurnPointInfos[iNumTurnPoints].iNumConcurrentEdgesBeforeTurn = 1;
				}
				else
				{
					// Compute the new edge direction, we should already have a previous edge direction, so check for a turn
					Vec3V vThisEdgeDirection = RCC_VEC3V(apProbeResults[i].m_vPosition) - vPrevPos;
					vThisEdgeDirection.SetZ(ScalarV(V_ZERO));
					vThisEdgeDirection = Normalize(vThisEdgeDirection);
					ScalarV fDot = Dot(vThisEdgeDirection, vPreviousEdgeDirection);
					const ScalarV TURN_ANGLE_COSINE = LoadScalar32IntoScalarV(0.707f);

					if (IsLessThanAll(fDot, ScalarV(TURN_ANGLE_COSINE)))	// > 45 degrees
					{
#if DEBUG_DRAW
						RenderCoverEdge(RCC_VEC3V(apProbeResults[i].m_vPosition), vPrevPos, i);
#endif // DEBUG_DRAW
						// We've found another turn point, store the probe index, increase the count of edges after then current turn
						// and the number of turn points found so far
						aTurnPointInfos[iNumTurnPoints].iTurnPointIndex = i - 1;
						++aTurnPointInfos[iNumTurnPoints].iNumConcurrentEdgesAfterTurn;
						// Set the number of edges before the turn from the previous turn point info if we have more than one
						if (iNumTurnPoints > 0)
						{
							aTurnPointInfos[iNumTurnPoints].iNumConcurrentEdgesBeforeTurn = aTurnPointInfos[iNumTurnPoints-1].iNumConcurrentEdgesAfterTurn;
						}
						++iNumTurnPoints;
						
					}
					else // <= 45 degrees
					{
#if DEBUG_DRAW
						RenderCoverEdge(RCC_VEC3V(apProbeResults[i].m_vPosition), vPrevPos, i);
#endif // DEBUG_DRAW

						// Increase the number of concurrent edges after the previous turn point if we have more than one turn point
						if (iNumTurnPoints > 0)
						{
							++aTurnPointInfos[iNumTurnPoints-1].iNumConcurrentEdgesAfterTurn;
						}
						
						// Increase the number of concurrent edges for the current turn point (which may not exist)
						++aTurnPointInfos[iNumTurnPoints].iNumConcurrentEdgesBeforeTurn;	
					}

					vPreviousEdgeDirection = vThisEdgeDirection;
					vPrevPos = RCC_VEC3V(apProbeResults[i].m_vPosition);
				}
			}
		}

#if DEBUG_DRAW
		// Render the turn points
		for (s32 i=0; i<iNumTurnPoints; ++i)
		{
			if (aTurnPointInfos[i].iTurnPointIndex != -1)
			{
				RenderCoverTurnPoint(apProbeResults, i, aTurnPointInfos[i].iTurnPointIndex, aTurnPointInfos[i].iNumConcurrentEdgesBeforeTurn, aTurnPointInfos[i].iNumConcurrentEdgesAfterTurn);
			}
		}
#endif // DEBUG_DRAW

		// Determine the turn point with the most concurrent edges
		s32 iBestTurnPointInfo = 0;
		s32 iMaxNumConcurrentEdges = rage::Max(aTurnPointInfos[iBestTurnPointInfo].iNumConcurrentEdgesBeforeTurn, aTurnPointInfos[iBestTurnPointInfo].iNumConcurrentEdgesAfterTurn);
		
		for (s32 i=1; i<iNumTurnPoints; ++i)
		{
			if (aTurnPointInfos[i].iTurnPointIndex != -1)
			{
				s32 iNumConcurrentEdgesAfterTurn = aTurnPointInfos[i].iNumConcurrentEdgesAfterTurn;
				if ((iNumConcurrentEdgesAfterTurn > iMaxNumConcurrentEdges) || 
					(iNumConcurrentEdgesAfterTurn > iMaxNumConcurrentEdges))
				{
					iBestTurnPointInfo = i;
					iMaxNumConcurrentEdges = rage::Max(aTurnPointInfos[iBestTurnPointInfo].iNumConcurrentEdgesBeforeTurn, aTurnPointInfos[iBestTurnPointInfo].iNumConcurrentEdgesAfterTurn);
				}
			}
		}

		// If we have a valid best turn point, determine whether to remove points after or prior to it
		// We will alter the next set of tests as a result of removing these points
		if (aTurnPointInfos[iBestTurnPointInfo].iTurnPointIndex != -1)
		{
			if ((aTurnPointInfos[iBestTurnPointInfo].iNumConcurrentEdgesBeforeTurn > aTurnPointInfos[iBestTurnPointInfo].iNumConcurrentEdgesAfterTurn) || 
				(aTurnPointInfos[iBestTurnPointInfo].iNumConcurrentEdgesBeforeTurn >= 2))
			{
				bRepositionCoverpoint = true;
				bRemoveAfterTurnpoint = true;
			}
			else if ((aTurnPointInfos[iBestTurnPointInfo].iNumConcurrentEdgesAfterTurn >aTurnPointInfos[iBestTurnPointInfo].iNumConcurrentEdgesBeforeTurn))
			{
				bRepositionCoverpoint = true;
				bRemovePriorTurnpoint = true;
			}

			// Remove all points before or after the turn point, both low and high
			for (s32 i = ILP_LeftLow; i <= LP_RightLow; i++ )
			{
				if( bRemoveAfterTurnpoint && i > aTurnPointInfos[iBestTurnPointInfo].iTurnPointIndex)
				{
					apProbeResults[i].m_bCollided = false;
					apProbeResults[i+5].m_bCollided = false;
				}
				else if( bRemovePriorTurnpoint && i < aTurnPointInfos[iBestTurnPointInfo].iTurnPointIndex)
				{
					apProbeResults[i].m_bCollided = false;
					apProbeResults[i+5].m_bCollided = false;
				}
			}
		}
	}

	float fMaxCentralDepth = 0.0f;
	float fMinCentralDepth = 9999.0f;
	s32 iNumCentralPoints = 0;

	// Keep a note of the number of central collisions
	for( s32 i = LP_FrontLowL; i <= LP_FrontLowR; i++ )
	{
		if( apProbeResults[i].m_bCollided )
		{
			++iNumCentralPoints;
			fMaxCentralDepth = MAX(fMaxCentralDepth, apProbeResults[i].m_fDepth);
			fMinCentralDepth = MIN(fMinCentralDepth, apProbeResults[i].m_fDepth);
		}
	}

	// Rule out either extent if the 3 central positions returned valid collision at a different average depth
	static float fEdgeDepthToIgnorePoint = 0.3f;

	if( iNumCentralPoints == 3 && ( ( fMaxCentralDepth - fMinCentralDepth ) < fEdgeDepthToIgnorePoint ) )
	{
		if( apProbeResults[LP_LeftLow].m_bCollided )
		{
			float fDiff = apProbeResults[LP_LeftLow].m_fDepth - fMaxCentralDepth;
			if( fabs(fDiff) > fEdgeDepthToIgnorePoint )
			{
				apProbeResults[LP_LeftLow].m_bCollided = false;
				apProbeResults[LP_LeftHigh].m_bCollided = false;
			}
		}
		if( apProbeResults[LP_RightLow].m_bCollided )
		{
			float fDiff = apProbeResults[LP_RightLow].m_fDepth - fMaxCentralDepth;
			if( fabs(fDiff) > fEdgeDepthToIgnorePoint )
			{
				apProbeResults[LP_RightLow].m_bCollided = false;
				apProbeResults[LP_RightHigh].m_bCollided = false;
			}
		}
	}

#if __BANK
	// Clear debug rendering
	for( s32 i = 0; i < LP_Max; i++ )
	{
		char szText[128];
		if(!apProbeResults[i].m_bCollided)
		{
			formatf(szText, "COLLISION_SPHERE_%u", i);
			CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(apProbeResults[i].m_vPosition), 0.05f, Color_red, 1000, atStringHash(szText));
		}
	}
#endif
	return bRepositionCoverpoint;
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::RemoveFarEdgeResultsWhenMoving(ProbeResults* apProbeResults)
{

	//Remove sudden depth changes from central probes
	float fPrimaryDepth = 0;
	float fSecondaryDepth = 0;
	s32 iNumPrimaryDepths = 0;
	s32 iNumSecondaryDepths = 0;
	// Find primary and secondary depths
	for (s32 i = MLP_CenterBackwardLow; i <= MLP_CenterForwardLow; i++)
	{		
		if (apProbeResults[i].m_bCollided)
		{
			if (!IsOutsideDepthRange(apProbeResults[i].m_fDepth, fPrimaryDepth, iNumPrimaryDepths))
			{
				if (iNumPrimaryDepths == 0)
				{
					fPrimaryDepth = apProbeResults[i].m_fDepth;
				}
				++iNumPrimaryDepths;
			}
			else if (!IsOutsideDepthRange(apProbeResults[i].m_fDepth, fSecondaryDepth, iNumSecondaryDepths))
			{
				if (iNumSecondaryDepths == 0)
				{
					fSecondaryDepth = apProbeResults[i].m_fDepth;
				}
				++iNumSecondaryDepths;
			}
		}
	}

	// If we have two very different depths, invalidate the one we have least of
	if (iNumPrimaryDepths > 0 && iNumSecondaryDepths > 0)
	{
		for (s32 i = MLP_CenterBackwardLow; i <= MLP_CenterForwardLow; i++)
		{
			const float fDominantDepth = iNumPrimaryDepths >= iNumSecondaryDepths ? fPrimaryDepth : fSecondaryDepth;
			if (apProbeResults[i].m_bCollided)
			{

				if (IsOutsideDepthRange(apProbeResults[i].m_fDepth, fDominantDepth, 1))
				{
					apProbeResults[i].m_bCollided = false;
					apProbeResults[i].m_bRejectedBecauseOfAngularCondition = true;
				}
			}
		}
	}


	float fMaxCentralDepth = 0.0f;
	float fMinCentralDepth = 9999.0f;
	s32 iNumCentralPoints = 0;

	// Keep a note of the number of central collisions
	for( s32 i = MLP_CenterBackwardLow; i <= MLP_CenterForwardLow; i++ )
	{
		if( apProbeResults[i].m_bCollided )
		{
			++iNumCentralPoints;
			fMaxCentralDepth = MAX(fMaxCentralDepth, apProbeResults[i].m_fDepth);
			fMinCentralDepth = MIN(fMinCentralDepth, apProbeResults[i].m_fDepth);
		}
	}

	// Rule out either extent if the 3 central positions returned valid collision at a different average depth
	static float fEdgeDepthToIgnorePoint = 0.3f;
	if( iNumCentralPoints == 3 && ( ( fMaxCentralDepth - fMinCentralDepth ) < fEdgeDepthToIgnorePoint ) )
	{
		if( apProbeResults[MLP_InnerForwardLow].m_bCollided )
		{
			float fDiff = apProbeResults[MLP_InnerForwardLow].m_fDepth - fMaxCentralDepth;
			if( fabs(fDiff) > fEdgeDepthToIgnorePoint )
			{
				apProbeResults[MLP_InnerForwardLow].m_bCollided = false;
				apProbeResults[MLP_InnerForwardHigh].m_bCollided = false;
			}
		}
		if( apProbeResults[MLP_OuterForwardLow].m_bCollided )
		{
			float fDiff = apProbeResults[MLP_OuterForwardLow].m_fDepth - fMaxCentralDepth;
			if( fabs(fDiff) > fEdgeDepthToIgnorePoint )
			{
				apProbeResults[MLP_OuterForwardLow].m_bCollided = false;
				apProbeResults[MLP_OuterForwardHigh].m_bCollided = false;
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::IsOutsideDepthRange(const float& fDepth, const float& fOtherDepth, s32 iNumDepths)
{
	if (iNumDepths == 0)
	{
		return false;
	}

	TUNE_GROUP_FLOAT(COVER_TUNE, DEPTH_TOLERANCE, 0.25f, 0.0f, 10.0f, 0.01f);
	
	if (fabs(fOtherDepth - fDepth) > DEPTH_TOLERANCE)
	{
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::RemoveConflictingNormalResults(ProbeResults* apProbeResults)
{
	Vector3 vPrimaryNorm(Vector3::ZeroType);
	Vector3 vSecondaryNorm(Vector3::ZeroType);
	s32 iNumPrimaryNormals = 0;
	s32 iNumSecondaryNormals = 0;

	// Find primary and secondary normals
	for (s32 i = MLP_CenterBackwardLow; i <= MLP_OuterForwardHigh; i++)
	{
		apProbeResults[i].m_bRejectedBecauseOfAngularCondition = false;
		if (apProbeResults[i].m_bCollided)
		{
			if (!IsOutsideAngularRange(apProbeResults[i].m_vNormal, vPrimaryNorm, iNumPrimaryNormals))
			{
				if (iNumPrimaryNormals == 0)
				{
					vPrimaryNorm = apProbeResults[i].m_vNormal;
				}
				++iNumPrimaryNormals;
			}
			else if (!IsOutsideAngularRange(apProbeResults[i].m_vNormal, vSecondaryNorm, iNumSecondaryNormals))
			{
				if (iNumSecondaryNormals == 0)
				{
					vSecondaryNorm = apProbeResults[i].m_vNormal;
				}
				++iNumSecondaryNormals;
			}
		}
	}

	// If we have two very different normals, invalidate the ones we have least of
	if (iNumPrimaryNormals > 0 && iNumSecondaryNormals > 0)
	{
		const Vector3 vDominantNormal = iNumPrimaryNormals >= iNumSecondaryNormals ? vPrimaryNorm : vSecondaryNorm;
		for (s32 i = MLP_CenterBackwardLow; i <= MLP_OuterForwardHigh; i++)
		{
			if (apProbeResults[i].m_bCollided)
			{
				if (IsOutsideAngularRange(apProbeResults[i].m_vNormal, vDominantNormal, 1))
				{
					apProbeResults[i].m_bCollided = false;
					apProbeResults[i].m_bRejectedBecauseOfAngularCondition = true;
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::IsOutsideAngularRange(const Vector3& vNormal, const Vector3& vOtherNormal, s32 iNumNormals)
{
	if (iNumNormals == 0)
	{
		return false;
	}

	TUNE_GROUP_FLOAT(COVER_TUNE, NORM_DOT_TOLERANCE, 0.707f, -1.0f, 1.0f, 0.001f);
	const float fNormDot = vNormal.Dot(vOtherNormal);
	if (fNormDot < NORM_DOT_TOLERANCE)
	{
		return true;
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

float CDynamicCoverHelper::GetCapsuleRadiusFromPed(const CPed& ped) const
{
	if (ped.GetCapsuleInfo() && ped.GetCapsuleInfo()->GetBipedCapsuleInfo())
	{
		if (ped.GetIsCrouching())
		{
			return ped.GetCapsuleInfo()->GetBipedCapsuleInfo()->GetRadius();
		}
		else
		{
			return ped.GetCapsuleInfo()->GetBipedCapsuleInfo()->GetRadiusInCover();
		}
	}
	return 0.25f;
}

////////////////////////////////////////////////////////////////////////////////

float CDynamicCoverHelper::GetPedRootToGroundOffsetFromPed(const CPed& ped) const
{
	if (ped.GetCapsuleInfo() && ped.GetCapsuleInfo()->GetBipedCapsuleInfo())
	{
		return ped.GetCapsuleInfo()->GetBipedCapsuleInfo()->GetGroundToRootOffset();
	}
	return 1.0f;
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::FindConcurrentCollisionsWhenMoving( ProbeResults* apProbeResults, 
								   Vector3 &vCoverPosition, 
								   s32 &iNumCollisions, 
								   float &fNearestCollision, 
								   Vector3 &vNormalFromCollisionNormal,
								   float &fLowDepth, 
								   float &fMidDepth, 
								   float &fHighDepth, 
								   s32 &iMaxNumLowConcurrentIntersections, 
								   Vector3 &vNormalFromLowPosition, 
								   s32 &iMaxNumHighConcurrentIntersections, 
								   Vector3 &vNormalFromHighPosition )
{
	s32 iNumLowConcurrentIntersections = 0;
	s32 iNumHighConcurrentIntersections = 0;
	s32 iLastValidCollision = -1;
	for( s32 i = MLP_CenterBackwardLow; i < MLP_Max; i++ )
	{
		if( apProbeResults[i].m_bCollided )
		{
			float fDist = apProbeResults[i].m_vCapsuleStart.Dist(apProbeResults[i].m_vPosition);
			fNearestCollision = MIN(fDist+ms_fOuterYOffset, fNearestCollision);

			vNormalFromCollisionNormal += apProbeResults[i].m_vNormal;

			if(i <= MLP_OuterForwardLow)
			{
				vCoverPosition += apProbeResults[i].m_vPosition;
				++iNumCollisions;
			}

			if( iLastValidCollision != -1 )
			{
				const float fDirMult = m_bFacingLeft ? -1.0f : 1.0f;
				if(i <= MLP_OuterForwardLow)
				{
					fMidDepth = MIN(fMidDepth, apProbeResults[i].m_fDepth);
					++iNumLowConcurrentIntersections;
					iMaxNumLowConcurrentIntersections = MAX(iNumLowConcurrentIntersections, iMaxNumLowConcurrentIntersections);
					vNormalFromLowPosition += fDirMult * (apProbeResults[iLastValidCollision].m_vPosition - apProbeResults[i].m_vPosition) * 1.0f/float(i-iLastValidCollision);
				}
				else if( i <= MLP_OuterForwardHigh )
				{
					fHighDepth = MIN(fHighDepth, apProbeResults[i].m_fDepth);
					++iNumHighConcurrentIntersections;
					iMaxNumHighConcurrentIntersections = MAX(iNumHighConcurrentIntersections, iMaxNumHighConcurrentIntersections);
					vNormalFromHighPosition += fDirMult * (apProbeResults[iLastValidCollision].m_vPosition - apProbeResults[i].m_vPosition) * 1.0f/float(i-iLastValidCollision);
				}
			}

			if( i == MLP_LowCentre )
			{
				fLowDepth = apProbeResults[i].m_fDepth;
			}			
			iLastValidCollision = i;
		}
		else
		{
			iNumLowConcurrentIntersections = 0;
			iNumHighConcurrentIntersections = 0;
		}

		// Reset the last valid collision before moving to the top row of probes
		if( i == MLP_OuterForwardLow )
		{
			iLastValidCollision = -1;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::DetectAndRemoveSlopes( float fLowDepth, float fMidDepth, float fHighDepth, s32 iMaxNumLowConcurrentIntersections, s32 &iMaxNumHighConcurrentIntersections, ProbeResults* apProbeResults )
{
	// If the collisions at the different heights seem to have detected a slope
	// Either rule out completely if a slope from the lowest detection
	// Or if a solid base is found ignore the highest collision results
	static float fLowDepthDifferenceToIgnoreCover = 0.3f;
	static float fHighDepthDifferenceToIgnoreCover = 0.3f;
	if( (fLowDepth < 990.0f && fMidDepth < 990.0f ) &&
		( fMidDepth - fLowDepth ) > fLowDepthDifferenceToIgnoreCover )
	{
		return false;
	}
	else if( (fHighDepth < 990.0f && fMidDepth < 990.0f ) &&
		( fHighDepth - fMidDepth ) > fHighDepthDifferenceToIgnoreCover )
	{
		if( iMaxNumLowConcurrentIntersections == 0 )
			return false;
		iMaxNumHighConcurrentIntersections = 0;
		for( s32 i = LP_LeftHigh; i <= LP_RightHigh; i++ )
		{
			apProbeResults[i].m_bCollided = false;
		}
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::FindConcurrentCollisions( ProbeResults* apProbeResults, 
												   Vector3 &vCoverPosition, 
												   s32 &iNumCollisions, 
												   float &fNearestCollision, 
												   Vector3 &vNormalFromCollisionNormal, 
												   float &fLowDepth, 
												   float &fMidDepth, 
												   float &fHighDepth, 
												   s32 &iMaxNumLowConcurrentIntersections,
												   Vector3 &vNormalFromLowPosition, 
												   s32 &iMaxNumHighConcurrentIntersections, 
												   Vector3 &vNormalFromHighPosition )
{
	s32 iNumLowConcurrentIntersections = 0;
	s32 iNumHighConcurrentIntersections = 0;
	s32 iLastValidCollision = -1;
	static dev_bool ENABLE_FRONT_ONLY_PROBES = true;
	for( s32 i = LP_LeftLow; i < LP_Max; i++ )
	{
		if( apProbeResults[i].m_bCollided )
		{
			float fDist = apProbeResults[i].m_vCapsuleStart.Dist(apProbeResults[i].m_vPosition);
			bool bFrontOnlyCheckPassed = !ENABLE_FRONT_ONLY_PROBES || ((i >= LP_FrontLowL && i <= LP_FrontLowR) || (i >= LP_FrontHighL && i <= LP_FrontHighR));
			if (bFrontOnlyCheckPassed)
				fNearestCollision = MIN(fDist+ms_fOuterYOffset, fNearestCollision);

			vNormalFromCollisionNormal += apProbeResults[i].m_vNormal;

			//if(i <= LP_RightLow)
			if (!ENABLE_FRONT_ONLY_PROBES || (i >= LP_FrontLowL && i <= LP_FrontLowR)) //B* 1492953 Only account for forward positions when not moving.
			{
				vCoverPosition += apProbeResults[i].m_vPosition;
				++iNumCollisions;
			}

			if( iLastValidCollision != -1 )
			{
				if(i <= LP_RightLow)
				{
					fMidDepth = MIN(fMidDepth, apProbeResults[i].m_fDepth);
					++iNumLowConcurrentIntersections;
					iMaxNumLowConcurrentIntersections = MAX(iNumLowConcurrentIntersections, iMaxNumLowConcurrentIntersections);
					if (bFrontOnlyCheckPassed) //B* 1492953 Only account for forward normals when not moving.
						vNormalFromLowPosition += (apProbeResults[iLastValidCollision].m_vPosition - apProbeResults[i].m_vPosition) * 1.0f/float(i-iLastValidCollision);
				}
				else if( i <= LP_RightHigh )
				{
					fHighDepth = MIN(fHighDepth, apProbeResults[i].m_fDepth);
					++iNumHighConcurrentIntersections;
					iMaxNumHighConcurrentIntersections = MAX(iNumHighConcurrentIntersections, iMaxNumHighConcurrentIntersections);
					if (bFrontOnlyCheckPassed)
						vNormalFromHighPosition += (apProbeResults[iLastValidCollision].m_vPosition - apProbeResults[i].m_vPosition)  * 1.0f/float(i-iLastValidCollision);
				}
			}

			if( i == LP_LowCentre )
			{
				fLowDepth = apProbeResults[i].m_fDepth;
			}			
			if (bFrontOnlyCheckPassed)
				iLastValidCollision = i;
		}
		else
		{
			iNumLowConcurrentIntersections = 0;
			iNumHighConcurrentIntersections = 0;
		}

		// Reset the last valid collision before moving to the top row of probes
		if( i == LP_RightLow )
		{
			iLastValidCollision = -1;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::SetCoverEntryEntity(CEntity* pEntity) 
{ 
	m_pCoverEntryEntity = pEntity; 
	if (m_pCoverEntryEntity)
	{
		m_vCachedCoverEntryEntityPosition = VEC3V_TO_VECTOR3(m_pCoverEntryEntity->GetTransform().GetPosition());
	}
}

float CDynamicCoverHelper::ComputeInitialSearchDirection(CPed* pPed)
{
#if __BANK
	if (m_bIsDebugMode)
	{
		return m_fDebugSearchHeading;
	}
#endif 

	if (m_fOverrideDir > -999.0f)
	{
		return m_fOverrideDir;
	}

	float fSearchDir = pPed->GetTransform().GetHeading();
	Vector2 vecStickInput = GetStickInputForCoverSearch(*pPed);

	float fCamOrient = camInterface::GetGameplayDirector().GetFrame().ComputeHeading();

	if(vecStickInput.Mag2() > 0.0f)
	{
		float fStickAngle = rage::Atan2f(-vecStickInput.x, vecStickInput.y);
		fStickAngle = rage::Clamp(fStickAngle, -ms_Tunables.m_MaxStickInputAngleInfluence, ms_Tunables.m_MaxStickInputAngleInfluence);

		if (ms_Tunables.m_UseCameraOrientationWeighting)
		{
			const camFrame& aimFrame = camInterface::GetPlayerControlCamAimFrame();
			Vec3V vCamFront = VECTOR3_TO_VEC3V(aimFrame.GetFront());
			vCamFront.SetZ(ScalarV(V_ZERO));
			vCamFront = Normalize(vCamFront);

#if DEBUG_DRAW
			Vec3V vPedPos = pPed->GetTransform().GetPosition();
			Vec3V vCamDir = vPedPos + vCamFront;
			CCoverDebug::ms_searchDebugDraw.AddArrow(vPedPos, vCamDir, 0.25f, Color_blue, 2000);
#endif // DEBUG_DRAW

			Vec3V vStick(vecStickInput.x, vecStickInput.y, 0.0f);
			vStick = Normalize(vStick);
			vStick = RotateAboutZAxis(vStick, ScalarVFromF32(fCamOrient));	// make stick input relative to camera

#if DEBUG_DRAW
			Vec3V vStickDir = vPedPos + vStick;
			CCoverDebug::ms_searchDebugDraw.AddArrow(vPedPos, vStickDir, 0.25f, Color_green, 2000);
#endif // DEBUG_DRAW

			float fDot = Dot(vCamFront, vStick).Getf();

#if DEBUG_DRAW
			char szText[256];
			formatf(szText, "Dot : %.2f", fDot);
			CCoverDebug::ms_searchDebugDraw.AddText(vPedPos, 0, 0, szText, Color_green, 2000);
#endif // DEBUG_DRAW

			const float fStickAngleRelative = fStickAngle + fCamOrient;
			if (fDot < ms_Tunables.m_BehindThreshold)
			{
				if (ms_Tunables.m_UseCameraOrientationForBackwardsDirection)
				{
					fSearchDir = fCamOrient;
				}
				else
				{
					fSearchDir = fStickAngleRelative;
				}
			}
			else
			{
				const float fScale = 0.5f;//(fDot + 1.0f) * 0.5f;
				fSearchDir = fStickAngleRelative * fScale + fCamOrient * (1.0f - fScale);
			}
#if DEBUG_DRAW
			Vec3V vSearchAngle(V_Y_AXIS_WONE);
			vSearchAngle = RotateAboutZAxis(vSearchAngle, ScalarVFromF32(fSearchDir));
			CTask::ms_debugDraw.AddArrow(vPedPos, vPedPos + vSearchAngle, 0.25f, Color_purple, 2000);
#endif // DEBUG_DRAW
		}
		else
		{
			fSearchDir = fStickAngle + fCamOrient;
		}
		fSearchDir = fwAngle::LimitRadianAngle(fSearchDir);
	}
	else if (ms_Tunables.m_UseCameraOrientationWhenStill)
	{
		fSearchDir = fwAngle::LimitRadianAngle(fCamOrient);
	}
	return fSearchDir;
}

////////////////////////////////////////////////////////////////////////////////

float CDynamicCoverHelper::ComputeSearchDirectionFromCoverPoint(CPed* pPed)
{
	float fSearchDir = pPed->GetTransform().GetHeading();
	if (taskVerifyf(pPed->GetCoverPoint(), "Ped does not have a cover point"))
	{
		Vector3 vDir;
		if (pPed->GetPlayerInfo()->IsRoundCover())
		{
			vDir = CPlayerInfo::ms_DynamicCoverHelper.ProcessRoundCoverDirection(pPed, pPed->GetPlayerInfo()->GetRoundCoverCenter());
		}	
		else
			vDir = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector(NULL));

		fSearchDir = rage::Atan2f(-vDir.x, vDir.y);
	}
	return fSearchDir;
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::UpdateCoverPointFromResults(CPed* pPed, ProbeResults* aProbeResults, Vector3& vNormal, Vector3& vCoverPosition, bool bMoving, bool bCovToCov)
{
	// This is the final check, so go ahead if there is a solid section of cover infront of the player
	// If there's less cover on top than below, its low
	bool bHighCollisionInFront = true;
	bool bCoverMostlySeeThrough = false;

	TUNE_GROUP_BOOL(COVER_TUNE, ENABLE_HIGH_COVER_VALIDATION, true);
	if (ENABLE_HIGH_COVER_VALIDATION && pPed->GetPlayerInfo() && !pPed->GetPlayerInfo()->IsRoundCover())
	{
		// Remove any high results that aren't close enough to the low centre probe intersection to prevent detecting high cover incorrectly
		// See B*1172893
		if (aProbeResults[LP_FrontLowC].m_bCollided)
		{
			TUNE_GROUP_FLOAT(COVER_TUNE, MAX_XY_DIST_FROM_LOW_POS, 0.2f, 0.0f, 1.0f, 0.01f);
			for (s32 i=LP_FrontHighL; i<=LP_FrontHighR; ++i)
			{
				float fDepthDelta = aProbeResults[i].m_fDepth - aProbeResults[i-5].m_fDepth;
				if (fabs(fDepthDelta) > MAX_XY_DIST_FROM_LOW_POS)
				{
					aProbeResults[i].m_bCollided = false;
				}
			}
		}
	}

	if (bMoving)
	{
		for( s32 i = MLP_CenterLow; i <= MLP_InnerForwardLow; i++ )
		{
			s32 iUpper = (i - MLP_CenterLow) + MLP_CenterHigh;
			if( aProbeResults[i].m_bCollided )
			{
				if( !aProbeResults[iUpper].m_bCollided ||
					(aProbeResults[iUpper].m_bCollidedWithSeeThrough && ( !aProbeResults[i].m_bCollidedWithSeeThrough || ( !aProbeResults[LP_LowCentre].m_bCollided || !aProbeResults[LP_LowCentre].m_bCollidedWithSeeThrough ) ) ) )
				{
					bHighCollisionInFront = false;
					break;
				}
				bCoverMostlySeeThrough = aProbeResults[i].m_bCollidedWithSeeThrough || (aProbeResults[iUpper].m_bCollided && aProbeResults[iUpper].m_bCollidedWithSeeThrough) || bCoverMostlySeeThrough;
			}
		}	
	}
	else
	{
		for( s32 i = ILP_FrontLowL; i <= ILP_FrontLowR; i++ )
		{
			s32 iUpper = (i - ILP_FrontLowL) + ILP_FrontHighL;
			if( aProbeResults[i].m_bCollided )
			{
				if( !aProbeResults[iUpper].m_bCollided ||
					(aProbeResults[iUpper].m_bCollidedWithSeeThrough && ( !aProbeResults[i].m_bCollidedWithSeeThrough || ( !aProbeResults[ILP_LowCentre].m_bCollided || !aProbeResults[ILP_LowCentre].m_bCollidedWithSeeThrough ) ) ) )
				{
					bHighCollisionInFront = false;
					break;
				}
				bCoverMostlySeeThrough = aProbeResults[i].m_bCollidedWithSeeThrough || (aProbeResults[iUpper].m_bCollided && aProbeResults[iUpper].m_bCollidedWithSeeThrough) || bCoverMostlySeeThrough;
			}
		}	
	}

	Vector3 vDir = -vNormal;
	// If the player is already using a cover point, lerp the direction as the player moves to smooth the movement
	if( !m_bIgnoreOldCoverDir && m_pOldCoverPoint && m_pOldCoverPoint->GetType() != CCoverPoint::COVTYPE_NONE && !bCovToCov)
	{
		vDir.Lerp(DIRECTIONAL_LERP_SPEED, VEC3V_TO_VECTOR3(m_pOldCoverPoint->GetCoverDirectionVector()), -vNormal);
		vDir.Normalize();
	}

	float fDir = rage::Atan2f(-vDir.x, vDir.y);
	fDir = LimitRadianAngle2PI(fDir); // We're going to store the direction in an unsigned int, make sure its in the range 0-2PI
	float fCovDir = fDir * (COVER_POINT_DIR_RANGE / (2.0f * (float)PI));
	taskAssert(fCovDir >= 0.0f);
	u8 iCovDir = static_cast<u8>(fCovDir);

	// Work out the height
	CCoverPoint::eCoverHeight height = CCoverPoint::COVHEIGHT_LOW;
	if( bHighCollisionInFront )
	{
		height = CCoverPoint::COVHEIGHT_TOOHIGH;
	}

	CCoverPoint::eCoverUsage usage = CCoverPoint::COVUSE_WALLTONEITHER;

	// Use the rejected results from the angular test to determine whether there is 
	const bool bLeftLowCollided = aProbeResults[LP_LeftLow].m_bCollided || (ms_Tunables.m_EnableConflictingNormalCollisionRemoval && aProbeResults[LP_LeftLow].m_bRejectedBecauseOfAngularCondition);
	const bool bRightLowCollided = aProbeResults[LP_RightLow].m_bCollided || (ms_Tunables.m_EnableConflictingNormalCollisionRemoval && aProbeResults[LP_RightLow].m_bRejectedBecauseOfAngularCondition);
	const bool bLeftHighCollided = aProbeResults[LP_LeftHigh].m_bCollided || (ms_Tunables.m_EnableConflictingNormalCollisionRemoval && aProbeResults[LP_LeftHigh].m_bRejectedBecauseOfAngularCondition);
	const bool bRightHighCollided = aProbeResults[LP_RightHigh].m_bCollided || (ms_Tunables.m_EnableConflictingNormalCollisionRemoval && aProbeResults[LP_RightHigh].m_bRejectedBecauseOfAngularCondition);
	const bool bOuterFwdLowCollided = aProbeResults[MLP_OuterForwardLow].m_bCollided || (ms_Tunables.m_EnableConflictingNormalCollisionRemoval && aProbeResults[MLP_OuterForwardLow].m_bRejectedBecauseOfAngularCondition);
	const bool bOuterFwdHighCollided = aProbeResults[MLP_OuterForwardHigh].m_bCollided || (ms_Tunables.m_EnableConflictingNormalCollisionRemoval && aProbeResults[MLP_OuterForwardHigh].m_bRejectedBecauseOfAngularCondition);

	bool bLeftBlocked = bLeftLowCollided && ( (bLeftHighCollided && (!aProbeResults[LP_LeftHigh].m_bCollidedWithSeeThrough || bCoverMostlySeeThrough ) ) || height != CCoverPoint::COVHEIGHT_TOOHIGH );
	bool bRightBlocked = bRightLowCollided && ( (bRightHighCollided && (!aProbeResults[LP_RightHigh].m_bCollidedWithSeeThrough || bCoverMostlySeeThrough ) ) || height != CCoverPoint::COVHEIGHT_TOOHIGH );

	if (bCovToCov)
	{
		if (m_bFacingLeft)
		{
			bRightBlocked = false;
		}
		else
		{
			bLeftBlocked = false;
		}
	}
	else if (bMoving)
	{
		if (m_bFacingLeft)
		{
			bLeftBlocked = bOuterFwdLowCollided &&
				( (bOuterFwdHighCollided && (!aProbeResults[MLP_OuterForwardHigh].m_bCollidedWithSeeThrough || bCoverMostlySeeThrough) ) || height != CCoverPoint::COVHEIGHT_TOOHIGH );
			bRightBlocked = true;
		}
		else
		{
			bRightBlocked = bOuterFwdLowCollided && 
				( (bOuterFwdHighCollided && (!aProbeResults[MLP_OuterForwardHigh].m_bCollidedWithSeeThrough || bCoverMostlySeeThrough) ) || height != CCoverPoint::COVHEIGHT_TOOHIGH );
			bLeftBlocked = true;
		}
	}
	if( bLeftBlocked && bRightBlocked)
	{
		usage = CCoverPoint::COVUSE_WALLTOBOTH;
	}
	else if( bLeftBlocked )
	{
		if (bMoving)
		{
			if ((!bOuterFwdHighCollided || aProbeResults[MLP_OuterForwardHigh].m_bCollidedWithSeeThrough) && bOuterFwdLowCollided)
			{
				usage = CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT;
			}
			else
			{
				usage = CCoverPoint::COVUSE_WALLTOLEFT;
			}
		}
		else
		{
			if ((!aProbeResults[LP_RightHigh].m_bCollided || aProbeResults[LP_RightHigh].m_bCollidedWithSeeThrough) && aProbeResults[LP_RightLow].m_bCollided)
			{
				usage = CCoverPoint::COVUSE_WALLTOLEFTANDLOWRIGHT;
			}
			else
			{
				usage = CCoverPoint::COVUSE_WALLTOLEFT;
			}
		}
	}
	else if( bRightBlocked )
	{
		if (bMoving)
		{
			if ((!bOuterFwdHighCollided || aProbeResults[MLP_OuterForwardHigh].m_bCollidedWithSeeThrough) && bOuterFwdLowCollided)
			{
				usage = CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT;
			}
			else
			{
				usage = CCoverPoint::COVUSE_WALLTORIGHT;
			}
		}
		else
		{
			if ((!aProbeResults[LP_LeftHigh].m_bCollided || aProbeResults[LP_LeftHigh].m_bCollidedWithSeeThrough) && aProbeResults[LP_LeftLow].m_bCollided)
			{
				usage = CCoverPoint::COVUSE_WALLTORIGHTANDLOWLEFT;
			}
			else
			{
				usage = CCoverPoint::COVUSE_WALLTORIGHT;
			}
		}
	}	

	// Don't allow movement between fixed and non-fixed collision types
	if (bMoving)
	{
		if (m_bFacingLeft)
		{
			pPed->GetPlayerInfo()->SetDynamicCoverCanMoveLeft( bOuterFwdLowCollided );//bLeftBlocked && aProbeResults[LP_FrontLowL].m_bCollidedWithFixed == aProbeResults[LP_LeftLow].m_bCollidedWithFixed;
			pPed->GetPlayerInfo()->SetDynamicCoverCanMoveRight( true);//bRightBlocked && aProbeResults[LP_FrontLowR].m_bCollidedWithFixed == aProbeResults[LP_RightLow].m_bCollidedWithFixed;
		}
		else
		{
			pPed->GetPlayerInfo()->SetDynamicCoverCanMoveRight( bOuterFwdLowCollided );//bRightBlocked && aProbeResults[LP_FrontLowR].m_bCollidedWithFixed == aProbeResults[LP_RightLow].m_bCollidedWithFixed;
			pPed->GetPlayerInfo()->SetDynamicCoverCanMoveLeft( true );//bLeftBlocked && aProbeResults[LP_FrontLowL].m_bCollidedWithFixed == aProbeResults[LP_LeftLow].m_bCollidedWithFixed;
		}
	}
	else
	{
		pPed->GetPlayerInfo()->SetDynamicCoverCanMoveLeft( aProbeResults[ILP_LeftLow].m_bCollided );//bLeftBlocked && aProbeResults[LP_FrontLowL].m_bCollidedWithFixed == aProbeResults[LP_LeftLow].m_bCollidedWithFixed;
		pPed->GetPlayerInfo()->SetDynamicCoverCanMoveRight( aProbeResults[ILP_RightLow].m_bCollided );//bRightBlocked && aProbeResults[LP_FrontLowR].m_bCollidedWithFixed == aProbeResults[LP_RightLow].m_bCollidedWithFixed;
	}

	// Check to see if any of the cover used is dynamic
	pPed->GetPlayerInfo()->SetCoverGeneratedByDynamicEntity( false );
	CEntity* pHitEntity = NULL;
	for( s32 i = 0; i < LP_Max && !pPed->GetPlayerInfo()->IsCoverGeneratedByDynamicEntity(); i++ )
	{
		if( aProbeResults[i].m_bCollided && !aProbeResults[i].m_bCollidedWithFixed && !aProbeResults[i].m_bCollidedWithSeeThrough )
		{
			pPed->GetPlayerInfo()->SetCoverGeneratedByDynamicEntity( true );
			pHitEntity = aProbeResults[i].m_pHitEntity;
		}
	}

//	m_pNewCoverPoint->ResetCoverPointStatus();

	CPhysical* pPhysical = pPed->GetGroundPhysical();
	m_pNewCoverPoint->SetType(pPhysical ? CCoverPoint::COVTYPE_BIG_OBJECT : CCoverPoint::COVTYPE_POINTONMAP);
	m_pNewCoverPoint->m_pEntity = pHitEntity ? pHitEntity : pPhysical;
	m_pNewCoverPoint->SetWorldDirection( iCovDir );
	// Don't change the height in round cover
	if (pPed->GetPlayerInfo()->IsRoundCover() && m_pOldCoverPoint)
	{
		const CCoverPoint::eCoverHeight oldHeight = m_pOldCoverPoint->GetHeight();
		m_pNewCoverPoint->SetHeight( oldHeight );
	}
	else
	{
		m_pNewCoverPoint->SetHeight( height );
	}
	m_pNewCoverPoint->SetUsage( usage );
	m_pNewCoverPoint->SetArc( CCoverPoint::COVARC_180);
	m_pNewCoverPoint->SetIsThin(false);
	// Keep the old cover position when idle turning
	if (m_bFromIdleTurn && m_pOldCoverPoint)
	{
		m_pOldCoverPoint->GetCoverPointPosition(vCoverPosition);
	}
	m_pNewCoverPoint->SetWorldPosition(vCoverPosition);
	
	for (s32 C = 0; C < MAX_PEDS_PER_COVER_POINT; C++)
	{
		m_pNewCoverPoint->m_pPedsUsingThisCover[C] = NULL;
	}
	m_pNewCoverPoint->m_pOwningGridCell = NULL;
	m_pNewCoverPoint->m_pNextCoverPoint = NULL;
	m_pNewCoverPoint->m_pPrevCoverPoint = NULL;

#if __DEV
	if( CCoverDebug::ms_Tunables.m_RenderDebug )
	{
		if ( CCoverDebug::ms_Tunables.m_RenderCoverInfo )
		{
			CCoverDebug::ms_debugDraw.AddLine(RCC_VEC3V(vCoverPosition), VECTOR3_TO_VEC3V(vCoverPosition + Vector3(0.0f, 0.0f, 1.0f)), Color_green, 1000);
			CCoverDebug::ms_debugDraw.AddLine(VECTOR3_TO_VEC3V(vCoverPosition + Vector3(0.0f, 0.0f, 1.0f)), VECTOR3_TO_VEC3V(vCoverPosition + Vector3(0.0f, 0.0f, 1.0f) + vNormal), Color_white, 1000);

			char szText[128];
			formatf(szText, "Usage: %s", CCoverPoint::GetCoverUsageName(usage));

			//grcDebugDraw::Text(vPos + Vector3(0.0f, 0.0f, 1.0f) + vNormal, Color_green, szText);
			CCoverDebug::ms_debugDraw.AddText(VECTOR3_TO_VEC3V(vCoverPosition + Vector3(0.0f, 0.0f, 1.0f) + vNormal), 0, 0, szText, Color_green, 1000);
		}
	}
#endif
}

bool CDynamicCoverHelper::ProcessRoundCover(CPed* pPed)
{
	if (pPed==NULL)
		return true;

	if (!ENABLE_ROUND_COVER)
		return true;

	if (pPed->GetCoverPoint() == NULL)
		return false;
	if(m_RoundCoverCapsuleResults[RCP_Mid].GetResultsStatus() == WorldProbe::TEST_NOT_SUBMITTED)
	{

		Vector3 vStart, vEnd, vNormal;		
		static dev_float roundCoverCapsuleHeightOffset = 0.5f;
		static dev_float roundCoverStartOffsetDepth = 0.25f;
		static dev_float roundCoverDepth = 1.5f;
		static dev_float roundCoverCapsuleRadius = 0.1f;
		s32 iTypeFlags = ArchetypeFlags::GTA_MAP_TYPE_COVER;
		// Probe for a round cover object

		WorldProbe::CShapeTestCapsuleDesc capsuleDesc;
		capsuleDesc.SetIncludeFlags(iTypeFlags);				
		vNormal = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector());

		//mid
		if (!pPed->GetCoverPoint()->GetCoverPointPosition(vStart))
			return false;
		vStart.z+=roundCoverCapsuleHeightOffset;
		vEnd.Set(vStart); 		
		vStart.AddScaled(vNormal, -roundCoverStartOffsetDepth);
		vEnd.AddScaled(vNormal, roundCoverDepth);
		capsuleDesc.SetResultsStructure(&m_RoundCoverCapsuleResults[RCP_Mid]);
		capsuleDesc.SetIsDirected(true); //non directed doesn't work asynch for now...
		capsuleDesc.SetCapsule(vStart, vEnd, roundCoverCapsuleRadius);				
		WorldProbe::GetShapeTestManager()->SubmitTest(capsuleDesc, WorldProbe::PERFORM_ASYNCHRONOUS_TEST);
#if __DEV
		if( CCoverDebug::ms_Tunables.m_RenderDebug )
		{
			CCoverDebug::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), roundCoverCapsuleRadius, Color_pink, 4500, 0, false);				
		}
#endif
		return false;
	}
	else
	{
		for (int i=0; i< RCP_Max; i++)
		{	
			if (!m_RoundCoverCapsuleResults[i].GetResultsReady())
				return false;
		}

		pPed->GetPlayerInfo()->ClearRoundCover();
		if (m_RoundCoverCapsuleResults[RCP_Mid].GetNumHits() != 0)
		{
			Vec3V vClosestHit = static_cast<phIntersection*>(&m_RoundCoverCapsuleResults[RCP_Mid][0])->GetPosition();			
			int count=0;
			for(WorldProbe::ResultIterator it = m_RoundCoverCapsuleResults[RCP_Mid].begin(); it < m_RoundCoverCapsuleResults[RCP_Mid].last_result(); ++it) 				
			{

				if (it->GetHitDetected())
				{				
					float fDistance = Dist(vClosestHit, it->GetHitPositionV()).Getf();
					static float sf_MinErrorDistance = 0.35f;
					if (fDistance < sf_MinErrorDistance)
					{
						Vector3 center(Vector3::ZeroType);
						float radius;
						if (CheckForRoundCover((static_cast<phIntersection*>(&m_RoundCoverCapsuleResults[RCP_Mid][count])), center, radius))
						{
							pPed->GetPlayerInfo()->SetRoundCover(center, radius);
							break;
						}
					}
				}	
				count++;
			}
		}
		m_RoundCoverCapsuleResults[RCP_Mid].Reset();
	}
	return true;
}

bool CDynamicCoverHelper::CheckForRoundCover(const phIntersection* pIntersection, Vector3& vRoundCoverCenter, float& fRadius)
{	
	if (!pIntersection)
		return false;

	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_CAPSULE_RADIUS_TO_CONSIDER_ROUND_COVER, 0.25f, 0.0f, 1.0f, 0.01f);
	TUNE_GROUP_FLOAT(COVER_TUNE, MIN_CAPSULE_HEIGHT_TO_CONSIDER_ROUND_COVER, 0.25f, 0.0f, 1.0f, 0.01f);
	const phInst* pInst = pIntersection->GetInstance();
	if (pInst && pInst->GetArchetype())
	{			
		bool bDoBVHTest = false;
		phBound* bound = pInst->GetArchetype()->GetBound();
		if (!bound)
			return false;

		if (bound->GetType()==phBound::CAPSULE)
		{
			//TODO center
			vRoundCoverCenter.Set(Vector3::ZeroType);
			Assertf(false, "Center needs done!");
			return true;
		}
		else if (bound->GetType()==phBound::BVH)
		{
			bDoBVHTest = true;
		}
		else if (bound->GetType()==phBound::COMPOSITE)
		{
			phBoundComposite* pBoundComposite = static_cast<phBoundComposite*>(bound);
			phBound* pTestBound = pBoundComposite->GetBound(pIntersection->GetComponent());
			if (pTestBound->GetType()==phBound::CAPSULE) 
			{								
				phBoundCapsule* pBndCapsule = (phBoundCapsule*)pTestBound;
				fRadius = pBndCapsule->GetRadius();
				if (fRadius > MIN_CAPSULE_RADIUS_TO_CONSIDER_ROUND_COVER)
				{
					const Vector3 vCapsuleEnd0 = VEC3V_TO_VECTOR3(pBndCapsule->GetEndPointA());
					const Vector3 vCapsuleEnd1 = VEC3V_TO_VECTOR3(pBndCapsule->GetEndPointB());
					if (Abs(vCapsuleEnd0.z - vCapsuleEnd1.z) > MIN_CAPSULE_HEIGHT_TO_CONSIDER_ROUND_COVER)
					{
						//vRoundCoverCenter.Average(vCapsuleEnd0, vCapsuleEnd1);	
						vRoundCoverCenter = vCapsuleEnd0.z < vCapsuleEnd1.z ? vCapsuleEnd0 : vCapsuleEnd1;
						MAT34V_TO_MATRIX34(pInst->GetMatrix()).Transform(vRoundCoverCenter);	
						return true;
					}
				}
			}
			else if (pTestBound->GetType()==phBound::CYLINDER)
			{
				phBoundCylinder* pBndCylinder = (phBoundCylinder*)pTestBound;
				fRadius = pBndCylinder->GetRadius();
				if (fRadius > MIN_CAPSULE_RADIUS_TO_CONSIDER_ROUND_COVER)
				{
					// Make sure the cylinder is upright, assume the height of the cylinder is bigger than it's width,
					// guess we may run into issues with short cylinder cover
					Vec3V vCentre = pBndCylinder->GetCentroidOffset();
					vCentre = Transform(pInst->GetMatrix(), vCentre);
					ScalarV vHalfHeight = pBndCylinder->GetHalfHeightV();
					Vec3V vStartPos = vCentre - (pInst->GetMatrix().GetCol1()*vHalfHeight);
					Vec3V vEndPos = vCentre + (pInst->GetMatrix().GetCol1()*vHalfHeight);
					if (Abs(vStartPos.GetZf() - vEndPos.GetZf()) > MIN_CAPSULE_HEIGHT_TO_CONSIDER_ROUND_COVER)
					{
						vRoundCoverCenter = VEC3V_TO_VECTOR3(vCentre);					
						return true;
					}
				}
			}
			else if (pTestBound->GetType()==phBound::BVH) 
			{
				bound = pTestBound;
				bDoBVHTest = true;								
			}
		}
		if (bDoBVHTest) 
		{
			phBoundBVH* pBoundBVH = static_cast<phBoundBVH*>(bound);
			int partIndex = pIntersection->GetPartIndex();		
			if (partIndex < pBoundBVH->GetNumPolygons())
			{							
				const phPrimitive& bvhPrimitive = pBoundBVH->GetPolygon(partIndex).GetPrimitive();														
				if (bvhPrimitive.GetType()==rage::PRIM_TYPE_CAPSULE)
				{
					const phPrimCapsule & primCapsule = bvhPrimitive.GetCapsule();
					fRadius = primCapsule.GetRadius();
					if (fRadius > MIN_CAPSULE_RADIUS_TO_CONSIDER_ROUND_COVER)
					{
						const Vector3 vCapsuleEnd0 = VEC3V_TO_VECTOR3(pBoundBVH->GetVertex(primCapsule.GetEndIndex0()));
						const Vector3 vCapsuleEnd1 = VEC3V_TO_VECTOR3(pBoundBVH->GetVertex(primCapsule.GetEndIndex1()));
						if (Abs(vCapsuleEnd0.z - vCapsuleEnd1.z) > MIN_CAPSULE_HEIGHT_TO_CONSIDER_ROUND_COVER)
						{
							//vRoundCoverCenter.Average(vCapsuleEnd0, vCapsuleEnd1); //average fails on really long capsules
							vRoundCoverCenter = vCapsuleEnd0.z < vCapsuleEnd1.z ? vCapsuleEnd0 : vCapsuleEnd1;
							MAT34V_TO_MATRIX34(pInst->GetMatrix()).Transform(vRoundCoverCenter);							
							return true;
						}
					}
				}
				else if (bvhPrimitive.GetType()==rage::PRIM_TYPE_CYLINDER)
				{

					const phPrimCylinder & primCylinder = bvhPrimitive.GetCylinder();
					fRadius = primCylinder.GetRadius();
					if (fRadius > MIN_CAPSULE_RADIUS_TO_CONSIDER_ROUND_COVER)
					{
						const Vector3 vCapsuleEnd0 = VEC3V_TO_VECTOR3(pBoundBVH->GetVertex(primCylinder.GetEndIndex0()));
						const Vector3 vCapsuleEnd1 = VEC3V_TO_VECTOR3(pBoundBVH->GetVertex(primCylinder.GetEndIndex1()));
						if (Abs(vCapsuleEnd0.z - vCapsuleEnd1.z) > MIN_CAPSULE_HEIGHT_TO_CONSIDER_ROUND_COVER)
						{
							vRoundCoverCenter = vCapsuleEnd0.z < vCapsuleEnd1.z ? vCapsuleEnd0 : vCapsuleEnd1;
							MAT34V_TO_MATRIX34(pInst->GetMatrix()).Transform(vRoundCoverCenter);							
							return true;
						}						
					}
				}
			}
		}
	}
	return false;
}

void CDynamicCoverHelper::ResetRoundCoverTest()
{		
	if (m_pPed != NULL && m_pPed->GetPlayerInfo())
	{
		m_pPed->GetPlayerInfo()->ClearRoundCover();
		for (int i=0; i<RCP_Max; i++)
			m_RoundCoverCapsuleResults[i].Reset();
	}
}

Vector3 CDynamicCoverHelper::ProcessRoundCoverDirection(const CPed* pPed, const Vector3& vCenter, const Vector3* pvCollisionPos)
{
	if (pPed==NULL )
		return Vector3::ZeroType;	
	
	Vector3 vStart, vDirection;		
	vDirection = vCenter;
	vStart = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());	
	const float fZDelta = Abs(vDirection.z - vStart.z);
	// If the center of the round cover is quite far from the ped and the capsule/cylidner bound is skewed, we
	// can end up using a bad location to base the direction off (B*1913087)
	// if we detect a large height delta, try to compute a new center based on the collision result
	TUNE_GROUP_FLOAT(COVER_TUNE, MAX_Z_DELTA_TO_USE_ROUND_COVER_CENTER, 5.0f, 0.0f, 10.0f, 0.01f);
	if (pPed->GetPlayerInfo() && fZDelta > MAX_Z_DELTA_TO_USE_ROUND_COVER_CENTER && (pvCollisionPos || pPed->GetCoverPoint()))
	{
		const float fRadius = pPed->GetPlayerInfo()->GetRoundCoverRadius();
		Vector3 vCollisionPoint;
		if (pvCollisionPos)
		{
			vCollisionPoint = *pvCollisionPos;
		}
		else 
		{
			TUNE_GROUP_FLOAT(COVER_TUNE, PED_TO_COVER_SCALE, 0.25f, 0.0f, 10.0f, 0.01f);
			Vector3 vCoverDir = VEC3V_TO_VECTOR3(pPed->GetCoverPoint()->GetCoverDirectionVector());
			vCollisionPoint = vStart + vCoverDir * PED_TO_COVER_SCALE;
		}

		Vector3 vToCover = vCollisionPoint - vStart;
		vToCover.Normalize();
		vToCover.Scale(fRadius);
		Vector3 vNewCenter = vCollisionPoint + vToCover;
		const_cast<CPlayerInfo*>(pPed->GetPlayerInfo())->SetRoundCover(vNewCenter, fRadius);
#if DEBUG_DRAW
		CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vNewCenter), 0.05f, Color_orange, 100, 0);
#endif
		vDirection = vNewCenter;
	}
	vDirection.z = vStart.z;
#if DEBUG_DRAW
	CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vDirection), 0.05f, Color_green, 100, 0);	
	CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vCenter), 0.05f, Color_cyan, 100, 0);			
	CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vStart), 0.05f, Color_red, 100, 0);			
	CTask::ms_debugDraw.AddArrow(RCC_VEC3V(vStart), RCC_VEC3V(vDirection), 0.1f, Color_tan, 100, 0);				
#endif
	vDirection.Subtract(vStart);
	vDirection.Normalize();
	return vDirection;
}

////////////////////////////////////////////////////////////////////////////////

bool CDynamicCoverHelper::IsNewCoverToCoverPointValid(const CPed& ped, const CCoverPoint& coverPoint) const
{
	// Need to already have a cover point to move between cover
	if (!ped.GetCoverPoint())
	{
		return false;
	}

	Vector3 vStart = VEC3V_TO_VECTOR3(ped.GetTransform().GetPosition());
	Vector3 vEnd(Vector3::ZeroType);
	if (coverPoint.GetCoverPointPosition(vEnd))
	{

#if DEBUG_DRAW		
		CTask::ms_debugDraw.AddSphere(RCC_VEC3V(vEnd), 0.05f, Color_pink, 2500);
#endif // DEBUG_DRAW

		// Enforce min distance condition
		if (vStart.Dist2(vEnd) < ms_Tunables.m_CTCMinDistance * ms_Tunables.m_CTCMinDistance)
		{
			aiDebugf2("New Cover To Cover Point Was Too Close (%.2f)", vStart.Dist(vEnd));
			return false;
		}

		// Make sure the cover isn't too high/low from our current position
		if (Abs(vStart.z - 1.0f - vEnd.z) > ms_Tunables.m_MaxZDiffBetweenCoverPoints)
		{
			aiDebugf2("New Cover To Cover Point Was Too High/Low From Current Position - StartZ(%.2f), EndZ(%.2f)", vStart.z - 1.0f, vEnd.z);
			return false;
		}

		const Vector3 vCurrentCoverDir = VEC3V_TO_VECTOR3(ped.GetCoverPoint()->GetCoverDirectionVector());
		const Vector3 vNewCoverDir = VEC3V_TO_VECTOR3(coverPoint.GetCoverDirectionVector());
		const float fHeadingDiffBetweenCoverPoints = Abs(vCurrentCoverDir.AngleZ(vNewCoverDir));
		if (fHeadingDiffBetweenCoverPoints > ms_Tunables.m_MaxHeadingDiffBetweenCTCPoints)
		{
			aiDebugf2("New Cover To Cover Point's Heading Was Too Far From Current Cover Heading - Current(%.2f), New(%.2f)", rage::Atan2f(-vCurrentCoverDir.x, vCurrentCoverDir.y), rage::Atan2f(-vNewCoverDir.x, vNewCoverDir.y));
			return false;
		}

		// Check the path is clear to the new cover
		const Vector3 vPedForward = VEC3V_TO_VECTOR3(ped.GetTransform().GetB());
		vStart += vPedForward * ms_Tunables.m_CTCClearanceCapsuleStartForwardOffset;
		vStart.z += ms_Tunables.m_CTCClearanceCapsuleStartZOffset;
		vEnd += vPedForward * ms_Tunables.m_CTCClearanceCapsuleEndForwardOffset;
		vEnd.z += ms_Tunables.m_CTCClearanceCapsuleEndZOffset;
		vEnd += vNewCoverDir * -ms_Tunables.m_DistanceToWallCoverToCover; 

		WorldProbe::CShapeTestFixedResults<> capsuleResult;
		s32 iTypeFlags = ArchetypeFlags::GTA_ALL_MAP_TYPES|ArchetypeFlags::GTA_VEHICLE_TYPE|ArchetypeFlags::GTA_OBJECT_TYPE|ArchetypeFlags::GTA_PED_TYPE;

		WorldProbe::CShapeTestCapsuleDesc capsuleDesc;
		capsuleDesc.SetResultsStructure(&capsuleResult);
		capsuleDesc.SetCapsule(vStart, vEnd, ms_Tunables.m_CTCClearanceCapsuleRadius);
		capsuleDesc.SetIncludeFlags(iTypeFlags);
		capsuleDesc.SetExcludeEntity(&ped);
		capsuleDesc.SetTypeFlags(ArchetypeFlags::GTA_AI_TEST);
		capsuleDesc.SetIsDirected(false);
		capsuleDesc.SetDoInitialSphereCheck(true);
		WorldProbe::GetShapeTestManager()->SubmitTest(capsuleDesc);

		if (!capsuleResult[0].GetHitDetected())
		{
#if DEBUG_DRAW
			CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), ms_Tunables.m_CTCClearanceCapsuleRadius, Color_DarkGreen, 2500, 0, false);
#endif // DEBUG_DRAW
			return true;
		}
#if DEBUG_DRAW
		CTask::ms_debugDraw.AddCapsule(RCC_VEC3V(vStart), RCC_VEC3V(vEnd), ms_Tunables.m_CTCClearanceCapsuleRadius, Color_red, 2500, 0, false);
		CTask::ms_debugDraw.AddSphere(RCC_VEC3V(capsuleResult[0].GetHitPosition()), 0.05f, Color_red, 2500);
#endif // DEBUG_DRAW
	}

	return false;
}

////////////////////////////////////////////////////////////////////////////////

#if !__FINAL

#if DEBUG_DRAW
void CDynamicCoverHelper::RenderSearchDirection(const CPed& ped, float fSearchDirection, Color32 colour, bool bOffset)
{
	if (CCoverDebug::ms_Tunables.m_RenderDebug)
	{
		if (CCoverDebug::ms_Tunables.m_RenderInitialSearchDirection)
		{
			Vec3V vPedPos = ped.GetTransform().GetPosition();
			if (bOffset)
			{
				vPedPos.SetZf(vPedPos.GetZf() - 1.0f);
			}

			Vec3V vLineStart = vPedPos;
			Vec3V vSearchDir(V_Y_AXIS_WZERO);
			vSearchDir = RotateAboutZAxis(vSearchDir, ScalarVFromF32(fSearchDirection));
			Vec3V vLineEnd = vPedPos + vSearchDir;
			CCoverDebug::ms_searchDebugDraw.AddArrow(vLineStart, vLineEnd, 0.25f, colour, 1000);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::RenderSearchProbes(const CPed& UNUSED_PARAM(ped), float UNUSED_PARAM(fSearchDirection))
{
// 	if (CCoverDebug::ms_bRenderInitialCoverProbes)
// 	{
// 	
// 	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::RenderCollisionResultNew(Vec3V_ConstRef vStart, Vec3V_ConstRef vEnd, Vec3V_ConstRef vIntersectionPos, CollisionTestType testType, ProbeResults* apProbeResults, s32 iResultIndex)
{
	TUNE_GROUP_FLOAT(COVER_DEBUG_TUNE, DEFAULT_COLLISION_RADIUS, 0.05f, 0.0f, 1.0f, 0.01f);
	const bool bCollided = apProbeResults[iResultIndex].m_bCollided;
	if (testType == CTT_Los)
	{
		s32 iContextToUse = 0;
		switch (CCoverDebug::ms_eInitialCheckType)
		{
			case CCoverDebug::FIRST_DYNAMIC_CHECK : iContextToUse = CCoverDebug::FIRST_DYNAMIC_COLLISION_LOS_TESTS; break;
			case CCoverDebug::SECOND_DYNAMIC_CHECK : iContextToUse = CCoverDebug::SECOND_DYNAMIC_COLLISION_LOS_TESTS; break;
			case CCoverDebug::FIRST_STATIC_CHECK : iContextToUse = CCoverDebug::FIRST_STATIC_COLLISION_LOS_TESTS; break;
			default: break;
		}

		char szText[128];
		formatf(szText, "%PROBE_TEST_%u", iResultIndex);
		CCoverDebug::sDebugLineParams debugLineParams;
		debugLineParams.vStart = vStart;
		debugLineParams.vEnd = bCollided ? vIntersectionPos : vEnd;
		debugLineParams.color = Color_blue;
		debugLineParams.uContextHash = iContextToUse;
		debugLineParams.szName = szText;
		CCoverDebug::AddDebugLine(debugLineParams);

		formatf(szText, "COLLISION_SPHERE_%u", iResultIndex);
		CCoverDebug::sDebugSphereParams debugSphereParams;
		debugSphereParams.vPos = bCollided ? vIntersectionPos : vEnd;
		debugSphereParams.color = bCollided ? Color_red : Color_green;
		debugSphereParams.fRadius = DEFAULT_COLLISION_RADIUS;
		debugSphereParams.uContextHash = iContextToUse;
		debugSphereParams.szName = szText;
		CCoverDebug::AddDebugPositionSphere(debugSphereParams);
	}
	else
	{
		s32 iContextToUse = 0;
		switch (CCoverDebug::ms_eInitialCheckType)
		{
			case CCoverDebug::FIRST_DYNAMIC_CHECK : iContextToUse = CCoverDebug::FIRST_DYNAMIC_COLLISION_CAPSULE_TESTS; break;
			case CCoverDebug::SECOND_DYNAMIC_CHECK : iContextToUse = CCoverDebug::SECOND_DYNAMIC_COLLISION_CAPSULE_TESTS; break;
			case CCoverDebug::FIRST_STATIC_CHECK : iContextToUse = CCoverDebug::FIRST_STATIC_COLLISION_CAPSULE_TESTS; break;
			default: break;
		}

		char szText[128];
		formatf(szText, "%CAPSULE_TEST_%u", iResultIndex);
		CCoverDebug::sDebugCapsuleParams debugCapsuleParams;
		debugCapsuleParams.vStart = vStart;
		debugCapsuleParams.vEnd = vEnd;
		debugCapsuleParams.color = Color_blue;
		debugCapsuleParams.fRadius = DEFAULT_COLLISION_RADIUS;
		debugCapsuleParams.uContextHash = iContextToUse;
		debugCapsuleParams.szName = szText;
		CCoverDebug::AddDebugCapsule(debugCapsuleParams);

		formatf(szText, "COLLISION_SPHERE_%u", iResultIndex);
		CCoverDebug::sDebugSphereParams debugSphereParams;
		debugSphereParams.vPos = bCollided ? vIntersectionPos : vEnd;
		debugSphereParams.color = bCollided ? Color_red : Color_green;
		debugSphereParams.fRadius = DEFAULT_COLLISION_RADIUS;
		debugSphereParams.uContextHash = iContextToUse;
		debugSphereParams.szName = szText;
		CCoverDebug::AddDebugPositionSphere(debugSphereParams);
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::RenderCollisionResult(Vec3V_ConstRef vStart, Vec3V_ConstRef vEnd, CollisionTestType testType, ProbeResults* apProbeResults, s32 iResultIndex, bool bMoving, const char* szName)
{
	if (CCoverDebug::ms_Tunables.m_RenderDebug)
	{
		char szText[128];
		if (testType == CTT_Los)
		{
			if (CCoverDebug::ms_Tunables.m_RenderInitialCoverProbes)
			{			
				if(apProbeResults[iResultIndex].m_bCollided && CCoverDebug::ms_Tunables.m_RenderCollisions)
				{	
					if (szName)
						formatf(szText, "%s_COLLISION_SPHERE_%u", szName, iResultIndex);
					else
						formatf(szText, "COLLISION_SPHERE_%u", iResultIndex);
					CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(apProbeResults[iResultIndex].m_vPosition), 0.05f, Color_green, 1000, atStringHash(szText));
					formatf(szText, "COLLISION_LINE_%u", iResultIndex);
					CCoverDebug::ms_debugDraw.AddLine(vStart, RCC_VEC3V(apProbeResults[iResultIndex].m_vPosition), Color_blue, 1000, atStringHash(szText));
				}
				else
				{
					if (szName)
						formatf(szText, "%s_COLLISION_ARROW_%u", szName, iResultIndex);
					else
						formatf(szText, "COLLISION_ARROW_%u", iResultIndex);
					CCoverDebug::ms_debugDraw.AddArrow(vStart, vEnd, 0.25f, Color_green, 1000, atStringHash(szText));
				}
				if (CCoverDebug::ms_Tunables.m_RenderCoverProbeNames)
				{
					CCoverDebug::ms_debugDraw.AddText(vStart, 0, 0, bMoving ? ms_MovingLineProbeStrings[iResultIndex] : ms_IdleLineProbeStrings[iResultIndex], Color_blue, 1000, atStringHash(bMoving ? ms_MovingLineProbeStrings[iResultIndex] : ms_IdleLineProbeStrings[iResultIndex]));
				}
			}
		}
		else 
		{
			if (CCoverDebug::ms_Tunables.m_RenderCoverCapsuleTests)
			{
				if(apProbeResults[iResultIndex].m_bCollided && CCoverDebug::ms_Tunables.m_RenderCollisions)
				{
					if (szName)
						formatf(szText, "%s_COLLISION_SPHERE_%u", szName, iResultIndex);
					else
						formatf(szText, "COLLISION_SPHERE_%u", iResultIndex);
							CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(apProbeResults[iResultIndex].m_vPosition), ms_fCapsuleRadius, Color_green, 1000, atStringHash(szText));
					if (szName)
						formatf(szText, "%s_COLLISION_CAPSULE_%u", szName, iResultIndex);
					else
						formatf(szText, "COLLISION_CAPSULE_%u", iResultIndex);
					CCoverDebug::ms_debugDraw.AddCapsule(vStart, vEnd, ms_fCapsuleRadius, Color_blue, 1000, atStringHash(szText), false);
				}
				else
				{
					if (szName)
						formatf(szText, "%s_COLLISION_CAPSULE_%u", szName, iResultIndex);
					else
						formatf(szText, "COLLISION_CAPSULE_%u", iResultIndex);
					CCoverDebug::ms_debugDraw.AddCapsule(vStart, vEnd, ms_fCapsuleRadius, Color_green, 1000, atStringHash(szText), false);
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::RenderNewCoverPositionAndNormal(Vec3V_ConstRef vPos, Vec3V_ConstRef vNorm, bool bLos)
{
	TUNE_GROUP_FLOAT(COVER_DEBUG_TUNE, DEFAULT_NEW_COVER_RADIUS, 0.05f, 0.0f, 1.0f, 0.01f);
	if (bLos)
	{
		s32 iContextToUse = 0;
		switch (CCoverDebug::ms_eInitialCheckType)
		{
			case CCoverDebug::FIRST_DYNAMIC_CHECK : iContextToUse = CCoverDebug::FIRST_DYNAMIC_COLLISION_LOS_TESTS; break;
			case CCoverDebug::SECOND_DYNAMIC_CHECK : iContextToUse = CCoverDebug::SECOND_DYNAMIC_COLLISION_LOS_TESTS; break;
			case CCoverDebug::FIRST_STATIC_CHECK : iContextToUse = CCoverDebug::FIRST_STATIC_COLLISION_LOS_TESTS; break;
			default: break;
		}

		CCoverDebug::sDebugSphereParams debugSphereParams;
		debugSphereParams.vPos = vPos;
		debugSphereParams.color = Color_orange;
		debugSphereParams.fRadius = DEFAULT_NEW_COVER_RADIUS;
		debugSphereParams.uContextHash = iContextToUse;
		CCoverDebug::AddDebugPositionSphere(debugSphereParams);

		CCoverDebug::sDebugArrowParams debugArrowParams;
		debugArrowParams.vPos = vPos;
		debugArrowParams.vDir = vNorm;
		debugArrowParams.color = Color_orange;
		debugArrowParams.uContextHash = iContextToUse;
		CCoverDebug::AddDebugDirectionArrow(debugArrowParams);
	}
	else
	{
		s32 iContextToUse = 0;
		switch (CCoverDebug::ms_eInitialCheckType)
		{
			case CCoverDebug::FIRST_DYNAMIC_CHECK : iContextToUse = CCoverDebug::FIRST_DYNAMIC_COLLISION_CAPSULE_TESTS; break;
			case CCoverDebug::SECOND_DYNAMIC_CHECK : iContextToUse = CCoverDebug::SECOND_DYNAMIC_COLLISION_CAPSULE_TESTS; break;
			case CCoverDebug::FIRST_STATIC_CHECK : iContextToUse = CCoverDebug::FIRST_STATIC_COLLISION_CAPSULE_TESTS; break;
			default: break;
		}

		CCoverDebug::sDebugSphereParams debugSphereParams;
		debugSphereParams.vPos = vPos;
		debugSphereParams.color = Color_purple;
		debugSphereParams.fRadius = DEFAULT_NEW_COVER_RADIUS;
		debugSphereParams.uContextHash = iContextToUse;
		CCoverDebug::AddDebugPositionSphere(debugSphereParams);

		CCoverDebug::sDebugArrowParams debugArrowParams;
		debugArrowParams.vPos = vPos;
		debugArrowParams.vDir = vNorm;
		debugArrowParams.color = Color_purple;
		debugArrowParams.uContextHash = iContextToUse;
		CCoverDebug::AddDebugDirectionArrow(debugArrowParams);
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::RenderCollisionNormal(Vec3V_ConstRef vPos, Vec3V_ConstRef vNormal, bool bLow)
{
	static u32 LOW_COVER_COLLISION_KEY = ATSTRINGHASH("LOW_COVER_COLLISION_KEY", 0xFF23F93D);
	static u32 HIGH_COVER_COLLISION_KEY = ATSTRINGHASH("HIGH_COVER_COLLISION_KEY", 0x13887EFD);
	CCoverDebug::ms_debugDraw.AddArrow(vPos, vPos + vNormal, 0.25f, Color_red, 500, bLow ? LOW_COVER_COLLISION_KEY : HIGH_COVER_COLLISION_KEY);
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::RenderCoverNormal(Vec3V_ConstRef vPos, Vec3V_ConstRef vNormal, bool bLow)
{
	static u32 LOW_COVER_NORMAL_KEY = ATSTRINGHASH("LOW_COVER_NORMAL_KEY", 0xBA113395);
	static u32 HIGH_COVER_NORMAL_KEY = ATSTRINGHASH("HIGH_COVER_NORMAL_KEY", 0x7A19C855);
	CCoverDebug::ms_debugDraw.AddArrow(vPos, vPos + vNormal, 0.25f, Color_orange, bLow ? LOW_COVER_NORMAL_KEY : HIGH_COVER_NORMAL_KEY);
}
////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::RenderCoverEdge(Vec3V_ConstRef vPos1, Vec3V_ConstRef vPos2, s32 iResultIndex)
{
	if (CCoverDebug::ms_Tunables.m_RenderEdges)
	{
		static float EDGE_CAPSULE_RADIUS = 0.005f;

		char szText[128];
		formatf(szText, "EDGE_LINE_%u", iResultIndex);

		CCoverDebug::ms_debugDraw.AddCapsule(vPos1, vPos2, EDGE_CAPSULE_RADIUS, Color_cyan, atStringHash(szText));

		formatf(szText, "EDGE_%u", iResultIndex);
		Vec3V vMidPoint = vPos1 + vPos2;
		vMidPoint = Scale(vMidPoint, ScalarV(V_HALF));

		CCoverDebug::ms_debugDraw.AddText(vMidPoint, 0, 0, szText, Color_cyan, 1000, atStringHash(szText));
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::ClearCoverEdgeDebug()
{
	for (s32 i=0; i<ILP_Max; ++i)
	{
		char szText[128];
		formatf(szText, "EDGE_LINE_%u", i);
		CCoverDebug::ms_debugDraw.Clear(atStringHash(szText));
		formatf(szText, "EDGE_%u", i);
		CCoverDebug::ms_debugDraw.Clear(atStringHash(szText));
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::RenderCoverTurnPoint(ProbeResults* apProbeResults, s32 iTurnPointNumber, s32 iResultIndex, s32 iPreTurnEdges, s32 iPostTurnEdges)
{
	if (CCoverDebug::ms_Tunables.m_RenderTurnPoints)
	{
		char szKeyText[128];
		char szText[128];
		formatf(szText, "TURN_POINT_%u, PRE_TURN_EDGES : %u, POST_TURN_EDGES : %u", iTurnPointNumber, iPreTurnEdges, iPostTurnEdges);
		formatf(szKeyText, "TURN_POINT_TEXT_%u", iResultIndex);
		CCoverDebug::ms_debugDraw.AddText(RCC_VEC3V(apProbeResults[iResultIndex].m_vPosition), 0, 0, szText, Color_purple, 1000, atStringHash(szKeyText));
		formatf(szKeyText, "TURN_POINT_SPHERE_%u", iResultIndex);
		CCoverDebug::ms_debugDraw.AddSphere(RCC_VEC3V(apProbeResults[iResultIndex].m_vPosition), ms_fCapsuleRadius, Color_purple, 1000, atStringHash(szKeyText));
	}
}

////////////////////////////////////////////////////////////////////////////////

void CDynamicCoverHelper::ClearCoverTurnPointDebug()
{
	for (s32 i=0; i<ILP_Max; ++i)
	{
		char szText[128];
		formatf(szText, "TURN_POINT_TEXT_%u", i);
		CCoverDebug::ms_debugDraw.Clear(atStringHash(szText));
		formatf(szText, "TURN_POINT_SPHERE_%u", i);
		CCoverDebug::ms_debugDraw.Clear(atStringHash(szText));
	}
}

#endif // DEBUG_DRAW

////////////////////////////////////////////////////////////////////////////////

const char* CDynamicCoverHelper::GetStaticStateName( s32 iState ) 
{
	switch (iState)
	{
	case State_Start:			return "State_Start";
	case State_FindNewCover:	return "State_FindNewCover";
	case State_UpdateCoverWhileMoving:		return "State_UpdateCoverWhileMoving";
	case State_TestForMovingAroundCorner: return "State_TestForMovingAroundCorner";
	case State_TestForInsideCornerTransition: return "State_TestForInsideCornerTransition";		
	case State_Finished:		return "State_Finished";
	default: taskAssertf(0, "Unhandled state");
	}
	return "State_Invalid";
}

#endif // !__FINAL

////////////////////////////////////////////////////////////////////////////////

// Statics
CClipScalingHelper::Tunables CClipScalingHelper::ms_Tunables;

IMPLEMENT_COMBAT_TASK_TUNABLES(CClipScalingHelper, 0xa9b34ab6);

////////////////////////////////////////////////////////////////////////////////

fwMvClipId	CClipScalingHelper::ms_Clip0Id("Clip0",0xF416C5E4);
fwMvClipId	CClipScalingHelper::ms_Clip1Id("Clip1",0xD60C89C4);
fwMvClipId	CClipScalingHelper::ms_Clip2Id("Clip2",0xB58F45C);
fwMvClipId	CClipScalingHelper::ms_Clip3Id("Clip3",0xb193c0d3);
fwMvClipId	CClipScalingHelper::ms_Clip4Id("Clip4",0xe6cd2b45);
fwMvClipId	CClipScalingHelper::ms_Clip5Id("Clip5",0x951e87e9);
fwMvFloatId	CClipScalingHelper::ms_Clip0PhaseId("Clip0Phase",0xCABCBBEE);
fwMvFloatId	CClipScalingHelper::ms_Clip1PhaseId("Clip1Phase",0x9E094ADE);
fwMvFloatId	CClipScalingHelper::ms_Clip2PhaseId("Clip2Phase",0x6A7D05E3);
fwMvFloatId	CClipScalingHelper::ms_Clip0BlendWeightId("Clip0BlendWeight",0x54E5FC05);
fwMvFloatId	CClipScalingHelper::ms_Clip1BlendWeightId("Clip1BlendWeight",0xB708FFEB);
fwMvFloatId	CClipScalingHelper::ms_Clip2BlendWeightId("Clip2BlendWeight",0x66D0E3);
fwMvBooleanId CClipScalingHelper::ms_Clip0FinishedId("Clip0Finished",0xE76BC22E);
fwMvBooleanId CClipScalingHelper::ms_Clip1FinishedId("Clip1Finished",0xCCA0D0CE);

////////////////////////////////////////////////////////////////////////////////

void CClipScalingHelper::ProcessScaling(const sScalingParams& scalingParams)
{
	// Only attempt to scale once we receive information back about the anims we're playing
	if (scalingParams.moveNetworkHelper.IsNetworkAttached())
	{
		// Ensure the use passes in a valid number of clips to scale
		const u32 uNumClipsToScale = scalingParams.uNumClips;
		if (taskVerifyf(uNumClipsToScale > 0 && ms_uMaxNumBlendedClips <= ms_uMaxNumBlendedClips, "Invalid number of clips to scale passed in : %i", uNumClipsToScale))
		{
			// Setup some arrays of values we'll need to achieve scaling
			atArray<float> 			afCachedWeights;					afCachedWeights.Reserve(uNumClipsToScale);
			atArray<float> 			afCachedPhases;						afCachedPhases.Reserve(uNumClipsToScale);
			atArray<const crClip*>	apCachedClips;						apCachedClips.Reserve(uNumClipsToScale);
			atArray<float> 			afRotationScalingStartPhases;		afRotationScalingStartPhases.Reserve(uNumClipsToScale);
			atArray<float> 			afRotationScalingEndPhases;			afRotationScalingEndPhases.Reserve(uNumClipsToScale);
			atArray<float> 			afTranslationScalingStartPhases;	afTranslationScalingStartPhases.Reserve(uNumClipsToScale);
			atArray<float> 			afTranslationScalingEndPhases;		afTranslationScalingEndPhases.Reserve(uNumClipsToScale);

			// Cache the blend weights, phases and clips 
			// Get each clips scaling start and end phases
			// Also compute the total blend weight
			const float fTotalBlendWeight = CacheMoveParamsAndComputeTotalBlendWeight(scalingParams,
																					  afCachedWeights, 
																					  afCachedPhases, 
																					  apCachedClips,
																					  afRotationScalingStartPhases,
																					  afRotationScalingEndPhases,
																					  afTranslationScalingStartPhases,
																					  afTranslationScalingEndPhases);

			// If the blend weights don't add to one, we make them do so
			const u32 uDominantClip = NormaliseBlendWeightsAndComputeDominantClip(afCachedWeights, fTotalBlendWeight, uNumClipsToScale);

			// Scale the rotational velocity if necessary and check for overshoot
			ProcessRotationalScaling(scalingParams, afCachedWeights, afCachedPhases, apCachedClips, afRotationScalingStartPhases, afRotationScalingEndPhases, uDominantClip);

			// Scale the translational velocity if necessary and check for overshoot
			ProcessTranslationalScaling(scalingParams, afCachedWeights, afCachedPhases, apCachedClips, afTranslationScalingStartPhases, afTranslationScalingEndPhases, uDominantClip);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

float CClipScalingHelper::CacheMoveParamsAndComputeTotalBlendWeight(const sScalingParams& scalingParams, 
																   atArray<float>& afCachedBlendWeights,
																   atArray<float>& afCachedPhases,
																   atArray<const crClip*>& apCachedClips,
																   atArray<float>& afRotationScalingStartPhases,
																   atArray<float>& afRotationScalingEndPhases,
																   atArray<float>& afTranslationScalingStartPhases,
																   atArray<float>& afTranslationScalingEndPhases)
{
	float fTotalWeight = 0.0f;

	for (u32 i=0; i<scalingParams.uNumClips; ++i)
	{
		float fBlendWeight = GetBlendWeight(scalingParams.moveNetworkHelper, i);

		// For some reason I don't get the blend weight param out with only 1 clip sometimes
		if (scalingParams.uNumClips == 1)
		{
			fBlendWeight = 1.0f;
		}

		fTotalWeight += fBlendWeight;

		afCachedBlendWeights.PushAndGrow(fBlendWeight);
		afCachedPhases.PushAndGrow(GetPhase(scalingParams.moveNetworkHelper, i));

		const crClip* pClip = GetClip(scalingParams.moveNetworkHelper, i);
		if (taskVerifyf(pClip, "Couldn't find clip (%i)", i))
		{
			float fRotationScalingStartPhase = 0.0f;
			float fRotationScalingEndPhase = 1.0f;
			CClipEventTags::FindMoverFixUpStartEndPhases(pClip, fRotationScalingStartPhase, fRotationScalingEndPhase, false);
			afRotationScalingStartPhases.PushAndGrow(fRotationScalingStartPhase);
			afRotationScalingEndPhases.PushAndGrow(fRotationScalingEndPhase);

			float fTranslationScalingStartPhase = 0.0f;
			float fTranslationScalingEndPhase = 1.0f;
			CClipEventTags::FindMoverFixUpStartEndPhases(pClip, fTranslationScalingStartPhase, fTranslationScalingEndPhase);
			afTranslationScalingStartPhases.PushAndGrow(fTranslationScalingStartPhase);
			afTranslationScalingEndPhases.PushAndGrow(fTranslationScalingEndPhase);
		}

		apCachedClips.PushAndGrow(pClip);
	}

	return fTotalWeight;
}

////////////////////////////////////////////////////////////////////////////////

u32 CClipScalingHelper::NormaliseBlendWeightsAndComputeDominantClip(atArray<float>& afCachedBlendWeights, float fTotalWeight, u32 uNumClips)
{
	float	fDominantClipBlendWeight = -1.0f;
	u32		uDominantClip = 0;

	// Renormalize blend weights and find the most blended in clip
	if (taskVerifyf(fTotalWeight > 0.0f, "Total Blend Weight (%.2f) Wasn't Valid", fTotalWeight))
	{
		for (u32 i=0; i<uNumClips; ++i)
		{
			if (afCachedBlendWeights[i] > fDominantClipBlendWeight)
			{
				fDominantClipBlendWeight = afCachedBlendWeights[i];
				uDominantClip = i;
			}
			//Displayf("Old Weight %.4f", afCachedBlendWeights[i]);
			afCachedBlendWeights[i] /= fTotalWeight;
			//Displayf("New Weight %.4f", afCachedBlendWeights[i]);
		}
	}
	return uDominantClip;
}

////////////////////////////////////////////////////////////////////////////////

void CClipScalingHelper::ComputeScalingPhases(float& fStartScalingPhase, 
											  float& fEndScalingPhase,
											  const atArray<float>& afCachedBlendWeights,
											  const atArray<float>& afScalingStartPhases, 
											  const atArray<float>& afScalingEndPhases, 
											  u32 uNumClips)
{
	fStartScalingPhase = 0.0f;
	fEndScalingPhase = 0.0f;

	for (s32 i=0; i<uNumClips; i++)
	{
		fStartScalingPhase += afCachedBlendWeights[i] * afScalingStartPhases[i];
		fEndScalingPhase += afCachedBlendWeights[i] * afScalingEndPhases[i];
	}

	//Displayf("Start Scaling Phase %.4f", fStartScalingPhase);
	//Displayf("End Scaling Phase %.4f", fEndScalingPhase);

	fStartScalingPhase = rage::Clamp(fStartScalingPhase, 0.0f, 1.0f);
	fEndScalingPhase = rage::Clamp(fEndScalingPhase, 0.0f, 1.0f);
}

////////////////////////////////////////////////////////////////////////////////

 void CClipScalingHelper::ComputeActivePhaseAndTimeStep(float& fActivePhase, 
													    float& fActiveTimestep, 
													    float fScalingStartPhase,
													    float fScalingEndPhase,
												     	const crClip* pDominantClip)
{
	//Displayf("Current Phase : %.4f", fActivePhase);
	//Displayf("Current Timestep : %.4f", fActiveTimestep);

	// Only scale in the scaling period, we adjust the current phase and timestep to reflect this if we're crossing boundaries
	float fPhaseThisFrame = rage::Clamp(fActivePhase + pDominantClip->ConvertTimeToPhase(fActiveTimestep), 0.0f, 1.0f);
	if (fActivePhase < fScalingStartPhase && fPhaseThisFrame > fScalingStartPhase)
	{
		const float fDeltaPhase = fPhaseThisFrame - fScalingStartPhase;
		taskAssert(fDeltaPhase >= 0.0f);
		fActivePhase = fScalingStartPhase;
		fActiveTimestep = pDominantClip->ConvertPhaseToTime(fDeltaPhase);
	}
	else if (fActivePhase < fScalingEndPhase && fPhaseThisFrame > fScalingEndPhase)
	{
		const float fDeltaPhase = rage::Min(fPhaseThisFrame, 1.0f) - fScalingEndPhase;
		taskAssert(fDeltaPhase >= 0.0f);
		fActiveTimestep = pDominantClip->ConvertPhaseToTime(fDeltaPhase);
	}

	taskAssert(fActiveTimestep > 0.0f);
	//Displayf("Current Phase : %.4f", fActivePhase);
	//Displayf("Active Timestep : %.4f", fActiveTimestep);
}

////////////////////////////////////////////////////////////////////////////////

void CClipScalingHelper::ComputeRemainingRotations(float fEndScalingPhase,
												   float& fRemainingRotationToEndOfScaling,
												   float& fRemainingRotationFromEndOfScaling,
												   const atArray<float>& afCachedBlendWeights,
												   const atArray<float>& afCachedPhases,
												   const atArray<const crClip*>& apCachedClips,
												   float fPreviousTimestep,
												   u32 uNumClips)
{
	for (u32 i=0; i<uNumClips; ++i)
	{
		const crClip* pClip = apCachedClips[i];
		if (pClip)
		{
			float fClipPhase = afCachedPhases[i];
			if (fClipPhase < fEndScalingPhase && fPreviousTimestep > 0.0f)
			{
				fClipPhase += pClip->ConvertTimeToPhase(fPreviousTimestep);
				//Displayf("Extra Clip %i Phase From First Timestep : %.4f", i, pClip->ConvertTimeToPhase(fPreviousTimestep));
			}

			float fCurrentToEndOfScalingRotation = 0.0f;
			if (fClipPhase < fEndScalingPhase)
			{
				Quaternion qClipStartRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, fClipPhase);
				Quaternion qClipEndRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, fEndScalingPhase);
				//Displayf("Start Current-Fixup Heading %.4f", qClipStartRotation.TwistAngle(ZAXIS));
				//Displayf("End Current-Fixup Heading %.4f", qClipEndRotation.TwistAngle(ZAXIS));
				fCurrentToEndOfScalingRotation = qClipEndRotation.TwistAngle(ZAXIS) - qClipStartRotation.TwistAngle(ZAXIS);
				//Displayf("Current-Fixup Delta %.4f", fCurrentToEndOfScalingRotation);
			}
		
			float fEndOfScalingToEndOfClipRotation = 0.0f;
			if (fClipPhase < 1.0f)
			{
				Quaternion qClipStartRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, fEndScalingPhase);
				Quaternion qClipEndRotation = fwAnimHelpers::GetMoverTrackRotation(*pClip, 1.0f);
				//Displayf("Start Fixup-End Heading %.4f", qClipStartRotation.TwistAngle(ZAXIS));
				//Displayf("End Fixup-End Heading %.4f", qClipEndRotation.TwistAngle(ZAXIS));
				fEndOfScalingToEndOfClipRotation = qClipEndRotation.TwistAngle(ZAXIS) - qClipStartRotation.TwistAngle(ZAXIS);
				//Displayf("Fixup-End Delta %.4f", fEndOfScalingToEndOfClipRotation);
			}

			fRemainingRotationToEndOfScaling += afCachedBlendWeights[i] * fCurrentToEndOfScalingRotation;
			fRemainingRotationFromEndOfScaling += afCachedBlendWeights[i] * fEndOfScalingToEndOfClipRotation;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CClipScalingHelper::ComputeRemainingTranslations(float fEndScalingPhase,
												   	  float& fRemainingTranslationToEndOfScaling,
												   	  float& fRemainingTranslationFromEndOfScaling,
												      const atArray<float>& afCachedBlendWeights,
												      const atArray<float>& afCachedPhases,
												   	  const atArray<const crClip*>& apCachedClips,
												   	  float fPreviousTimestep,
												   	  u32 uNumClips)
{
	for (u32 i=0; i<uNumClips; ++i)
	{
		const crClip* pClip = apCachedClips[i];
		if (pClip)
		{
			float fClipPhase = afCachedPhases[i];
			if (fClipPhase < fEndScalingPhase && fPreviousTimestep > 0.0f)
			{
				fClipPhase += pClip->ConvertTimeToPhase(fPreviousTimestep);
				//Displayf("Extra Clip %i Phase From First Timestep : %.4f", i, pClip->ConvertTimeToPhase(fPreviousTimestep));
			}

			float fCurrentToEndOfScalingTranslation = 0.0f;
			if (fClipPhase < fEndScalingPhase)
			{
				Vector3 vTranslationDiffToEndOfScaling = fwAnimHelpers::GetMoverTrackTranslationDiff(*pClip, fClipPhase, fEndScalingPhase);
				vTranslationDiffToEndOfScaling.z = 0.0f;
				fCurrentToEndOfScalingTranslation = vTranslationDiffToEndOfScaling.Mag();
				//Displayf("Current-Fixup Delta %.4f", fCurrentToEndOfScalingTranslation);
			}

			float fEndOfScalingToEndOfClipTranslation = 0.0f;
			if (fClipPhase < 1.0f)
			{
				Vector3 vTranslationDiffEndOfScalingToEndOfClip = fwAnimHelpers::GetMoverTrackTranslationDiff(*pClip, fEndScalingPhase, 1.0f);
				vTranslationDiffEndOfScalingToEndOfClip.z = 0.0f;
				fEndOfScalingToEndOfClipTranslation = vTranslationDiffEndOfScalingToEndOfClip.Mag();
				//Displayf("Fixup-End Delta %.4f", fEndOfScalingToEndOfClipTranslation);
			}

			fRemainingTranslationToEndOfScaling += afCachedBlendWeights[i] * fCurrentToEndOfScalingTranslation;
			fRemainingTranslationFromEndOfScaling += afCachedBlendWeights[i] * fEndOfScalingToEndOfClipTranslation;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CClipScalingHelper::ScaleRotationalVelocity(float& fRotationalVelocity,
												 float fRemainingRotationToEndOfScaling,
												 float fDeltaToFixUp, 
												 float fRemainingTime)
{
	if (Abs(fRemainingRotationToEndOfScaling) > ms_Tunables.m_MinAnimRotationDeltaToScale)
	{
		float fScaleFactor = Abs((fDeltaToFixUp + fRemainingRotationToEndOfScaling) / fRemainingRotationToEndOfScaling);
		//Displayf("Scale Pre Clamp : %.4f", fScaleFactor);
		fScaleFactor = rage::Clamp(fScaleFactor, ms_Tunables.m_DefaultMinRotationScalingValue, ms_Tunables.m_DefaultMaxRotationScalingValue);
		fRotationalVelocity *= fScaleFactor;
		//Displayf("Rotational Velocity Post Scale : %.4f", fRotationalVelocity);
	}
	else if (fRemainingTime > ms_Tunables.m_MinRemainingAnimDurationToScale)
	{
		fRotationalVelocity -= fDeltaToFixUp / fRemainingTime; 
	}
}

////////////////////////////////////////////////////////////////////////////////

void CClipScalingHelper::ScaleTranslationalVelocity(const sScalingParams& scalingParams,
													float& fTranslationalVelocity,
													float fDistInClipBlend,
													float fDistToTarget, 
													float fRemainingTime)
{
	if (!scalingParams.bPositionReached  && Abs(fDistInClipBlend) > ms_Tunables.m_MinAnimTranslationDeltaToScale)
	{
		float fScaleFactor = fDistToTarget / fDistInClipBlend;
		//Displayf("Scale Pre Clamp : %.4f", fScaleFactor);
		scalingParams.fTranslationScalingValue = rage::Clamp(fScaleFactor, ms_Tunables.m_DefaultMinTranslationScalingValue, ms_Tunables.m_DefaultMaxTranslationScalingValue);
		fTranslationalVelocity *= scalingParams.fTranslationScalingValue;
		//Displayf("Translational Velocity Post Scale : %.4f", fTranslationalVelocity);
	}
	else if (fRemainingTime > ms_Tunables.m_MinRemainingAnimDurationToScale)
	{
		fTranslationalVelocity -= fDistToTarget / fRemainingTime; 
	}
}

////////////////////////////////////////////////////////////////////////////////

void CClipScalingHelper::ProcessRotationalScaling(const sScalingParams& scalingParams, 
												 const atArray<float>& afCachedWeights, 
												 const atArray<float>& afCachedPhases, 
												 const atArray<const crClip*>& apCachedClips, 
												 const atArray<float>& afRotationScalingStartPhases, 
												 const atArray<float>& afRotationScalingEndPhases, 
												 u32 uDominantClip)
{
	// If we should scale the rotation, then do so
	if (!ms_Tunables.m_DisableRotationScaling && !scalingParams.bOrientationReached)
	{
		// Make sure we go in the 'right' direction
		scalingParams.fRotationalVelocity = scalingParams.bApproachLeft ? -Abs(scalingParams.fRotationalVelocity) : Abs(scalingParams.fRotationalVelocity);

		// Since each clip may have a mover fixup tag, we compute an average of them based on their blend weights
		float fStartRotationScalingPhase = 0.0f;
		float fEndRotationScalingPhase = 0.0f;
		ComputeScalingPhases(fStartRotationScalingPhase, fEndRotationScalingPhase, afCachedWeights, afRotationScalingStartPhases, afRotationScalingEndPhases, scalingParams.uNumClips);

		// We should only scale between the fixup start and end phases, and must take into account the double physics update
		// Recompute a new phase and timestep if we're passing the tag boundaries
		float fActivePhase = afCachedPhases[uDominantClip] + scalingParams.fPreviousPhysicsTimestep;
		float fActiveTimeStep = scalingParams.fCurrentTimeStep; 
		const crClip* pDominantClip = apCachedClips[uDominantClip];
		ComputeActivePhaseAndTimeStep(fActivePhase, fActiveTimeStep, fStartRotationScalingPhase, fEndRotationScalingPhase, pDominantClip);

		if (fActivePhase >= fStartRotationScalingPhase)
		{
			// We need to know the rotation up to the end of the scaling period and after it to compute the difference we need to fixup
			float fRemainingRotationToEndOfScaling = 0.0f;
			float fRemainingRotationFromEndOfScaling = 0.0f;
			ComputeRemainingRotations(fEndRotationScalingPhase, fRemainingRotationToEndOfScaling, fRemainingRotationFromEndOfScaling, afCachedWeights, afCachedPhases, apCachedClips, scalingParams.fPreviousPhysicsTimestep, scalingParams.uNumClips);

			// Compute remaining rotation left in the anim blend
			const float fTotalAnimatedRotationDelta = fRemainingRotationToEndOfScaling + fRemainingRotationFromEndOfScaling;
			//Displayf("Animated Rotation Delta : %.4f", fTotalAnimatedRotationDelta);

			// Compute remaining rotation left to get to the target
			const float fCurrentRotationDelta = scalingParams.bApproachLeft 
				? CClipHelper::ComputeHeadingDeltaFromLeft(scalingParams.fCurrentHeading, scalingParams.fTargetHeading) : CClipHelper::ComputeHeadingDeltaFromRight(scalingParams.fCurrentHeading, scalingParams.fTargetHeading);
			//Displayf("Remaining Rotation Delta : %.4f", fCurrentRotationDelta);

			// Compute the difference
			const float fDeltaToFixUp = fwAngle::LimitRadianAngleSafe(fTotalAnimatedRotationDelta - fCurrentRotationDelta);
			//Displayf("Fixup Delta : %.4f", fDeltaToFixUp);

			// Compute remaining time left for the dominant anim
			const float fDominantClipDuration = pDominantClip->ConvertPhaseToTime(1.0f);
			const float fDominantClipCurrentTime = pDominantClip->ConvertPhaseToTime(fActivePhase);
			const float fRemainingTime = fDominantClipDuration - fDominantClipCurrentTime;

			// Now we have all the info we need to scale
			ScaleRotationalVelocity(scalingParams.fRotationalVelocity, fRemainingRotationToEndOfScaling, fDeltaToFixUp, fRemainingTime);

			// Check for overshoot
			if (!ms_Tunables.m_DisableRotationOvershoot)
			{
				// See if we'll overshoot if we apply this rotation and clamp it if needed
				const float fCurrentHeadingDelta = fwAngle::LimitRadianAngle(scalingParams.fCurrentHeading - scalingParams.fTargetHeading);
				const float fPredictedNewHeading = fwAngle::LimitRadianAngle(scalingParams.fCurrentHeading + scalingParams.fRotationalVelocity * fActiveTimeStep);
				const float fPredictedHeadingDelta = fwAngle::LimitRadianAngle(fPredictedNewHeading - scalingParams.fTargetHeading);

				if (Abs(fPredictedHeadingDelta) < ms_Tunables.m_MinCurrentRotationDeltaToScale || Sign(fPredictedHeadingDelta) != Sign(fCurrentHeadingDelta))
				{
					scalingParams.bOrientationReached = true;
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

void CClipScalingHelper::ProcessTranslationalScaling(const sScalingParams& scalingParams, 
												  const atArray<float>& afCachedWeights, 
												  const atArray<float>& afCachedPhases, 
												  const atArray<const crClip*>& apCachedClips, 
												  const atArray<float>& afTranslationScalingStartPhases, 
												  const atArray<float>& afTranslationScalingEndPhases, 
												  u32 uDominantClip)
{
	// If we should scale the translation, then do so
	if (!ms_Tunables.m_DisableTranslationScaling)
	{
		// Store the current speed and compute the difference vector from the target to our current position
		float fDesiredVelocity = scalingParams.vTranslationalVelocity.Mag();
		Vector3 vToTarget = scalingParams.vTargetPosition - scalingParams.vCurrentPosition;
		vToTarget.z = 0.0f;

		// Compute remaining Translation left to get to the target
		const float fCurrentTranslationDelta = vToTarget.Mag();
		//Displayf("Remaining Translation Delta : %.4f", fCurrentTranslationDelta);

		// Force the velocity in the correct direction
		vToTarget.Normalize();
		scalingParams.vTranslationalVelocity = vToTarget;

		// Since each clip may have a mover fixup tag, we compute an average of them based on their blend weights
		float fStartTranslationScalingPhase = 0.0f;
		float fEndTranslationScalingPhase = 0.0f;
		ComputeScalingPhases(fStartTranslationScalingPhase, fEndTranslationScalingPhase, afCachedWeights, afTranslationScalingStartPhases, afTranslationScalingEndPhases, scalingParams.uNumClips);

		// We should only scale between the fixup start and end phases, and must take into account the double physics update
		// Recompute a new phase and timestep if we're passing the tag boundaries
		float fActivePhase = afCachedPhases[uDominantClip] + scalingParams.fPreviousPhysicsTimestep;
		float fActiveTimeStep = scalingParams.fCurrentTimeStep; 
		const crClip* pDominantClip = apCachedClips[uDominantClip];
		ComputeActivePhaseAndTimeStep(fActivePhase, fActiveTimeStep, fStartTranslationScalingPhase, fEndTranslationScalingPhase, pDominantClip);

		if (fActivePhase >= fStartTranslationScalingPhase)
		{
			//if (!scalingParams.bPositionReached || scalingParams.fTranslationScalingValue < 0.0f || fDesiredVelocity < ms_Tunables.m_MinVelocityToScale || fActivePhase >= fEndTranslationScalingPhase)
			static bool USE_CONSTANT_SCALING = true;
			if (scalingParams.fTranslationScalingValue < 0.0f || USE_CONSTANT_SCALING)
			{
				// We need to know the Translation up to the end of the scaling period and after it to compute the difference we need to fixup
				float fRemainingTranslationToEndOfScaling = 0.0f;
				float fRemainingTranslationFromEndOfScaling = 0.0f;
				ComputeRemainingTranslations(fEndTranslationScalingPhase, fRemainingTranslationToEndOfScaling, fRemainingTranslationFromEndOfScaling, afCachedWeights, afCachedPhases, apCachedClips, scalingParams.fPreviousPhysicsTimestep, scalingParams.uNumClips);

				// Compute remaining Translation left in the anim blend
				const float fTotalAnimatedTranslationDelta = fRemainingTranslationToEndOfScaling + fRemainingTranslationFromEndOfScaling;
				//Displayf("Animated Translation Delta : %.4f", fTotalAnimatedTranslationDelta);

				// Compute the difference
				//const float fDeltaToFixUp = fCurrentTranslationDelta - fTotalAnimatedTranslationDelta;
				//Displayf("Fixup Delta : %.4f", fDeltaToFixUp);

				// Compute remaining time left for the dominant anim
				const float fDominantClipDuration = pDominantClip->ConvertPhaseToTime(1.0f);
				const float fDominantClipCurrentTime = pDominantClip->ConvertPhaseToTime(fActivePhase);
				const float fRemainingTime = fDominantClipDuration - fDominantClipCurrentTime;
				
				// Now we have all the info we need to scale
				ScaleTranslationalVelocity(scalingParams, fDesiredVelocity, fTotalAnimatedTranslationDelta, fCurrentTranslationDelta, fRemainingTime);
			}
			else /*if (fActivePhase < fEndTranslationScalingPhase)*/
			{
				// Reuse the scaling value passed in during the fixup period
				fDesiredVelocity *= scalingParams.fTranslationScalingValue;
			}
		}

		fDesiredVelocity = rage::Clamp(fDesiredVelocity, 0.0f, ms_Tunables.m_MaxTransVelocity);

		// Set the magnitude of the velocity
		scalingParams.vTranslationalVelocity.Scale(fDesiredVelocity);

		// Check for overshoot
		if (!ms_Tunables.m_DisableTranslationOvershoot)
		{
			// Compute our initial direction to the target
			Vector3 vOriginalToTarget = scalingParams.vTargetPosition - scalingParams.vOriginalPosition;
			vOriginalToTarget.z = 0.0f;
			vOriginalToTarget.Normalize();

			// If the current to target is opposite from the initial we must have overshot the target position
			if (vToTarget.Dot(vOriginalToTarget) < 0.0f || fCurrentTranslationDelta < ms_Tunables.m_MinAnimTranslationDeltaToScale)
			{
				const float fScale = rage::Clamp(fCurrentTranslationDelta/fActiveTimeStep, 0.0f, 5.0f);
				scalingParams.vTranslationalVelocity = vToTarget;
				scalingParams.vTranslationalVelocity.Scale(fScale);
				scalingParams.bPositionReached = true;
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////

float CClipScalingHelper::GetBlendWeight(const CMoveNetworkHelper& moveNetworkHelper, s32 i)
{
	switch (i)
	{
		case 0 : return rage::Clamp(moveNetworkHelper.GetFloat(ms_Clip0BlendWeightId), 0.0f, 1.0f);
		case 1 : return rage::Clamp(moveNetworkHelper.GetFloat(ms_Clip1BlendWeightId), 0.0f, 1.0f);
		case 2 : return rage::Clamp(moveNetworkHelper.GetFloat(ms_Clip2BlendWeightId), 0.0f, 1.0f);
		default: taskAssertf(0, "Unhandled clip index");
	}
	return 0.0f;
}

////////////////////////////////////////////////////////////////////////////////

float CClipScalingHelper::GetPhase(const CMoveNetworkHelper& moveNetworkHelper, s32 i)
{
	switch (i)
	{
		case 0 : return rage::Clamp(moveNetworkHelper.GetFloat(ms_Clip0PhaseId), 0.0f, 1.0f);
		case 1 : return rage::Clamp(moveNetworkHelper.GetFloat(ms_Clip1PhaseId), 0.0f, 1.0f);
		case 2 : return rage::Clamp(moveNetworkHelper.GetFloat(ms_Clip2PhaseId), 0.0f, 1.0f);
		default: taskAssertf(0, "Unhandled clip index");
	}
	return 0.0f;
}

////////////////////////////////////////////////////////////////////////////////

const crClip* CClipScalingHelper::GetClip(const CMoveNetworkHelper& moveNetworkHelper, s32 i)
{
	const crClip* pReturnClip = NULL;
	switch (i)
	{
		case 0 : pReturnClip = moveNetworkHelper.GetClip(ms_Clip0Id); break;
		case 1 : pReturnClip = moveNetworkHelper.GetClip(ms_Clip1Id); break;
		case 2 : pReturnClip = moveNetworkHelper.GetClip(ms_Clip2Id); break;
		default: taskAssertf(0, "Unhandled clip index");
	}
	taskAssertf(pReturnClip != NULL, "Couldn't find clip with index %i, is it being output from the move network?", i);
	return pReturnClip;
}

////////////////////////////////////////////////////////////////////////////////

fwMvClipId CClipScalingHelper::GetClipId(s32 i)
{
	switch (i)
	{
		case 0 : return ms_Clip0Id;
		case 1 : return ms_Clip1Id;
		case 2 : return ms_Clip2Id;
		case 3 : return ms_Clip3Id;
		case 4 : return ms_Clip4Id;
		case 5 : return ms_Clip5Id;
		default: taskAssertf(0, "Unhandled clip index");
	}
	return CLIP_ID_INVALID;
}

////////////////////////////////////////////////////////////////////////////////

#if !__FINAL

CCoverDebug::sContextDebugInfo* CCoverDebug::sContextDebugInfo::FindDebugSubContextByHash(u32 uHash)
{
	// See if we actually have any sub contexts, if not, then bail out
	const u32 uNumSubContexts = m_SubContexts.GetCount();
	if (uNumSubContexts > 0)
	{
		for (s32 i=0; i<uNumSubContexts; ++i)
		{
			if (m_SubContexts[i].m_Name == uHash)
			{
				return &m_SubContexts[i];
			}
		}
	}
	return NULL;
}

void CCoverDebug::sContextDebugInfo::Init()
{
	const u32 uNumSubContexts = m_SubContexts.GetCount();
	for (s32 i=0; i<uNumSubContexts; ++i)
	{
		m_SubContexts[i].Init();
	}
#if DEBUG_DRAW
	m_DebugDrawStore.InitStoreSize(m_MaxNumDebugDrawables);
#endif // DEBUG_DRAW
}

void CCoverDebug::sContextDebugInfo::Render()
{
	// Find out what the lower most level is selected and render that and all sub contexts
}

#if DEBUG_DRAW
CDebugDrawStore& CCoverDebug::Tunables::FindDebugContextByHash(u32 uHash)
{
	// TODO:
	// Maybe could cache the pointer in a static variable to avoid lookup cost if the context tree grows too large
	sContextDebugInfo* pSubContextDebugInfo = m_DefaultCoverDebugContext.FindDebugSubContextByHash(uHash);
	if (pSubContextDebugInfo)
	{
		return pSubContextDebugInfo->m_DebugDrawStore;
	}
	return m_DefaultCoverDebugContext.m_DebugDrawStore;
}
#endif // DEBUG_DRAW

// Debug rendering
#if DEBUG_DRAW
#undef MAX_TASK_DRAWABLES // ubfix
#define MAX_TASK_DRAWABLES 100
CDebugDrawStore CCoverDebug::ms_debugDraw(MAX_TASK_DRAWABLES);
CDebugDrawStore CCoverDebug::ms_searchDebugDraw(MAX_TASK_DRAWABLES);

Vec3V CCoverDebug::GetGamePlayCamPosition()
{
	const camGameplayDirector& rDirector = camInterface::GetGameplayDirector();
	const camThirdPersonCamera* pThirdPersonCam = rDirector.GetThirdPersonCamera();
	if (pThirdPersonCam)
	{
		return VECTOR3_TO_VEC3V(pThirdPersonCam->GetFrame().GetPosition());
	}
	return Vec3V(V_ZERO);
}

Vec3V CCoverDebug::GetGamePlayCamDirection()
{
	const camGameplayDirector& rDirector = camInterface::GetGameplayDirector();
	const camThirdPersonCamera* pThirdPersonCam = rDirector.GetThirdPersonCamera();
	if (pThirdPersonCam)
	{
		return VECTOR3_TO_VEC3V(pThirdPersonCam->GetFrame().GetFront());
	}
	return Vec3V(V_Y_AXIS_WZERO);
}

bool CCoverDebug::IsContextValid(s32 UNUSED_PARAM(iContext))
{
	return true;
	//return iContext >= 0 && iContext < NUM_COVER_DEBUG_CONTEXTS;
}

void CCoverDebug::AddDebugText(Vec3V_ConstRef vPos, Color32 color, const char* szName, s32 iDuration, s32 iYTextOffset, u32 uContextHash, bool bUnique)
{
	const s32 iRenderDuration = iDuration > 0 ? iDuration : ms_Tunables.m_DefaultRenderDuration;
	CDebugDrawStore& rSelectedDebugStore = CCoverDebug::GetDebugContext(uContextHash);
	char szText[128];
	if (iYTextOffset == 0)
	{
		formatf(szText, "FC: %i | ", fwTimer::GetFrameCount());
	}
	else
	{
		formatf(szText, " ");
	}
	atString debugStr(szText);
	debugStr += szName;

	u32 uHash = bUnique ? atStringHash(szName) : 0;
	rSelectedDebugStore.AddText(vPos, 0, iYTextOffset, debugStr.c_str(), color, iRenderDuration, uHash);
}

void CCoverDebug::AddDebugLine(const sDebugLineParams& rLineParams)
{
	const s32 iRenderDuration = rLineParams.iDuration > 0 ? rLineParams.iDuration : ms_Tunables.m_DefaultRenderDuration;
	CDebugDrawStore& rSelectedDebugStore = CCoverDebug::GetDebugContext(rLineParams.uContextHash);
	static u32 noHash = ATSTRINGHASH("NO NAME", 0x99EBEBEA);
	const u32 nameHash = atStringHash(rLineParams.szName);
	u32 uHashToUse = nameHash == noHash ? 0 : nameHash;
	rSelectedDebugStore.AddLine(rLineParams.vStart, rLineParams.vEnd, rLineParams.color, iRenderDuration, uHashToUse);	
	if (rLineParams.bAddText)
	{
		AddDebugText(rLineParams.vStart, rLineParams.color, rLineParams.szName, iRenderDuration, rLineParams.iYTextOffset, rLineParams.uContextHash);
	}
}

void CCoverDebug::AddDebugDirectionArrow(const sDebugArrowParams& rArrowParams)
{
	const s32 iRenderDuration = rArrowParams.iDuration > 0 ? rArrowParams.iDuration : ms_Tunables.m_DefaultRenderDuration;
	TUNE_GROUP_FLOAT(COVER_DEBUG_TUNE, DIRECTION_ARROW_HEAD_SIZE, 0.25f, 0.0f, 1.0f, 0.01f);
	CDebugDrawStore& rSelectedDebugStore = CCoverDebug::GetDebugContext(rArrowParams.uContextHash);
	rSelectedDebugStore.AddArrow(rArrowParams.vPos, rArrowParams.vPos + rArrowParams.vDir, DIRECTION_ARROW_HEAD_SIZE, rArrowParams.color, iRenderDuration);	
	if (rArrowParams.bAddText)
	{
		AddDebugText(rArrowParams.vPos, rArrowParams.color, rArrowParams.szName, iRenderDuration, rArrowParams.iYTextOffset, rArrowParams.uContextHash);
	}
}

void CCoverDebug::AddDebugPositionSphere(const sDebugSphereParams& rSphereParams)
{
	const s32 iRenderDuration = rSphereParams.iDuration > 0 ? rSphereParams.iDuration : ms_Tunables.m_DefaultRenderDuration;
	TUNE_GROUP_FLOAT(COVER_DEBUG_TUNE, POSITION_SPHERE_RADIUS, 0.05f, 0.0f, 1.0f, 0.01f);
	CDebugDrawStore& rSelectedDebugStore = CCoverDebug::GetDebugContext(rSphereParams.uContextHash);
	static u32 noHash = ATSTRINGHASH("NO NAME", 0x99EBEBEA);
	const u32 nameHash = atStringHash(rSphereParams.szName);
	u32 uHashToUse = nameHash == noHash ? 0 : nameHash;
	rSelectedDebugStore.AddSphere(rSphereParams.vPos, POSITION_SPHERE_RADIUS, rSphereParams.color, iRenderDuration, uHashToUse);	
	if (rSphereParams.bAddText)
	{
		AddDebugText(rSphereParams.vPos, rSphereParams.color, rSphereParams.szName, iRenderDuration, 0, rSphereParams.uContextHash);
	}
}

void CCoverDebug::AddDebugCapsule(const sDebugCapsuleParams& rCapsuleParams)
{
	const s32 iRenderDuration = rCapsuleParams.iDuration > 0 ? rCapsuleParams.iDuration : ms_Tunables.m_DefaultRenderDuration;
	CDebugDrawStore& rSelectedDebugStore = CCoverDebug::GetDebugContext(rCapsuleParams.uContextHash);
	static u32 noHash = ATSTRINGHASH("NO NAME", 0x99EBEBEA);
	const u32 nameHash = atStringHash(rCapsuleParams.szName);
	u32 uHashToUse = nameHash == noHash ? 0 : nameHash;
	rSelectedDebugStore.AddCapsule(rCapsuleParams.vStart, rCapsuleParams.vEnd, rCapsuleParams.fRadius, rCapsuleParams.color, iRenderDuration, uHashToUse, false);	
	if (rCapsuleParams.bAddText)
	{
		AddDebugText(rCapsuleParams.vStart, rCapsuleParams.color, rCapsuleParams.szName, iRenderDuration, 0, rCapsuleParams.uContextHash);
	}
}

void CCoverDebug::AddDebugPositionSphereAndDirection(Vec3V_ConstRef vPos, Vec3V_ConstRef vDir, Color32 color, const char* szName, s32 iYTextOffset, u32 uContextHash, bool bRenderMainText)
{
	const s32 iRenderDuration = ms_Tunables.m_DefaultRenderDuration;
	const bool bRenderText = false;
	sDebugSphereParams sphereParams;
	sphereParams.vPos = vPos;
	sphereParams.color = color;
	sphereParams.szName = szName;
	sphereParams.iDuration = iRenderDuration;
	sphereParams.bAddText = bRenderText;
	sphereParams.uContextHash = uContextHash;
	AddDebugPositionSphere(sphereParams);

	sDebugArrowParams arrowParams;
	arrowParams.vPos = vPos;
	arrowParams.vDir = vDir;
	arrowParams.color = color;
	arrowParams.szName = szName;
	arrowParams.iDuration = iRenderDuration;
	arrowParams.bAddText = bRenderText;
	arrowParams.iYTextOffset = iYTextOffset;
	arrowParams.uContextHash = uContextHash;
	AddDebugDirectionArrow(arrowParams);

	if (bRenderMainText)
	{
		AddDebugText(vPos, color, szName, iRenderDuration, iYTextOffset, uContextHash);
	}
}

bool	CCoverDebug::ms_bInitializedDebugDrawStores = false;

#endif // DEBUG_DRAW

CDynamicCoverHelper CCoverDebug::ms_DynamicCoverHelper;

// Other
CCoverDebug::eInitialCheckType CCoverDebug::ms_eInitialCheckType = CCoverDebug::FIRST_DYNAMIC_CHECK;

CCoverDebug::Tunables CCoverDebug::ms_Tunables;

IMPLEMENT_NON_FINAL_COMBAT_TASK_TUNABLES(CCoverDebug, 0x2774b9f0);

atHashWithStringNotFinal CCoverDebug::DEFAULT("DEFAULT", 0xe4df46d5);
atHashWithStringNotFinal CCoverDebug::INITIAL_SEARCH_SIMPLE("INITIAL_SEARCH_SIMPLE", 0xf82b115e);
atHashWithStringNotFinal CCoverDebug::STATIC_COVER_EVALUATION("STATIC_COVER_EVALUATION", 0x62f22df3);
atHashWithStringNotFinal CCoverDebug::STATIC_COVER_POINTS("STATIC_COVER_POINTS", 0x8ef247ed);
atHashWithStringNotFinal CCoverDebug::FIRST_DYNAMIC_COLLISION_LOS_TESTS("FIRST_DYNAMIC_COLLISION_LOS_TESTS", 0xec624935);
atHashWithStringNotFinal CCoverDebug::FIRST_DYNAMIC_COLLISION_CAPSULE_TESTS("FIRST_DYNAMIC_COLLISION_CAPSULE_TESTS", 0x5c9da0e0);
atHashWithStringNotFinal CCoverDebug::SECOND_DYNAMIC_COLLISION_LOS_TESTS("SECOND_DYNAMIC_COLLISION_LOS_TESTS", 0xfb207b31);
atHashWithStringNotFinal CCoverDebug::SECOND_DYNAMIC_COLLISION_CAPSULE_TESTS("SECOND_DYNAMIC_COLLISION_CAPSULE_TESTS", 0x13f4294c);
atHashWithStringNotFinal CCoverDebug::FIRST_STATIC_COLLISION_LOS_TESTS("FIRST_STATIC_COLLISION_LOS_TESTS", 0xa8f4df3e);
atHashWithStringNotFinal CCoverDebug::FIRST_STATIC_COLLISION_CAPSULE_TESTS("FIRST_STATIC_COLLISION_CAPSULE_TESTS", 0x30a76df5);
atHashWithStringNotFinal CCoverDebug::LEFT_EDGE_TEST("LEFT_EDGE_TEST", 0xb7cbe654);
atHashWithStringNotFinal CCoverDebug::RIGHT_EDGE_TEST("RIGHT_EDGE_TEST", 0x0bf5b67e);
atHashWithStringNotFinal CCoverDebug::EDGE_TEST_RESULTS("EDGE_TEST_RESULTS", 0xa0e0f791);
atHashWithStringNotFinal CCoverDebug::INSIDE_EDGE_TEST("INSIDE_EDGE_TEST", 0x648ac3d9);
atHashWithStringNotFinal CCoverDebug::CAPSULE_CLEARANCE_TESTS("CAPSULE_CLEARANCE_TESTS", 0xe354beb9);
atHashWithStringNotFinal CCoverDebug::THREATS("THREATS", 0x7a3a7606);

#if __BANK

bkGroup* CCoverDebug::FindSubGroupInBank(bkBank& rBank, const char* szGroupToFind)
{
	bkGroup* pGroup = NULL;
	char szText[128];
	formatf(szText, "%s/%s", rBank.GetTitle(), szGroupToFind);
	bkWidget* pWidget = BANKMGR.FindWidget(szText);
	if (pWidget)
	{
		pGroup = dynamic_cast<bkGroup*>(pWidget);
		if (pGroup && rBank.GetCurrentGroup() != pGroup)
		{
			return pGroup;
		}
	}
	return NULL;
}

void CCoverDebug::InitWidgets()
{
	// Find our non final tunables group so we have all the cover debug widgets in the same place
	bkBank* pBank = BANKMGR.FindBank("Task Tuning Non Final");
	if (pBank)
	{
		bkGroup* pBoundingAreasGroup = FindSubGroupInBank(*pBank, "Combat Tasks Non Final/CCoverDebug/BoundingAreas");
		if (pBoundingAreasGroup)
		{
			pBank->SetCurrentGroup(*pBoundingAreasGroup);
			pBank->AddToggle("Enable measuring tool", 		&CPhysics::ms_bDebugMeasuringTool);		
			pBank->AddButton("Add blocking area",			CreateCoverBlockingAreaCB);
			pBank->AddButton("Remove all blocking areas",	RemoveAllCoverBlockingAreasCB);
			pBank->AddButton("Remove specified blocking area", RemoveSpecificCoverBlockingArea);
			pBank->AddButton("Remove blocking areas that intersect player pos", RemoveCoverBlockingAreaAtPlayerPosCB);
			pBank->UnSetCurrentGroup(*pBoundingAreasGroup);
		}
		bkGroup* pCoverDebugGroup = FindSubGroupInBank(*pBank, "Combat Tasks Non Final/CCoverDebug");
		if (pCoverDebugGroup)
		{
			pBank->SetCurrentGroup(*pCoverDebugGroup);
			pBank->PushGroup("Utilities", false);
				pBank->AddToggle("Enable gun", &CPhysics::ms_bMouseShooter);
				pBank->AddButton("Add scripted cover point", CreateCoverPointAtLocationCB);
				pBank->AddButton("Does cover point provide cover?", DoesCoverPointProvideCoverCB);
				pBank->AddButton("Check for existing scripted coverpoint at location", CheckIfScriptedCoverPointExistsCB);
				pBank->AddButton("Set nearest cover point as high priority", SetNearestCoverPointAsHighPriorityCB);
				pBank->AddButton("Clear nearest cover point as high priority", ClearNearestCoverPointAsHighPriorityCB);
				pBank->AddButton("Mark nearest cover point status as position blocked", SetNearestCoverPointStatusPositionBlockedCB);
			pBank->PopGroup();
			pBank->UnSetCurrentGroup(*pCoverDebugGroup);
		}
	}
}

void CCoverDebug::CheckIfScriptedCoverPointExistsCB()
{
	Vector3 vPositionToCheck(Vector3::ZeroType);

	if (CPhysics::GetMeasuringToolPos(0, vPositionToCheck))
	{
		CCoverPoint* pOverlappingCoverPoint = NULL;
		if (!CCoverPointsContainer::CheckIfNoOverlapAndGetGridCell(vPositionToCheck, CCoverPoint::COVTYPE_SCRIPTED, NULL, pOverlappingCoverPoint, false))
		{
			Vector3 vCoverPos(Vector3::ZeroType);
			if (pOverlappingCoverPoint && pOverlappingCoverPoint->GetCoverPointPosition(vCoverPos))
			{
				Displayf("Cannot Add Cover Point As It Is Occupied By Cover Point At (%.2f,%.2f,%.2f), Type: %i", vCoverPos.x, vCoverPos.y, vCoverPos.z, pOverlappingCoverPoint->GetType());
			}
			else
			{
				Assertf(0, "Can't add cover point for unknown reason");
			}
		}
		else
		{
			Displayf("No Existing Scripted Cover Point Found At Coords (%.2f,%.2f,%.2f)", vPositionToCheck.x, vPositionToCheck.y, vPositionToCheck.z);
		}

	}
}

void CCoverDebug::SetNearestCoverPointStatusPositionBlockedCB()
{
	Vector3 vPosition1(Vector3::ZeroType);

	if (CPhysics::GetMeasuringToolPos(0, vPosition1))
	{
		CCoverPoint* pCoverPoint = CCover::FindClosestCoverPoint(NULL, vPosition1);
		if (pCoverPoint)
		{
			pCoverPoint->SetStatus(CCoverPoint::COVSTATUS_PositionBlocked);
		}
	}
}

void CCoverDebug::RemoveAllCoverBlockingAreasCB()
{
	CCover::FlushCoverBlockingAreas();
}

void CCoverDebug::CreateCoverBlockingAreaCB()
{
	Vector3 vMin(Vector3::ZeroType);
	Vector3 vMax(Vector3::ZeroType);

	if (CPhysics::GetMeasuringToolPos(0, vMin) && CPhysics::GetMeasuringToolPos(1, vMax))
	{
		vMin.z -= CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockingBoundGroundExtraOffset;
		vMax.z += CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockingBoundHeight;
		CCover::AddCoverBlockingArea(vMin, vMax, CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockObject, CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockVehicle, CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockMap, CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockPlayer);
	}
}

void CCoverDebug::RemoveCoverBlockingAreaAtPlayerPosCB()
{
	CPed *pPed = CGameWorld::FindLocalPlayer();
	if (pPed)
	{
		Vector3 vPos = VEC3V_TO_VECTOR3(pPed->GetTransform().GetPosition());
		CCover::RemoveCoverBlockingAreasAtPosition(vPos);
	}
}

void CCoverDebug::RemoveSpecificCoverBlockingArea()
{
	Vector3 vMin(Vector3::ZeroType);
	Vector3 vMax(Vector3::ZeroType);

	if (CPhysics::GetMeasuringToolPos(0, vMin) && CPhysics::GetMeasuringToolPos(1, vMax))
	{
		vMin.z -= CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockingBoundGroundExtraOffset;
		vMax.z += CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockingBoundHeight;
		CCover::RemoveSpecificCoverBlockingArea(vMin, vMax, CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockObject, CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockVehicle, CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockMap, CCoverDebug::ms_Tunables.m_BoundingAreas.m_BlockPlayer);
	}
}

void CCoverDebug::CreateCoverPointAtLocationCB()
{
	Vector3 vPosition1(Vector3::ZeroType);
	Vector3 vPosition2(Vector3::ZeroType);

	if (CPhysics::GetMeasuringToolPos(0, vPosition1) && CPhysics::GetMeasuringToolPos( 1, vPosition2 ))
	{
		float fAngle = fwAngle::GetRadianAngleBetweenPoints(vPosition2.x, vPosition2.y, vPosition1.x, vPosition1.y);

		ms_Tunables.m_LastCreatedCoverPoint = CCover::AddCoverPoint(CCover::CP_SciptedPoint,
			CCoverPoint::COVTYPE_SCRIPTED,
			NULL,
			&vPosition1,
			CCoverPoint::COVHEIGHT_TOOHIGH,
			CCoverPoint::COVUSE_WALLTORIGHT,
			static_cast<u8>(fAngle * (COVER_POINT_DIR_RANGE / (2.0f * PI))),
			CCoverPoint::COVARC_180 );
	}
}

void CCoverDebug::DoesCoverPointProvideCoverCB()
{
	Vector3 vPosition1(Vector3::ZeroType);
	Vector3 vPosition2(Vector3::ZeroType);

	if (CPhysics::GetMeasuringToolPos(0, vPosition1))
	{
		CCoverPoint* pCoverPoint = CCover::FindCoverPointWithIndex(ms_Tunables.m_LastCreatedCoverPoint);
		if (pCoverPoint)
		{
			if (CCover::DoesCoverPointProvideCover(pCoverPoint, pCoverPoint->GetArc(), vPosition1 ))
			{
				aiDisplayf("Provides Cover");
			}
			else
			{
				aiDisplayf("Doesn't provide cover");
			}
		}
	}
}

void CCoverDebug::SetNearestCoverPointAsHighPriorityCB()
{
	Vector3 vPosition1(Vector3::ZeroType);

	if (CPhysics::GetMeasuringToolPos(0, vPosition1))
	{
		CCoverPoint* pCoverPoint = CCover::FindClosestCoverPoint(NULL, vPosition1);
		if (pCoverPoint)
		{
			pCoverPoint->SetFlag(CCoverPoint::COVFLAGS_IsPriority);
		}
	}
}

void CCoverDebug::ClearNearestCoverPointAsHighPriorityCB()
{
	Vector3 vPosition1(Vector3::ZeroType);

	if (CPhysics::GetMeasuringToolPos(0, vPosition1))
	{
		CCoverPoint* pCoverPoint = CCover::FindClosestCoverPoint(NULL, vPosition1);
		if (pCoverPoint)
		{
			pCoverPoint->ClearFlag(CCoverPoint::COVFLAGS_IsPriority);
		}
	}
}

void CCoverDebug::Debug()
{
	atArray<sContextDebugInfo>& rCoverSubContextDebugInfos = ms_Tunables.m_DefaultCoverDebugContext.m_SubContexts;
	const u32 uNumContexts = rCoverSubContextDebugInfos.GetCount();
	
	if (ms_Tunables.m_CurrentSelectedContext == -1)
	{
		ms_Tunables.m_DefaultCoverDebugContext.m_DebugDrawStore.Render();
	}
	else if (ms_Tunables.m_CurrentSelectedContext < uNumContexts)
	{
		rCoverSubContextDebugInfos[ms_Tunables.m_CurrentSelectedContext].m_DebugDrawStore.Render();
	}

	if (!ms_Tunables.m_EnableNewCoverDebugRendering)
	{
		return;
	}

	if (ms_Tunables.m_EnableDebugDynamicCoverFinder)
	{
		Vector3 vPosition1, vPosition2;

		if (CPhysics::GetMeasuringToolPos(0, vPosition1) && CPhysics::GetMeasuringToolPos( 1, vPosition2 ))
		{
			vPosition1.z += 1.0f;
			vPosition2.z = vPosition1.z;

			CCoverPoint newCoverPoint;
			ms_DynamicCoverHelper.m_bIsDebugMode = true;
			ms_DynamicCoverHelper.m_fDebugSearchHeading = fwAngle::GetRadianAngleBetweenPoints(vPosition2.x, vPosition2.y, vPosition1.x, vPosition1.y);

			if (ms_DynamicCoverHelper.FindNewCoverPoint(&newCoverPoint, CGameWorld::FindLocalPlayer(), vPosition1))
			{
				if (ms_Tunables.m_RenderCoverPoint)
				{
					Vector3 vCoverPosition;
					newCoverPoint.GetCoverPointPosition(vCoverPosition);
					Vector3 vNormal = VEC3V_TO_VECTOR3(newCoverPoint.GetCoverDirectionVector());

					CCoverDebug::ms_debugDraw.AddLine(RCC_VEC3V(vCoverPosition), VECTOR3_TO_VEC3V(vCoverPosition + Vector3(0.0f, 0.0f, 1.0f)), Color_green, 1000);
					CCoverDebug::ms_debugDraw.AddLine(VECTOR3_TO_VEC3V(vCoverPosition + Vector3(0.0f, 0.0f, 1.0f)), VECTOR3_TO_VEC3V(vCoverPosition + Vector3(0.0f, 0.0f, 1.0f) + vNormal), Color_white, 1000);

					char szText[128];
					formatf(szText, "Usage: %s", CCoverPoint::GetCoverUsageName(newCoverPoint.GetUsage()));

					CCoverDebug::ms_debugDraw.AddText(VECTOR3_TO_VEC3V(vCoverPosition + Vector3(0.0f, 0.0f, 1.0f) + vNormal), 0, 0, szText, Color_green, 1000);
				}
			}
		}
	}

	if (ms_Tunables.m_RenderDebug)
	{
		ms_debugDraw.Render();
	}

	if (ms_Tunables.m_RenderCoverInfo)
	{
		CEntity* pFocusEnt = CDebugScene::FocusEntities_Get(0);
		if(pFocusEnt && pFocusEnt->GetIsTypePed())
		{
			CPed* pFocusPed = static_cast<CPed*>(pFocusEnt);

			if (pFocusPed && pFocusPed->GetCoverPoint()) 
			{
				static s32 s_iVerticalSpace = 10;
				s32 iNoTexts = 0;

				const Vector3 vPedPos = VEC3V_TO_VECTOR3(pFocusPed->GetTransform().GetPosition());

				char szText[128];

				grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, "--- COVER DEBUG ---");

				if (pFocusPed->IsAPlayerPed() && pFocusPed->GetPlayerInfo()->GetDynamicCoverPoint()
					&& (pFocusPed->GetPlayerInfo()->GetDynamicCoverPoint() == pFocusPed->GetCoverPoint()))
				{
					grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, "Dynamic Cover Points Used");
				}
				else
				{
					grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, "Static Cover Points Used");
				}

				grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, CCoverPoint::GetCoverTypeName(pFocusPed->GetCoverPoint()->GetType()));

				grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, CCoverPoint::GetCoverHeightName(pFocusPed->GetCoverPoint()->GetHeight()));

				formatf(szText, "Usage: %s", CCoverPoint::GetCoverUsageName(pFocusPed->GetCoverPoint()->GetUsage()));

				grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, szText);

				grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, CCoverPoint::GetCoverArcName(pFocusPed->GetCoverPoint()->GetArc()));

				u16 iCoverStatus = pFocusPed->GetCoverPoint()->GetStatus();

				if (iCoverStatus & CCoverPoint::COVSTATUS_PositionBlocked)
				{
					formatf(szText, "Status: COVSTATUS_PositionBlocked");
					grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, szText);
				}

				if (iCoverStatus & CCoverPoint::COVSTATUS_DirectionBlocked) 
				{
					formatf(szText, "Status: COVSTATUS_DirectionBlocked");
					grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, szText);
				}

				if (pFocusPed->GetCoverPoint()->GetFlag(CCoverPoint::COVFLAGS_Transient))
				{
					grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, CCoverPoint::GetFlagName(CCoverPoint::COVFLAGS_Transient));
				}

				if (pFocusPed->GetCoverPoint()->GetFlag(CCoverPoint::COVFLAGS_ThinPoint))
				{
					grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, CCoverPoint::GetFlagName(CCoverPoint::COVFLAGS_ThinPoint));
				}

				if (pFocusPed->GetCoverPoint()->GetFlag(CCoverPoint::COVFLAGS_IsPriority))
				{
					grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, CCoverPoint::GetFlagName(CCoverPoint::COVFLAGS_IsPriority));
				}

				if (pFocusPed->GetCoverPoint()->GetFlag(CCoverPoint::COVFLAGS_IsLowCorner))
				{
					grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, CCoverPoint::GetFlagName(CCoverPoint::COVFLAGS_IsLowCorner));
				}

				aiTask* pTask = pFocusPed->GetPedIntelligence()->FindTaskActiveByType(CTaskTypes::TASK_IN_COVER);
				if (pTask)
				{
					CTaskInCover* pCoverTask = static_cast<CTaskInCover*>(pTask);

					if (pCoverTask->IsCoverFlagSet(CTaskCover::CF_FacingLeft))
						grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, "Facing: Left");
					else 
						grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, "Facing: Right");

					if (pCoverTask->IsCoverFlagSet(CTaskCover::CF_AtCorner))
						grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, "At Corner");

					formatf(szText, "Speed: %.2f", Mag(NMovingGround::GetPedVelocity(pFocusPed)).Getf());
					grcDebugDraw::Text(vPedPos, Color_green, 0, iNoTexts++ * s_iVerticalSpace, szText);

					pCoverTask->DrawDebug();
					// Render direction info
				}

				// Render cover pos
				Vector3 vCoverPos;
				pFocusPed->GetCoverPoint()->GetCoverPointPosition(vCoverPos);
				static float s_fCoverSphereRadius = 0.05f;
				grcDebugDraw::Sphere(vCoverPos, s_fCoverSphereRadius, Color_blue);
				grcDebugDraw::Line(vPedPos, vCoverPos, Color_orange, Color_orange);

				// Render cover dir
				Vector3 vCoverDirection;
				pFocusPed->GetCoverPoint()->GetCoverDirectionVector(&RCC_VEC3V(vCoverDirection));

				// Note: the above looks like a bug, should probably be
				//	Vector3 vCoverDirection = RCC_VECTOR3(pFocusPed->GetCoverPoint()->GetCoverDirectionVector(NULL));

				vCoverDirection.Normalize();
				grcDebugDraw::Line(vCoverPos, vCoverPos + vCoverDirection, Color_orange, Color_green);
			}
		}	
	}
}
#endif // __BANK

#endif // !__FINAL
